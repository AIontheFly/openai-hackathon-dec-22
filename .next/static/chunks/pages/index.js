/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./lib/axios */ \"./node_modules/axios/lib/axios.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsNEZBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcz81M2U5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/index.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./node_modules/axios/lib/helpers/cookies.js\");\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./node_modules/axios/lib/helpers/parseHeaders.js\");\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\nvar createError = __webpack_require__(/*! ../core/createError */ \"./node_modules/axios/lib/core/createError.js\");\nvar transitionalDefaults = __webpack_require__(/*! ../defaults/transitional */ \"./node_modules/axios/lib/defaults/transitional.js\");\nvar Cancel = __webpack_require__(/*! ../cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      var transitional = config.transitional || transitionalDefaults;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(\n        timeoutErrorMessage,\n        config,\n        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function(cancel) {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGlFQUFrQjtBQUN2QyxjQUFjLG1CQUFPLENBQUMseUVBQXNCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQywyRUFBdUI7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsNkVBQXVCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN0RCxzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDNUQsa0JBQWtCLG1CQUFPLENBQUMseUVBQXFCO0FBQy9DLDJCQUEyQixtQkFBTyxDQUFDLG1GQUEwQjtBQUM3RCxhQUFhLG1CQUFPLENBQUMsbUVBQWtCOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcz8xYTVjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuLi9jb3JlL2J1aWxkRnVsbFBhdGgnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xudmFyIHRyYW5zaXRpb25hbERlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMvdHJhbnNpdGlvbmFsJyk7XG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL0NhbmNlbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG4gICAgdmFyIHJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgdmFyIG9uQ2FuY2VsZWQ7XG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnVuc3Vic2NyaWJlKG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBjb25maWcuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICBmdW5jdGlvbiBvbmxvYWRlbmQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8ICByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShmdW5jdGlvbiBfcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gX3JlamVjdChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0ID8gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyA6ICd0aW1lb3V0IGV4Y2VlZGVkJztcbiAgICAgIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsIHx8IHRyYW5zaXRpb25hbERlZmF1bHRzO1xuICAgICAgaWYgKGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/ICdFVElNRURPVVQnIDogJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihmdWxsUGF0aCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFjb25maWcud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAocmVzcG9uc2VUeXBlICYmIHJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbiB8fCBjb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGZ1bmN0aW9uKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KCFjYW5jZWwgfHwgKGNhbmNlbCAmJiBjYW5jZWwudHlwZSkgPyBuZXcgQ2FuY2VsKCdjYW5jZWxlZCcpIDogY2FuY2VsKTtcbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbiAmJiBjb25maWcuY2FuY2VsVG9rZW4uc3Vic2NyaWJlKG9uQ2FuY2VsZWQpO1xuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5hYm9ydGVkID8gb25DYW5jZWxlZCgpIDogY29uZmlnLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/adapters/xhr.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\nvar Axios = __webpack_require__(/*! ./core/Axios */ \"./node_modules/axios/lib/core/Axios.js\");\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/axios/lib/defaults/index.js\");\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"./node_modules/axios/lib/cancel/CancelToken.js\");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\naxios.VERSION = (__webpack_require__(/*! ./env/data */ \"./node_modules/axios/lib/env/data.js\").version);\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \"./node_modules/axios/lib/helpers/spread.js\");\n\n// Expose isAxiosError\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ \"./node_modules/axios/lib/helpers/isAxiosError.js\");\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports[\"default\"] = axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxrREFBUztBQUM3QixXQUFXLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyw0REFBYztBQUNsQyxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBb0I7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLDhEQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrRUFBaUI7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLHNFQUFtQjtBQUM1QyxnQkFBZ0IsdUZBQTZCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvRUFBa0I7O0FBRXpDO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQXdCOztBQUVyRDs7QUFFQTtBQUNBLHlCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzP2ZhZDYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vY29yZS9tZXJnZUNvbmZpZycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIC8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbiAgaW5zdGFuY2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGRlZmF1bHRDb25maWcsIGluc3RhbmNlQ29uZmlnKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuYXhpb3MuVkVSU0lPTiA9IHJlcXVpcmUoJy4vZW52L2RhdGEnKS52ZXJzaW9uO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/axios.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcz9kMmEyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/cancel/Cancel.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n\n  // eslint-disable-next-line func-names\n  this.promise.then(function(cancel) {\n    if (!token._listeners) return;\n\n    var i;\n    var l = token._listeners.length;\n\n    for (i = 0; i < l; i++) {\n      token._listeners[i](cancel);\n    }\n    token._listeners = null;\n  });\n\n  // eslint-disable-next-line func-names\n  this.promise.then = function(onfulfilled) {\n    var _resolve;\n    // eslint-disable-next-line func-names\n    var promise = new Promise(function(resolve) {\n      token.subscribe(resolve);\n      _resolve = resolve;\n    }).then(onfulfilled);\n\n    promise.cancel = function reject() {\n      token.unsubscribe(_resolve);\n    };\n\n    return promise;\n  };\n\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Subscribe to the cancel signal\n */\n\nCancelToken.prototype.subscribe = function subscribe(listener) {\n  if (this.reason) {\n    listener(this.reason);\n    return;\n  }\n\n  if (this._listeners) {\n    this._listeners.push(listener);\n  } else {\n    this._listeners = [listener];\n  }\n};\n\n/**\n * Unsubscribe from the cancel signal\n */\n\nCancelToken.prototype.unsubscribe = function unsubscribe(listener) {\n  if (!this._listeners) {\n    return;\n  }\n  var index = this._listeners.indexOf(listener);\n  if (index !== -1) {\n    this._listeners.splice(index, 1);\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsMkRBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanM/NzJjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG5cbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgdGhpcy5wcm9taXNlLnRoZW4oZnVuY3Rpb24oY2FuY2VsKSB7XG4gICAgaWYgKCF0b2tlbi5fbGlzdGVuZXJzKSByZXR1cm47XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbCA9IHRva2VuLl9saXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdG9rZW4uX2xpc3RlbmVyc1tpXShjYW5jZWwpO1xuICAgIH1cbiAgICB0b2tlbi5fbGlzdGVuZXJzID0gbnVsbDtcbiAgfSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgdGhpcy5wcm9taXNlLnRoZW4gPSBmdW5jdGlvbihvbmZ1bGZpbGxlZCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgdG9rZW4uc3Vic2NyaWJlKHJlc29sdmUpO1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pLnRoZW4ob25mdWxmaWxsZWQpO1xuXG4gICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiByZWplY3QoKSB7XG4gICAgICB0b2tlbi51bnN1YnNjcmliZShfcmVzb2x2ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byB0aGUgY2FuY2VsIHNpZ25hbFxuICovXG5cbkNhbmNlbFRva2VuLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgbGlzdGVuZXIodGhpcy5yZWFzb24pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW2xpc3RlbmVyXTtcbiAgfVxufTtcblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIHRoZSBjYW5jZWwgc2lnbmFsXG4gKi9cblxuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/cancel/CancelToken.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanM/YzE3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/cancel/isCancel.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./node_modules/axios/lib/core/InterceptorManager.js\");\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./node_modules/axios/lib/core/dispatchRequest.js\");\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar validator = __webpack_require__(/*! ../helpers/validator */ \"./node_modules/axios/lib/helpers/validator.js\");\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(configOrUrl, config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof configOrUrl === 'string') {\n    config = config || {};\n    config.url = configOrUrl;\n  } else {\n    config = configOrUrl || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean),\n      forcedJSONParsing: validators.transitional(validators.boolean),\n      clarifyTimeoutError: validators.transitional(validators.boolean)\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyx5RUFBcUI7QUFDNUMseUJBQXlCLG1CQUFPLENBQUMsaUZBQXNCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLDJFQUFtQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBZTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBc0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzPzI5ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xudmFyIHZhbGlkYXRvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdmFsaWRhdG9yJyk7XG5cbnZhciB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnT3JVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBjb25maWdPclVybDtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWw7XG5cbiAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKVxuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgdmFyIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHZhciBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJ1bldoZW4gPT09ICdmdW5jdGlvbicgJiYgaW50ZXJjZXB0b3IucnVuV2hlbihjb25maWcpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcblxuICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdmFyIHByb21pc2U7XG5cbiAgaWYgKCFzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMpIHtcbiAgICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuXG4gICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICBjaGFpbiA9IGNoYWluLmNvbmNhdChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuXG4gICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuXG4gIHZhciBuZXdDb25maWcgPSBjb25maWc7XG4gIHdoaWxlIChyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICB2YXIgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpO1xuICAgIHZhciBvblJlamVjdGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB0cnkge1xuICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25SZWplY3RlZChlcnJvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QobmV3Q29uZmlnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG5cbiAgd2hpbGUgKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/Axios.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcz9jNzkyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQsXG4gICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXG4gICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/InterceptorManager.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ \"./node_modules/axios/lib/helpers/isAbsoluteURL.js\");\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ \"./node_modules/axios/lib/helpers/combineURLs.js\");\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBMEI7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXdCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanM/ZjAyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/buildFullPath.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMscUVBQWdCOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcz83NzBjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/createError.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar transformData = __webpack_require__(/*! ./transformData */ \"./node_modules/axios/lib/core/transformData.js\");\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults/index.js\");\nvar Cancel = __webpack_require__(/*! ../cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new Cancel('canceled');\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTtBQUNoQyxvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLHVFQUFvQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsK0RBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLG1FQUFrQjs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcz80ZGM5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvQ2FuY2VsJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cblxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgQ2FuY2VsKCdjYW5jZWxlZCcpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNcbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/dispatchRequest.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  };\n  return error;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanM/MGRmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG5cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XG5cbiAgZXJyb3IudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgc3RhdHVzOiB0aGlzLnJlc3BvbnNlICYmIHRoaXMucmVzcG9uc2Uuc3RhdHVzID8gdGhpcy5yZXNwb25zZS5zdGF0dXMgOiBudWxsXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGVycm9yO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/enhanceError.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(prop) {\n    if (prop in config2) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  var mergeMap = {\n    'url': valueFromConfig2,\n    'method': valueFromConfig2,\n    'data': valueFromConfig2,\n    'baseURL': defaultToConfig2,\n    'transformRequest': defaultToConfig2,\n    'transformResponse': defaultToConfig2,\n    'paramsSerializer': defaultToConfig2,\n    'timeout': defaultToConfig2,\n    'timeoutMessage': defaultToConfig2,\n    'withCredentials': defaultToConfig2,\n    'adapter': defaultToConfig2,\n    'responseType': defaultToConfig2,\n    'xsrfCookieName': defaultToConfig2,\n    'xsrfHeaderName': defaultToConfig2,\n    'onUploadProgress': defaultToConfig2,\n    'onDownloadProgress': defaultToConfig2,\n    'decompress': defaultToConfig2,\n    'maxContentLength': defaultToConfig2,\n    'maxBodyLength': defaultToConfig2,\n    'transport': defaultToConfig2,\n    'httpAgent': defaultToConfig2,\n    'httpsAgent': defaultToConfig2,\n    'cancelToken': defaultToConfig2,\n    'socketPath': defaultToConfig2,\n    'responseEncoding': defaultToConfig2,\n    'validateStatus': mergeDirectKeys\n  };\n\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    var merge = mergeMap[prop] || mergeDeepProperties;\n    var configValue = merge(prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLG1EQUFVOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJCQUEyQjtBQUMzQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcz9iZDEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURpcmVjdEtleXMocHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1lcmdlTWFwID0ge1xuICAgICd1cmwnOiB2YWx1ZUZyb21Db25maWcyLFxuICAgICdtZXRob2QnOiB2YWx1ZUZyb21Db25maWcyLFxuICAgICdkYXRhJzogdmFsdWVGcm9tQ29uZmlnMixcbiAgICAnYmFzZVVSTCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RyYW5zZm9ybVJlcXVlc3QnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0cmFuc2Zvcm1SZXNwb25zZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3BhcmFtc1NlcmlhbGl6ZXInOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0aW1lb3V0JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndGltZW91dE1lc3NhZ2UnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd3aXRoQ3JlZGVudGlhbHMnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdhZGFwdGVyJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAncmVzcG9uc2VUeXBlJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAneHNyZkNvb2tpZU5hbWUnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd4c3JmSGVhZGVyTmFtZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ29uVXBsb2FkUHJvZ3Jlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdvbkRvd25sb2FkUHJvZ3Jlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdkZWNvbXByZXNzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnbWF4Q29udGVudExlbmd0aCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ21heEJvZHlMZW5ndGgnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0cmFuc3BvcnQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdodHRwQWdlbnQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdodHRwc0FnZW50JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnY2FuY2VsVG9rZW4nOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdzb2NrZXRQYXRoJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAncmVzcG9uc2VFbmNvZGluZyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3ZhbGlkYXRlU3RhdHVzJzogbWVyZ2VEaXJlY3RLZXlzXG4gIH07XG5cbiAgdXRpbHMuZm9yRWFjaChPYmplY3Qua2V5cyhjb25maWcxKS5jb25jYXQoT2JqZWN0LmtleXMoY29uZmlnMikpLCBmdW5jdGlvbiBjb21wdXRlQ29uZmlnVmFsdWUocHJvcCkge1xuICAgIHZhciBtZXJnZSA9IG1lcmdlTWFwW3Byb3BdIHx8IG1lcmdlRGVlcFByb3BlcnRpZXM7XG4gICAgdmFyIGNvbmZpZ1ZhbHVlID0gbWVyZ2UocHJvcCk7XG4gICAgKHV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZ1ZhbHVlKSAmJiBtZXJnZSAhPT0gbWVyZ2VEaXJlY3RLZXlzKSB8fCAoY29uZmlnW3Byb3BdID0gY29uZmlnVmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/mergeConfig.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar createError = __webpack_require__(/*! ./createError */ \"./node_modules/axios/lib/core/createError.js\");\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLG1FQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzPzg3NjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/settle.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults/index.js\");\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7QUFDaEMsZUFBZSxtQkFBTyxDQUFDLCtEQUFhOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanM/NzY2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICB2YXIgY29udGV4dCA9IHRoaXMgfHwgZGVmYXVsdHM7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuLmNhbGwoY29udGV4dCwgZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/core/transformData.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/defaults/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/defaults/index.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\nvar normalizeHeaderName = __webpack_require__(/*! ../helpers/normalizeHeaderName */ \"./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\nvar enhanceError = __webpack_require__(/*! ../core/enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\nvar transitionalDefaults = __webpack_require__(/*! ./transitional */ \"./node_modules/axios/lib/defaults/transitional.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ../adapters/xhr */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ../adapters/http */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional || defaults.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*'\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsbURBQVU7QUFDOUIsMEJBQTBCLG1CQUFPLENBQUMsK0ZBQWdDO0FBQ2xFLG1CQUFtQixtQkFBTyxDQUFDLDJFQUFzQjtBQUNqRCwyQkFBMkIsbUJBQU8sQ0FBQyx5RUFBZ0I7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGlFQUFpQjtBQUN2QyxJQUFJLGdCQUFnQixPQUFPLG1EQUFtRCxPQUFPO0FBQ3JGO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGtFQUFrQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy9pbmRleC5qcz9mZjEwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9lbmhhbmNlRXJyb3InKTtcbnZhciB0cmFuc2l0aW9uYWxEZWZhdWx0cyA9IHJlcXVpcmUoJy4vdHJhbnNpdGlvbmFsJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4uL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuXG4gIHRyYW5zaXRpb25hbDogdHJhbnNpdGlvbmFsRGVmYXVsdHMsXG5cbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSB8fCAoaGVhZGVycyAmJiBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IGRlZmF1bHRzLnRyYW5zaXRpb25hbDtcbiAgICB2YXIgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgIHZhciBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgdmFyIHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcgfHwgKGZvcmNlZEpTT05QYXJzaW5nICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGVuaGFuY2VFcnJvcihlLCB0aGlzLCAnRV9KU09OX1BBUlNFJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH0sXG5cbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gICAgfVxuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/defaults/index.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/defaults/transitional.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/defaults/transitional.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nmodule.exports = {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzPzI3YTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2lsZW50SlNPTlBhcnNpbmc6IHRydWUsXG4gIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/defaults/transitional.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = {\n  \"version\": \"0.26.1\"\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2Vudi9kYXRhLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2Vudi9kYXRhLmpzPzExMGYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFwidmVyc2lvblwiOiBcIjAuMjYuMVwiXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/env/data.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanM/NGJlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/bind.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzP2MxNzgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/buildURL.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcz82YmM2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/combineURLs.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0MsU0FBUzs7QUFFVDtBQUNBLDREQUE0RCx3QkFBd0I7QUFDcEY7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcz8xZDNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/cookies.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzP2EyMjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGQrXFwtLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/isAbsoluteURL.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanM/YmQ5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiB1dGlscy5pc09iamVjdChwYXlsb2FkKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/isAxiosError.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcz84Nzk1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/isURLSameOrigin.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsbURBQVU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcz82YjE1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/normalizeHeaderName.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzPzU0ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/parseHeaders.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanM/MjcyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/spread.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar VERSION = (__webpack_require__(/*! ../env/data */ \"./node_modules/axios/lib/env/data.js\").version);\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  assertOptions: assertOptions,\n  validators: validators\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdmFsaWRhdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsd0ZBQThCOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcz8wMTMyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFZFUlNJT04gPSByZXF1aXJlKCcuLi9lbnYvZGF0YScpLnZlcnNpb247XG5cbnZhciB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaChmdW5jdGlvbih0eXBlLCBpKSB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG52YXIgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG5cbi8qKlxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb24gLSBkZXByZWNhdGVkIHZlcnNpb24gLyByZW1vdmVkIHNpbmNlIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICovXG52YWxpZGF0b3JzLnRyYW5zaXRpb25hbCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25hbCh2YWxpZGF0b3IsIHZlcnNpb24sIG1lc3NhZ2UpIHtcbiAgZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShvcHQsIGRlc2MpIHtcbiAgICByZXR1cm4gJ1tBeGlvcyB2JyArIFZFUlNJT04gKyAnXSBUcmFuc2l0aW9uYWwgb3B0aW9uIFxcJycgKyBvcHQgKyAnXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvcHQsIG9wdHMpIHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQnICsgKHZlcnNpb24gPyAnIGluICcgKyB2ZXJzaW9uIDogJycpKSk7XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gJiYgIWRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdKSB7XG4gICAgICBkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSA9IHRydWU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIG9wdCxcbiAgICAgICAgICAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdicgKyB2ZXJzaW9uICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZWFyIGZ1dHVyZSdcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdG9yID8gdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdHMpIDogdHJ1ZTtcbiAgfTtcbn07XG5cbi8qKlxuICogQXNzZXJ0IG9iamVjdCdzIHByb3BlcnRpZXMgdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGFsbG93VW5rbm93blxuICovXG5cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbnMob3B0aW9ucywgc2NoZW1hLCBhbGxvd1Vua25vd24pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIHZhciBvcHQgPSBrZXlzW2ldO1xuICAgIHZhciB2YWxpZGF0b3IgPSBzY2hlbWFbb3B0XTtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW29wdF07XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiAnICsgb3B0ICsgJyBtdXN0IGJlICcgKyByZXN1bHQpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbGxvd1Vua25vd24gIT09IHRydWUpIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIG9wdGlvbiAnICsgb3B0KTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFzc2VydE9wdGlvbnM6IGFzc2VydE9wdGlvbnMsXG4gIHZhbGlkYXRvcnM6IHZhbGlkYXRvcnNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/helpers/validator.js\n"));

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return toString.call(val) === '[object FormData]';\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return toString.call(val) === '[object URLSearchParams]';\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxnRUFBZ0I7O0FBRW5DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxHQUFHLFNBQVM7QUFDNUMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0QkFBNEI7QUFDNUIsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcz9jOWViIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZvcm1EYXRhXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBVUkxTZWFyY2hQYXJhbXNdJztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW0sXG4gIHN0cmlwQk9NOiBzdHJpcEJPTVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/axios/lib/utils.js\n"));

/***/ }),

/***/ "./node_modules/form-data/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/form-data/lib/browser.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* eslint-env browser */\nmodule.exports = typeof self == 'object' ? self.FormData : window.FormData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9icm93c2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Zvcm0tZGF0YS9saWIvYnJvd3Nlci5qcz8wY2IyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyA/IHNlbGYuRm9ybURhdGEgOiB3aW5kb3cuRm9ybURhdGE7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/form-data/lib/browser.js\n"));

/***/ }),

/***/ "./node_modules/mic-recorder-to-mp3/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/mic-recorder-to-mp3/dist/index.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n\t true ? module.exports = factory() :\n\t0;\n}(this, (function () {\n\nfunction new_byte$1(count) {\n    return new Int8Array(count);\n}\n\nfunction new_short(count) {\n    return new Int16Array(count);\n}\n\nfunction new_int$1(count) {\n    return new Int32Array(count);\n}\n\nfunction new_float$1(count) {\n    return new Float32Array(count);\n}\n\nfunction new_double$1(count) {\n    return new Float64Array(count);\n}\n\nfunction new_float_n$1(args) {\n    if (args.length == 1) {\n        return new_float$1(args[0]);\n    }\n    var sz = args[0];\n    args = args.slice(1);\n    var A = [];\n    for (var i = 0; i < sz; i++) {\n        A.push(new_float_n$1(args));\n    }\n    return A;\n}\nfunction new_int_n$1(args) {\n    if (args.length == 1) {\n        return new_int$1(args[0]);\n    }\n    var sz = args[0];\n    args = args.slice(1);\n    var A = [];\n    for (var i = 0; i < sz; i++) {\n        A.push(new_int_n$1(args));\n    }\n    return A;\n}\n\nfunction new_short_n(args) {\n    if (args.length == 1) {\n        return new_short(args[0]);\n    }\n    var sz = args[0];\n    args = args.slice(1);\n    var A = [];\n    for (var i = 0; i < sz; i++) {\n        A.push(new_short_n(args));\n    }\n    return A;\n}\n\nfunction new_array_n$1(args) {\n    if (args.length == 1) {\n        return new Array(args[0]);\n    }\n    var sz = args[0];\n    args = args.slice(1);\n    var A = [];\n    for (var i = 0; i < sz; i++) {\n        A.push(new_array_n$1(args));\n    }\n    return A;\n}\n\n\nvar Arrays$1 = {};\n\nArrays$1.fill = function (a, fromIndex, toIndex, val) {\n    if (arguments.length == 2) {\n        for (var i = 0; i < a.length; i++) {\n            a[i] = arguments[1];\n        }\n    } else {\n        for (var i = fromIndex; i < toIndex; i++) {\n            a[i] = val;\n        }\n    }\n};\n\nvar System$1 = {};\n\nSystem$1.arraycopy = function (src, srcPos, dest, destPos, length) {\n    var srcEnd = srcPos + length;\n    while (srcPos < srcEnd)\n        dest[destPos++] = src[srcPos++];\n};\n\n\nvar Util$1 = {};\nUtil$1.SQRT2 = 1.41421356237309504880;\nUtil$1.FAST_LOG10 = function (x) {\n    return Math.log10(x);\n};\n\nUtil$1.FAST_LOG10_X = function (x, y) {\n    return Math.log10(x) * y;\n};\n\nfunction ShortBlock$1(ordinal) {\n    this.ordinal = ordinal;\n}\n/**\n * LAME may use them, even different block types for L/R.\n */\nShortBlock$1.short_block_allowed = new ShortBlock$1(0);\n/**\n * LAME may use them, but always same block types in L/R.\n */\nShortBlock$1.short_block_coupled = new ShortBlock$1(1);\n/**\n * LAME will not use short blocks, long blocks only.\n */\nShortBlock$1.short_block_dispensed = new ShortBlock$1(2);\n/**\n * LAME will not use long blocks, short blocks only.\n */\nShortBlock$1.short_block_forced = new ShortBlock$1(3);\n\nvar Float$1 = {};\nFloat$1.MAX_VALUE = 3.4028235e+38;\n\nfunction VbrMode$1(ordinal) {\n    this.ordinal = ordinal;\n}\nVbrMode$1.vbr_off = new VbrMode$1(0);\nVbrMode$1.vbr_mt = new VbrMode$1(1);\nVbrMode$1.vbr_rh = new VbrMode$1(2);\nVbrMode$1.vbr_abr = new VbrMode$1(3);\nVbrMode$1.vbr_mtrh = new VbrMode$1(4);\nVbrMode$1.vbr_default = VbrMode$1.vbr_mtrh;\n\nvar assert$1 = function (x) {\n    //console.assert(x);\n};\n\nvar common = {\n    \"System\": System$1,\n    \"VbrMode\": VbrMode$1,\n    \"Float\": Float$1,\n    \"ShortBlock\": ShortBlock$1,\n    \"Util\": Util$1,\n    \"Arrays\": Arrays$1,\n    \"new_array_n\": new_array_n$1,\n    \"new_byte\": new_byte$1,\n    \"new_double\": new_double$1,\n    \"new_float\": new_float$1,\n    \"new_float_n\": new_float_n$1,\n    \"new_int\": new_int$1,\n    \"new_int_n\": new_int_n$1,\n    \"new_short\": new_short,\n    \"new_short_n\": new_short_n,\n    \"assert\": assert$1\n};\n\n/*\n *      MP3 window subband -> subband filtering -> mdct routine\n *\n *      Copyright (c) 1999-2000 Takehiro Tominaga\n *\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n/*\n *         Special Thanks to Patrick De Smet for your advices.\n */\n\n/* $Id: NewMDCT.java,v 1.11 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n//import java.util.Arrays;\n\nvar System$6 = common.System;\nvar Util$6 = common.Util;\nvar Arrays$6 = common.Arrays;\nvar new_float$6 = common.new_float;\nfunction NewMDCT() {\n\n\tvar enwindow = [\n\t\t\t-4.77e-07 * 0.740951125354959 / 2.384e-06,\n\t\t\t1.03951e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t9.53674e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t2.841473e-03 * 0.740951125354959 / 2.384e-06,\n\t\t\t3.5758972e-02 * 0.740951125354959 / 2.384e-06,\n\t\t\t3.401756e-03 * 0.740951125354959 / 2.384e-06,\n\t\t\t9.83715e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t9.9182e-05 * 0.740951125354959 / 2.384e-06, /* 15 */\n\t\t\t1.2398e-05 * 0.740951125354959 / 2.384e-06,\n\t\t\t1.91212e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t2.283096e-03 * 0.740951125354959 / 2.384e-06,\n\t\t\t1.6994476e-02 * 0.740951125354959 / 2.384e-06,\n\t\t\t-1.8756866e-02 * 0.740951125354959 / 2.384e-06,\n\t\t\t-2.630711e-03 * 0.740951125354959 / 2.384e-06,\n\t\t\t-2.47478e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t-1.4782e-05 * 0.740951125354959 / 2.384e-06,\n\t\t\t9.063471690191471e-01, 1.960342806591213e-01,\n\n\t\t\t-4.77e-07 * 0.773010453362737 / 2.384e-06,\n\t\t\t1.05858e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t9.30786e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t2.521515e-03 * 0.773010453362737 / 2.384e-06,\n\t\t\t3.5694122e-02 * 0.773010453362737 / 2.384e-06,\n\t\t\t3.643036e-03 * 0.773010453362737 / 2.384e-06,\n\t\t\t9.91821e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t9.6321e-05 * 0.773010453362737 / 2.384e-06, /* 14 */\n\t\t\t1.1444e-05 * 0.773010453362737 / 2.384e-06,\n\t\t\t1.65462e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t2.110004e-03 * 0.773010453362737 / 2.384e-06,\n\t\t\t1.6112804e-02 * 0.773010453362737 / 2.384e-06,\n\t\t\t-1.9634247e-02 * 0.773010453362737 / 2.384e-06,\n\t\t\t-2.803326e-03 * 0.773010453362737 / 2.384e-06,\n\t\t\t-2.77042e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t-1.6689e-05 * 0.773010453362737 / 2.384e-06,\n\t\t\t8.206787908286602e-01, 3.901806440322567e-01,\n\n\t\t\t-4.77e-07 * 0.803207531480645 / 2.384e-06,\n\t\t\t1.07288e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t9.02653e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t2.174854e-03 * 0.803207531480645 / 2.384e-06,\n\t\t\t3.5586357e-02 * 0.803207531480645 / 2.384e-06,\n\t\t\t3.858566e-03 * 0.803207531480645 / 2.384e-06,\n\t\t\t9.95159e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t9.3460e-05 * 0.803207531480645 / 2.384e-06, /* 13 */\n\t\t\t1.0014e-05 * 0.803207531480645 / 2.384e-06,\n\t\t\t1.40190e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t1.937389e-03 * 0.803207531480645 / 2.384e-06,\n\t\t\t1.5233517e-02 * 0.803207531480645 / 2.384e-06,\n\t\t\t-2.0506859e-02 * 0.803207531480645 / 2.384e-06,\n\t\t\t-2.974033e-03 * 0.803207531480645 / 2.384e-06,\n\t\t\t-3.07560e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t-1.8120e-05 * 0.803207531480645 / 2.384e-06,\n\t\t\t7.416505462720353e-01, 5.805693545089249e-01,\n\n\t\t\t-4.77e-07 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.08242e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t8.68797e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.800537e-03 * 0.831469612302545 / 2.384e-06,\n\t\t\t3.5435200e-02 * 0.831469612302545 / 2.384e-06,\n\t\t\t4.049301e-03 * 0.831469612302545 / 2.384e-06,\n\t\t\t9.94205e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t9.0599e-05 * 0.831469612302545 / 2.384e-06, /* 12 */\n\t\t\t9.060e-06 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.16348e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.766682e-03 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.4358521e-02 * 0.831469612302545 / 2.384e-06,\n\t\t\t-2.1372318e-02 * 0.831469612302545 / 2.384e-06,\n\t\t\t-3.14188e-03 * 0.831469612302545 / 2.384e-06,\n\t\t\t-3.39031e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t-1.9550e-05 * 0.831469612302545 / 2.384e-06,\n\t\t\t6.681786379192989e-01, 7.653668647301797e-01,\n\n\t\t\t-4.77e-07 * 0.857728610000272 / 2.384e-06,\n\t\t\t1.08719e-04 * 0.857728610000272 / 2.384e-06,\n\t\t\t8.29220e-04 * 0.857728610000272 / 2.384e-06,\n\t\t\t1.399517e-03 * 0.857728610000272 / 2.384e-06,\n\t\t\t3.5242081e-02 * 0.857728610000272 / 2.384e-06,\n\t\t\t4.215240e-03 * 0.857728610000272 / 2.384e-06,\n\t\t\t9.89437e-04 * 0.857728610000272 / 2.384e-06,\n\t\t\t8.7261e-05 * 0.857728610000272 / 2.384e-06, /* 11 */\n\t\t\t8.106e-06 * 0.857728610000272 / 2.384e-06,\n\t\t\t9.3937e-05 * 0.857728610000272 / 2.384e-06,\n\t\t\t1.597881e-03 * 0.857728610000272 / 2.384e-06,\n\t\t\t1.3489246e-02 * 0.857728610000272 / 2.384e-06,\n\t\t\t-2.2228718e-02 * 0.857728610000272 / 2.384e-06,\n\t\t\t-3.306866e-03 * 0.857728610000272 / 2.384e-06,\n\t\t\t-3.71456e-04 * 0.857728610000272 / 2.384e-06,\n\t\t\t-2.1458e-05 * 0.857728610000272 / 2.384e-06,\n\t\t\t5.993769336819237e-01, 9.427934736519954e-01,\n\n\t\t\t-4.77e-07 * 0.881921264348355 / 2.384e-06,\n\t\t\t1.08719e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t7.8392e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t9.71317e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t3.5007000e-02 * 0.881921264348355 / 2.384e-06,\n\t\t\t4.357815e-03 * 0.881921264348355 / 2.384e-06,\n\t\t\t9.80854e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t8.3923e-05 * 0.881921264348355 / 2.384e-06, /* 10 */\n\t\t\t7.629e-06 * 0.881921264348355 / 2.384e-06,\n\t\t\t7.2956e-05 * 0.881921264348355 / 2.384e-06,\n\t\t\t1.432419e-03 * 0.881921264348355 / 2.384e-06,\n\t\t\t1.2627602e-02 * 0.881921264348355 / 2.384e-06,\n\t\t\t-2.3074150e-02 * 0.881921264348355 / 2.384e-06,\n\t\t\t-3.467083e-03 * 0.881921264348355 / 2.384e-06,\n\t\t\t-4.04358e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t-2.3365e-05 * 0.881921264348355 / 2.384e-06,\n\t\t\t5.345111359507916e-01, 1.111140466039205e+00,\n\n\t\t\t-9.54e-07 * 0.903989293123443 / 2.384e-06,\n\t\t\t1.08242e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t7.31945e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t5.15938e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t3.4730434e-02 * 0.903989293123443 / 2.384e-06,\n\t\t\t4.477024e-03 * 0.903989293123443 / 2.384e-06,\n\t\t\t9.68933e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t8.0585e-05 * 0.903989293123443 / 2.384e-06, /* 9 */\n\t\t\t6.676e-06 * 0.903989293123443 / 2.384e-06,\n\t\t\t5.2929e-05 * 0.903989293123443 / 2.384e-06,\n\t\t\t1.269817e-03 * 0.903989293123443 / 2.384e-06,\n\t\t\t1.1775017e-02 * 0.903989293123443 / 2.384e-06,\n\t\t\t-2.3907185e-02 * 0.903989293123443 / 2.384e-06,\n\t\t\t-3.622532e-03 * 0.903989293123443 / 2.384e-06,\n\t\t\t-4.38213e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t-2.5272e-05 * 0.903989293123443 / 2.384e-06,\n\t\t\t4.729647758913199e-01, 1.268786568327291e+00,\n\n\t\t\t-9.54e-07 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t1.06812e-04 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t6.74248e-04 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t3.3379e-05 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t3.4412861e-02 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t4.573822e-03 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t9.54151e-04 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t7.6771e-05 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t6.199e-06 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t3.4332e-05 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t1.111031e-03 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t1.0933399e-02 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t-2.4725437e-02 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t-3.771782e-03 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t-4.72546e-04 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t-2.7657e-05 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t4.1421356237309504879e-01, /* tan(PI/8) */\n\t\t\t1.414213562373095e+00,\n\n\t\t\t-9.54e-07 * 0.941544065183021 / 2.384e-06,\n\t\t\t1.05381e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t6.10352e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t-4.75883e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t3.4055710e-02 * 0.941544065183021 / 2.384e-06,\n\t\t\t4.649162e-03 * 0.941544065183021 / 2.384e-06,\n\t\t\t9.35555e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t7.3433e-05 * 0.941544065183021 / 2.384e-06, /* 7 */\n\t\t\t5.245e-06 * 0.941544065183021 / 2.384e-06,\n\t\t\t1.7166e-05 * 0.941544065183021 / 2.384e-06,\n\t\t\t9.56535e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t1.0103703e-02 * 0.941544065183021 / 2.384e-06,\n\t\t\t-2.5527000e-02 * 0.941544065183021 / 2.384e-06,\n\t\t\t-3.914356e-03 * 0.941544065183021 / 2.384e-06,\n\t\t\t-5.07355e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t-3.0041e-05 * 0.941544065183021 / 2.384e-06,\n\t\t\t3.578057213145241e-01, 1.546020906725474e+00,\n\n\t\t\t-9.54e-07 * 0.956940335732209 / 2.384e-06,\n\t\t\t1.02520e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t5.39303e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t-1.011848e-03 * 0.956940335732209 / 2.384e-06,\n\t\t\t3.3659935e-02 * 0.956940335732209 / 2.384e-06,\n\t\t\t4.703045e-03 * 0.956940335732209 / 2.384e-06,\n\t\t\t9.15051e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t7.0095e-05 * 0.956940335732209 / 2.384e-06, /* 6 */\n\t\t\t4.768e-06 * 0.956940335732209 / 2.384e-06,\n\t\t\t9.54e-07 * 0.956940335732209 / 2.384e-06,\n\t\t\t8.06808e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t9.287834e-03 * 0.956940335732209 / 2.384e-06,\n\t\t\t-2.6310921e-02 * 0.956940335732209 / 2.384e-06,\n\t\t\t-4.048824e-03 * 0.956940335732209 / 2.384e-06,\n\t\t\t-5.42164e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t-3.2425e-05 * 0.956940335732209 / 2.384e-06,\n\t\t\t3.033466836073424e-01, 1.662939224605090e+00,\n\n\t\t\t-1.431e-06 * 0.970031253194544 / 2.384e-06,\n\t\t\t9.9182e-05 * 0.970031253194544 / 2.384e-06,\n\t\t\t4.62532e-04 * 0.970031253194544 / 2.384e-06,\n\t\t\t-1.573563e-03 * 0.970031253194544 / 2.384e-06,\n\t\t\t3.3225536e-02 * 0.970031253194544 / 2.384e-06,\n\t\t\t4.737377e-03 * 0.970031253194544 / 2.384e-06,\n\t\t\t8.91685e-04 * 0.970031253194544 / 2.384e-06,\n\t\t\t6.6280e-05 * 0.970031253194544 / 2.384e-06, /* 5 */\n\t\t\t4.292e-06 * 0.970031253194544 / 2.384e-06,\n\t\t\t-1.3828e-05 * 0.970031253194544 / 2.384e-06,\n\t\t\t6.61850e-04 * 0.970031253194544 / 2.384e-06,\n\t\t\t8.487225e-03 * 0.970031253194544 / 2.384e-06,\n\t\t\t-2.7073860e-02 * 0.970031253194544 / 2.384e-06,\n\t\t\t-4.174709e-03 * 0.970031253194544 / 2.384e-06,\n\t\t\t-5.76973e-04 * 0.970031253194544 / 2.384e-06,\n\t\t\t-3.4809e-05 * 0.970031253194544 / 2.384e-06,\n\t\t\t2.504869601913055e-01, 1.763842528696710e+00,\n\n\t\t\t-1.431e-06 * 0.98078528040323 / 2.384e-06,\n\t\t\t9.5367e-05 * 0.98078528040323 / 2.384e-06,\n\t\t\t3.78609e-04 * 0.98078528040323 / 2.384e-06,\n\t\t\t-2.161503e-03 * 0.98078528040323 / 2.384e-06,\n\t\t\t3.2754898e-02 * 0.98078528040323 / 2.384e-06,\n\t\t\t4.752159e-03 * 0.98078528040323 / 2.384e-06,\n\t\t\t8.66413e-04 * 0.98078528040323 / 2.384e-06,\n\t\t\t6.2943e-05 * 0.98078528040323 / 2.384e-06, /* 4 */\n\t\t\t3.815e-06 * 0.98078528040323 / 2.384e-06,\n\t\t\t-2.718e-05 * 0.98078528040323 / 2.384e-06,\n\t\t\t5.22137e-04 * 0.98078528040323 / 2.384e-06,\n\t\t\t7.703304e-03 * 0.98078528040323 / 2.384e-06,\n\t\t\t-2.7815342e-02 * 0.98078528040323 / 2.384e-06,\n\t\t\t-4.290581e-03 * 0.98078528040323 / 2.384e-06,\n\t\t\t-6.11782e-04 * 0.98078528040323 / 2.384e-06,\n\t\t\t-3.7670e-05 * 0.98078528040323 / 2.384e-06,\n\t\t\t1.989123673796580e-01, 1.847759065022573e+00,\n\n\t\t\t-1.907e-06 * 0.989176509964781 / 2.384e-06,\n\t\t\t9.0122e-05 * 0.989176509964781 / 2.384e-06,\n\t\t\t2.88486e-04 * 0.989176509964781 / 2.384e-06,\n\t\t\t-2.774239e-03 * 0.989176509964781 / 2.384e-06,\n\t\t\t3.2248020e-02 * 0.989176509964781 / 2.384e-06,\n\t\t\t4.748821e-03 * 0.989176509964781 / 2.384e-06,\n\t\t\t8.38757e-04 * 0.989176509964781 / 2.384e-06,\n\t\t\t5.9605e-05 * 0.989176509964781 / 2.384e-06, /* 3 */\n\t\t\t3.338e-06 * 0.989176509964781 / 2.384e-06,\n\t\t\t-3.9577e-05 * 0.989176509964781 / 2.384e-06,\n\t\t\t3.88145e-04 * 0.989176509964781 / 2.384e-06,\n\t\t\t6.937027e-03 * 0.989176509964781 / 2.384e-06,\n\t\t\t-2.8532982e-02 * 0.989176509964781 / 2.384e-06,\n\t\t\t-4.395962e-03 * 0.989176509964781 / 2.384e-06,\n\t\t\t-6.46591e-04 * 0.989176509964781 / 2.384e-06,\n\t\t\t-4.0531e-05 * 0.989176509964781 / 2.384e-06,\n\t\t\t1.483359875383474e-01, 1.913880671464418e+00,\n\n\t\t\t-1.907e-06 * 0.995184726672197 / 2.384e-06,\n\t\t\t8.4400e-05 * 0.995184726672197 / 2.384e-06,\n\t\t\t1.91689e-04 * 0.995184726672197 / 2.384e-06,\n\t\t\t-3.411293e-03 * 0.995184726672197 / 2.384e-06,\n\t\t\t3.1706810e-02 * 0.995184726672197 / 2.384e-06,\n\t\t\t4.728317e-03 * 0.995184726672197 / 2.384e-06,\n\t\t\t8.09669e-04 * 0.995184726672197 / 2.384e-06,\n\t\t\t5.579e-05 * 0.995184726672197 / 2.384e-06,\n\t\t\t3.338e-06 * 0.995184726672197 / 2.384e-06,\n\t\t\t-5.0545e-05 * 0.995184726672197 / 2.384e-06,\n\t\t\t2.59876e-04 * 0.995184726672197 / 2.384e-06,\n\t\t\t6.189346e-03 * 0.995184726672197 / 2.384e-06,\n\t\t\t-2.9224873e-02 * 0.995184726672197 / 2.384e-06,\n\t\t\t-4.489899e-03 * 0.995184726672197 / 2.384e-06,\n\t\t\t-6.80923e-04 * 0.995184726672197 / 2.384e-06,\n\t\t\t-4.3392e-05 * 0.995184726672197 / 2.384e-06,\n\t\t\t9.849140335716425e-02, 1.961570560806461e+00,\n\n\t\t\t-2.384e-06 * 0.998795456205172 / 2.384e-06,\n\t\t\t7.7724e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t8.8215e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t-4.072189e-03 * 0.998795456205172 / 2.384e-06,\n\t\t\t3.1132698e-02 * 0.998795456205172 / 2.384e-06,\n\t\t\t4.691124e-03 * 0.998795456205172 / 2.384e-06,\n\t\t\t7.79152e-04 * 0.998795456205172 / 2.384e-06,\n\t\t\t5.2929e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t2.861e-06 * 0.998795456205172 / 2.384e-06,\n\t\t\t-6.0558e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t1.37329e-04 * 0.998795456205172 / 2.384e-06,\n\t\t\t5.462170e-03 * 0.998795456205172 / 2.384e-06,\n\t\t\t-2.9890060e-02 * 0.998795456205172 / 2.384e-06,\n\t\t\t-4.570484e-03 * 0.998795456205172 / 2.384e-06,\n\t\t\t-7.14302e-04 * 0.998795456205172 / 2.384e-06,\n\t\t\t-4.6253e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t4.912684976946725e-02, 1.990369453344394e+00,\n\n\t\t\t3.5780907e-02 * Util$6.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t1.7876148e-02 * Util$6.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t3.134727e-03 * Util$6.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t2.457142e-03 * Util$6.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t9.71317e-04 * Util$6.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t2.18868e-04 * Util$6.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t1.01566e-04 * Util$6.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t1.3828e-05 * Util$6.SQRT2 * 0.5 / 2.384e-06,\n\n\t\t\t3.0526638e-02 / 2.384e-06, 4.638195e-03 / 2.384e-06,\n\t\t\t7.47204e-04 / 2.384e-06, 4.9591e-05 / 2.384e-06,\n\t\t\t4.756451e-03 / 2.384e-06, 2.1458e-05 / 2.384e-06,\n\t\t\t-6.9618e-05 / 2.384e-06, /* 2.384e-06/2.384e-06 */\n\t];\n\n\tvar NS = 12;\n\tvar NL = 36;\n\n\tvar win = [\n\t    [\n\t     2.382191739347913e-13,\n\t     6.423305872147834e-13,\n\t     9.400849094049688e-13,\n\t     1.122435026096556e-12,\n\t     1.183840321267481e-12,\n\t     1.122435026096556e-12,\n\t     9.400849094049690e-13,\n\t     6.423305872147839e-13,\n\t     2.382191739347918e-13,\n\n\t     5.456116108943412e-12,\n\t     4.878985199565852e-12,\n\t     4.240448995017367e-12,\n\t     3.559909094758252e-12,\n\t     2.858043359288075e-12,\n\t     2.156177623817898e-12,\n\t     1.475637723558783e-12,\n\t     8.371015190102974e-13,\n\t     2.599706096327376e-13,\n\n\t     -5.456116108943412e-12,\n\t     -4.878985199565852e-12,\n\t     -4.240448995017367e-12,\n\t     -3.559909094758252e-12,\n\t     -2.858043359288076e-12,\n\t     -2.156177623817898e-12,\n\t     -1.475637723558783e-12,\n\t     -8.371015190102975e-13,\n\t     -2.599706096327376e-13,\n\n\t     -2.382191739347923e-13,\n\t     -6.423305872147843e-13,\n\t     -9.400849094049696e-13,\n\t     -1.122435026096556e-12,\n\t     -1.183840321267481e-12,\n\t     -1.122435026096556e-12,\n\t     -9.400849094049694e-13,\n\t     -6.423305872147840e-13,\n\t     -2.382191739347918e-13,\n\t     ],\n\t    [\n\t     2.382191739347913e-13,\n\t     6.423305872147834e-13,\n\t     9.400849094049688e-13,\n\t     1.122435026096556e-12,\n\t     1.183840321267481e-12,\n\t     1.122435026096556e-12,\n\t     9.400849094049688e-13,\n\t     6.423305872147841e-13,\n\t     2.382191739347918e-13,\n\n\t     5.456116108943413e-12,\n\t     4.878985199565852e-12,\n\t     4.240448995017367e-12,\n\t     3.559909094758253e-12,\n\t     2.858043359288075e-12,\n\t     2.156177623817898e-12,\n\t     1.475637723558782e-12,\n\t     8.371015190102975e-13,\n\t     2.599706096327376e-13,\n\n\t     -5.461314069809755e-12,\n\t     -4.921085770524055e-12,\n\t     -4.343405037091838e-12,\n\t     -3.732668368707687e-12,\n\t     -3.093523840190885e-12,\n\t     -2.430835727329465e-12,\n\t     -1.734679010007751e-12,\n\t     -9.748253656609281e-13,\n\t     -2.797435120168326e-13,\n\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     -2.283748241799531e-13,\n\t     -4.037858874020686e-13,\n\t     -2.146547464825323e-13,\n\t     ],\n\t    [\n\t     1.316524975873958e-01, /* win[SHORT_TYPE] */\n\t     4.142135623730950e-01,\n\t     7.673269879789602e-01,\n\n\t     1.091308501069271e+00, /* tantab_l */\n\t     1.303225372841206e+00,\n\t     1.569685577117490e+00,\n\t     1.920982126971166e+00,\n\t     2.414213562373094e+00,\n\t     3.171594802363212e+00,\n\t     4.510708503662055e+00,\n\t     7.595754112725146e+00,\n\t     2.290376554843115e+01,\n\n\t     0.98480775301220802032, /* cx */\n\t     0.64278760968653936292,\n\t     0.34202014332566882393,\n\t     0.93969262078590842791,\n\t     -0.17364817766693030343,\n\t     -0.76604444311897790243,\n\t     0.86602540378443870761,\n\t     0.500000000000000e+00,\n\n\t     -5.144957554275265e-01, /* ca */\n\t     -4.717319685649723e-01,\n\t     -3.133774542039019e-01,\n\t     -1.819131996109812e-01,\n\t     -9.457419252642064e-02,\n\t     -4.096558288530405e-02,\n\t     -1.419856857247115e-02,\n\t     -3.699974673760037e-03,\n\n\t     8.574929257125442e-01, /* cs */\n\t     8.817419973177052e-01,\n\t     9.496286491027329e-01,\n\t     9.833145924917901e-01,\n\t     9.955178160675857e-01,\n\t     9.991605581781475e-01,\n\t     9.998991952444470e-01,\n\t     9.999931550702802e-01,\n\t     ],\n\t    [\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     2.283748241799531e-13,\n\t     4.037858874020686e-13,\n\t     2.146547464825323e-13,\n\n\t     5.461314069809755e-12,\n\t     4.921085770524055e-12,\n\t     4.343405037091838e-12,\n\t     3.732668368707687e-12,\n\t     3.093523840190885e-12,\n\t     2.430835727329466e-12,\n\t     1.734679010007751e-12,\n\t     9.748253656609281e-13,\n\t     2.797435120168326e-13,\n\n\t     -5.456116108943413e-12,\n\t     -4.878985199565852e-12,\n\t     -4.240448995017367e-12,\n\t     -3.559909094758253e-12,\n\t     -2.858043359288075e-12,\n\t     -2.156177623817898e-12,\n\t     -1.475637723558782e-12,\n\t     -8.371015190102975e-13,\n\t     -2.599706096327376e-13,\n\n\t     -2.382191739347913e-13,\n\t     -6.423305872147834e-13,\n\t     -9.400849094049688e-13,\n\t     -1.122435026096556e-12,\n\t     -1.183840321267481e-12,\n\t     -1.122435026096556e-12,\n\t     -9.400849094049688e-13,\n\t     -6.423305872147841e-13,\n\t     -2.382191739347918e-13,\n\t     ]\n\t];\n\n\tvar tantab_l = win[Encoder_1.SHORT_TYPE];\n\tvar cx = win[Encoder_1.SHORT_TYPE];\n\tvar ca = win[Encoder_1.SHORT_TYPE];\n\tvar cs = win[Encoder_1.SHORT_TYPE];\n\n\t/**\n\t * new IDCT routine written by Takehiro TOMINAGA\n\t *\n\t * PURPOSE: Overlapping window on PCM samples<BR>\n\t *\n\t * SEMANTICS:<BR>\n\t * 32 16-bit pcm samples are scaled to fractional 2's complement and\n\t * concatenated to the end of the window buffer #x#. The updated window\n\t * buffer #x# is then windowed by the analysis window #c# to produce the\n\t * windowed sample #z#\n\t */\n\tvar order = [\n\t    0, 1, 16, 17, 8, 9, 24, 25, 4, 5, 20, 21, 12, 13, 28, 29,\n\t    2, 3, 18, 19, 10, 11, 26, 27, 6, 7, 22, 23, 14, 15, 30, 31\n\t];\n\n\t/**\n\t * returns sum_j=0^31 a[j]*cos(PI*j*(k+1/2)/32), 0<=k<32\n\t */\n\tfunction window_subband(x1, x1Pos, a) {\n\t\tvar wp = 10;\n\n\t\tvar x2 = x1Pos + 238 - 14 - 286;\n\n\t\tfor (var i = -15; i < 0; i++) {\n\t\t\tvar w, s, t;\n\n\t\t\tw = enwindow[wp + -10];\n\t\t\ts = x1[x2 + -224] * w;\n\t\t\tt = x1[x1Pos + 224] * w;\n\t\t\tw = enwindow[wp + -9];\n\t\t\ts += x1[x2 + -160] * w;\n\t\t\tt += x1[x1Pos + 160] * w;\n\t\t\tw = enwindow[wp + -8];\n\t\t\ts += x1[x2 + -96] * w;\n\t\t\tt += x1[x1Pos + 96] * w;\n\t\t\tw = enwindow[wp + -7];\n\t\t\ts += x1[x2 + -32] * w;\n\t\t\tt += x1[x1Pos + 32] * w;\n\t\t\tw = enwindow[wp + -6];\n\t\t\ts += x1[x2 + 32] * w;\n\t\t\tt += x1[x1Pos + -32] * w;\n\t\t\tw = enwindow[wp + -5];\n\t\t\ts += x1[x2 + 96] * w;\n\t\t\tt += x1[x1Pos + -96] * w;\n\t\t\tw = enwindow[wp + -4];\n\t\t\ts += x1[x2 + 160] * w;\n\t\t\tt += x1[x1Pos + -160] * w;\n\t\t\tw = enwindow[wp + -3];\n\t\t\ts += x1[x2 + 224] * w;\n\t\t\tt += x1[x1Pos + -224] * w;\n\n\t\t\tw = enwindow[wp + -2];\n\t\t\ts += x1[x1Pos + -256] * w;\n\t\t\tt -= x1[x2 + 256] * w;\n\t\t\tw = enwindow[wp + -1];\n\t\t\ts += x1[x1Pos + -192] * w;\n\t\t\tt -= x1[x2 + 192] * w;\n\t\t\tw = enwindow[wp + 0];\n\t\t\ts += x1[x1Pos + -128] * w;\n\t\t\tt -= x1[x2 + 128] * w;\n\t\t\tw = enwindow[wp + 1];\n\t\t\ts += x1[x1Pos + -64] * w;\n\t\t\tt -= x1[x2 + 64] * w;\n\t\t\tw = enwindow[wp + 2];\n\t\t\ts += x1[x1Pos + 0] * w;\n\t\t\tt -= x1[x2 + 0] * w;\n\t\t\tw = enwindow[wp + 3];\n\t\t\ts += x1[x1Pos + 64] * w;\n\t\t\tt -= x1[x2 + -64] * w;\n\t\t\tw = enwindow[wp + 4];\n\t\t\ts += x1[x1Pos + 128] * w;\n\t\t\tt -= x1[x2 + -128] * w;\n\t\t\tw = enwindow[wp + 5];\n\t\t\ts += x1[x1Pos + 192] * w;\n\t\t\tt -= x1[x2 + -192] * w;\n\n\t\t\t/*\n\t\t\t * this multiplyer could be removed, but it needs more 256 FLOAT\n\t\t\t * data. thinking about the data cache performance, I think we\n\t\t\t * should not use such a huge table. tt 2000/Oct/25\n\t\t\t */\n\t\t\ts *= enwindow[wp + 6];\n\t\t\tw = t - s;\n\t\t\ta[30 + i * 2] = t + s;\n\t\t\ta[31 + i * 2] = enwindow[wp + 7] * w;\n\t\t\twp += 18;\n\t\t\tx1Pos--;\n\t\t\tx2++;\n\t\t}\n\t\t{\n\t\t\tvar s, t, u, v;\n\t\t\tt = x1[x1Pos + -16] * enwindow[wp + -10];\n\t\t\ts = x1[x1Pos + -32] * enwindow[wp + -2];\n\t\t\tt += (x1[x1Pos + -48] - x1[x1Pos + 16]) * enwindow[wp + -9];\n\t\t\ts += x1[x1Pos + -96] * enwindow[wp + -1];\n\t\t\tt += (x1[x1Pos + -80] + x1[x1Pos + 48]) * enwindow[wp + -8];\n\t\t\ts += x1[x1Pos + -160] * enwindow[wp + 0];\n\t\t\tt += (x1[x1Pos + -112] - x1[x1Pos + 80]) * enwindow[wp + -7];\n\t\t\ts += x1[x1Pos + -224] * enwindow[wp + 1];\n\t\t\tt += (x1[x1Pos + -144] + x1[x1Pos + 112]) * enwindow[wp + -6];\n\t\t\ts -= x1[x1Pos + 32] * enwindow[wp + 2];\n\t\t\tt += (x1[x1Pos + -176] - x1[x1Pos + 144]) * enwindow[wp + -5];\n\t\t\ts -= x1[x1Pos + 96] * enwindow[wp + 3];\n\t\t\tt += (x1[x1Pos + -208] + x1[x1Pos + 176]) * enwindow[wp + -4];\n\t\t\ts -= x1[x1Pos + 160] * enwindow[wp + 4];\n\t\t\tt += (x1[x1Pos + -240] - x1[x1Pos + 208]) * enwindow[wp + -3];\n\t\t\ts -= x1[x1Pos + 224];\n\n\t\t\tu = s - t;\n\t\t\tv = s + t;\n\n\t\t\tt = a[14];\n\t\t\ts = a[15] - t;\n\n\t\t\ta[31] = v + t; /* A0 */\n\t\t\ta[30] = u + s; /* A1 */\n\t\t\ta[15] = u - s; /* A2 */\n\t\t\ta[14] = v - t; /* A3 */\n\t\t}\n\t\t{\n\t\t\tvar xr;\n\t\t\txr = a[28] - a[0];\n\t\t\ta[0] += a[28];\n\t\t\ta[28] = xr * enwindow[wp + -2 * 18 + 7];\n\t\t\txr = a[29] - a[1];\n\t\t\ta[1] += a[29];\n\t\t\ta[29] = xr * enwindow[wp + -2 * 18 + 7];\n\n\t\t\txr = a[26] - a[2];\n\t\t\ta[2] += a[26];\n\t\t\ta[26] = xr * enwindow[wp + -4 * 18 + 7];\n\t\t\txr = a[27] - a[3];\n\t\t\ta[3] += a[27];\n\t\t\ta[27] = xr * enwindow[wp + -4 * 18 + 7];\n\n\t\t\txr = a[24] - a[4];\n\t\t\ta[4] += a[24];\n\t\t\ta[24] = xr * enwindow[wp + -6 * 18 + 7];\n\t\t\txr = a[25] - a[5];\n\t\t\ta[5] += a[25];\n\t\t\ta[25] = xr * enwindow[wp + -6 * 18 + 7];\n\n\t\t\txr = a[22] - a[6];\n\t\t\ta[6] += a[22];\n\t\t\ta[22] = xr * Util$6.SQRT2;\n\t\t\txr = a[23] - a[7];\n\t\t\ta[7] += a[23];\n\t\t\ta[23] = xr * Util$6.SQRT2 - a[7];\n\t\t\ta[7] -= a[6];\n\t\t\ta[22] -= a[7];\n\t\t\ta[23] -= a[22];\n\n\t\t\txr = a[6];\n\t\t\ta[6] = a[31] - xr;\n\t\t\ta[31] = a[31] + xr;\n\t\t\txr = a[7];\n\t\t\ta[7] = a[30] - xr;\n\t\t\ta[30] = a[30] + xr;\n\t\t\txr = a[22];\n\t\t\ta[22] = a[15] - xr;\n\t\t\ta[15] = a[15] + xr;\n\t\t\txr = a[23];\n\t\t\ta[23] = a[14] - xr;\n\t\t\ta[14] = a[14] + xr;\n\n\t\t\txr = a[20] - a[8];\n\t\t\ta[8] += a[20];\n\t\t\ta[20] = xr * enwindow[wp + -10 * 18 + 7];\n\t\t\txr = a[21] - a[9];\n\t\t\ta[9] += a[21];\n\t\t\ta[21] = xr * enwindow[wp + -10 * 18 + 7];\n\n\t\t\txr = a[18] - a[10];\n\t\t\ta[10] += a[18];\n\t\t\ta[18] = xr * enwindow[wp + -12 * 18 + 7];\n\t\t\txr = a[19] - a[11];\n\t\t\ta[11] += a[19];\n\t\t\ta[19] = xr * enwindow[wp + -12 * 18 + 7];\n\n\t\t\txr = a[16] - a[12];\n\t\t\ta[12] += a[16];\n\t\t\ta[16] = xr * enwindow[wp + -14 * 18 + 7];\n\t\t\txr = a[17] - a[13];\n\t\t\ta[13] += a[17];\n\t\t\ta[17] = xr * enwindow[wp + -14 * 18 + 7];\n\n\t\t\txr = -a[20] + a[24];\n\t\t\ta[20] += a[24];\n\t\t\ta[24] = xr * enwindow[wp + -12 * 18 + 7];\n\t\t\txr = -a[21] + a[25];\n\t\t\ta[21] += a[25];\n\t\t\ta[25] = xr * enwindow[wp + -12 * 18 + 7];\n\n\t\t\txr = a[4] - a[8];\n\t\t\ta[4] += a[8];\n\t\t\ta[8] = xr * enwindow[wp + -12 * 18 + 7];\n\t\t\txr = a[5] - a[9];\n\t\t\ta[5] += a[9];\n\t\t\ta[9] = xr * enwindow[wp + -12 * 18 + 7];\n\n\t\t\txr = a[0] - a[12];\n\t\t\ta[0] += a[12];\n\t\t\ta[12] = xr * enwindow[wp + -4 * 18 + 7];\n\t\t\txr = a[1] - a[13];\n\t\t\ta[1] += a[13];\n\t\t\ta[13] = xr * enwindow[wp + -4 * 18 + 7];\n\t\t\txr = a[16] - a[28];\n\t\t\ta[16] += a[28];\n\t\t\ta[28] = xr * enwindow[wp + -4 * 18 + 7];\n\t\t\txr = -a[17] + a[29];\n\t\t\ta[17] += a[29];\n\t\t\ta[29] = xr * enwindow[wp + -4 * 18 + 7];\n\n\t\t\txr = Util$6.SQRT2 * (a[2] - a[10]);\n\t\t\ta[2] += a[10];\n\t\t\ta[10] = xr;\n\t\t\txr = Util$6.SQRT2 * (a[3] - a[11]);\n\t\t\ta[3] += a[11];\n\t\t\ta[11] = xr;\n\t\t\txr = Util$6.SQRT2 * (-a[18] + a[26]);\n\t\t\ta[18] += a[26];\n\t\t\ta[26] = xr - a[18];\n\t\t\txr = Util$6.SQRT2 * (-a[19] + a[27]);\n\t\t\ta[19] += a[27];\n\t\t\ta[27] = xr - a[19];\n\n\t\t\txr = a[2];\n\t\t\ta[19] -= a[3];\n\t\t\ta[3] -= xr;\n\t\t\ta[2] = a[31] - xr;\n\t\t\ta[31] += xr;\n\t\t\txr = a[3];\n\t\t\ta[11] -= a[19];\n\t\t\ta[18] -= xr;\n\t\t\ta[3] = a[30] - xr;\n\t\t\ta[30] += xr;\n\t\t\txr = a[18];\n\t\t\ta[27] -= a[11];\n\t\t\ta[19] -= xr;\n\t\t\ta[18] = a[15] - xr;\n\t\t\ta[15] += xr;\n\n\t\t\txr = a[19];\n\t\t\ta[10] -= xr;\n\t\t\ta[19] = a[14] - xr;\n\t\t\ta[14] += xr;\n\t\t\txr = a[10];\n\t\t\ta[11] -= xr;\n\t\t\ta[10] = a[23] - xr;\n\t\t\ta[23] += xr;\n\t\t\txr = a[11];\n\t\t\ta[26] -= xr;\n\t\t\ta[11] = a[22] - xr;\n\t\t\ta[22] += xr;\n\t\t\txr = a[26];\n\t\t\ta[27] -= xr;\n\t\t\ta[26] = a[7] - xr;\n\t\t\ta[7] += xr;\n\n\t\t\txr = a[27];\n\t\t\ta[27] = a[6] - xr;\n\t\t\ta[6] += xr;\n\n\t\t\txr = Util$6.SQRT2 * (a[0] - a[4]);\n\t\t\ta[0] += a[4];\n\t\t\ta[4] = xr;\n\t\t\txr = Util$6.SQRT2 * (a[1] - a[5]);\n\t\t\ta[1] += a[5];\n\t\t\ta[5] = xr;\n\t\t\txr = Util$6.SQRT2 * (a[16] - a[20]);\n\t\t\ta[16] += a[20];\n\t\t\ta[20] = xr;\n\t\t\txr = Util$6.SQRT2 * (a[17] - a[21]);\n\t\t\ta[17] += a[21];\n\t\t\ta[21] = xr;\n\n\t\t\txr = -Util$6.SQRT2 * (a[8] - a[12]);\n\t\t\ta[8] += a[12];\n\t\t\ta[12] = xr - a[8];\n\t\t\txr = -Util$6.SQRT2 * (a[9] - a[13]);\n\t\t\ta[9] += a[13];\n\t\t\ta[13] = xr - a[9];\n\t\t\txr = -Util$6.SQRT2 * (a[25] - a[29]);\n\t\t\ta[25] += a[29];\n\t\t\ta[29] = xr - a[25];\n\t\t\txr = -Util$6.SQRT2 * (a[24] + a[28]);\n\t\t\ta[24] -= a[28];\n\t\t\ta[28] = xr - a[24];\n\n\t\t\txr = a[24] - a[16];\n\t\t\ta[24] = xr;\n\t\t\txr = a[20] - xr;\n\t\t\ta[20] = xr;\n\t\t\txr = a[28] - xr;\n\t\t\ta[28] = xr;\n\n\t\t\txr = a[25] - a[17];\n\t\t\ta[25] = xr;\n\t\t\txr = a[21] - xr;\n\t\t\ta[21] = xr;\n\t\t\txr = a[29] - xr;\n\t\t\ta[29] = xr;\n\n\t\t\txr = a[17] - a[1];\n\t\t\ta[17] = xr;\n\t\t\txr = a[9] - xr;\n\t\t\ta[9] = xr;\n\t\t\txr = a[25] - xr;\n\t\t\ta[25] = xr;\n\t\t\txr = a[5] - xr;\n\t\t\ta[5] = xr;\n\t\t\txr = a[21] - xr;\n\t\t\ta[21] = xr;\n\t\t\txr = a[13] - xr;\n\t\t\ta[13] = xr;\n\t\t\txr = a[29] - xr;\n\t\t\ta[29] = xr;\n\n\t\t\txr = a[1] - a[0];\n\t\t\ta[1] = xr;\n\t\t\txr = a[16] - xr;\n\t\t\ta[16] = xr;\n\t\t\txr = a[17] - xr;\n\t\t\ta[17] = xr;\n\t\t\txr = a[8] - xr;\n\t\t\ta[8] = xr;\n\t\t\txr = a[9] - xr;\n\t\t\ta[9] = xr;\n\t\t\txr = a[24] - xr;\n\t\t\ta[24] = xr;\n\t\t\txr = a[25] - xr;\n\t\t\ta[25] = xr;\n\t\t\txr = a[4] - xr;\n\t\t\ta[4] = xr;\n\t\t\txr = a[5] - xr;\n\t\t\ta[5] = xr;\n\t\t\txr = a[20] - xr;\n\t\t\ta[20] = xr;\n\t\t\txr = a[21] - xr;\n\t\t\ta[21] = xr;\n\t\t\txr = a[12] - xr;\n\t\t\ta[12] = xr;\n\t\t\txr = a[13] - xr;\n\t\t\ta[13] = xr;\n\t\t\txr = a[28] - xr;\n\t\t\ta[28] = xr;\n\t\t\txr = a[29] - xr;\n\t\t\ta[29] = xr;\n\n\t\t\txr = a[0];\n\t\t\ta[0] += a[31];\n\t\t\ta[31] -= xr;\n\t\t\txr = a[1];\n\t\t\ta[1] += a[30];\n\t\t\ta[30] -= xr;\n\t\t\txr = a[16];\n\t\t\ta[16] += a[15];\n\t\t\ta[15] -= xr;\n\t\t\txr = a[17];\n\t\t\ta[17] += a[14];\n\t\t\ta[14] -= xr;\n\t\t\txr = a[8];\n\t\t\ta[8] += a[23];\n\t\t\ta[23] -= xr;\n\t\t\txr = a[9];\n\t\t\ta[9] += a[22];\n\t\t\ta[22] -= xr;\n\t\t\txr = a[24];\n\t\t\ta[24] += a[7];\n\t\t\ta[7] -= xr;\n\t\t\txr = a[25];\n\t\t\ta[25] += a[6];\n\t\t\ta[6] -= xr;\n\t\t\txr = a[4];\n\t\t\ta[4] += a[27];\n\t\t\ta[27] -= xr;\n\t\t\txr = a[5];\n\t\t\ta[5] += a[26];\n\t\t\ta[26] -= xr;\n\t\t\txr = a[20];\n\t\t\ta[20] += a[11];\n\t\t\ta[11] -= xr;\n\t\t\txr = a[21];\n\t\t\ta[21] += a[10];\n\t\t\ta[10] -= xr;\n\t\t\txr = a[12];\n\t\t\ta[12] += a[19];\n\t\t\ta[19] -= xr;\n\t\t\txr = a[13];\n\t\t\ta[13] += a[18];\n\t\t\ta[18] -= xr;\n\t\t\txr = a[28];\n\t\t\ta[28] += a[3];\n\t\t\ta[3] -= xr;\n\t\t\txr = a[29];\n\t\t\ta[29] += a[2];\n\t\t\ta[2] -= xr;\n\t\t}\n\t}\n\n\t/**\n\t * Function: Calculation of the MDCT In the case of long blocks (type 0,1,3)\n\t * there are 36 coefficents in the time domain and 18 in the frequency\n\t * domain.<BR>\n\t * In the case of short blocks (type 2) there are 3 transformations with\n\t * short length. This leads to 12 coefficents in the time and 6 in the\n\t * frequency domain. In this case the results are stored side by side in the\n\t * vector out[].\n\t *\n\t * New layer3\n\t */\n\tfunction mdct_short(inout, inoutPos) {\n\t\tfor (var l = 0; l < 3; l++) {\n\t\t\tvar tc0, tc1, tc2, ts0, ts1, ts2;\n\n\t\t\tts0 = inout[inoutPos + 2 * 3] * win[Encoder_1.SHORT_TYPE][0]\n\t\t\t\t\t- inout[inoutPos + 5 * 3];\n\t\t\ttc0 = inout[inoutPos + 0 * 3] * win[Encoder_1.SHORT_TYPE][2]\n\t\t\t\t\t- inout[inoutPos + 3 * 3];\n\t\t\ttc1 = ts0 + tc0;\n\t\t\ttc2 = ts0 - tc0;\n\n\t\t\tts0 = inout[inoutPos + 5 * 3] * win[Encoder_1.SHORT_TYPE][0]\n\t\t\t\t\t+ inout[inoutPos + 2 * 3];\n\t\t\ttc0 = inout[inoutPos + 3 * 3] * win[Encoder_1.SHORT_TYPE][2]\n\t\t\t\t\t+ inout[inoutPos + 0 * 3];\n\t\t\tts1 = ts0 + tc0;\n\t\t\tts2 = -ts0 + tc0;\n\n\t\t\ttc0 = (inout[inoutPos + 1 * 3] * win[Encoder_1.SHORT_TYPE][1] - inout[inoutPos + 4 * 3]) * 2.069978111953089e-11;\n\t\t\t/*\n\t\t\t * tritab_s [ 1 ]\n\t\t\t */\n\t\t\tts0 = (inout[inoutPos + 4 * 3] * win[Encoder_1.SHORT_TYPE][1] + inout[inoutPos + 1 * 3]) * 2.069978111953089e-11;\n\t\t\t/*\n\t\t\t * tritab_s [ 1 ]\n\t\t\t */\n\t\t\tinout[inoutPos + 3 * 0] = tc1 * 1.907525191737280e-11 + tc0;\n\t\t\t/*\n\t\t\t * tritab_s[ 2 ]\n\t\t\t */\n\t\t\tinout[inoutPos + 3 * 5] = -ts1 * 1.907525191737280e-11 + ts0;\n\t\t\t/*\n\t\t\t * tritab_s[0 ]\n\t\t\t */\n\t\t\ttc2 = tc2 * 0.86602540378443870761 * 1.907525191737281e-11;\n\t\t\t/*\n\t\t\t * tritab_s[ 2]\n\t\t\t */\n\t\t\tts1 = ts1 * 0.5 * 1.907525191737281e-11 + ts0;\n\t\t\tinout[inoutPos + 3 * 1] = tc2 - ts1;\n\t\t\tinout[inoutPos + 3 * 2] = tc2 + ts1;\n\n\t\t\ttc1 = tc1 * 0.5 * 1.907525191737281e-11 - tc0;\n\t\t\tts2 = ts2 * 0.86602540378443870761 * 1.907525191737281e-11;\n\t\t\t/*\n\t\t\t * tritab_s[ 0]\n\t\t\t */\n\t\t\tinout[inoutPos + 3 * 3] = tc1 + ts2;\n\t\t\tinout[inoutPos + 3 * 4] = tc1 - ts2;\n\n\t\t\tinoutPos++;\n\t\t}\n\t}\n\n\tfunction mdct_long(out, outPos, _in) {\n\t\tvar ct, st;\n\t\t{\n\t\t\tvar tc1, tc2, tc3, tc4, ts5, ts6, ts7, ts8;\n\t\t\t/* 1,2, 5,6, 9,10, 13,14, 17 */\n\t\t\ttc1 = _in[17] - _in[9];\n\t\t\ttc3 = _in[15] - _in[11];\n\t\t\ttc4 = _in[14] - _in[12];\n\t\t\tts5 = _in[0] + _in[8];\n\t\t\tts6 = _in[1] + _in[7];\n\t\t\tts7 = _in[2] + _in[6];\n\t\t\tts8 = _in[3] + _in[5];\n\n\t\t\tout[outPos + 17] = (ts5 + ts7 - ts8) - (ts6 - _in[4]);\n\t\t\tst = (ts5 + ts7 - ts8) * cx[12 + 7] + (ts6 - _in[4]);\n\t\t\tct = (tc1 - tc3 - tc4) * cx[12 + 6];\n\t\t\tout[outPos + 5] = ct + st;\n\t\t\tout[outPos + 6] = ct - st;\n\n\t\t\ttc2 = (_in[16] - _in[10]) * cx[12 + 6];\n\t\t\tts6 = ts6 * cx[12 + 7] + _in[4];\n\t\t\tct = tc1 * cx[12 + 0] + tc2 + tc3 * cx[12 + 1] + tc4 * cx[12 + 2];\n\t\t\tst = -ts5 * cx[12 + 4] + ts6 - ts7 * cx[12 + 5] + ts8 * cx[12 + 3];\n\t\t\tout[outPos + 1] = ct + st;\n\t\t\tout[outPos + 2] = ct - st;\n\n\t\t\tct = tc1 * cx[12 + 1] - tc2 - tc3 * cx[12 + 2] + tc4 * cx[12 + 0];\n\t\t\tst = -ts5 * cx[12 + 5] + ts6 - ts7 * cx[12 + 3] + ts8 * cx[12 + 4];\n\t\t\tout[outPos + 9] = ct + st;\n\t\t\tout[outPos + 10] = ct - st;\n\n\t\t\tct = tc1 * cx[12 + 2] - tc2 + tc3 * cx[12 + 0] - tc4 * cx[12 + 1];\n\t\t\tst = ts5 * cx[12 + 3] - ts6 + ts7 * cx[12 + 4] - ts8 * cx[12 + 5];\n\t\t\tout[outPos + 13] = ct + st;\n\t\t\tout[outPos + 14] = ct - st;\n\t\t}\n\t\t{\n\t\t\tvar ts1, ts2, ts3, ts4, tc5, tc6, tc7, tc8;\n\n\t\t\tts1 = _in[8] - _in[0];\n\t\t\tts3 = _in[6] - _in[2];\n\t\t\tts4 = _in[5] - _in[3];\n\t\t\ttc5 = _in[17] + _in[9];\n\t\t\ttc6 = _in[16] + _in[10];\n\t\t\ttc7 = _in[15] + _in[11];\n\t\t\ttc8 = _in[14] + _in[12];\n\n\t\t\tout[outPos + 0] = (tc5 + tc7 + tc8) + (tc6 + _in[13]);\n\t\t\tct = (tc5 + tc7 + tc8) * cx[12 + 7] - (tc6 + _in[13]);\n\t\t\tst = (ts1 - ts3 + ts4) * cx[12 + 6];\n\t\t\tout[outPos + 11] = ct + st;\n\t\t\tout[outPos + 12] = ct - st;\n\n\t\t\tts2 = (_in[7] - _in[1]) * cx[12 + 6];\n\t\t\ttc6 = _in[13] - tc6 * cx[12 + 7];\n\t\t\tct = tc5 * cx[12 + 3] - tc6 + tc7 * cx[12 + 4] + tc8 * cx[12 + 5];\n\t\t\tst = ts1 * cx[12 + 2] + ts2 + ts3 * cx[12 + 0] + ts4 * cx[12 + 1];\n\t\t\tout[outPos + 3] = ct + st;\n\t\t\tout[outPos + 4] = ct - st;\n\n\t\t\tct = -tc5 * cx[12 + 5] + tc6 - tc7 * cx[12 + 3] - tc8 * cx[12 + 4];\n\t\t\tst = ts1 * cx[12 + 1] + ts2 - ts3 * cx[12 + 2] - ts4 * cx[12 + 0];\n\t\t\tout[outPos + 7] = ct + st;\n\t\t\tout[outPos + 8] = ct - st;\n\n\t\t\tct = -tc5 * cx[12 + 4] + tc6 - tc7 * cx[12 + 5] - tc8 * cx[12 + 3];\n\t\t\tst = ts1 * cx[12 + 0] - ts2 + ts3 * cx[12 + 1] - ts4 * cx[12 + 2];\n\t\t\tout[outPos + 15] = ct + st;\n\t\t\tout[outPos + 16] = ct - st;\n\t\t}\n\t}\n\n\tthis.mdct_sub48 = function(gfc, w0, w1) {\n\t\tvar wk = w0;\n\t\tvar wkPos = 286;\n\t\t/* thinking cache performance, ch->gr loop is better than gr->ch loop */\n\t\tfor (var ch = 0; ch < gfc.channels_out; ch++) {\n\t\t\tfor (var gr = 0; gr < gfc.mode_gr; gr++) {\n\t\t\t\tvar band;\n\t\t\t\tvar gi = (gfc.l3_side.tt[gr][ch]);\n\t\t\t\tvar mdct_enc = gi.xr;\n\t\t\t\tvar mdct_encPos = 0;\n\t\t\t\tvar samp = gfc.sb_sample[ch][1 - gr];\n\t\t\t\tvar sampPos = 0;\n\n\t\t\t\tfor (var k = 0; k < 18 / 2; k++) {\n\t\t\t\t\twindow_subband(wk, wkPos, samp[sampPos]);\n\t\t\t\t\twindow_subband(wk, wkPos + 32, samp[sampPos + 1]);\n\t\t\t\t\tsampPos += 2;\n\t\t\t\t\twkPos += 64;\n\t\t\t\t\t/*\n\t\t\t\t\t * Compensate for inversion in the analysis filter\n\t\t\t\t\t */\n\t\t\t\t\tfor (band = 1; band < 32; band += 2) {\n\t\t\t\t\t\tsamp[sampPos - 1][band] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Perform imdct of 18 previous subband samples + 18 current\n\t\t\t\t * subband samples\n\t\t\t\t */\n\t\t\t\tfor (band = 0; band < 32; band++, mdct_encPos += 18) {\n\t\t\t\t\tvar type = gi.block_type;\n\t\t\t\t\tvar band0 = gfc.sb_sample[ch][gr];\n\t\t\t\t\tvar band1 = gfc.sb_sample[ch][1 - gr];\n\t\t\t\t\tif (gi.mixed_block_flag != 0 && band < 2)\n\t\t\t\t\t\ttype = 0;\n\t\t\t\t\tif (gfc.amp_filter[band] < 1e-12) {\n\t\t\t\t\t\tArrays$6.fill(mdct_enc, mdct_encPos + 0,\n\t\t\t\t\t\t\t\tmdct_encPos + 18, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (gfc.amp_filter[band] < 1.0) {\n\t\t\t\t\t\t\tfor (var k = 0; k < 18; k++)\n\t\t\t\t\t\t\t\tband1[k][order[band]] *= gfc.amp_filter[band];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (type == Encoder_1.SHORT_TYPE) {\n\t\t\t\t\t\t\tfor (var k = -NS / 4; k < 0; k++) {\n\t\t\t\t\t\t\t\tvar w = win[Encoder_1.SHORT_TYPE][k + 3];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 9] = band0[9 + k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w - band0[8 - k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 18] = band0[14 - k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w + band0[15 + k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 10] = band0[15 + k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w - band0[14 - k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 19] = band1[2 - k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w + band1[3 + k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 11] = band1[3 + k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w - band1[2 - k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 20] = band1[8 - k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w + band1[9 + k][order[band]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmdct_short(mdct_enc, mdct_encPos);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar work = new_float$6(18);\n\t\t\t\t\t\t\tfor (var k = -NL / 4; k < 0; k++) {\n\t\t\t\t\t\t\t\tvar a, b;\n\t\t\t\t\t\t\t\ta = win[type][k + 27]\n\t\t\t\t\t\t\t\t\t\t* band1[k + 9][order[band]]\n\t\t\t\t\t\t\t\t\t\t+ win[type][k + 36]\n\t\t\t\t\t\t\t\t\t\t* band1[8 - k][order[band]];\n\t\t\t\t\t\t\t\tb = win[type][k + 9]\n\t\t\t\t\t\t\t\t\t\t* band0[k + 9][order[band]]\n\t\t\t\t\t\t\t\t\t\t- win[type][k + 18]\n\t\t\t\t\t\t\t\t\t\t* band0[8 - k][order[band]];\n\t\t\t\t\t\t\t\twork[k + 9] = a - b * tantab_l[3 + k + 9];\n\t\t\t\t\t\t\t\twork[k + 18] = a * tantab_l[3 + k + 9] + b;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmdct_long(mdct_enc, mdct_encPos, work);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * Perform aliasing reduction butterfly\n\t\t\t\t\t */\n\t\t\t\t\tif (type != Encoder_1.SHORT_TYPE && band != 0) {\n\t\t\t\t\t\tfor (var k = 7; k >= 0; --k) {\n\t\t\t\t\t\t\tvar bu, bd;\n\t\t\t\t\t\t\tbu = mdct_enc[mdct_encPos + k] * ca[20 + k]\n\t\t\t\t\t\t\t\t\t+ mdct_enc[mdct_encPos + -1 - k]\n\t\t\t\t\t\t\t\t\t* cs[28 + k];\n\t\t\t\t\t\t\tbd = mdct_enc[mdct_encPos + k] * cs[28 + k]\n\t\t\t\t\t\t\t\t\t- mdct_enc[mdct_encPos + -1 - k]\n\t\t\t\t\t\t\t\t\t* ca[20 + k];\n\n\t\t\t\t\t\t\tmdct_enc[mdct_encPos + -1 - k] = bu;\n\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k] = bd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twk = w1;\n\t\t\twkPos = 286;\n\t\t\tif (gfc.mode_gr == 1) {\n\t\t\t\tfor (var i = 0; i < 18; i++) {\n\t\t\t\t\tSystem$6.arraycopy(gfc.sb_sample[ch][1][i], 0,\n\t\t\t\t\t\t\tgfc.sb_sample[ch][0][i], 0, 32);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\nvar NewMDCT_1 = NewMDCT;\n\nvar System$7 = common.System;\nvar new_float$7 = common.new_float;\nvar new_float_n$7 = common.new_float_n;\nfunction III_psy_xmin() {\n    this.l = new_float$7(Encoder_1.SBMAX_l);\n    this.s = new_float_n$7([Encoder_1.SBMAX_s, 3]);\n\n    var self = this;\n    this.assign = function (iii_psy_xmin) {\n        System$7.arraycopy(iii_psy_xmin.l, 0, self.l, 0, Encoder_1.SBMAX_l);\n        for (var i = 0; i < Encoder_1.SBMAX_s; i++) {\n            for (var j = 0; j < 3; j++) {\n                self.s[i][j] = iii_psy_xmin.s[i][j];\n            }\n        }\n    };\n}\n\nvar III_psy_xmin_1 = III_psy_xmin;\n\n//package mp3;\n\n\n\nfunction III_psy_ratio() {\n\tthis.thm = new III_psy_xmin_1();\n\tthis.en = new III_psy_xmin_1();\n}\n\nvar III_psy_ratio_1 = III_psy_ratio;\n\nvar System$5 = common.System;\nvar VbrMode$5 = common.VbrMode;\nvar new_array_n$5 = common.new_array_n;\nvar new_float$5 = common.new_float;\nvar new_float_n$5 = common.new_float_n;\nvar new_int$5 = common.new_int;\nvar assert$5 = common.assert;\n\n/**\n * ENCDELAY The encoder delay.\n *\n * Minimum allowed is MDCTDELAY (see below)\n *\n * The first 96 samples will be attenuated, so using a value less than 96\n * will result in corrupt data for the first 96-ENCDELAY samples.\n *\n * suggested: 576 set to 1160 to sync with FhG.\n */\nEncoder$2.ENCDELAY = 576;\n/**\n * make sure there is at least one complete frame after the last frame\n * containing real data\n *\n * Using a value of 288 would be sufficient for a a very sophisticated\n * decoder that can decode granule-by-granule instead of frame by frame. But\n * lets not assume this, and assume the decoder will not decode frame N\n * unless it also has data for frame N+1\n */\nEncoder$2.POSTDELAY = 1152;\n\n/**\n * delay of the MDCT used in mdct.c original ISO routines had a delay of\n * 528! Takehiro's routines:\n */\nEncoder$2.MDCTDELAY = 48;\nEncoder$2.FFTOFFSET = (224 + Encoder$2.MDCTDELAY);\n\n/**\n * Most decoders, including the one we use, have a delay of 528 samples.\n */\nEncoder$2.DECDELAY = 528;\n\n/**\n * number of subbands\n */\nEncoder$2.SBLIMIT = 32;\n\n/**\n * parition bands bands\n */\nEncoder$2.CBANDS = 64;\n\n/**\n * number of critical bands/scale factor bands where masking is computed\n */\nEncoder$2.SBPSY_l = 21;\nEncoder$2.SBPSY_s = 12;\n\n/**\n * total number of scalefactor bands encoded\n */\nEncoder$2.SBMAX_l = 22;\nEncoder$2.SBMAX_s = 13;\nEncoder$2.PSFB21 = 6;\nEncoder$2.PSFB12 = 6;\n\n/**\n * FFT sizes\n */\nEncoder$2.BLKSIZE = 1024;\nEncoder$2.HBLKSIZE = (Encoder$2.BLKSIZE / 2 + 1);\nEncoder$2.BLKSIZE_s = 256;\nEncoder$2.HBLKSIZE_s = (Encoder$2.BLKSIZE_s / 2 + 1);\n\nEncoder$2.NORM_TYPE = 0;\nEncoder$2.START_TYPE = 1;\nEncoder$2.SHORT_TYPE = 2;\nEncoder$2.STOP_TYPE = 3;\n\n/**\n * <PRE>\n * Mode Extention:\n * When we are in stereo mode, there are 4 possible methods to store these\n * two channels. The stereo modes -m? are using a subset of them.\n *\n *  -ms: MPG_MD_LR_LR\n *  -mj: MPG_MD_LR_LR and MPG_MD_MS_LR\n *  -mf: MPG_MD_MS_LR\n *  -mi: all\n * </PRE>\n */\nEncoder$2.MPG_MD_LR_LR = 0;\nEncoder$2.MPG_MD_LR_I = 1;\nEncoder$2.MPG_MD_MS_LR = 2;\nEncoder$2.MPG_MD_MS_I = 3;\n\nEncoder$2.fircoef = [-0.0207887 * 5, -0.0378413 * 5,\n    -0.0432472 * 5, -0.031183 * 5, 7.79609e-18 * 5, 0.0467745 * 5,\n    0.10091 * 5, 0.151365 * 5, 0.187098 * 5];\n\nfunction Encoder$2() {\n    var NewMDCT = NewMDCT_1;\n    var III_psy_ratio = III_psy_ratio_1;\n\n    var FFTOFFSET = Encoder$2.FFTOFFSET;\n    var MPG_MD_MS_LR = Encoder$2.MPG_MD_MS_LR;\n    //BitStream bs;\n    //PsyModel psy;\n    //VBRTag vbr;\n    //QuantizePVT qupvt;\n    var bs = null;\n    this.psy = null;\n    var psy = null;\n    var vbr = null;\n    var qupvt = null;\n\n    //public final void setModules(BitStream bs, PsyModel psy, QuantizePVT qupvt,\n    //    VBRTag vbr) {\n    this.setModules = function (_bs, _psy, _qupvt, _vbr) {\n        bs = _bs;\n        this.psy = _psy;\n        psy = _psy;\n        vbr = _vbr;\n        qupvt = _qupvt;\n    };\n\n    var newMDCT = new NewMDCT();\n\n    /***********************************************************************\n     *\n     * encoder and decoder delays\n     *\n     ***********************************************************************/\n\n    /**\n     * <PRE>\n     * layer III enc->dec delay:  1056 (1057?)   (observed)\n     * layer  II enc->dec delay:   480  (481?)   (observed)\n     *\n     * polyphase 256-16             (dec or enc)        = 240\n     * mdct      256+32  (9*32)     (dec or enc)        = 288\n     * total:    512+16\n     *\n     * My guess is that delay of polyphase filterbank is actualy 240.5\n     * (there are technical reasons for this, see postings in mp3encoder).\n     * So total Encode+Decode delay = ENCDELAY + 528 + 1\n     * </PRE>\n     */\n\n\n    /**\n     * auto-adjust of ATH, useful for low volume Gabriel Bouvigne 3 feb 2001\n     *\n     * modifies some values in gfp.internal_flags.ATH (gfc.ATH)\n     */\n//private void adjust_ATH(final LameInternalFlags gfc) {\n    function adjust_ATH(gfc) {\n        var gr2_max, max_pow;\n\n        if (gfc.ATH.useAdjust == 0) {\n            gfc.ATH.adjust = 1.0;\n            /* no adjustment */\n            return;\n        }\n\n        /* jd - 2001 mar 12, 27, jun 30 */\n        /* loudness based on equal loudness curve; */\n        /* use granule with maximum combined loudness */\n        max_pow = gfc.loudness_sq[0][0];\n        gr2_max = gfc.loudness_sq[1][0];\n        if (gfc.channels_out == 2) {\n            max_pow += gfc.loudness_sq[0][1];\n            gr2_max += gfc.loudness_sq[1][1];\n        } else {\n            max_pow += max_pow;\n            gr2_max += gr2_max;\n        }\n        if (gfc.mode_gr == 2) {\n            max_pow = Math.max(max_pow, gr2_max);\n        }\n        max_pow *= 0.5;\n        /* max_pow approaches 1.0 for full band noise */\n\n        /* jd - 2001 mar 31, jun 30 */\n        /* user tuning of ATH adjustment region */\n        max_pow *= gfc.ATH.aaSensitivityP;\n\n        /*\n         * adjust ATH depending on range of maximum value\n         */\n\n        /* jd - 2001 feb27, mar12,20, jun30, jul22 */\n        /* continuous curves based on approximation */\n        /* to GB's original values. */\n        /* For an increase in approximate loudness, */\n        /* set ATH adjust to adjust_limit immediately */\n        /* after a delay of one frame. */\n        /* For a loudness decrease, reduce ATH adjust */\n        /* towards adjust_limit gradually. */\n        /* max_pow is a loudness squared or a power. */\n        if (max_pow > 0.03125) { /* ((1 - 0.000625)/ 31.98) from curve below */\n            if (gfc.ATH.adjust >= 1.0) {\n                gfc.ATH.adjust = 1.0;\n            } else {\n                /* preceding frame has lower ATH adjust; */\n                /* ascend only to the preceding adjust_limit */\n                /* in case there is leading low volume */\n                if (gfc.ATH.adjust < gfc.ATH.adjustLimit) {\n                    gfc.ATH.adjust = gfc.ATH.adjustLimit;\n                }\n            }\n            gfc.ATH.adjustLimit = 1.0;\n        } else { /* adjustment curve */\n            /* about 32 dB maximum adjust (0.000625) */\n            var adj_lim_new = 31.98 * max_pow + 0.000625;\n            if (gfc.ATH.adjust >= adj_lim_new) { /* descend gradually */\n                gfc.ATH.adjust *= adj_lim_new * 0.075 + 0.925;\n                if (gfc.ATH.adjust < adj_lim_new) { /* stop descent */\n                    gfc.ATH.adjust = adj_lim_new;\n                }\n            } else { /* ascend */\n                if (gfc.ATH.adjustLimit >= adj_lim_new) {\n                    gfc.ATH.adjust = adj_lim_new;\n                } else {\n                    /* preceding frame has lower ATH adjust; */\n                    /* ascend only to the preceding adjust_limit */\n                    if (gfc.ATH.adjust < gfc.ATH.adjustLimit) {\n                        gfc.ATH.adjust = gfc.ATH.adjustLimit;\n                    }\n                }\n            }\n            gfc.ATH.adjustLimit = adj_lim_new;\n        }\n    }\n\n    /**\n     * <PRE>\n     *  some simple statistics\n     *\n     *  bitrate index 0: free bitrate . not allowed in VBR mode\n     *  : bitrates, kbps depending on MPEG version\n     *  bitrate index 15: forbidden\n     *\n     *  mode_ext:\n     *  0:  LR\n     *  1:  LR-i\n     *  2:  MS\n     *  3:  MS-i\n     * </PRE>\n     */\n    function updateStats(gfc) {\n        var gr, ch;\n        assert$5(0 <= gfc.bitrate_index && gfc.bitrate_index < 16);\n        assert$5(0 <= gfc.mode_ext && gfc.mode_ext < 4);\n\n        /* count bitrate indices */\n        gfc.bitrate_stereoMode_Hist[gfc.bitrate_index][4]++;\n        gfc.bitrate_stereoMode_Hist[15][4]++;\n\n        /* count 'em for every mode extension in case of 2 channel encoding */\n        if (gfc.channels_out == 2) {\n            gfc.bitrate_stereoMode_Hist[gfc.bitrate_index][gfc.mode_ext]++;\n            gfc.bitrate_stereoMode_Hist[15][gfc.mode_ext]++;\n        }\n        for (gr = 0; gr < gfc.mode_gr; ++gr) {\n            for (ch = 0; ch < gfc.channels_out; ++ch) {\n                var bt = gfc.l3_side.tt[gr][ch].block_type | 0;\n                if (gfc.l3_side.tt[gr][ch].mixed_block_flag != 0)\n                    bt = 4;\n                gfc.bitrate_blockType_Hist[gfc.bitrate_index][bt]++;\n                gfc.bitrate_blockType_Hist[gfc.bitrate_index][5]++;\n                gfc.bitrate_blockType_Hist[15][bt]++;\n                gfc.bitrate_blockType_Hist[15][5]++;\n            }\n        }\n    }\n\n    function lame_encode_frame_init(gfp, inbuf) {\n        var gfc = gfp.internal_flags;\n\n        var ch, gr;\n\n        if (gfc.lame_encode_frame_init == 0) {\n            /* prime the MDCT/polyphase filterbank with a short block */\n            var i, j;\n            var primebuff0 = new_float$5(286 + 1152 + 576);\n            var primebuff1 = new_float$5(286 + 1152 + 576);\n            gfc.lame_encode_frame_init = 1;\n            for (i = 0, j = 0; i < 286 + 576 * (1 + gfc.mode_gr); ++i) {\n                if (i < 576 * gfc.mode_gr) {\n                    primebuff0[i] = 0;\n                    if (gfc.channels_out == 2)\n                        primebuff1[i] = 0;\n                } else {\n                    primebuff0[i] = inbuf[0][j];\n                    if (gfc.channels_out == 2)\n                        primebuff1[i] = inbuf[1][j];\n                    ++j;\n                }\n            }\n            /* polyphase filtering / mdct */\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    gfc.l3_side.tt[gr][ch].block_type = Encoder$2.SHORT_TYPE;\n                }\n            }\n            newMDCT.mdct_sub48(gfc, primebuff0, primebuff1);\n\n            /* check FFT will not use a negative starting offset */\n            assert$5(576 >= Encoder$2.FFTOFFSET);\n            /* check if we have enough data for FFT */\n            assert$5(gfc.mf_size >= (Encoder$2.BLKSIZE + gfp.framesize - Encoder$2.FFTOFFSET));\n            /* check if we have enough data for polyphase filterbank */\n            assert$5(gfc.mf_size >= (512 + gfp.framesize - 32));\n        }\n\n    }\n\n    /**\n     * <PRE>\n     * encodeframe()           Layer 3\n     *\n     * encode a single frame\n     *\n     *\n     *    lame_encode_frame()\n     *\n     *\n     *                           gr 0            gr 1\n     *    inbuf:           |--------------|--------------|--------------|\n     *\n     *\n     *    Polyphase (18 windows, each shifted 32)\n     *    gr 0:\n     *    window1          <----512---.\n     *    window18                 <----512---.\n     *\n     *    gr 1:\n     *    window1                         <----512---.\n     *    window18                                <----512---.\n     *\n     *\n     *\n     *    MDCT output:  |--------------|--------------|--------------|\n     *\n     *    FFT's                    <---------1024---------.\n     *                                             <---------1024-------.\n     *\n     *\n     *\n     *        inbuf = buffer of PCM data size=MP3 framesize\n     *        encoder acts on inbuf[ch][0], but output is delayed by MDCTDELAY\n     *        so the MDCT coefficints are from inbuf[ch][-MDCTDELAY]\n     *\n     *        psy-model FFT has a 1 granule delay, so we feed it data for the\n     *        next granule.\n     *        FFT is centered over granule:  224+576+224\n     *        So FFT starts at:   576-224-MDCTDELAY\n     *\n     *        MPEG2:  FFT ends at:  BLKSIZE+576-224-MDCTDELAY      (1328)\n     *        MPEG1:  FFT ends at:  BLKSIZE+2*576-224-MDCTDELAY    (1904)\n     *\n     *        MPEG2:  polyphase first window:  [0..511]\n     *                          18th window:   [544..1055]          (1056)\n     *        MPEG1:            36th window:   [1120..1631]         (1632)\n     *                data needed:  512+framesize-32\n     *\n     *        A close look newmdct.c shows that the polyphase filterbank\n     *        only uses data from [0..510] for each window.  Perhaps because the window\n     *        used by the filterbank is zero for the last point, so Takehiro's\n     *        code doesn't bother to compute with it.\n     *\n     *        FFT starts at 576-224-MDCTDELAY (304)  = 576-FFTOFFSET\n     *\n     * </PRE>\n     */\n\n\n    this.lame_encode_mp3_frame = function (gfp, inbuf_l, inbuf_r, mp3buf, mp3bufPos, mp3buf_size) {\n        var mp3count;\n        var masking_LR = new_array_n$5([2, 2]);\n        /*\n         * LR masking &\n         * energy\n         */\n        masking_LR[0][0] = new III_psy_ratio();\n        masking_LR[0][1] = new III_psy_ratio();\n        masking_LR[1][0] = new III_psy_ratio();\n        masking_LR[1][1] = new III_psy_ratio();\n        var masking_MS = new_array_n$5([2, 2]);\n        /* MS masking & energy */\n        masking_MS[0][0] = new III_psy_ratio();\n        masking_MS[0][1] = new III_psy_ratio();\n        masking_MS[1][0] = new III_psy_ratio();\n        masking_MS[1][1] = new III_psy_ratio();\n        //III_psy_ratio masking[][];\n        var masking;\n        /* pointer to selected maskings */\n        var inbuf = [null, null];\n        var gfc = gfp.internal_flags;\n\n        var tot_ener = new_float_n$5([2, 4]);\n        var ms_ener_ratio = [.5, .5];\n        var pe = [[0., 0.], [0., 0.]];\n        var pe_MS = [[0., 0.], [0., 0.]];\n\n//float[][] pe_use;\n        var pe_use;\n\n        var ch, gr;\n\n        inbuf[0] = inbuf_l;\n        inbuf[1] = inbuf_r;\n\n        if (gfc.lame_encode_frame_init == 0) {\n            /* first run? */\n            lame_encode_frame_init(gfp, inbuf);\n\n        }\n\n        /********************** padding *****************************/\n        /**\n         * <PRE>\n         * padding method as described in\n         * \"MPEG-Layer3 / Bitstream Syntax and Decoding\"\n         * by Martin Sieler, Ralph Sperschneider\n         *\n         * note: there is no padding for the very first frame\n         *\n         * Robert Hegemann 2000-06-22\n         * </PRE>\n         */\n        gfc.padding = 0;\n        if ((gfc.slot_lag -= gfc.frac_SpF) < 0) {\n            gfc.slot_lag += gfp.out_samplerate;\n            gfc.padding = 1;\n        }\n\n        /****************************************\n         * Stage 1: psychoacoustic model *\n         ****************************************/\n\n        if (gfc.psymodel != 0) {\n            /*\n             * psychoacoustic model psy model has a 1 granule (576) delay that\n             * we must compensate for (mt 6/99).\n             */\n            var ret;\n            var bufp = [null, null];\n            /* address of beginning of left & right granule */\n            var bufpPos = 0;\n            /* address of beginning of left & right granule */\n            var blocktype = new_int$5(2);\n\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    bufp[ch] = inbuf[ch];\n                    bufpPos = 576 + gr * 576 - Encoder$2.FFTOFFSET;\n                }\n                if (gfp.VBR == VbrMode$5.vbr_mtrh || gfp.VBR == VbrMode$5.vbr_mt) {\n                    ret = psy.L3psycho_anal_vbr(gfp, bufp, bufpPos, gr,\n                        masking_LR, masking_MS, pe[gr], pe_MS[gr],\n                        tot_ener[gr], blocktype);\n                } else {\n                    ret = psy.L3psycho_anal_ns(gfp, bufp, bufpPos, gr,\n                        masking_LR, masking_MS, pe[gr], pe_MS[gr],\n                        tot_ener[gr], blocktype);\n                }\n                if (ret != 0)\n                    return -4;\n\n                if (gfp.mode == MPEGMode.JOINT_STEREO) {\n                    ms_ener_ratio[gr] = tot_ener[gr][2] + tot_ener[gr][3];\n                    if (ms_ener_ratio[gr] > 0)\n                        ms_ener_ratio[gr] = tot_ener[gr][3] / ms_ener_ratio[gr];\n                }\n\n                /* block type flags */\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    var cod_info = gfc.l3_side.tt[gr][ch];\n                    cod_info.block_type = blocktype[ch];\n                    cod_info.mixed_block_flag = 0;\n                }\n            }\n        } else {\n            /* no psy model */\n            for (gr = 0; gr < gfc.mode_gr; gr++)\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    gfc.l3_side.tt[gr][ch].block_type = Encoder$2.NORM_TYPE;\n                    gfc.l3_side.tt[gr][ch].mixed_block_flag = 0;\n                    pe_MS[gr][ch] = pe[gr][ch] = 700;\n                }\n        }\n\n        /* auto-adjust of ATH, useful for low volume */\n        adjust_ATH(gfc);\n\n        /****************************************\n         * Stage 2: MDCT *\n         ****************************************/\n\n        /* polyphase filtering / mdct */\n        newMDCT.mdct_sub48(gfc, inbuf[0], inbuf[1]);\n\n        /****************************************\n         * Stage 3: MS/LR decision *\n         ****************************************/\n\n        /* Here will be selected MS or LR coding of the 2 stereo channels */\n        gfc.mode_ext = Encoder$2.MPG_MD_LR_LR;\n\n        if (gfp.force_ms) {\n            gfc.mode_ext = Encoder$2.MPG_MD_MS_LR;\n        } else if (gfp.mode == MPEGMode.JOINT_STEREO) {\n            /*\n             * ms_ratio = is scaled, for historical reasons, to look like a\n             * ratio of side_channel / total. 0 = signal is 100% mono .5 = L & R\n             * uncorrelated\n             */\n\n            /**\n             * <PRE>\n             * [0] and [1] are the results for the two granules in MPEG-1,\n             * in MPEG-2 it's only a faked averaging of the same value\n             * _prev is the value of the last granule of the previous frame\n             * _next is the value of the first granule of the next frame\n             * </PRE>\n             */\n\n            var sum_pe_MS = 0.;\n            var sum_pe_LR = 0.;\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    sum_pe_MS += pe_MS[gr][ch];\n                    sum_pe_LR += pe[gr][ch];\n                }\n            }\n\n            /* based on PE: M/S coding would not use much more bits than L/R */\n            if (sum_pe_MS <= 1.00 * sum_pe_LR) {\n\n                var gi0 = gfc.l3_side.tt[0];\n                var gi1 = gfc.l3_side.tt[gfc.mode_gr - 1];\n\n                if (gi0[0].block_type == gi0[1].block_type\n                    && gi1[0].block_type == gi1[1].block_type) {\n\n                    gfc.mode_ext = Encoder$2.MPG_MD_MS_LR;\n                }\n            }\n        }\n\n        /* bit and noise allocation */\n        if (gfc.mode_ext == MPG_MD_MS_LR) {\n            masking = masking_MS;\n            /* use MS masking */\n            pe_use = pe_MS;\n        } else {\n            masking = masking_LR;\n            /* use LR masking */\n            pe_use = pe;\n        }\n\n        /* copy data for MP3 frame analyzer */\n        if (gfp.analysis && gfc.pinfo != null) {\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    gfc.pinfo.ms_ratio[gr] = gfc.ms_ratio[gr];\n                    gfc.pinfo.ms_ener_ratio[gr] = ms_ener_ratio[gr];\n                    gfc.pinfo.blocktype[gr][ch] = gfc.l3_side.tt[gr][ch].block_type;\n                    gfc.pinfo.pe[gr][ch] = pe_use[gr][ch];\n                    System$5.arraycopy(gfc.l3_side.tt[gr][ch].xr, 0,\n                        gfc.pinfo.xr[gr][ch], 0, 576);\n                    /*\n                     * in psymodel, LR and MS data was stored in pinfo. switch\n                     * to MS data:\n                     */\n                    if (gfc.mode_ext == MPG_MD_MS_LR) {\n                        gfc.pinfo.ers[gr][ch] = gfc.pinfo.ers[gr][ch + 2];\n                        System$5.arraycopy(gfc.pinfo.energy[gr][ch + 2], 0,\n                            gfc.pinfo.energy[gr][ch], 0,\n                            gfc.pinfo.energy[gr][ch].length);\n                    }\n                }\n            }\n        }\n\n        /****************************************\n         * Stage 4: quantization loop *\n         ****************************************/\n\n        if (gfp.VBR == VbrMode$5.vbr_off || gfp.VBR == VbrMode$5.vbr_abr) {\n\n            var i;\n            var f;\n\n            for (i = 0; i < 18; i++)\n                gfc.nsPsy.pefirbuf[i] = gfc.nsPsy.pefirbuf[i + 1];\n\n            f = 0.0;\n            for (gr = 0; gr < gfc.mode_gr; gr++)\n                for (ch = 0; ch < gfc.channels_out; ch++)\n                    f += pe_use[gr][ch];\n            gfc.nsPsy.pefirbuf[18] = f;\n\n            f = gfc.nsPsy.pefirbuf[9];\n            for (i = 0; i < 9; i++)\n                f += (gfc.nsPsy.pefirbuf[i] + gfc.nsPsy.pefirbuf[18 - i])\n                    * Encoder$2.fircoef[i];\n\n            f = (670 * 5 * gfc.mode_gr * gfc.channels_out) / f;\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    pe_use[gr][ch] *= f;\n                }\n            }\n        }\n        gfc.iteration_loop.iteration_loop(gfp, pe_use, ms_ener_ratio, masking);\n\n        /****************************************\n         * Stage 5: bitstream formatting *\n         ****************************************/\n\n        /* write the frame to the bitstream */\n        bs.format_bitstream(gfp);\n\n        /* copy mp3 bit buffer into array */\n        mp3count = bs.copy_buffer(gfc, mp3buf, mp3bufPos, mp3buf_size, 1);\n\n        if (gfp.bWriteVbrTag)\n            vbr.addVbrFrame(gfp);\n\n        if (gfp.analysis && gfc.pinfo != null) {\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                var j;\n                for (j = 0; j < FFTOFFSET; j++)\n                    gfc.pinfo.pcmdata[ch][j] = gfc.pinfo.pcmdata[ch][j\n                    + gfp.framesize];\n                for (j = FFTOFFSET; j < 1600; j++) {\n                    gfc.pinfo.pcmdata[ch][j] = inbuf[ch][j - FFTOFFSET];\n                }\n            }\n            qupvt.set_frame_pinfo(gfp, masking);\n        }\n\n        updateStats(gfc);\n\n        return mp3count;\n    };\n}\n\n\nvar Encoder_1 = Encoder$2;\n\nvar Util$4 = common.Util;\nvar new_float$4 = common.new_float;\nfunction FFT() {\n\n    var window = new_float$4(Encoder_1.BLKSIZE);\n    var window_s = new_float$4(Encoder_1.BLKSIZE_s / 2);\n\n    var costab = [\n        9.238795325112867e-01, 3.826834323650898e-01,\n        9.951847266721969e-01, 9.801714032956060e-02,\n        9.996988186962042e-01, 2.454122852291229e-02,\n        9.999811752826011e-01, 6.135884649154475e-03\n    ];\n\n    function fht(fz, fzPos, n) {\n        var tri = 0;\n        var k4;\n        var fi;\n        var gi;\n\n        n <<= 1;\n        /* to get BLKSIZE, because of 3DNow! ASM routine */\n        var fn = fzPos + n;\n        k4 = 4;\n        do {\n            var s1, c1;\n            var i, k1, k2, k3, kx;\n            kx = k4 >> 1;\n            k1 = k4;\n            k2 = k4 << 1;\n            k3 = k2 + k1;\n            k4 = k2 << 1;\n            fi = fzPos;\n            gi = fi + kx;\n            do {\n                var f0, f1, f2, f3;\n                f1 = fz[fi + 0] - fz[fi + k1];\n                f0 = fz[fi + 0] + fz[fi + k1];\n                f3 = fz[fi + k2] - fz[fi + k3];\n                f2 = fz[fi + k2] + fz[fi + k3];\n                fz[fi + k2] = f0 - f2;\n                fz[fi + 0] = f0 + f2;\n                fz[fi + k3] = f1 - f3;\n                fz[fi + k1] = f1 + f3;\n                f1 = fz[gi + 0] - fz[gi + k1];\n                f0 = fz[gi + 0] + fz[gi + k1];\n                f3 = (Util$4.SQRT2 * fz[gi + k3]);\n                f2 = (Util$4.SQRT2 * fz[gi + k2]);\n                fz[gi + k2] = f0 - f2;\n                fz[gi + 0] = f0 + f2;\n                fz[gi + k3] = f1 - f3;\n                fz[gi + k1] = f1 + f3;\n                gi += k4;\n                fi += k4;\n            } while (fi < fn);\n            c1 = costab[tri + 0];\n            s1 = costab[tri + 1];\n            for (i = 1; i < kx; i++) {\n                var c2, s2;\n                c2 = 1 - (2 * s1) * s1;\n                s2 = (2 * s1) * c1;\n                fi = fzPos + i;\n                gi = fzPos + k1 - i;\n                do {\n                    var a, b, g0, f0, f1, g1, f2, g2, f3, g3;\n                    b = s2 * fz[fi + k1] - c2 * fz[gi + k1];\n                    a = c2 * fz[fi + k1] + s2 * fz[gi + k1];\n                    f1 = fz[fi + 0] - a;\n                    f0 = fz[fi + 0] + a;\n                    g1 = fz[gi + 0] - b;\n                    g0 = fz[gi + 0] + b;\n                    b = s2 * fz[fi + k3] - c2 * fz[gi + k3];\n                    a = c2 * fz[fi + k3] + s2 * fz[gi + k3];\n                    f3 = fz[fi + k2] - a;\n                    f2 = fz[fi + k2] + a;\n                    g3 = fz[gi + k2] - b;\n                    g2 = fz[gi + k2] + b;\n                    b = s1 * f2 - c1 * g3;\n                    a = c1 * f2 + s1 * g3;\n                    fz[fi + k2] = f0 - a;\n                    fz[fi + 0] = f0 + a;\n                    fz[gi + k3] = g1 - b;\n                    fz[gi + k1] = g1 + b;\n                    b = c1 * g2 - s1 * f3;\n                    a = s1 * g2 + c1 * f3;\n                    fz[gi + k2] = g0 - a;\n                    fz[gi + 0] = g0 + a;\n                    fz[fi + k3] = f1 - b;\n                    fz[fi + k1] = f1 + b;\n                    gi += k4;\n                    fi += k4;\n                } while (fi < fn);\n                c2 = c1;\n                c1 = c2 * costab[tri + 0] - s1 * costab[tri + 1];\n                s1 = c2 * costab[tri + 1] + s1 * costab[tri + 0];\n            }\n            tri += 2;\n        } while (k4 < n);\n    }\n\n    var rv_tbl = [0x00, 0x80, 0x40,\n        0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10,\n        0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70,\n        0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28,\n        0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58,\n        0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04,\n        0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64,\n        0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34,\n        0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c,\n        0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c,\n        0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c,\n        0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22,\n        0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52,\n        0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a,\n        0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a,\n        0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a,\n        0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46,\n        0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16,\n        0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76,\n        0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e,\n        0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e,\n        0xde, 0x3e, 0xbe, 0x7e, 0xfe];\n\n    this.fft_short = function (gfc, x_real, chn, buffer, bufPos) {\n        for (var b = 0; b < 3; b++) {\n            var x = Encoder_1.BLKSIZE_s / 2;\n            var k = 0xffff & ((576 / 3) * (b + 1));\n            var j = Encoder_1.BLKSIZE_s / 8 - 1;\n            do {\n                var f0, f1, f2, f3, w;\n                var i = rv_tbl[j << 2] & 0xff;\n\n                f0 = window_s[i] * buffer[chn][bufPos + i + k];\n                w = window_s[0x7f - i] * buffer[chn][bufPos + i + k + 0x80];\n                f1 = f0 - w;\n                f0 = f0 + w;\n                f2 = window_s[i + 0x40] * buffer[chn][bufPos + i + k + 0x40];\n                w = window_s[0x3f - i] * buffer[chn][bufPos + i + k + 0xc0];\n                f3 = f2 - w;\n                f2 = f2 + w;\n\n                x -= 4;\n                x_real[b][x + 0] = f0 + f2;\n                x_real[b][x + 2] = f0 - f2;\n                x_real[b][x + 1] = f1 + f3;\n                x_real[b][x + 3] = f1 - f3;\n\n                f0 = window_s[i + 0x01] * buffer[chn][bufPos + i + k + 0x01];\n                w = window_s[0x7e - i] * buffer[chn][bufPos + i + k + 0x81];\n                f1 = f0 - w;\n                f0 = f0 + w;\n                f2 = window_s[i + 0x41] * buffer[chn][bufPos + i + k + 0x41];\n                w = window_s[0x3e - i] * buffer[chn][bufPos + i + k + 0xc1];\n                f3 = f2 - w;\n                f2 = f2 + w;\n\n                x_real[b][x + Encoder_1.BLKSIZE_s / 2 + 0] = f0 + f2;\n                x_real[b][x + Encoder_1.BLKSIZE_s / 2 + 2] = f0 - f2;\n                x_real[b][x + Encoder_1.BLKSIZE_s / 2 + 1] = f1 + f3;\n                x_real[b][x + Encoder_1.BLKSIZE_s / 2 + 3] = f1 - f3;\n            } while (--j >= 0);\n\n            fht(x_real[b], x, Encoder_1.BLKSIZE_s / 2);\n            /* BLKSIZE_s/2 because of 3DNow! ASM routine */\n            /* BLKSIZE/2 because of 3DNow! ASM routine */\n        }\n    };\n\n    this.fft_long = function (gfc, y, chn, buffer, bufPos) {\n        var jj = Encoder_1.BLKSIZE / 8 - 1;\n        var x = Encoder_1.BLKSIZE / 2;\n\n        do {\n            var f0, f1, f2, f3, w;\n            var i = rv_tbl[jj] & 0xff;\n            f0 = window[i] * buffer[chn][bufPos + i];\n            w = window[i + 0x200] * buffer[chn][bufPos + i + 0x200];\n            f1 = f0 - w;\n            f0 = f0 + w;\n            f2 = window[i + 0x100] * buffer[chn][bufPos + i + 0x100];\n            w = window[i + 0x300] * buffer[chn][bufPos + i + 0x300];\n            f3 = f2 - w;\n            f2 = f2 + w;\n\n            x -= 4;\n            y[x + 0] = f0 + f2;\n            y[x + 2] = f0 - f2;\n            y[x + 1] = f1 + f3;\n            y[x + 3] = f1 - f3;\n\n            f0 = window[i + 0x001] * buffer[chn][bufPos + i + 0x001];\n            w = window[i + 0x201] * buffer[chn][bufPos + i + 0x201];\n            f1 = f0 - w;\n            f0 = f0 + w;\n            f2 = window[i + 0x101] * buffer[chn][bufPos + i + 0x101];\n            w = window[i + 0x301] * buffer[chn][bufPos + i + 0x301];\n            f3 = f2 - w;\n            f2 = f2 + w;\n\n            y[x + Encoder_1.BLKSIZE / 2 + 0] = f0 + f2;\n            y[x + Encoder_1.BLKSIZE / 2 + 2] = f0 - f2;\n            y[x + Encoder_1.BLKSIZE / 2 + 1] = f1 + f3;\n            y[x + Encoder_1.BLKSIZE / 2 + 3] = f1 - f3;\n        } while (--jj >= 0);\n\n        fht(y, x, Encoder_1.BLKSIZE / 2);\n        /* BLKSIZE/2 because of 3DNow! ASM routine */\n    };\n\n    this.init_fft = function (gfc) {\n        /* The type of window used here will make no real difference, but */\n        /*\n         * in the interest of merging nspsytune stuff - switch to blackman\n         * window\n         */\n        for (var i = 0; i < Encoder_1.BLKSIZE; i++)\n            /* blackman window */\n            window[i] = (0.42 - 0.5 * Math.cos(2 * Math.PI * (i + .5)\n                / Encoder_1.BLKSIZE) + 0.08 * Math.cos(4 * Math.PI * (i + .5)\n                / Encoder_1.BLKSIZE));\n\n        for (var i = 0; i < Encoder_1.BLKSIZE_s / 2; i++)\n            window_s[i] = (0.5 * (1.0 - Math.cos(2.0 * Math.PI\n                * (i + 0.5) / Encoder_1.BLKSIZE_s)));\n\n    };\n\n}\n\nvar FFT_1 = FFT;\n\nvar VbrMode$3 = common.VbrMode;\nvar Float$3 = common.Float;\nvar ShortBlock$3 = common.ShortBlock;\nvar Util$3 = common.Util;\nvar Arrays$3 = common.Arrays;\nvar new_float$3 = common.new_float;\nvar new_float_n$3 = common.new_float_n;\nvar new_int$3 = common.new_int;\nvar assert$3 = common.assert;\n\n\n\n\nfunction PsyModel() {\n\n    var fft = new FFT_1();\n\n    var LOG10 = 2.30258509299404568402;\n\n    var rpelev = 2;\n    var rpelev2 = 16;\n    var rpelev_s = 2;\n    var rpelev2_s = 16;\n\n    /* size of each partition band, in barks: */\n    var DELBARK = .34;\n\n    /* tuned for output level (sensitive to energy scale) */\n    var VO_SCALE = (1. / (14752 * 14752) / (Encoder_1.BLKSIZE / 2));\n\n    var temporalmask_sustain_sec = 0.01;\n\n    var NS_PREECHO_ATT0 = 0.8;\n    var NS_PREECHO_ATT1 = 0.6;\n    var NS_PREECHO_ATT2 = 0.3;\n\n    var NS_MSFIX = 3.5;\n\n    var NSATTACKTHRE = 4.4;\n    var NSATTACKTHRE_S = 25;\n\n    var NSFIRLEN = 21;\n\n    /* size of each partition band, in barks: */\n    var LN_TO_LOG10 = 0.2302585093;\n\n    function NON_LINEAR_SCALE_ENERGY(x) {\n        return x;\n    }\n\n    /**\n     * <PRE>\n     *       L3psycho_anal.  Compute psycho acoustics.\n     *\n     *       Data returned to the calling program must be delayed by one\n     *       granule.\n     *\n     *       This is done in two places.\n     *       If we do not need to know the blocktype, the copying\n     *       can be done here at the top of the program: we copy the data for\n     *       the last granule (computed during the last call) before it is\n     *       overwritten with the new data.  It looks like this:\n     *\n     *       0. static psymodel_data\n     *       1. calling_program_data = psymodel_data\n     *       2. compute psymodel_data\n     *\n     *       For data which needs to know the blocktype, the copying must be\n     *       done at the end of this loop, and the old values must be saved:\n     *\n     *       0. static psymodel_data_old\n     *       1. compute psymodel_data\n     *       2. compute possible block type of this granule\n     *       3. compute final block type of previous granule based on #2.\n     *       4. calling_program_data = psymodel_data_old\n     *       5. psymodel_data_old = psymodel_data\n     *     psycho_loudness_approx\n     *       jd - 2001 mar 12\n     *    in:  energy   - BLKSIZE/2 elements of frequency magnitudes ^ 2\n     *         gfp      - uses out_samplerate, ATHtype (also needed for ATHformula)\n     *    returns: loudness^2 approximation, a positive value roughly tuned for a value\n     *             of 1.0 for signals near clipping.\n     *    notes:   When calibrated, feeding this function binary white noise at sample\n     *             values +32767 or -32768 should return values that approach 3.\n     *             ATHformula is used to approximate an equal loudness curve.\n     *    future:  Data indicates that the shape of the equal loudness curve varies\n     *             with intensity.  This function might be improved by using an equal\n     *             loudness curve shaped for typical playback levels (instead of the\n     *             ATH, that is shaped for the threshold).  A flexible realization might\n     *             simply bend the existing ATH curve to achieve the desired shape.\n     *             However, the potential gain may not be enough to justify an effort.\n     * </PRE>\n     */\n    function psycho_loudness_approx(energy, gfc) {\n        var loudness_power = 0.0;\n        /* apply weights to power in freq. bands */\n        for (var i = 0; i < Encoder_1.BLKSIZE / 2; ++i)\n            loudness_power += energy[i] * gfc.ATH.eql_w[i];\n        loudness_power *= VO_SCALE;\n\n        return loudness_power;\n    }\n\n    function compute_ffts(gfp, fftenergy, fftenergy_s, wsamp_l, wsamp_lPos, wsamp_s, wsamp_sPos, gr_out, chn, buffer, bufPos) {\n        var gfc = gfp.internal_flags;\n        if (chn < 2) {\n            fft.fft_long(gfc, wsamp_l[wsamp_lPos], chn, buffer, bufPos);\n            fft.fft_short(gfc, wsamp_s[wsamp_sPos], chn, buffer, bufPos);\n        }\n        /* FFT data for mid and side channel is derived from L & R */\n        else if (chn == 2) {\n            for (var j = Encoder_1.BLKSIZE - 1; j >= 0; --j) {\n                var l = wsamp_l[wsamp_lPos + 0][j];\n                var r = wsamp_l[wsamp_lPos + 1][j];\n                wsamp_l[wsamp_lPos + 0][j] = (l + r) * Util$3.SQRT2 * 0.5;\n                wsamp_l[wsamp_lPos + 1][j] = (l - r) * Util$3.SQRT2 * 0.5;\n            }\n            for (var b = 2; b >= 0; --b) {\n                for (var j = Encoder_1.BLKSIZE_s - 1; j >= 0; --j) {\n                    var l = wsamp_s[wsamp_sPos + 0][b][j];\n                    var r = wsamp_s[wsamp_sPos + 1][b][j];\n                    wsamp_s[wsamp_sPos + 0][b][j] = (l + r) * Util$3.SQRT2 * 0.5;\n                    wsamp_s[wsamp_sPos + 1][b][j] = (l - r) * Util$3.SQRT2 * 0.5;\n                }\n            }\n        }\n\n        /*********************************************************************\n         * compute energies\n         *********************************************************************/\n        fftenergy[0] = NON_LINEAR_SCALE_ENERGY(wsamp_l[wsamp_lPos + 0][0]);\n        fftenergy[0] *= fftenergy[0];\n\n        for (var j = Encoder_1.BLKSIZE / 2 - 1; j >= 0; --j) {\n            var re = (wsamp_l[wsamp_lPos + 0])[Encoder_1.BLKSIZE / 2 - j];\n            var im = (wsamp_l[wsamp_lPos + 0])[Encoder_1.BLKSIZE / 2 + j];\n            fftenergy[Encoder_1.BLKSIZE / 2 - j] = NON_LINEAR_SCALE_ENERGY((re\n                * re + im * im) * 0.5);\n        }\n        for (var b = 2; b >= 0; --b) {\n            fftenergy_s[b][0] = (wsamp_s[wsamp_sPos + 0])[b][0];\n            fftenergy_s[b][0] *= fftenergy_s[b][0];\n            for (var j = Encoder_1.BLKSIZE_s / 2 - 1; j >= 0; --j) {\n                var re = (wsamp_s[wsamp_sPos + 0])[b][Encoder_1.BLKSIZE_s\n                / 2 - j];\n                var im = (wsamp_s[wsamp_sPos + 0])[b][Encoder_1.BLKSIZE_s\n                / 2 + j];\n                fftenergy_s[b][Encoder_1.BLKSIZE_s / 2 - j] = NON_LINEAR_SCALE_ENERGY((re\n                    * re + im * im) * 0.5);\n            }\n        }\n        /* total energy */\n        {\n            var totalenergy = 0.0;\n            for (var j = 11; j < Encoder_1.HBLKSIZE; j++)\n                totalenergy += fftenergy[j];\n\n            gfc.tot_ener[chn] = totalenergy;\n        }\n\n        if (gfp.analysis) {\n            for (var j = 0; j < Encoder_1.HBLKSIZE; j++) {\n                gfc.pinfo.energy[gr_out][chn][j] = gfc.pinfo.energy_save[chn][j];\n                gfc.pinfo.energy_save[chn][j] = fftenergy[j];\n            }\n            gfc.pinfo.pe[gr_out][chn] = gfc.pe[chn];\n        }\n\n        /*********************************************************************\n         * compute loudness approximation (used for ATH auto-level adjustment)\n         *********************************************************************/\n        if (gfp.athaa_loudapprox == 2 && chn < 2) {\n            // no loudness for mid/side ch\n            gfc.loudness_sq[gr_out][chn] = gfc.loudness_sq_save[chn];\n            gfc.loudness_sq_save[chn] = psycho_loudness_approx(fftenergy, gfc);\n        }\n    }\n\n    /* mask_add optimization */\n    /* init the limit values used to avoid computing log in mask_add when it is not necessary */\n\n    /**\n     * <PRE>\n     *  For example, with i = 10*log10(m2/m1)/10*16         (= log10(m2/m1)*16)\n     *\n     * abs(i)>8 is equivalent (as i is an integer) to\n     * abs(i)>=9\n     * i>=9 || i<=-9\n     * equivalent to (as i is the biggest integer smaller than log10(m2/m1)*16\n     * or the smallest integer bigger than log10(m2/m1)*16 depending on the sign of log10(m2/m1)*16)\n     * log10(m2/m1)>=9/16 || log10(m2/m1)<=-9/16\n     * exp10 is strictly increasing thus this is equivalent to\n     * m2/m1 >= 10^(9/16) || m2/m1<=10^(-9/16) which are comparisons to constants\n     * </PRE>\n     */\n\n    /**\n     * as in if(i>8)\n     */\n    var I1LIMIT = 8;\n    /**\n     * as in if(i>24) . changed 23\n     */\n    var I2LIMIT = 23;\n    /**\n     * as in if(m<15)\n     */\n    var MLIMIT = 15;\n\n    var ma_max_i1;\n    var ma_max_i2;\n    var ma_max_m;\n\n    /**\n     * This is the masking table:<BR>\n     * According to tonality, values are going from 0dB (TMN) to 9.3dB (NMT).<BR>\n     * After additive masking computation, 8dB are added, so final values are\n     * going from 8dB to 17.3dB\n     *\n     * pow(10, -0.0..-0.6)\n     */\n    var tab = [1.0, 0.79433, 0.63096, 0.63096,\n        0.63096, 0.63096, 0.63096, 0.25119, 0.11749];\n\n    function init_mask_add_max_values() {\n        ma_max_i1 = Math.pow(10, (I1LIMIT + 1) / 16.0);\n        ma_max_i2 = Math.pow(10, (I2LIMIT + 1) / 16.0);\n        ma_max_m = Math.pow(10, (MLIMIT) / 10.0);\n    }\n\n    var table1 = [3.3246 * 3.3246,\n        3.23837 * 3.23837, 3.15437 * 3.15437, 3.00412 * 3.00412,\n        2.86103 * 2.86103, 2.65407 * 2.65407, 2.46209 * 2.46209,\n        2.284 * 2.284, 2.11879 * 2.11879, 1.96552 * 1.96552,\n        1.82335 * 1.82335, 1.69146 * 1.69146, 1.56911 * 1.56911,\n        1.46658 * 1.46658, 1.37074 * 1.37074, 1.31036 * 1.31036,\n        1.25264 * 1.25264, 1.20648 * 1.20648, 1.16203 * 1.16203,\n        1.12765 * 1.12765, 1.09428 * 1.09428, 1.0659 * 1.0659,\n        1.03826 * 1.03826, 1.01895 * 1.01895, 1];\n\n    var table2 = [1.33352 * 1.33352,\n        1.35879 * 1.35879, 1.38454 * 1.38454, 1.39497 * 1.39497,\n        1.40548 * 1.40548, 1.3537 * 1.3537, 1.30382 * 1.30382,\n        1.22321 * 1.22321, 1.14758 * 1.14758, 1];\n\n    var table3 = [2.35364 * 2.35364,\n        2.29259 * 2.29259, 2.23313 * 2.23313, 2.12675 * 2.12675,\n        2.02545 * 2.02545, 1.87894 * 1.87894, 1.74303 * 1.74303,\n        1.61695 * 1.61695, 1.49999 * 1.49999, 1.39148 * 1.39148,\n        1.29083 * 1.29083, 1.19746 * 1.19746, 1.11084 * 1.11084,\n        1.03826 * 1.03826];\n\n    /**\n     * addition of simultaneous masking Naoki Shibata 2000/7\n     */\n    function mask_add(m1, m2, kk, b, gfc, shortblock) {\n        var ratio;\n\n        if (m2 > m1) {\n            if (m2 < (m1 * ma_max_i2))\n                ratio = m2 / m1;\n            else\n                return (m1 + m2);\n        } else {\n            if (m1 >= (m2 * ma_max_i2))\n                return (m1 + m2);\n            ratio = m1 / m2;\n        }\n\n        /* Should always be true, just checking */\n        assert$3(m1 >= 0);\n        assert$3(m2 >= 0);\n\n        m1 += m2;\n        //if (((long)(b + 3) & 0xffffffff) <= 3 + 3) {\n        if ((b + 3) <= 3 + 3) {\n            /* approximately, 1 bark = 3 partitions */\n            /* 65% of the cases */\n            /* originally 'if(i > 8)' */\n            if (ratio >= ma_max_i1) {\n                /* 43% of the total */\n                return m1;\n            }\n\n            /* 22% of the total */\n            var i = 0 | (Util$3.FAST_LOG10_X(ratio, 16.0));\n            return m1 * table2[i];\n        }\n\n        /**\n         * <PRE>\n         * m<15 equ log10((m1+m2)/gfc.ATH.cb[k])<1.5\n         * equ (m1+m2)/gfc.ATH.cb[k]<10^1.5\n         * equ (m1+m2)<10^1.5 * gfc.ATH.cb[k]\n         * </PRE>\n         */\n        var i = 0 | Util$3.FAST_LOG10_X(ratio, 16.0);\n        if (shortblock != 0) {\n            m2 = gfc.ATH.cb_s[kk] * gfc.ATH.adjust;\n        } else {\n            m2 = gfc.ATH.cb_l[kk] * gfc.ATH.adjust;\n        }\n        assert$3(m2 >= 0);\n        if (m1 < ma_max_m * m2) {\n            /* 3% of the total */\n            /* Originally if (m > 0) { */\n            if (m1 > m2) {\n                var f, r;\n\n                f = 1.0;\n                if (i <= 13)\n                    f = table3[i];\n\n                r = Util$3.FAST_LOG10_X(m1 / m2, 10.0 / 15.0);\n                return m1 * ((table1[i] - f) * r + f);\n            }\n\n            if (i > 13)\n                return m1;\n\n            return m1 * table3[i];\n        }\n\n        /* 10% of total */\n        return m1 * table1[i];\n    }\n\n    var table2_ = [1.33352 * 1.33352,\n        1.35879 * 1.35879, 1.38454 * 1.38454, 1.39497 * 1.39497,\n        1.40548 * 1.40548, 1.3537 * 1.3537, 1.30382 * 1.30382,\n        1.22321 * 1.22321, 1.14758 * 1.14758, 1];\n\n    /**\n     * addition of simultaneous masking Naoki Shibata 2000/7\n     */\n    function vbrpsy_mask_add(m1, m2, b) {\n        var ratio;\n\n        if (m1 < 0) {\n            m1 = 0;\n        }\n        if (m2 < 0) {\n            m2 = 0;\n        }\n        if (m1 <= 0) {\n            return m2;\n        }\n        if (m2 <= 0) {\n            return m1;\n        }\n        if (m2 > m1) {\n            ratio = m2 / m1;\n        } else {\n            ratio = m1 / m2;\n        }\n        if (-2 <= b && b <= 2) {\n            /* approximately, 1 bark = 3 partitions */\n            /* originally 'if(i > 8)' */\n            if (ratio >= ma_max_i1) {\n                return m1 + m2;\n            } else {\n                var i = 0 | (Util$3.FAST_LOG10_X(ratio, 16.0));\n                return (m1 + m2) * table2_[i];\n            }\n        }\n        if (ratio < ma_max_i2) {\n            return m1 + m2;\n        }\n        if (m1 < m2) {\n            m1 = m2;\n        }\n        return m1;\n    }\n\n    /**\n     * compute interchannel masking effects\n     */\n    function calc_interchannel_masking(gfp, ratio) {\n        var gfc = gfp.internal_flags;\n        if (gfc.channels_out > 1) {\n            for (var sb = 0; sb < Encoder_1.SBMAX_l; sb++) {\n                var l = gfc.thm[0].l[sb];\n                var r = gfc.thm[1].l[sb];\n                gfc.thm[0].l[sb] += r * ratio;\n                gfc.thm[1].l[sb] += l * ratio;\n            }\n            for (var sb = 0; sb < Encoder_1.SBMAX_s; sb++) {\n                for (var sblock = 0; sblock < 3; sblock++) {\n                    var l = gfc.thm[0].s[sb][sblock];\n                    var r = gfc.thm[1].s[sb][sblock];\n                    gfc.thm[0].s[sb][sblock] += r * ratio;\n                    gfc.thm[1].s[sb][sblock] += l * ratio;\n                }\n            }\n        }\n    }\n\n    /**\n     * compute M/S thresholds from Johnston & Ferreira 1992 ICASSP paper\n     */\n    function msfix1(gfc) {\n        for (var sb = 0; sb < Encoder_1.SBMAX_l; sb++) {\n            /* use this fix if L & R masking differs by 2db or less */\n            /* if db = 10*log10(x2/x1) < 2 */\n            /* if (x2 < 1.58*x1) { */\n            if (gfc.thm[0].l[sb] > 1.58 * gfc.thm[1].l[sb]\n                || gfc.thm[1].l[sb] > 1.58 * gfc.thm[0].l[sb])\n                continue;\n            var mld = gfc.mld_l[sb] * gfc.en[3].l[sb];\n            var rmid = Math.max(gfc.thm[2].l[sb],\n                Math.min(gfc.thm[3].l[sb], mld));\n\n            mld = gfc.mld_l[sb] * gfc.en[2].l[sb];\n            var rside = Math.max(gfc.thm[3].l[sb],\n                Math.min(gfc.thm[2].l[sb], mld));\n            gfc.thm[2].l[sb] = rmid;\n            gfc.thm[3].l[sb] = rside;\n        }\n\n        for (var sb = 0; sb < Encoder_1.SBMAX_s; sb++) {\n            for (var sblock = 0; sblock < 3; sblock++) {\n                if (gfc.thm[0].s[sb][sblock] > 1.58 * gfc.thm[1].s[sb][sblock]\n                    || gfc.thm[1].s[sb][sblock] > 1.58 * gfc.thm[0].s[sb][sblock])\n                    continue;\n                var mld = gfc.mld_s[sb] * gfc.en[3].s[sb][sblock];\n                var rmid = Math.max(gfc.thm[2].s[sb][sblock],\n                    Math.min(gfc.thm[3].s[sb][sblock], mld));\n\n                mld = gfc.mld_s[sb] * gfc.en[2].s[sb][sblock];\n                var rside = Math.max(gfc.thm[3].s[sb][sblock],\n                    Math.min(gfc.thm[2].s[sb][sblock], mld));\n\n                gfc.thm[2].s[sb][sblock] = rmid;\n                gfc.thm[3].s[sb][sblock] = rside;\n            }\n        }\n    }\n\n    /**\n     * Adjust M/S maskings if user set \"msfix\"\n     *\n     * Naoki Shibata 2000\n     */\n    function ns_msfix(gfc, msfix, athadjust) {\n        var msfix2 = msfix;\n        var athlower = Math.pow(10, athadjust);\n\n        msfix *= 2.0;\n        msfix2 *= 2.0;\n        for (var sb = 0; sb < Encoder_1.SBMAX_l; sb++) {\n            var thmLR, thmM, thmS, ath;\n            ath = (gfc.ATH.cb_l[gfc.bm_l[sb]]) * athlower;\n            thmLR = Math.min(Math.max(gfc.thm[0].l[sb], ath),\n                Math.max(gfc.thm[1].l[sb], ath));\n            thmM = Math.max(gfc.thm[2].l[sb], ath);\n            thmS = Math.max(gfc.thm[3].l[sb], ath);\n            if (thmLR * msfix < thmM + thmS) {\n                var f = thmLR * msfix2 / (thmM + thmS);\n                thmM *= f;\n                thmS *= f;\n                assert$3(thmM + thmS > 0);\n            }\n            gfc.thm[2].l[sb] = Math.min(thmM, gfc.thm[2].l[sb]);\n            gfc.thm[3].l[sb] = Math.min(thmS, gfc.thm[3].l[sb]);\n        }\n\n        athlower *= ( Encoder_1.BLKSIZE_s / Encoder_1.BLKSIZE);\n        for (var sb = 0; sb < Encoder_1.SBMAX_s; sb++) {\n            for (var sblock = 0; sblock < 3; sblock++) {\n                var thmLR, thmM, thmS, ath;\n                ath = (gfc.ATH.cb_s[gfc.bm_s[sb]]) * athlower;\n                thmLR = Math.min(Math.max(gfc.thm[0].s[sb][sblock], ath),\n                    Math.max(gfc.thm[1].s[sb][sblock], ath));\n                thmM = Math.max(gfc.thm[2].s[sb][sblock], ath);\n                thmS = Math.max(gfc.thm[3].s[sb][sblock], ath);\n\n                if (thmLR * msfix < thmM + thmS) {\n                    var f = thmLR * msfix / (thmM + thmS);\n                    thmM *= f;\n                    thmS *= f;\n                    assert$3(thmM + thmS > 0);\n                }\n                gfc.thm[2].s[sb][sblock] = Math.min(gfc.thm[2].s[sb][sblock],\n                    thmM);\n                gfc.thm[3].s[sb][sblock] = Math.min(gfc.thm[3].s[sb][sblock],\n                    thmS);\n            }\n        }\n    }\n\n    /**\n     * short block threshold calculation (part 2)\n     *\n     * partition band bo_s[sfb] is at the transition from scalefactor band sfb\n     * to the next one sfb+1; enn and thmm have to be split between them\n     */\n    function convert_partition2scalefac_s(gfc, eb, thr, chn, sblock) {\n        var sb, b;\n        var enn = 0.0;\n        var thmm = 0.0;\n        for (sb = b = 0; sb < Encoder_1.SBMAX_s; ++b, ++sb) {\n            var bo_s_sb = gfc.bo_s[sb];\n            var npart_s = gfc.npart_s;\n            var b_lim = bo_s_sb < npart_s ? bo_s_sb : npart_s;\n            while (b < b_lim) {\n                assert$3(eb[b] >= 0);\n                // iff failed, it may indicate some index error elsewhere\n                assert$3(thr[b] >= 0);\n                enn += eb[b];\n                thmm += thr[b];\n                b++;\n            }\n            gfc.en[chn].s[sb][sblock] = enn;\n            gfc.thm[chn].s[sb][sblock] = thmm;\n\n            if (b >= npart_s) {\n                ++sb;\n                break;\n            }\n            assert$3(eb[b] >= 0);\n            // iff failed, it may indicate some index error elsewhere\n            assert$3(thr[b] >= 0);\n            {\n                /* at transition sfb . sfb+1 */\n                var w_curr = gfc.PSY.bo_s_weight[sb];\n                var w_next = 1.0 - w_curr;\n                enn = w_curr * eb[b];\n                thmm = w_curr * thr[b];\n                gfc.en[chn].s[sb][sblock] += enn;\n                gfc.thm[chn].s[sb][sblock] += thmm;\n                enn = w_next * eb[b];\n                thmm = w_next * thr[b];\n            }\n        }\n        /* zero initialize the rest */\n        for (; sb < Encoder_1.SBMAX_s; ++sb) {\n            gfc.en[chn].s[sb][sblock] = 0;\n            gfc.thm[chn].s[sb][sblock] = 0;\n        }\n    }\n\n    /**\n     * longblock threshold calculation (part 2)\n     */\n    function convert_partition2scalefac_l(gfc, eb, thr, chn) {\n        var sb, b;\n        var enn = 0.0;\n        var thmm = 0.0;\n        for (sb = b = 0; sb < Encoder_1.SBMAX_l; ++b, ++sb) {\n            var bo_l_sb = gfc.bo_l[sb];\n            var npart_l = gfc.npart_l;\n            var b_lim = bo_l_sb < npart_l ? bo_l_sb : npart_l;\n            while (b < b_lim) {\n                assert$3(eb[b] >= 0);\n                // iff failed, it may indicate some index error elsewhere\n                assert$3(thr[b] >= 0);\n                enn += eb[b];\n                thmm += thr[b];\n                b++;\n            }\n            gfc.en[chn].l[sb] = enn;\n            gfc.thm[chn].l[sb] = thmm;\n\n            if (b >= npart_l) {\n                ++sb;\n                break;\n            }\n            assert$3(eb[b] >= 0);\n            assert$3(thr[b] >= 0);\n            {\n                /* at transition sfb . sfb+1 */\n                var w_curr = gfc.PSY.bo_l_weight[sb];\n                var w_next = 1.0 - w_curr;\n                enn = w_curr * eb[b];\n                thmm = w_curr * thr[b];\n                gfc.en[chn].l[sb] += enn;\n                gfc.thm[chn].l[sb] += thmm;\n                enn = w_next * eb[b];\n                thmm = w_next * thr[b];\n            }\n        }\n        /* zero initialize the rest */\n        for (; sb < Encoder_1.SBMAX_l; ++sb) {\n            gfc.en[chn].l[sb] = 0;\n            gfc.thm[chn].l[sb] = 0;\n        }\n    }\n\n    function compute_masking_s(gfp, fftenergy_s, eb, thr, chn, sblock) {\n        var gfc = gfp.internal_flags;\n        var j, b;\n\n        for (b = j = 0; b < gfc.npart_s; ++b) {\n            var ebb = 0, m = 0;\n            var n = gfc.numlines_s[b];\n            for (var i = 0; i < n; ++i, ++j) {\n                var el = fftenergy_s[sblock][j];\n                ebb += el;\n                if (m < el)\n                    m = el;\n            }\n            eb[b] = ebb;\n        }\n        assert$3(b == gfc.npart_s);\n        assert$3(j == 129);\n        for (j = b = 0; b < gfc.npart_s; b++) {\n            var kk = gfc.s3ind_s[b][0];\n            var ecb = gfc.s3_ss[j++] * eb[kk];\n            ++kk;\n            while (kk <= gfc.s3ind_s[b][1]) {\n                ecb += gfc.s3_ss[j] * eb[kk];\n                ++j;\n                ++kk;\n            }\n\n            { /* limit calculated threshold by previous granule */\n                var x = rpelev_s * gfc.nb_s1[chn][b];\n                thr[b] = Math.min(ecb, x);\n            }\n            if (gfc.blocktype_old[chn & 1] == Encoder_1.SHORT_TYPE) {\n                /* limit calculated threshold by even older granule */\n                var x = rpelev2_s * gfc.nb_s2[chn][b];\n                var y = thr[b];\n                thr[b] = Math.min(x, y);\n            }\n\n            gfc.nb_s2[chn][b] = gfc.nb_s1[chn][b];\n            gfc.nb_s1[chn][b] = ecb;\n            assert$3(thr[b] >= 0);\n        }\n        for (; b <= Encoder_1.CBANDS; ++b) {\n            eb[b] = 0;\n            thr[b] = 0;\n        }\n    }\n\n    function block_type_set(gfp, uselongblock, blocktype_d, blocktype) {\n        var gfc = gfp.internal_flags;\n\n        if (gfp.short_blocks == ShortBlock$3.short_block_coupled\n                /* force both channels to use the same block type */\n                /* this is necessary if the frame is to be encoded in ms_stereo. */\n                /* But even without ms_stereo, FhG does this */\n            && !(uselongblock[0] != 0 && uselongblock[1] != 0))\n            uselongblock[0] = uselongblock[1] = 0;\n\n        /*\n         * update the blocktype of the previous granule, since it depends on\n         * what happend in this granule\n         */\n        for (var chn = 0; chn < gfc.channels_out; chn++) {\n            blocktype[chn] = Encoder_1.NORM_TYPE;\n            /* disable short blocks */\n            if (gfp.short_blocks == ShortBlock$3.short_block_dispensed)\n                uselongblock[chn] = 1;\n            if (gfp.short_blocks == ShortBlock$3.short_block_forced)\n                uselongblock[chn] = 0;\n\n            if (uselongblock[chn] != 0) {\n                /* no attack : use long blocks */\n                assert$3(gfc.blocktype_old[chn] != Encoder_1.START_TYPE);\n                if (gfc.blocktype_old[chn] == Encoder_1.SHORT_TYPE)\n                    blocktype[chn] = Encoder_1.STOP_TYPE;\n            } else {\n                /* attack : use short blocks */\n                blocktype[chn] = Encoder_1.SHORT_TYPE;\n                if (gfc.blocktype_old[chn] == Encoder_1.NORM_TYPE) {\n                    gfc.blocktype_old[chn] = Encoder_1.START_TYPE;\n                }\n                if (gfc.blocktype_old[chn] == Encoder_1.STOP_TYPE)\n                    gfc.blocktype_old[chn] = Encoder_1.SHORT_TYPE;\n            }\n\n            blocktype_d[chn] = gfc.blocktype_old[chn];\n            // value returned to calling program\n            gfc.blocktype_old[chn] = blocktype[chn];\n            // save for next call to l3psy_anal\n        }\n    }\n\n    function NS_INTERP(x, y, r) {\n        /* was pow((x),(r))*pow((y),1-(r)) */\n        if (r >= 1.0) {\n            /* 99.7% of the time */\n            return x;\n        }\n        if (r <= 0.0)\n            return y;\n        if (y > 0.0) {\n            /* rest of the time */\n            return (Math.pow(x / y, r) * y);\n        }\n        /* never happens */\n        return 0.0;\n    }\n\n    /**\n     * these values are tuned only for 44.1kHz...\n     */\n    var regcoef_s = [11.8, 13.6, 17.2, 32, 46.5,\n        51.3, 57.5, 67.1, 71.5, 84.6, 97.6, 130,\n        /* 255.8 */\n    ];\n\n    function pecalc_s(mr, masking_lower) {\n        var pe_s = 1236.28 / 4;\n        for (var sb = 0; sb < Encoder_1.SBMAX_s - 1; sb++) {\n            for (var sblock = 0; sblock < 3; sblock++) {\n                var thm = mr.thm.s[sb][sblock];\n                assert$3(sb < regcoef_s.length);\n                if (thm > 0.0) {\n                    var x = thm * masking_lower;\n                    var en = mr.en.s[sb][sblock];\n                    if (en > x) {\n                        if (en > x * 1e10) {\n                            pe_s += regcoef_s[sb] * (10.0 * LOG10);\n                        } else {\n                            assert$3(x > 0);\n                            pe_s += regcoef_s[sb] * Util$3.FAST_LOG10(en / x);\n                        }\n                    }\n                }\n            }\n        }\n\n        return pe_s;\n    }\n\n    /**\n     * these values are tuned only for 44.1kHz...\n     */\n    var regcoef_l = [6.8, 5.8, 5.8, 6.4, 6.5, 9.9,\n        12.1, 14.4, 15, 18.9, 21.6, 26.9, 34.2, 40.2, 46.8, 56.5,\n        60.7, 73.9, 85.7, 93.4, 126.1,\n        /* 241.3 */\n    ];\n\n    function pecalc_l(mr, masking_lower) {\n        var pe_l = 1124.23 / 4;\n        for (var sb = 0; sb < Encoder_1.SBMAX_l - 1; sb++) {\n            var thm = mr.thm.l[sb];\n            assert$3(sb < regcoef_l.length);\n            if (thm > 0.0) {\n                var x = thm * masking_lower;\n                var en = mr.en.l[sb];\n                if (en > x) {\n                    if (en > x * 1e10) {\n                        pe_l += regcoef_l[sb] * (10.0 * LOG10);\n                    } else {\n                        assert$3(x > 0);\n                        pe_l += regcoef_l[sb] * Util$3.FAST_LOG10(en / x);\n                    }\n                }\n            }\n        }\n        return pe_l;\n    }\n\n    function calc_energy(gfc, fftenergy, eb, max, avg) {\n        var b, j;\n\n        for (b = j = 0; b < gfc.npart_l; ++b) {\n            var ebb = 0, m = 0;\n            var i;\n            for (i = 0; i < gfc.numlines_l[b]; ++i, ++j) {\n                var el = fftenergy[j];\n                assert$3(el >= 0);\n                ebb += el;\n                if (m < el)\n                    m = el;\n            }\n            eb[b] = ebb;\n            max[b] = m;\n            avg[b] = ebb * gfc.rnumlines_l[b];\n            assert$3(gfc.rnumlines_l[b] >= 0);\n            assert$3(ebb >= 0);\n            assert$3(eb[b] >= 0);\n            assert$3(max[b] >= 0);\n            assert$3(avg[b] >= 0);\n        }\n    }\n\n    function calc_mask_index_l(gfc, max, avg, mask_idx) {\n        var last_tab_entry = tab.length - 1;\n        var b = 0;\n        var a = avg[b] + avg[b + 1];\n        assert$3(a >= 0);\n        if (a > 0.0) {\n            var m = max[b];\n            if (m < max[b + 1])\n                m = max[b + 1];\n            assert$3((gfc.numlines_l[b] + gfc.numlines_l[b + 1] - 1) > 0);\n            a = 20.0 * (m * 2.0 - a)\n                / (a * (gfc.numlines_l[b] + gfc.numlines_l[b + 1] - 1));\n            var k = 0 | a;\n            if (k > last_tab_entry)\n                k = last_tab_entry;\n            mask_idx[b] = k;\n        } else {\n            mask_idx[b] = 0;\n        }\n\n        for (b = 1; b < gfc.npart_l - 1; b++) {\n            a = avg[b - 1] + avg[b] + avg[b + 1];\n            assert$3(a >= 0);\n            if (a > 0.0) {\n                var m = max[b - 1];\n                if (m < max[b])\n                    m = max[b];\n                if (m < max[b + 1])\n                    m = max[b + 1];\n                assert$3((gfc.numlines_l[b - 1] + gfc.numlines_l[b] + gfc.numlines_l[b + 1] - 1) > 0);\n                a = 20.0\n                    * (m * 3.0 - a)\n                    / (a * (gfc.numlines_l[b - 1] + gfc.numlines_l[b]\n                    + gfc.numlines_l[b + 1] - 1));\n                var k = 0 | a;\n                if (k > last_tab_entry)\n                    k = last_tab_entry;\n                mask_idx[b] = k;\n            } else {\n                mask_idx[b] = 0;\n            }\n        }\n        assert$3(b > 0);\n        assert$3(b == gfc.npart_l - 1);\n\n        a = avg[b - 1] + avg[b];\n        assert$3(a >= 0);\n        if (a > 0.0) {\n            var m = max[b - 1];\n            if (m < max[b])\n                m = max[b];\n            assert$3((gfc.numlines_l[b - 1] + gfc.numlines_l[b] - 1) > 0);\n            a = 20.0 * (m * 2.0 - a)\n                / (a * (gfc.numlines_l[b - 1] + gfc.numlines_l[b] - 1));\n            var k = 0 | a;\n            if (k > last_tab_entry)\n                k = last_tab_entry;\n            mask_idx[b] = k;\n        } else {\n            mask_idx[b] = 0;\n        }\n        assert$3(b == (gfc.npart_l - 1));\n    }\n\n    var fircoef = [\n        -8.65163e-18 * 2, -0.00851586 * 2, -6.74764e-18 * 2, 0.0209036 * 2,\n        -3.36639e-17 * 2, -0.0438162 * 2, -1.54175e-17 * 2, 0.0931738 * 2,\n        -5.52212e-17 * 2, -0.313819 * 2\n    ];\n\n    this.L3psycho_anal_ns = function (gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, percep_entropy, percep_MS_entropy, energy, blocktype_d) {\n        /*\n         * to get a good cache performance, one has to think about the sequence,\n         * in which the variables are used.\n         */\n        var gfc = gfp.internal_flags;\n\n        /* fft and energy calculation */\n        var wsamp_L = new_float_n$3([2, Encoder_1.BLKSIZE]);\n        var wsamp_S = new_float_n$3([2, 3, Encoder_1.BLKSIZE_s]);\n\n        /* convolution */\n        var eb_l = new_float$3(Encoder_1.CBANDS + 1);\n        var eb_s = new_float$3(Encoder_1.CBANDS + 1);\n        var thr = new_float$3(Encoder_1.CBANDS + 2);\n\n        /* block type */\n        var blocktype = new_int$3(2), uselongblock = new_int$3(2);\n\n        /* usual variables like loop indices, etc.. */\n        var numchn, chn;\n        var b, i, j, k;\n        var sb, sblock;\n\n        /* variables used for --nspsytune */\n        var ns_hpfsmpl = new_float_n$3([2, 576]);\n        var pcfact;\n        var mask_idx_l = new_int$3(Encoder_1.CBANDS + 2), mask_idx_s = new_int$3(Encoder_1.CBANDS + 2);\n\n        Arrays$3.fill(mask_idx_s, 0);\n\n        numchn = gfc.channels_out;\n        /* chn=2 and 3 = Mid and Side channels */\n        if (gfp.mode == MPEGMode.JOINT_STEREO)\n            numchn = 4;\n\n        if (gfp.VBR == VbrMode$3.vbr_off)\n            pcfact = gfc.ResvMax == 0 ? 0 : ( gfc.ResvSize)\n            / gfc.ResvMax * 0.5;\n        else if (gfp.VBR == VbrMode$3.vbr_rh || gfp.VBR == VbrMode$3.vbr_mtrh\n            || gfp.VBR == VbrMode$3.vbr_mt) {\n            pcfact = 0.6;\n        } else\n            pcfact = 1.0;\n\n        /**********************************************************************\n         * Apply HPF of fs/4 to the input signal. This is used for attack\n         * detection / handling.\n         **********************************************************************/\n        /* Don't copy the input buffer into a temporary buffer */\n        /* unroll the loop 2 times */\n        for (chn = 0; chn < gfc.channels_out; chn++) {\n            /* apply high pass filter of fs/4 */\n            var firbuf = buffer[chn];\n            var firbufPos = bufPos + 576 - 350 - NSFIRLEN + 192;\n            assert$3(fircoef.length == ((NSFIRLEN - 1) / 2));\n            for (i = 0; i < 576; i++) {\n                var sum1, sum2;\n                sum1 = firbuf[firbufPos + i + 10];\n                sum2 = 0.0;\n                for (j = 0; j < ((NSFIRLEN - 1) / 2) - 1; j += 2) {\n                    sum1 += fircoef[j]\n                        * (firbuf[firbufPos + i + j] + firbuf[firbufPos + i\n                        + NSFIRLEN - j]);\n                    sum2 += fircoef[j + 1]\n                        * (firbuf[firbufPos + i + j + 1] + firbuf[firbufPos\n                        + i + NSFIRLEN - j - 1]);\n                }\n                ns_hpfsmpl[chn][i] = sum1 + sum2;\n            }\n            masking_ratio[gr_out][chn].en.assign(gfc.en[chn]);\n            masking_ratio[gr_out][chn].thm.assign(gfc.thm[chn]);\n            if (numchn > 2) {\n                /* MS maskings */\n                /* percep_MS_entropy [chn-2] = gfc . pe [chn]; */\n                masking_MS_ratio[gr_out][chn].en.assign(gfc.en[chn + 2]);\n                masking_MS_ratio[gr_out][chn].thm.assign(gfc.thm[chn + 2]);\n            }\n        }\n\n        for (chn = 0; chn < numchn; chn++) {\n            var wsamp_l;\n            var wsamp_s;\n            var en_subshort = new_float$3(12);\n            var en_short = [0, 0, 0, 0];\n            var attack_intensity = new_float$3(12);\n            var ns_uselongblock = 1;\n            var attackThreshold;\n            var max = new_float$3(Encoder_1.CBANDS), avg = new_float$3(Encoder_1.CBANDS);\n            var ns_attacks = [0, 0, 0, 0];\n            var fftenergy = new_float$3(Encoder_1.HBLKSIZE);\n            var fftenergy_s = new_float_n$3([3, Encoder_1.HBLKSIZE_s]);\n\n            /*\n             * rh 20040301: the following loops do access one off the limits so\n             * I increase the array dimensions by one and initialize the\n             * accessed values to zero\n             */\n            assert$3(gfc.npart_s <= Encoder_1.CBANDS);\n            assert$3(gfc.npart_l <= Encoder_1.CBANDS);\n\n            /***************************************************************\n             * determine the block type (window type)\n             ***************************************************************/\n            /* calculate energies of each sub-shortblocks */\n            for (i = 0; i < 3; i++) {\n                en_subshort[i] = gfc.nsPsy.last_en_subshort[chn][i + 6];\n                assert$3(gfc.nsPsy.last_en_subshort[chn][i + 4] > 0);\n                attack_intensity[i] = en_subshort[i]\n                    / gfc.nsPsy.last_en_subshort[chn][i + 4];\n                en_short[0] += en_subshort[i];\n            }\n\n            if (chn == 2) {\n                for (i = 0; i < 576; i++) {\n                    var l, r;\n                    l = ns_hpfsmpl[0][i];\n                    r = ns_hpfsmpl[1][i];\n                    ns_hpfsmpl[0][i] = l + r;\n                    ns_hpfsmpl[1][i] = l - r;\n                }\n            }\n            {\n                var pf = ns_hpfsmpl[chn & 1];\n                var pfPos = 0;\n                for (i = 0; i < 9; i++) {\n                    var pfe = pfPos + 576 / 9;\n                    var p = 1.;\n                    for (; pfPos < pfe; pfPos++)\n                        if (p < Math.abs(pf[pfPos]))\n                            p = Math.abs(pf[pfPos]);\n\n                    gfc.nsPsy.last_en_subshort[chn][i] = en_subshort[i + 3] = p;\n                    en_short[1 + i / 3] += p;\n                    if (p > en_subshort[i + 3 - 2]) {\n                        assert$3(en_subshort[i + 3 - 2] > 0);\n                        p = p / en_subshort[i + 3 - 2];\n                    } else if (en_subshort[i + 3 - 2] > p * 10.0) {\n                        assert$3(p > 0);\n                        p = en_subshort[i + 3 - 2] / (p * 10.0);\n                    } else\n                        p = 0.0;\n                    attack_intensity[i + 3] = p;\n                }\n            }\n\n            if (gfp.analysis) {\n                var x = attack_intensity[0];\n                for (i = 1; i < 12; i++)\n                    if (x < attack_intensity[i])\n                        x = attack_intensity[i];\n                gfc.pinfo.ers[gr_out][chn] = gfc.pinfo.ers_save[chn];\n                gfc.pinfo.ers_save[chn] = x;\n            }\n\n            /* compare energies between sub-shortblocks */\n            attackThreshold = (chn == 3) ? gfc.nsPsy.attackthre_s\n                : gfc.nsPsy.attackthre;\n            for (i = 0; i < 12; i++)\n                if (0 == ns_attacks[i / 3]\n                    && attack_intensity[i] > attackThreshold)\n                    ns_attacks[i / 3] = (i % 3) + 1;\n\n            /*\n             * should have energy change between short blocks, in order to avoid\n             * periodic signals\n             */\n            for (i = 1; i < 4; i++) {\n                var ratio;\n                if (en_short[i - 1] > en_short[i]) {\n                    assert$3(en_short[i] > 0);\n                    ratio = en_short[i - 1] / en_short[i];\n                } else {\n                    assert$3(en_short[i - 1] > 0);\n                    ratio = en_short[i] / en_short[i - 1];\n                }\n                if (ratio < 1.7) {\n                    ns_attacks[i] = 0;\n                    if (i == 1)\n                        ns_attacks[0] = 0;\n                }\n            }\n\n            if (ns_attacks[0] != 0 && gfc.nsPsy.lastAttacks[chn] != 0)\n                ns_attacks[0] = 0;\n\n            if (gfc.nsPsy.lastAttacks[chn] == 3\n                || (ns_attacks[0] + ns_attacks[1] + ns_attacks[2] + ns_attacks[3]) != 0) {\n                ns_uselongblock = 0;\n\n                if (ns_attacks[1] != 0 && ns_attacks[0] != 0)\n                    ns_attacks[1] = 0;\n                if (ns_attacks[2] != 0 && ns_attacks[1] != 0)\n                    ns_attacks[2] = 0;\n                if (ns_attacks[3] != 0 && ns_attacks[2] != 0)\n                    ns_attacks[3] = 0;\n            }\n\n            if (chn < 2) {\n                uselongblock[chn] = ns_uselongblock;\n            } else {\n                if (ns_uselongblock == 0) {\n                    uselongblock[0] = uselongblock[1] = 0;\n                }\n            }\n\n            /*\n             * there is a one granule delay. Copy maskings computed last call\n             * into masking_ratio to return to calling program.\n             */\n            energy[chn] = gfc.tot_ener[chn];\n\n            /*********************************************************************\n             * compute FFTs\n             *********************************************************************/\n            wsamp_s = wsamp_S;\n            wsamp_l = wsamp_L;\n            compute_ffts(gfp, fftenergy, fftenergy_s, wsamp_l, (chn & 1),\n                wsamp_s, (chn & 1), gr_out, chn, buffer, bufPos);\n\n            /*********************************************************************\n             * Calculate the energy and the tonality of each partition.\n             *********************************************************************/\n            calc_energy(gfc, fftenergy, eb_l, max, avg);\n            calc_mask_index_l(gfc, max, avg, mask_idx_l);\n            /* compute masking thresholds for short blocks */\n            for (sblock = 0; sblock < 3; sblock++) {\n                var enn, thmm;\n                compute_masking_s(gfp, fftenergy_s, eb_s, thr, chn, sblock);\n                convert_partition2scalefac_s(gfc, eb_s, thr, chn, sblock);\n                /**** short block pre-echo control ****/\n                for (sb = 0; sb < Encoder_1.SBMAX_s; sb++) {\n                    thmm = gfc.thm[chn].s[sb][sblock];\n\n                    thmm *= NS_PREECHO_ATT0;\n                    if (ns_attacks[sblock] >= 2 || ns_attacks[sblock + 1] == 1) {\n                        var idx = (sblock != 0) ? sblock - 1 : 2;\n                        var p = NS_INTERP(gfc.thm[chn].s[sb][idx], thmm,\n                            NS_PREECHO_ATT1 * pcfact);\n                        thmm = Math.min(thmm, p);\n                    }\n\n                    if (ns_attacks[sblock] == 1) {\n                        var idx = (sblock != 0) ? sblock - 1 : 2;\n                        var p = NS_INTERP(gfc.thm[chn].s[sb][idx], thmm,\n                            NS_PREECHO_ATT2 * pcfact);\n                        thmm = Math.min(thmm, p);\n                    } else if ((sblock != 0 && ns_attacks[sblock - 1] == 3)\n                        || (sblock == 0 && gfc.nsPsy.lastAttacks[chn] == 3)) {\n                        var idx = (sblock != 2) ? sblock + 1 : 0;\n                        var p = NS_INTERP(gfc.thm[chn].s[sb][idx], thmm,\n                            NS_PREECHO_ATT2 * pcfact);\n                        thmm = Math.min(thmm, p);\n                    }\n\n                    /* pulse like signal detection for fatboy.wav and so on */\n                    enn = en_subshort[sblock * 3 + 3]\n                        + en_subshort[sblock * 3 + 4]\n                        + en_subshort[sblock * 3 + 5];\n                    if (en_subshort[sblock * 3 + 5] * 6 < enn) {\n                        thmm *= 0.5;\n                        if (en_subshort[sblock * 3 + 4] * 6 < enn)\n                            thmm *= 0.5;\n                    }\n\n                    gfc.thm[chn].s[sb][sblock] = thmm;\n                }\n            }\n            gfc.nsPsy.lastAttacks[chn] = ns_attacks[2];\n\n            /*********************************************************************\n             * convolve the partitioned energy and unpredictability with the\n             * spreading function, s3_l[b][k]\n             ********************************************************************/\n            k = 0;\n            {\n                for (b = 0; b < gfc.npart_l; b++) {\n                    /*\n                     * convolve the partitioned energy with the spreading\n                     * function\n                     */\n                    var kk = gfc.s3ind[b][0];\n                    var eb2 = eb_l[kk] * tab[mask_idx_l[kk]];\n                    var ecb = gfc.s3_ll[k++] * eb2;\n                    while (++kk <= gfc.s3ind[b][1]) {\n                        eb2 = eb_l[kk] * tab[mask_idx_l[kk]];\n                        ecb = mask_add(ecb, gfc.s3_ll[k++] * eb2, kk, kk - b,\n                            gfc, 0);\n                    }\n                    ecb *= 0.158489319246111;\n                    /* pow(10,-0.8) */\n\n                    /**** long block pre-echo control ****/\n                    /**\n                     * <PRE>\n                     * dont use long block pre-echo control if previous granule was\n                     * a short block.  This is to avoid the situation:\n                     * frame0:  quiet (very low masking)\n                     * frame1:  surge  (triggers short blocks)\n                     * frame2:  regular frame.  looks like pre-echo when compared to\n                     *          frame0, but all pre-echo was in frame1.\n                     * </PRE>\n                     */\n                    /*\n                     * chn=0,1 L and R channels\n                     *\n                     * chn=2,3 S and M channels.\n                     */\n\n                    if (gfc.blocktype_old[chn & 1] == Encoder_1.SHORT_TYPE)\n                        thr[b] = ecb;\n                    else\n                        thr[b] = NS_INTERP(\n                            Math.min(ecb, Math.min(rpelev\n                                * gfc.nb_1[chn][b], rpelev2\n                                * gfc.nb_2[chn][b])), ecb, pcfact);\n\n                    gfc.nb_2[chn][b] = gfc.nb_1[chn][b];\n                    gfc.nb_1[chn][b] = ecb;\n                }\n            }\n            for (; b <= Encoder_1.CBANDS; ++b) {\n                eb_l[b] = 0;\n                thr[b] = 0;\n            }\n            /* compute masking thresholds for long blocks */\n            convert_partition2scalefac_l(gfc, eb_l, thr, chn);\n        }\n        /* end loop over chn */\n\n        if (gfp.mode == MPEGMode.STEREO || gfp.mode == MPEGMode.JOINT_STEREO) {\n            if (gfp.interChRatio > 0.0) {\n                calc_interchannel_masking(gfp, gfp.interChRatio);\n            }\n        }\n\n        if (gfp.mode == MPEGMode.JOINT_STEREO) {\n            var msfix;\n            msfix1(gfc);\n            msfix = gfp.msfix;\n            if (Math.abs(msfix) > 0.0)\n                ns_msfix(gfc, msfix, gfp.ATHlower * gfc.ATH.adjust);\n        }\n\n        /***************************************************************\n         * determine final block type\n         ***************************************************************/\n        block_type_set(gfp, uselongblock, blocktype_d, blocktype);\n\n        /*********************************************************************\n         * compute the value of PE to return ... no delay and advance\n         *********************************************************************/\n        for (chn = 0; chn < numchn; chn++) {\n            var ppe;\n            var ppePos = 0;\n            var type;\n            var mr;\n\n            if (chn > 1) {\n                ppe = percep_MS_entropy;\n                ppePos = -2;\n                type = Encoder_1.NORM_TYPE;\n                if (blocktype_d[0] == Encoder_1.SHORT_TYPE\n                    || blocktype_d[1] == Encoder_1.SHORT_TYPE)\n                    type = Encoder_1.SHORT_TYPE;\n                mr = masking_MS_ratio[gr_out][chn - 2];\n            } else {\n                ppe = percep_entropy;\n                ppePos = 0;\n                type = blocktype_d[chn];\n                mr = masking_ratio[gr_out][chn];\n            }\n\n            if (type == Encoder_1.SHORT_TYPE)\n                ppe[ppePos + chn] = pecalc_s(mr, gfc.masking_lower);\n            else\n                ppe[ppePos + chn] = pecalc_l(mr, gfc.masking_lower);\n\n            if (gfp.analysis)\n                gfc.pinfo.pe[gr_out][chn] = ppe[ppePos + chn];\n\n        }\n        return 0;\n    };\n\n    function vbrpsy_compute_fft_l(gfp, buffer, bufPos, chn, gr_out, fftenergy, wsamp_l, wsamp_lPos) {\n        var gfc = gfp.internal_flags;\n        if (chn < 2) {\n            fft.fft_long(gfc, wsamp_l[wsamp_lPos], chn, buffer, bufPos);\n        } else if (chn == 2) {\n            /* FFT data for mid and side channel is derived from L & R */\n            for (var j = Encoder_1.BLKSIZE - 1; j >= 0; --j) {\n                var l = wsamp_l[wsamp_lPos + 0][j];\n                var r = wsamp_l[wsamp_lPos + 1][j];\n                wsamp_l[wsamp_lPos + 0][j] = (l + r) * Util$3.SQRT2 * 0.5;\n                wsamp_l[wsamp_lPos + 1][j] = (l - r) * Util$3.SQRT2 * 0.5;\n            }\n        }\n\n        /*********************************************************************\n         * compute energies\n         *********************************************************************/\n        fftenergy[0] = NON_LINEAR_SCALE_ENERGY(wsamp_l[wsamp_lPos + 0][0]);\n        fftenergy[0] *= fftenergy[0];\n\n        for (var j = Encoder_1.BLKSIZE / 2 - 1; j >= 0; --j) {\n            var re = wsamp_l[wsamp_lPos + 0][Encoder_1.BLKSIZE / 2 - j];\n            var im = wsamp_l[wsamp_lPos + 0][Encoder_1.BLKSIZE / 2 + j];\n            fftenergy[Encoder_1.BLKSIZE / 2 - j] = NON_LINEAR_SCALE_ENERGY((re\n                * re + im * im) * 0.5);\n        }\n        /* total energy */\n        {\n            var totalenergy = 0.0;\n            for (var j = 11; j < Encoder_1.HBLKSIZE; j++)\n                totalenergy += fftenergy[j];\n\n            gfc.tot_ener[chn] = totalenergy;\n        }\n\n        if (gfp.analysis) {\n            for (var j = 0; j < Encoder_1.HBLKSIZE; j++) {\n                gfc.pinfo.energy[gr_out][chn][j] = gfc.pinfo.energy_save[chn][j];\n                gfc.pinfo.energy_save[chn][j] = fftenergy[j];\n            }\n            gfc.pinfo.pe[gr_out][chn] = gfc.pe[chn];\n        }\n    }\n\n    function vbrpsy_compute_fft_s(gfp, buffer, bufPos, chn, sblock, fftenergy_s, wsamp_s, wsamp_sPos) {\n        var gfc = gfp.internal_flags;\n\n        if (sblock == 0 && chn < 2) {\n            fft.fft_short(gfc, wsamp_s[wsamp_sPos], chn, buffer, bufPos);\n        }\n        if (chn == 2) {\n            /* FFT data for mid and side channel is derived from L & R */\n            for (var j = Encoder_1.BLKSIZE_s - 1; j >= 0; --j) {\n                var l = wsamp_s[wsamp_sPos + 0][sblock][j];\n                var r = wsamp_s[wsamp_sPos + 1][sblock][j];\n                wsamp_s[wsamp_sPos + 0][sblock][j] = (l + r) * Util$3.SQRT2 * 0.5;\n                wsamp_s[wsamp_sPos + 1][sblock][j] = (l - r) * Util$3.SQRT2 * 0.5;\n            }\n        }\n\n        /*********************************************************************\n         * compute energies\n         *********************************************************************/\n        fftenergy_s[sblock][0] = wsamp_s[wsamp_sPos + 0][sblock][0];\n        fftenergy_s[sblock][0] *= fftenergy_s[sblock][0];\n        for (var j = Encoder_1.BLKSIZE_s / 2 - 1; j >= 0; --j) {\n            var re = wsamp_s[wsamp_sPos + 0][sblock][Encoder_1.BLKSIZE_s / 2 - j];\n            var im = wsamp_s[wsamp_sPos + 0][sblock][Encoder_1.BLKSIZE_s / 2 + j];\n            fftenergy_s[sblock][Encoder_1.BLKSIZE_s / 2 - j] = NON_LINEAR_SCALE_ENERGY((re\n                * re + im * im) * 0.5);\n        }\n    }\n\n    /**\n     * compute loudness approximation (used for ATH auto-level adjustment)\n     */\n    function vbrpsy_compute_loudness_approximation_l(gfp, gr_out, chn, fftenergy) {\n        var gfc = gfp.internal_flags;\n        if (gfp.athaa_loudapprox == 2 && chn < 2) {\n            // no loudness for mid/side ch\n            gfc.loudness_sq[gr_out][chn] = gfc.loudness_sq_save[chn];\n            gfc.loudness_sq_save[chn] = psycho_loudness_approx(fftenergy, gfc);\n        }\n    }\n\n    var fircoef_ = [-8.65163e-18 * 2,\n        -0.00851586 * 2, -6.74764e-18 * 2, 0.0209036 * 2,\n        -3.36639e-17 * 2, -0.0438162 * 2, -1.54175e-17 * 2,\n        0.0931738 * 2, -5.52212e-17 * 2, -0.313819 * 2];\n\n    /**\n     * Apply HPF of fs/4 to the input signal. This is used for attack detection\n     * / handling.\n     */\n    function vbrpsy_attack_detection(gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, energy, sub_short_factor, ns_attacks, uselongblock) {\n        var ns_hpfsmpl = new_float_n$3([2, 576]);\n        var gfc = gfp.internal_flags;\n        var n_chn_out = gfc.channels_out;\n        /* chn=2 and 3 = Mid and Side channels */\n        var n_chn_psy = (gfp.mode == MPEGMode.JOINT_STEREO) ? 4 : n_chn_out;\n        /* Don't copy the input buffer into a temporary buffer */\n        /* unroll the loop 2 times */\n        for (var chn = 0; chn < n_chn_out; chn++) {\n            /* apply high pass filter of fs/4 */\n            firbuf = buffer[chn];\n            var firbufPos = bufPos + 576 - 350 - NSFIRLEN + 192;\n            assert$3(fircoef_.length == ((NSFIRLEN - 1) / 2));\n            for (var i = 0; i < 576; i++) {\n                var sum1, sum2;\n                sum1 = firbuf[firbufPos + i + 10];\n                sum2 = 0.0;\n                for (var j = 0; j < ((NSFIRLEN - 1) / 2) - 1; j += 2) {\n                    sum1 += fircoef_[j]\n                        * (firbuf[firbufPos + i + j] + firbuf[firbufPos + i\n                        + NSFIRLEN - j]);\n                    sum2 += fircoef_[j + 1]\n                        * (firbuf[firbufPos + i + j + 1] + firbuf[firbufPos\n                        + i + NSFIRLEN - j - 1]);\n                }\n                ns_hpfsmpl[chn][i] = sum1 + sum2;\n            }\n            masking_ratio[gr_out][chn].en.assign(gfc.en[chn]);\n            masking_ratio[gr_out][chn].thm.assign(gfc.thm[chn]);\n            if (n_chn_psy > 2) {\n                /* MS maskings */\n                /* percep_MS_entropy [chn-2] = gfc . pe [chn]; */\n                masking_MS_ratio[gr_out][chn].en.assign(gfc.en[chn + 2]);\n                masking_MS_ratio[gr_out][chn].thm.assign(gfc.thm[chn + 2]);\n            }\n        }\n        for (var chn = 0; chn < n_chn_psy; chn++) {\n            var attack_intensity = new_float$3(12);\n            var en_subshort = new_float$3(12);\n            var en_short = [0, 0, 0, 0];\n            var pf = ns_hpfsmpl[chn & 1];\n            var pfPos = 0;\n            var attackThreshold = (chn == 3) ? gfc.nsPsy.attackthre_s\n                : gfc.nsPsy.attackthre;\n            var ns_uselongblock = 1;\n\n            if (chn == 2) {\n                for (var i = 0, j = 576; j > 0; ++i, --j) {\n                    var l = ns_hpfsmpl[0][i];\n                    var r = ns_hpfsmpl[1][i];\n                    ns_hpfsmpl[0][i] = l + r;\n                    ns_hpfsmpl[1][i] = l - r;\n                }\n            }\n            /***************************************************************\n             * determine the block type (window type)\n             ***************************************************************/\n            /* calculate energies of each sub-shortblocks */\n            for (var i = 0; i < 3; i++) {\n                en_subshort[i] = gfc.nsPsy.last_en_subshort[chn][i + 6];\n                assert$3(gfc.nsPsy.last_en_subshort[chn][i + 4] > 0);\n                attack_intensity[i] = en_subshort[i]\n                    / gfc.nsPsy.last_en_subshort[chn][i + 4];\n                en_short[0] += en_subshort[i];\n            }\n\n            for (var i = 0; i < 9; i++) {\n                var pfe = pfPos + 576 / 9;\n                var p = 1.;\n                for (; pfPos < pfe; pfPos++)\n                    if (p < Math.abs(pf[pfPos]))\n                        p = Math.abs(pf[pfPos]);\n\n                gfc.nsPsy.last_en_subshort[chn][i] = en_subshort[i + 3] = p;\n                en_short[1 + i / 3] += p;\n                if (p > en_subshort[i + 3 - 2]) {\n                    assert$3(en_subshort[i + 3 - 2] > 0);\n                    p = p / en_subshort[i + 3 - 2];\n                } else if (en_subshort[i + 3 - 2] > p * 10.0) {\n                    assert$3(p > 0);\n                    p = en_subshort[i + 3 - 2] / (p * 10.0);\n                } else {\n                    p = 0.0;\n                }\n                attack_intensity[i + 3] = p;\n            }\n            /* pulse like signal detection for fatboy.wav and so on */\n            for (var i = 0; i < 3; ++i) {\n                var enn = en_subshort[i * 3 + 3]\n                    + en_subshort[i * 3 + 4] + en_subshort[i * 3 + 5];\n                var factor = 1.;\n                if (en_subshort[i * 3 + 5] * 6 < enn) {\n                    factor *= 0.5;\n                    if (en_subshort[i * 3 + 4] * 6 < enn) {\n                        factor *= 0.5;\n                    }\n                }\n                sub_short_factor[chn][i] = factor;\n            }\n\n            if (gfp.analysis) {\n                var x = attack_intensity[0];\n                for (var i = 1; i < 12; i++) {\n                    if (x < attack_intensity[i]) {\n                        x = attack_intensity[i];\n                    }\n                }\n                gfc.pinfo.ers[gr_out][chn] = gfc.pinfo.ers_save[chn];\n                gfc.pinfo.ers_save[chn] = x;\n            }\n\n            /* compare energies between sub-shortblocks */\n            for (var i = 0; i < 12; i++) {\n                if (0 == ns_attacks[chn][i / 3]\n                    && attack_intensity[i] > attackThreshold) {\n                    ns_attacks[chn][i / 3] = (i % 3) + 1;\n                }\n            }\n\n            /*\n             * should have energy change between short blocks, in order to avoid\n             * periodic signals\n             */\n            /* Good samples to show the effect are Trumpet test songs */\n            /*\n             * GB: tuned (1) to avoid too many short blocks for test sample\n             * TRUMPET\n             */\n            /*\n             * RH: tuned (2) to let enough short blocks through for test sample\n             * FSOL and SNAPS\n             */\n            for (var i = 1; i < 4; i++) {\n                var u = en_short[i - 1];\n                var v = en_short[i];\n                var m = Math.max(u, v);\n                if (m < 40000) { /* (2) */\n                    if (u < 1.7 * v && v < 1.7 * u) { /* (1) */\n                        if (i == 1 && ns_attacks[chn][0] <= ns_attacks[chn][i]) {\n                            ns_attacks[chn][0] = 0;\n                        }\n                        ns_attacks[chn][i] = 0;\n                    }\n                }\n            }\n\n            if (ns_attacks[chn][0] <= gfc.nsPsy.lastAttacks[chn]) {\n                ns_attacks[chn][0] = 0;\n            }\n\n            if (gfc.nsPsy.lastAttacks[chn] == 3\n                || (ns_attacks[chn][0] + ns_attacks[chn][1]\n                + ns_attacks[chn][2] + ns_attacks[chn][3]) != 0) {\n                ns_uselongblock = 0;\n\n                if (ns_attacks[chn][1] != 0 && ns_attacks[chn][0] != 0) {\n                    ns_attacks[chn][1] = 0;\n                }\n                if (ns_attacks[chn][2] != 0 && ns_attacks[chn][1] != 0) {\n                    ns_attacks[chn][2] = 0;\n                }\n                if (ns_attacks[chn][3] != 0 && ns_attacks[chn][2] != 0) {\n                    ns_attacks[chn][3] = 0;\n                }\n            }\n            if (chn < 2) {\n                uselongblock[chn] = ns_uselongblock;\n            } else {\n                if (ns_uselongblock == 0) {\n                    uselongblock[0] = uselongblock[1] = 0;\n                }\n            }\n\n            /*\n             * there is a one granule delay. Copy maskings computed last call\n             * into masking_ratio to return to calling program.\n             */\n            energy[chn] = gfc.tot_ener[chn];\n        }\n    }\n\n    function vbrpsy_skip_masking_s(gfc, chn, sblock) {\n        if (sblock == 0) {\n            for (var b = 0; b < gfc.npart_s; b++) {\n                gfc.nb_s2[chn][b] = gfc.nb_s1[chn][b];\n                gfc.nb_s1[chn][b] = 0;\n            }\n        }\n    }\n\n    function vbrpsy_skip_masking_l(gfc, chn) {\n        for (var b = 0; b < gfc.npart_l; b++) {\n            gfc.nb_2[chn][b] = gfc.nb_1[chn][b];\n            gfc.nb_1[chn][b] = 0;\n        }\n    }\n\n    function psyvbr_calc_mask_index_s(gfc, max, avg, mask_idx) {\n        var last_tab_entry = tab.length - 1;\n        var b = 0;\n        var a = avg[b] + avg[b + 1];\n        assert$3(a >= 0);\n        if (a > 0.0) {\n            var m = max[b];\n            if (m < max[b + 1])\n                m = max[b + 1];\n            assert$3((gfc.numlines_s[b] + gfc.numlines_s[b + 1] - 1) > 0);\n            a = 20.0 * (m * 2.0 - a)\n                / (a * (gfc.numlines_s[b] + gfc.numlines_s[b + 1] - 1));\n            var k = 0 | a;\n            if (k > last_tab_entry)\n                k = last_tab_entry;\n            mask_idx[b] = k;\n        } else {\n            mask_idx[b] = 0;\n        }\n\n        for (b = 1; b < gfc.npart_s - 1; b++) {\n            a = avg[b - 1] + avg[b] + avg[b + 1];\n            assert$3(b + 1 < gfc.npart_s);\n            assert$3(a >= 0);\n            if (a > 0.0) {\n                var m = max[b - 1];\n                if (m < max[b])\n                    m = max[b];\n                if (m < max[b + 1])\n                    m = max[b + 1];\n                assert$3((gfc.numlines_s[b - 1] + gfc.numlines_s[b] + gfc.numlines_s[b + 1] - 1) > 0);\n                a = 20.0\n                    * (m * 3.0 - a)\n                    / (a * (gfc.numlines_s[b - 1] + gfc.numlines_s[b]\n                    + gfc.numlines_s[b + 1] - 1));\n                var k = 0 | a;\n                if (k > last_tab_entry)\n                    k = last_tab_entry;\n                mask_idx[b] = k;\n            } else {\n                mask_idx[b] = 0;\n            }\n        }\n        assert$3(b > 0);\n        assert$3(b == gfc.npart_s - 1);\n\n        a = avg[b - 1] + avg[b];\n        assert$3(a >= 0);\n        if (a > 0.0) {\n            var m = max[b - 1];\n            if (m < max[b])\n                m = max[b];\n            assert$3((gfc.numlines_s[b - 1] + gfc.numlines_s[b] - 1) > 0);\n            a = 20.0 * (m * 2.0 - a)\n                / (a * (gfc.numlines_s[b - 1] + gfc.numlines_s[b] - 1));\n            var k = 0 | a;\n            if (k > last_tab_entry)\n                k = last_tab_entry;\n            mask_idx[b] = k;\n        } else {\n            mask_idx[b] = 0;\n        }\n        assert$3(b == (gfc.npart_s - 1));\n    }\n\n    function vbrpsy_compute_masking_s(gfp, fftenergy_s, eb, thr, chn, sblock) {\n        var gfc = gfp.internal_flags;\n        var max = new float[Encoder_1.CBANDS], avg = new_float$3(Encoder_1.CBANDS);\n        var i, j, b;\n        var mask_idx_s = new int[Encoder_1.CBANDS];\n\n        for (b = j = 0; b < gfc.npart_s; ++b) {\n            var ebb = 0, m = 0;\n            var n = gfc.numlines_s[b];\n            for (i = 0; i < n; ++i, ++j) {\n                var el = fftenergy_s[sblock][j];\n                ebb += el;\n                if (m < el)\n                    m = el;\n            }\n            eb[b] = ebb;\n            assert$3(ebb >= 0);\n            max[b] = m;\n            assert$3(n > 0);\n            avg[b] = ebb / n;\n            assert$3(avg[b] >= 0);\n        }\n        assert$3(b == gfc.npart_s);\n        assert$3(j == 129);\n        for (; b < Encoder_1.CBANDS; ++b) {\n            max[b] = 0;\n            avg[b] = 0;\n        }\n        psyvbr_calc_mask_index_s(gfc, max, avg, mask_idx_s);\n        for (j = b = 0; b < gfc.npart_s; b++) {\n            var kk = gfc.s3ind_s[b][0];\n            var last = gfc.s3ind_s[b][1];\n            var dd, dd_n;\n            var x, ecb, avg_mask;\n            dd = mask_idx_s[kk];\n            dd_n = 1;\n            ecb = gfc.s3_ss[j] * eb[kk] * tab[mask_idx_s[kk]];\n            ++j;\n            ++kk;\n            while (kk <= last) {\n                dd += mask_idx_s[kk];\n                dd_n += 1;\n                x = gfc.s3_ss[j] * eb[kk] * tab[mask_idx_s[kk]];\n                ecb = vbrpsy_mask_add(ecb, x, kk - b);\n                ++j;\n                ++kk;\n            }\n            dd = (1 + 2 * dd) / (2 * dd_n);\n            avg_mask = tab[dd] * 0.5;\n            ecb *= avg_mask;\n            thr[b] = ecb;\n            gfc.nb_s2[chn][b] = gfc.nb_s1[chn][b];\n            gfc.nb_s1[chn][b] = ecb;\n            {\n                /*\n                 * if THR exceeds EB, the quantization routines will take the\n                 * difference from other bands. in case of strong tonal samples\n                 * (tonaltest.wav) this leads to heavy distortions. that's why\n                 * we limit THR here.\n                 */\n                x = max[b];\n                x *= gfc.minval_s[b];\n                x *= avg_mask;\n                if (thr[b] > x) {\n                    thr[b] = x;\n                }\n            }\n            if (gfc.masking_lower > 1) {\n                thr[b] *= gfc.masking_lower;\n            }\n            if (thr[b] > eb[b]) {\n                thr[b] = eb[b];\n            }\n            if (gfc.masking_lower < 1) {\n                thr[b] *= gfc.masking_lower;\n            }\n\n            assert$3(thr[b] >= 0);\n        }\n        for (; b < Encoder_1.CBANDS; ++b) {\n            eb[b] = 0;\n            thr[b] = 0;\n        }\n    }\n\n    function vbrpsy_compute_masking_l(gfc, fftenergy, eb_l, thr, chn) {\n        var max = new_float$3(Encoder_1.CBANDS), avg = new_float$3(Encoder_1.CBANDS);\n        var mask_idx_l = new_int$3(Encoder_1.CBANDS + 2);\n        var b;\n\n        /*********************************************************************\n         * Calculate the energy and the tonality of each partition.\n         *********************************************************************/\n        calc_energy(gfc, fftenergy, eb_l, max, avg);\n        calc_mask_index_l(gfc, max, avg, mask_idx_l);\n\n        /*********************************************************************\n         * convolve the partitioned energy and unpredictability with the\n         * spreading function, s3_l[b][k]\n         ********************************************************************/\n        var k = 0;\n        for (b = 0; b < gfc.npart_l; b++) {\n            var x, ecb, avg_mask, t;\n            /* convolve the partitioned energy with the spreading function */\n            var kk = gfc.s3ind[b][0];\n            var last = gfc.s3ind[b][1];\n            var dd = 0, dd_n = 0;\n            dd = mask_idx_l[kk];\n            dd_n += 1;\n            ecb = gfc.s3_ll[k] * eb_l[kk] * tab[mask_idx_l[kk]];\n            ++k;\n            ++kk;\n            while (kk <= last) {\n                dd += mask_idx_l[kk];\n                dd_n += 1;\n                x = gfc.s3_ll[k] * eb_l[kk] * tab[mask_idx_l[kk]];\n                t = vbrpsy_mask_add(ecb, x, kk - b);\n                ecb = t;\n                ++k;\n                ++kk;\n            }\n            dd = (1 + 2 * dd) / (2 * dd_n);\n            avg_mask = tab[dd] * 0.5;\n            ecb *= avg_mask;\n\n            /**** long block pre-echo control ****/\n            /**\n             * <PRE>\n             * dont use long block pre-echo control if previous granule was\n             * a short block.  This is to avoid the situation:\n             * frame0:  quiet (very low masking)\n             * frame1:  surge  (triggers short blocks)\n             * frame2:  regular frame.  looks like pre-echo when compared to\n             *          frame0, but all pre-echo was in frame1.\n             * </PRE>\n             */\n            /*\n             * chn=0,1 L and R channels chn=2,3 S and M channels.\n             */\n            if (gfc.blocktype_old[chn & 0x01] == Encoder_1.SHORT_TYPE) {\n                var ecb_limit = rpelev * gfc.nb_1[chn][b];\n                if (ecb_limit > 0) {\n                    thr[b] = Math.min(ecb, ecb_limit);\n                } else {\n                    /**\n                     * <PRE>\n                     * Robert 071209:\n                     * Because we don't calculate long block psy when we know a granule\n                     * should be of short blocks, we don't have any clue how the granule\n                     * before would have looked like as a long block. So we have to guess\n                     * a little bit for this END_TYPE block.\n                     * Most of the time we get away with this sloppyness. (fingers crossed :)\n                     * The speed increase is worth it.\n                     * </PRE>\n                     */\n                    thr[b] = Math.min(ecb, eb_l[b] * NS_PREECHO_ATT2);\n                }\n            } else {\n                var ecb_limit_2 = rpelev2 * gfc.nb_2[chn][b];\n                var ecb_limit_1 = rpelev * gfc.nb_1[chn][b];\n                var ecb_limit;\n                if (ecb_limit_2 <= 0) {\n                    ecb_limit_2 = ecb;\n                }\n                if (ecb_limit_1 <= 0) {\n                    ecb_limit_1 = ecb;\n                }\n                if (gfc.blocktype_old[chn & 0x01] == Encoder_1.NORM_TYPE) {\n                    ecb_limit = Math.min(ecb_limit_1, ecb_limit_2);\n                } else {\n                    ecb_limit = ecb_limit_1;\n                }\n                thr[b] = Math.min(ecb, ecb_limit);\n            }\n            gfc.nb_2[chn][b] = gfc.nb_1[chn][b];\n            gfc.nb_1[chn][b] = ecb;\n            {\n                /*\n                 * if THR exceeds EB, the quantization routines will take the\n                 * difference from other bands. in case of strong tonal samples\n                 * (tonaltest.wav) this leads to heavy distortions. that's why\n                 * we limit THR here.\n                 */\n                x = max[b];\n                x *= gfc.minval_l[b];\n                x *= avg_mask;\n                if (thr[b] > x) {\n                    thr[b] = x;\n                }\n            }\n            if (gfc.masking_lower > 1) {\n                thr[b] *= gfc.masking_lower;\n            }\n            if (thr[b] > eb_l[b]) {\n                thr[b] = eb_l[b];\n            }\n            if (gfc.masking_lower < 1) {\n                thr[b] *= gfc.masking_lower;\n            }\n            assert$3(thr[b] >= 0);\n        }\n        for (; b < Encoder_1.CBANDS; ++b) {\n            eb_l[b] = 0;\n            thr[b] = 0;\n        }\n    }\n\n    function vbrpsy_compute_block_type(gfp, uselongblock) {\n        var gfc = gfp.internal_flags;\n\n        if (gfp.short_blocks == ShortBlock$3.short_block_coupled\n                /* force both channels to use the same block type */\n                /* this is necessary if the frame is to be encoded in ms_stereo. */\n                /* But even without ms_stereo, FhG does this */\n            && !(uselongblock[0] != 0 && uselongblock[1] != 0))\n            uselongblock[0] = uselongblock[1] = 0;\n\n        for (var chn = 0; chn < gfc.channels_out; chn++) {\n            /* disable short blocks */\n            if (gfp.short_blocks == ShortBlock$3.short_block_dispensed) {\n                uselongblock[chn] = 1;\n            }\n            if (gfp.short_blocks == ShortBlock$3.short_block_forced) {\n                uselongblock[chn] = 0;\n            }\n        }\n    }\n\n    function vbrpsy_apply_block_type(gfp, uselongblock, blocktype_d) {\n        var gfc = gfp.internal_flags;\n\n        /*\n         * update the blocktype of the previous granule, since it depends on\n         * what happend in this granule\n         */\n        for (var chn = 0; chn < gfc.channels_out; chn++) {\n            var blocktype = Encoder_1.NORM_TYPE;\n            /* disable short blocks */\n\n            if (uselongblock[chn] != 0) {\n                /* no attack : use long blocks */\n                assert$3(gfc.blocktype_old[chn] != Encoder_1.START_TYPE);\n                if (gfc.blocktype_old[chn] == Encoder_1.SHORT_TYPE)\n                    blocktype = Encoder_1.STOP_TYPE;\n            } else {\n                /* attack : use short blocks */\n                blocktype = Encoder_1.SHORT_TYPE;\n                if (gfc.blocktype_old[chn] == Encoder_1.NORM_TYPE) {\n                    gfc.blocktype_old[chn] = Encoder_1.START_TYPE;\n                }\n                if (gfc.blocktype_old[chn] == Encoder_1.STOP_TYPE)\n                    gfc.blocktype_old[chn] = Encoder_1.SHORT_TYPE;\n            }\n\n            blocktype_d[chn] = gfc.blocktype_old[chn];\n            // value returned to calling program\n            gfc.blocktype_old[chn] = blocktype;\n            // save for next call to l3psy_anal\n        }\n    }\n\n    /**\n     * compute M/S thresholds from Johnston & Ferreira 1992 ICASSP paper\n     */\n    function vbrpsy_compute_MS_thresholds(eb, thr, cb_mld, ath_cb, athadjust, msfix, n) {\n        var msfix2 = msfix * 2;\n        var athlower = msfix > 0 ? Math.pow(10, athadjust) : 1;\n        var rside, rmid;\n        for (var b = 0; b < n; ++b) {\n            var ebM = eb[2][b];\n            var ebS = eb[3][b];\n            var thmL = thr[0][b];\n            var thmR = thr[1][b];\n            var thmM = thr[2][b];\n            var thmS = thr[3][b];\n\n            /* use this fix if L & R masking differs by 2db or less */\n            if (thmL <= 1.58 * thmR && thmR <= 1.58 * thmL) {\n                var mld_m = cb_mld[b] * ebS;\n                var mld_s = cb_mld[b] * ebM;\n                rmid = Math.max(thmM, Math.min(thmS, mld_m));\n                rside = Math.max(thmS, Math.min(thmM, mld_s));\n            } else {\n                rmid = thmM;\n                rside = thmS;\n            }\n            if (msfix > 0) {\n                /***************************************************************/\n                /* Adjust M/S maskings if user set \"msfix\" */\n                /***************************************************************/\n                /* Naoki Shibata 2000 */\n                var thmLR, thmMS;\n                var ath = ath_cb[b] * athlower;\n                thmLR = Math.min(Math.max(thmL, ath), Math.max(thmR, ath));\n                thmM = Math.max(rmid, ath);\n                thmS = Math.max(rside, ath);\n                thmMS = thmM + thmS;\n                if (thmMS > 0 && (thmLR * msfix2) < thmMS) {\n                    var f = thmLR * msfix2 / thmMS;\n                    thmM *= f;\n                    thmS *= f;\n                    assert$3(thmMS > 0);\n                }\n                rmid = Math.min(thmM, rmid);\n                rside = Math.min(thmS, rside);\n            }\n            if (rmid > ebM) {\n                rmid = ebM;\n            }\n            if (rside > ebS) {\n                rside = ebS;\n            }\n            thr[2][b] = rmid;\n            thr[3][b] = rside;\n        }\n    }\n\n    this.L3psycho_anal_vbr = function (gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, percep_entropy, percep_MS_entropy, energy, blocktype_d) {\n        var gfc = gfp.internal_flags;\n\n        /* fft and energy calculation */\n        var wsamp_l;\n        var wsamp_s;\n        var fftenergy = new_float$3(Encoder_1.HBLKSIZE);\n        var fftenergy_s = new_float_n$3([3, Encoder_1.HBLKSIZE_s]);\n        var wsamp_L = new_float_n$3([2, Encoder_1.BLKSIZE]);\n        var wsamp_S = new_float_n$3([2, 3, Encoder_1.BLKSIZE_s]);\n        var eb = new_float_n$3([4, Encoder_1.CBANDS]), thr = new_float_n$3([4, Encoder_1.CBANDS]);\n        var sub_short_factor = new_float_n$3([4, 3]);\n        var pcfact = 0.6;\n\n        /* block type */\n        var ns_attacks = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],\n            [0, 0, 0, 0]];\n        var uselongblock = new_int$3(2);\n\n        /* usual variables like loop indices, etc.. */\n\n        /* chn=2 and 3 = Mid and Side channels */\n        var n_chn_psy = (gfp.mode == MPEGMode.JOINT_STEREO) ? 4\n            : gfc.channels_out;\n\n        vbrpsy_attack_detection(gfp, buffer, bufPos, gr_out, masking_ratio,\n            masking_MS_ratio, energy, sub_short_factor, ns_attacks,\n            uselongblock);\n\n        vbrpsy_compute_block_type(gfp, uselongblock);\n\n        /* LONG BLOCK CASE */\n        {\n            for (var chn = 0; chn < n_chn_psy; chn++) {\n                var ch01 = chn & 0x01;\n                wsamp_l = wsamp_L;\n                vbrpsy_compute_fft_l(gfp, buffer, bufPos, chn, gr_out,\n                    fftenergy, wsamp_l, ch01);\n\n                vbrpsy_compute_loudness_approximation_l(gfp, gr_out, chn,\n                    fftenergy);\n\n                if (uselongblock[ch01] != 0) {\n                    vbrpsy_compute_masking_l(gfc, fftenergy, eb[chn], thr[chn],\n                        chn);\n                } else {\n                    vbrpsy_skip_masking_l(gfc, chn);\n                }\n            }\n            if ((uselongblock[0] + uselongblock[1]) == 2) {\n                /* M/S channel */\n                if (gfp.mode == MPEGMode.JOINT_STEREO) {\n                    vbrpsy_compute_MS_thresholds(eb, thr, gfc.mld_cb_l,\n                        gfc.ATH.cb_l, gfp.ATHlower * gfc.ATH.adjust,\n                        gfp.msfix, gfc.npart_l);\n                }\n            }\n            /* TODO: apply adaptive ATH masking here ?? */\n            for (var chn = 0; chn < n_chn_psy; chn++) {\n                var ch01 = chn & 0x01;\n                if (uselongblock[ch01] != 0) {\n                    convert_partition2scalefac_l(gfc, eb[chn], thr[chn], chn);\n                }\n            }\n        }\n\n        /* SHORT BLOCKS CASE */\n        {\n            for (var sblock = 0; sblock < 3; sblock++) {\n                for (var chn = 0; chn < n_chn_psy; ++chn) {\n                    var ch01 = chn & 0x01;\n\n                    if (uselongblock[ch01] != 0) {\n                        vbrpsy_skip_masking_s(gfc, chn, sblock);\n                    } else {\n                        /* compute masking thresholds for short blocks */\n                        wsamp_s = wsamp_S;\n                        vbrpsy_compute_fft_s(gfp, buffer, bufPos, chn, sblock,\n                            fftenergy_s, wsamp_s, ch01);\n                        vbrpsy_compute_masking_s(gfp, fftenergy_s, eb[chn],\n                            thr[chn], chn, sblock);\n                    }\n                }\n                if ((uselongblock[0] + uselongblock[1]) == 0) {\n                    /* M/S channel */\n                    if (gfp.mode == MPEGMode.JOINT_STEREO) {\n                        vbrpsy_compute_MS_thresholds(eb, thr, gfc.mld_cb_s,\n                            gfc.ATH.cb_s, gfp.ATHlower * gfc.ATH.adjust,\n                            gfp.msfix, gfc.npart_s);\n                    }\n                    /* L/R channel */\n                }\n                /* TODO: apply adaptive ATH masking here ?? */\n                for (var chn = 0; chn < n_chn_psy; ++chn) {\n                    var ch01 = chn & 0x01;\n                    if (0 == uselongblock[ch01]) {\n                        convert_partition2scalefac_s(gfc, eb[chn], thr[chn],\n                            chn, sblock);\n                    }\n                }\n            }\n\n            /**** short block pre-echo control ****/\n            for (var chn = 0; chn < n_chn_psy; chn++) {\n                var ch01 = chn & 0x01;\n\n                if (uselongblock[ch01] != 0) {\n                    continue;\n                }\n                for (var sb = 0; sb < Encoder_1.SBMAX_s; sb++) {\n                    var new_thmm = new_float$3(3);\n                    for (var sblock = 0; sblock < 3; sblock++) {\n                        var thmm = gfc.thm[chn].s[sb][sblock];\n                        thmm *= NS_PREECHO_ATT0;\n\n                        if (ns_attacks[chn][sblock] >= 2\n                            || ns_attacks[chn][sblock + 1] == 1) {\n                            var idx = (sblock != 0) ? sblock - 1 : 2;\n                            var p = NS_INTERP(gfc.thm[chn].s[sb][idx], thmm,\n                                NS_PREECHO_ATT1 * pcfact);\n                            thmm = Math.min(thmm, p);\n                        } else if (ns_attacks[chn][sblock] == 1) {\n                            var idx = (sblock != 0) ? sblock - 1 : 2;\n                            var p = NS_INTERP(gfc.thm[chn].s[sb][idx], thmm,\n                                NS_PREECHO_ATT2 * pcfact);\n                            thmm = Math.min(thmm, p);\n                        } else if ((sblock != 0 && ns_attacks[chn][sblock - 1] == 3)\n                            || (sblock == 0 && gfc.nsPsy.lastAttacks[chn] == 3)) {\n                            var idx = (sblock != 2) ? sblock + 1 : 0;\n                            var p = NS_INTERP(gfc.thm[chn].s[sb][idx], thmm,\n                                NS_PREECHO_ATT2 * pcfact);\n                            thmm = Math.min(thmm, p);\n                        }\n\n                        /* pulse like signal detection for fatboy.wav and so on */\n                        thmm *= sub_short_factor[chn][sblock];\n\n                        new_thmm[sblock] = thmm;\n                    }\n                    for (var sblock = 0; sblock < 3; sblock++) {\n                        gfc.thm[chn].s[sb][sblock] = new_thmm[sblock];\n                    }\n                }\n            }\n        }\n        for (var chn = 0; chn < n_chn_psy; chn++) {\n            gfc.nsPsy.lastAttacks[chn] = ns_attacks[chn][2];\n        }\n\n        /***************************************************************\n         * determine final block type\n         ***************************************************************/\n        vbrpsy_apply_block_type(gfp, uselongblock, blocktype_d);\n\n        /*********************************************************************\n         * compute the value of PE to return ... no delay and advance\n         *********************************************************************/\n        for (var chn = 0; chn < n_chn_psy; chn++) {\n            var ppe;\n            var ppePos;\n            var type;\n            var mr;\n\n            if (chn > 1) {\n                ppe = percep_MS_entropy;\n                ppePos = -2;\n                type = Encoder_1.NORM_TYPE;\n                if (blocktype_d[0] == Encoder_1.SHORT_TYPE\n                    || blocktype_d[1] == Encoder_1.SHORT_TYPE)\n                    type = Encoder_1.SHORT_TYPE;\n                mr = masking_MS_ratio[gr_out][chn - 2];\n            } else {\n                ppe = percep_entropy;\n                ppePos = 0;\n                type = blocktype_d[chn];\n                mr = masking_ratio[gr_out][chn];\n            }\n\n            if (type == Encoder_1.SHORT_TYPE) {\n                ppe[ppePos + chn] = pecalc_s(mr, gfc.masking_lower);\n            } else {\n                ppe[ppePos + chn] = pecalc_l(mr, gfc.masking_lower);\n            }\n\n            if (gfp.analysis) {\n                gfc.pinfo.pe[gr_out][chn] = ppe[ppePos + chn];\n            }\n        }\n        return 0;\n    };\n\n    function s3_func_x(bark, hf_slope) {\n        var tempx = bark, tempy;\n\n        if (tempx >= 0) {\n            tempy = -tempx * 27;\n        } else {\n            tempy = tempx * hf_slope;\n        }\n        if (tempy <= -72.0) {\n            return 0;\n        }\n        return Math.exp(tempy * LN_TO_LOG10);\n    }\n\n    function norm_s3_func_x(hf_slope) {\n        var lim_a = 0, lim_b = 0;\n        {\n            var x = 0, l, h;\n            for (x = 0; s3_func_x(x, hf_slope) > 1e-20; x -= 1)\n                ;\n            l = x;\n            h = 0;\n            while (Math.abs(h - l) > 1e-12) {\n                x = (h + l) / 2;\n                if (s3_func_x(x, hf_slope) > 0) {\n                    h = x;\n                } else {\n                    l = x;\n                }\n            }\n            lim_a = l;\n        }\n        {\n            var x = 0, l, h;\n            for (x = 0; s3_func_x(x, hf_slope) > 1e-20; x += 1)\n                ;\n            l = 0;\n            h = x;\n            while (Math.abs(h - l) > 1e-12) {\n                x = (h + l) / 2;\n                if (s3_func_x(x, hf_slope) > 0) {\n                    l = x;\n                } else {\n                    h = x;\n                }\n            }\n            lim_b = h;\n        }\n        {\n            var sum = 0;\n            var m = 1000;\n            var i;\n            for (i = 0; i <= m; ++i) {\n                var x = lim_a + i * (lim_b - lim_a) / m;\n                var y = s3_func_x(x, hf_slope);\n                sum += y;\n            }\n            {\n                var norm = (m + 1) / (sum * (lim_b - lim_a));\n                /* printf( \"norm = %lf\\n\",norm); */\n                return norm;\n            }\n        }\n    }\n\n    /**\n     *   The spreading function.  Values returned in units of energy\n     */\n    function s3_func(bark) {\n        var tempx, x, tempy, temp;\n        tempx = bark;\n        if (tempx >= 0)\n            tempx *= 3;\n        else\n            tempx *= 1.5;\n\n        if (tempx >= 0.5 && tempx <= 2.5) {\n            temp = tempx - 0.5;\n            x = 8.0 * (temp * temp - 2.0 * temp);\n        } else\n            x = 0.0;\n        tempx += 0.474;\n        tempy = 15.811389 + 7.5 * tempx - 17.5\n            * Math.sqrt(1.0 + tempx * tempx);\n\n        if (tempy <= -60.0)\n            return 0.0;\n\n        tempx = Math.exp((x + tempy) * LN_TO_LOG10);\n\n        /**\n         * <PRE>\n         * Normalization.  The spreading function should be normalized so that:\n         * +inf\n         * /\n         * |  s3 [ bark ]  d(bark)   =  1\n         * /\n         * -inf\n         * </PRE>\n         */\n        tempx /= .6609193;\n        return tempx;\n    }\n\n    /**\n     * see for example \"Zwicker: Psychoakustik, 1982; ISBN 3-540-11401-7\n     */\n    function freq2bark(freq) {\n        /* input: freq in hz output: barks */\n        if (freq < 0)\n            freq = 0;\n        freq = freq * 0.001;\n        return 13.0 * Math.atan(.76 * freq) + 3.5\n            * Math.atan(freq * freq / (7.5 * 7.5));\n    }\n\n    function init_numline(numlines, bo, bm, bval, bval_width, mld, bo_w, sfreq, blksize, scalepos, deltafreq, sbmax) {\n        var b_frq = new_float$3(Encoder_1.CBANDS + 1);\n        var sample_freq_frac = sfreq / (sbmax > 15 ? 2 * 576 : 2 * 192);\n        var partition = new_int$3(Encoder_1.HBLKSIZE);\n        var i;\n        sfreq /= blksize;\n        var j = 0;\n        var ni = 0;\n        /* compute numlines, the number of spectral lines in each partition band */\n        /* each partition band should be about DELBARK wide. */\n        for (i = 0; i < Encoder_1.CBANDS; i++) {\n            var bark1;\n            var j2;\n            bark1 = freq2bark(sfreq * j);\n\n            b_frq[i] = sfreq * j;\n\n            for (j2 = j; freq2bark(sfreq * j2) - bark1 < DELBARK\n            && j2 <= blksize / 2; j2++)\n                ;\n\n            numlines[i] = j2 - j;\n            ni = i + 1;\n\n            while (j < j2) {\n                assert$3(j < Encoder_1.HBLKSIZE);\n                partition[j++] = i;\n            }\n            if (j > blksize / 2) {\n                j = blksize / 2;\n                ++i;\n                break;\n            }\n        }\n        assert$3(i < Encoder_1.CBANDS);\n        b_frq[i] = sfreq * j;\n\n        for (var sfb = 0; sfb < sbmax; sfb++) {\n            var i1, i2, start, end;\n            var arg;\n            start = scalepos[sfb];\n            end = scalepos[sfb + 1];\n\n            i1 = 0 | Math.floor(.5 + deltafreq * (start - .5));\n            if (i1 < 0)\n                i1 = 0;\n            i2 = 0 | Math.floor(.5 + deltafreq * (end - .5));\n\n            if (i2 > blksize / 2)\n                i2 = blksize / 2;\n\n            bm[sfb] = (partition[i1] + partition[i2]) / 2;\n            bo[sfb] = partition[i2];\n            var f_tmp = sample_freq_frac * end;\n            /*\n             * calculate how much of this band belongs to current scalefactor\n             * band\n             */\n            bo_w[sfb] = (f_tmp - b_frq[bo[sfb]])\n                / (b_frq[bo[sfb] + 1] - b_frq[bo[sfb]]);\n            if (bo_w[sfb] < 0) {\n                bo_w[sfb] = 0;\n            } else {\n                if (bo_w[sfb] > 1) {\n                    bo_w[sfb] = 1;\n                }\n            }\n            /* setup stereo demasking thresholds */\n            /* formula reverse enginerred from plot in paper */\n            arg = freq2bark(sfreq * scalepos[sfb] * deltafreq);\n            arg = ( Math.min(arg, 15.5) / 15.5);\n\n            mld[sfb] = Math.pow(10.0,\n                1.25 * (1 - Math.cos(Math.PI * arg)) - 2.5);\n        }\n\n        /* compute bark values of each critical band */\n        j = 0;\n        for (var k = 0; k < ni; k++) {\n            var w = numlines[k];\n            var bark1, bark2;\n\n            bark1 = freq2bark(sfreq * (j));\n            bark2 = freq2bark(sfreq * (j + w - 1));\n            bval[k] = .5 * (bark1 + bark2);\n\n            bark1 = freq2bark(sfreq * (j - .5));\n            bark2 = freq2bark(sfreq * (j + w - .5));\n            bval_width[k] = bark2 - bark1;\n            j += w;\n        }\n\n        return ni;\n    }\n\n    function init_s3_values(s3ind, npart, bval, bval_width, norm, use_old_s3) {\n        var s3 = new_float_n$3([Encoder_1.CBANDS, Encoder_1.CBANDS]);\n        /*\n         * The s3 array is not linear in the bark scale.\n         *\n         * bval[x] should be used to get the bark value.\n         */\n        var j;\n        var numberOfNoneZero = 0;\n\n        /**\n         * <PRE>\n         * s[i][j], the value of the spreading function,\n         * centered at band j (masker), for band i (maskee)\n         *\n         * i.e.: sum over j to spread into signal barkval=i\n         * NOTE: i and j are used opposite as in the ISO docs\n         * </PRE>\n         */\n        if (use_old_s3) {\n            for (var i = 0; i < npart; i++) {\n                for (j = 0; j < npart; j++) {\n                    var v = s3_func(bval[i] - bval[j]) * bval_width[j];\n                    s3[i][j] = v * norm[i];\n                }\n            }\n        } else {\n            for (j = 0; j < npart; j++) {\n                var hf_slope = 15 + Math.min(21 / bval[j], 12);\n                var s3_x_norm = norm_s3_func_x(hf_slope);\n                for (var i = 0; i < npart; i++) {\n                    var v = s3_x_norm\n                        * s3_func_x(bval[i] - bval[j], hf_slope)\n                        * bval_width[j];\n                    s3[i][j] = v * norm[i];\n                }\n            }\n        }\n        for (var i = 0; i < npart; i++) {\n            for (j = 0; j < npart; j++) {\n                if (s3[i][j] > 0.0)\n                    break;\n            }\n            s3ind[i][0] = j;\n\n            for (j = npart - 1; j > 0; j--) {\n                if (s3[i][j] > 0.0)\n                    break;\n            }\n            s3ind[i][1] = j;\n            numberOfNoneZero += (s3ind[i][1] - s3ind[i][0] + 1);\n        }\n\n        var p = new_float$3(numberOfNoneZero);\n        var k = 0;\n        for (var i = 0; i < npart; i++)\n            for (j = s3ind[i][0]; j <= s3ind[i][1]; j++)\n                p[k++] = s3[i][j];\n\n        return p;\n    }\n\n    function stereo_demask(f) {\n        /* setup stereo demasking thresholds */\n        /* formula reverse enginerred from plot in paper */\n        var arg = freq2bark(f);\n        arg = (Math.min(arg, 15.5) / 15.5);\n\n        return Math.pow(10.0,\n            1.25 * (1 - Math.cos(Math.PI * arg)) - 2.5);\n    }\n\n    /**\n     * NOTE: the bitrate reduction from the inter-channel masking effect is low\n     * compared to the chance of getting annyoing artefacts. L3psycho_anal_vbr\n     * does not use this feature. (Robert 071216)\n     */\n    this.psymodel_init = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var i;\n        var useOldS3 = true;\n        var bvl_a = 13, bvl_b = 24;\n        var snr_l_a = 0, snr_l_b = 0;\n        var snr_s_a = -8.25, snr_s_b = -4.5;\n        var bval = new_float$3(Encoder_1.CBANDS);\n        var bval_width = new_float$3(Encoder_1.CBANDS);\n        var norm = new_float$3(Encoder_1.CBANDS);\n        var sfreq = gfp.out_samplerate;\n\n        switch (gfp.experimentalZ) {\n            default:\n            case 0:\n                useOldS3 = true;\n                break;\n            case 1:\n                useOldS3 = (gfp.VBR == VbrMode$3.vbr_mtrh || gfp.VBR == VbrMode$3.vbr_mt) ? false\n                    : true;\n                break;\n            case 2:\n                useOldS3 = false;\n                break;\n            case 3:\n                bvl_a = 8;\n                snr_l_a = -1.75;\n                snr_l_b = -0.0125;\n                snr_s_a = -8.25;\n                snr_s_b = -2.25;\n                break;\n        }\n        gfc.ms_ener_ratio_old = .25;\n        gfc.blocktype_old[0] = gfc.blocktype_old[1] = Encoder_1.NORM_TYPE;\n        // the vbr header is long blocks\n\n        for (i = 0; i < 4; ++i) {\n            for (var j = 0; j < Encoder_1.CBANDS; ++j) {\n                gfc.nb_1[i][j] = 1e20;\n                gfc.nb_2[i][j] = 1e20;\n                gfc.nb_s1[i][j] = gfc.nb_s2[i][j] = 1.0;\n            }\n            for (var sb = 0; sb < Encoder_1.SBMAX_l; sb++) {\n                gfc.en[i].l[sb] = 1e20;\n                gfc.thm[i].l[sb] = 1e20;\n            }\n            for (var j = 0; j < 3; ++j) {\n                for (var sb = 0; sb < Encoder_1.SBMAX_s; sb++) {\n                    gfc.en[i].s[sb][j] = 1e20;\n                    gfc.thm[i].s[sb][j] = 1e20;\n                }\n                gfc.nsPsy.lastAttacks[i] = 0;\n            }\n            for (var j = 0; j < 9; j++)\n                gfc.nsPsy.last_en_subshort[i][j] = 10.;\n        }\n\n        /* init. for loudness approx. -jd 2001 mar 27 */\n        gfc.loudness_sq_save[0] = gfc.loudness_sq_save[1] = 0.0;\n\n        /*************************************************************************\n         * now compute the psychoacoustic model specific constants\n         ************************************************************************/\n        /* compute numlines, bo, bm, bval, bval_width, mld */\n\n        gfc.npart_l = init_numline(gfc.numlines_l, gfc.bo_l, gfc.bm_l, bval,\n            bval_width, gfc.mld_l, gfc.PSY.bo_l_weight, sfreq,\n            Encoder_1.BLKSIZE, gfc.scalefac_band.l, Encoder_1.BLKSIZE\n            / (2.0 * 576), Encoder_1.SBMAX_l);\n        assert$3(gfc.npart_l < Encoder_1.CBANDS);\n        /* compute the spreading function */\n        for (i = 0; i < gfc.npart_l; i++) {\n            var snr = snr_l_a;\n            if (bval[i] >= bvl_a) {\n                snr = snr_l_b * (bval[i] - bvl_a) / (bvl_b - bvl_a) + snr_l_a\n                    * (bvl_b - bval[i]) / (bvl_b - bvl_a);\n            }\n            norm[i] = Math.pow(10.0, snr / 10.0);\n            if (gfc.numlines_l[i] > 0) {\n                gfc.rnumlines_l[i] = 1.0 / gfc.numlines_l[i];\n            } else {\n                gfc.rnumlines_l[i] = 0;\n            }\n        }\n        gfc.s3_ll = init_s3_values(gfc.s3ind, gfc.npart_l, bval, bval_width,\n            norm, useOldS3);\n\n        /* compute long block specific values, ATH and MINVAL */\n        var j = 0;\n        for (i = 0; i < gfc.npart_l; i++) {\n            var x;\n\n            /* ATH */\n            x = Float$3.MAX_VALUE;\n            for (var k = 0; k < gfc.numlines_l[i]; k++, j++) {\n                var freq = sfreq * j / (1000.0 * Encoder_1.BLKSIZE);\n                var level;\n                /*\n                 * ATH below 100 Hz constant, not further climbing\n                 */\n                level = this.ATHformula(freq * 1000, gfp) - 20;\n                // scale to FFT units; returned value is in dB\n                level = Math.pow(10., 0.1 * level);\n                // convert from dB . energy\n                level *= gfc.numlines_l[i];\n                if (x > level)\n                    x = level;\n            }\n            gfc.ATH.cb_l[i] = x;\n\n            /*\n             * MINVAL. For low freq, the strength of the masking is limited by\n             * minval this is an ISO MPEG1 thing, dont know if it is really\n             * needed\n             */\n            /*\n             * FIXME: it does work to reduce low-freq problems in S53-Wind-Sax\n             * and lead-voice samples, but introduces some 3 kbps bit bloat too.\n             * TODO: Further refinement of the shape of this hack.\n             */\n            x = -20 + bval[i] * 20 / 10;\n            if (x > 6) {\n                x = 100;\n            }\n            if (x < -15) {\n                x = -15;\n            }\n            x -= 8.;\n            gfc.minval_l[i] = (Math.pow(10.0, x / 10.) * gfc.numlines_l[i]);\n        }\n\n        /************************************************************************\n         * do the same things for short blocks\n         ************************************************************************/\n        gfc.npart_s = init_numline(gfc.numlines_s, gfc.bo_s, gfc.bm_s, bval,\n            bval_width, gfc.mld_s, gfc.PSY.bo_s_weight, sfreq,\n            Encoder_1.BLKSIZE_s, gfc.scalefac_band.s, Encoder_1.BLKSIZE_s\n            / (2.0 * 192), Encoder_1.SBMAX_s);\n        assert$3(gfc.npart_s < Encoder_1.CBANDS);\n\n        /* SNR formula. short block is normalized by SNR. is it still right ? */\n        j = 0;\n        for (i = 0; i < gfc.npart_s; i++) {\n            var x;\n            var snr = snr_s_a;\n            if (bval[i] >= bvl_a) {\n                snr = snr_s_b * (bval[i] - bvl_a) / (bvl_b - bvl_a) + snr_s_a\n                    * (bvl_b - bval[i]) / (bvl_b - bvl_a);\n            }\n            norm[i] = Math.pow(10.0, snr / 10.0);\n\n            /* ATH */\n            x = Float$3.MAX_VALUE;\n            for (var k = 0; k < gfc.numlines_s[i]; k++, j++) {\n                var freq = sfreq * j / (1000.0 * Encoder_1.BLKSIZE_s);\n                var level;\n                /* freq = Min(.1,freq); */\n                /*\n                 * ATH below 100 Hz constant, not\n                 * further climbing\n                 */\n                level = this.ATHformula(freq * 1000, gfp) - 20;\n                // scale to FFT units; returned value is in dB\n                level = Math.pow(10., 0.1 * level);\n                // convert from dB . energy\n                level *= gfc.numlines_s[i];\n                if (x > level)\n                    x = level;\n            }\n            gfc.ATH.cb_s[i] = x;\n\n            /*\n             * MINVAL. For low freq, the strength of the masking is limited by\n             * minval this is an ISO MPEG1 thing, dont know if it is really\n             * needed\n             */\n            x = (-7.0 + bval[i] * 7.0 / 12.0);\n            if (bval[i] > 12) {\n                x *= 1 + Math.log(1 + x) * 3.1;\n            }\n            if (bval[i] < 12) {\n                x *= 1 + Math.log(1 - x) * 2.3;\n            }\n            if (x < -15) {\n                x = -15;\n            }\n            x -= 8;\n            gfc.minval_s[i] = Math.pow(10.0, x / 10)\n                * gfc.numlines_s[i];\n        }\n\n        gfc.s3_ss = init_s3_values(gfc.s3ind_s, gfc.npart_s, bval, bval_width,\n            norm, useOldS3);\n\n        init_mask_add_max_values();\n        fft.init_fft(gfc);\n\n        /* setup temporal masking */\n        gfc.decay = Math.exp(-1.0 * LOG10\n            / (temporalmask_sustain_sec * sfreq / 192.0));\n\n        {\n            var msfix;\n            msfix = NS_MSFIX;\n            if ((gfp.exp_nspsytune & 2) != 0)\n                msfix = 1.0;\n            if (Math.abs(gfp.msfix) > 0.0)\n                msfix = gfp.msfix;\n            gfp.msfix = msfix;\n\n            /*\n             * spread only from npart_l bands. Normally, we use the spreading\n             * function to convolve from npart_l down to npart_l bands\n             */\n            for (var b = 0; b < gfc.npart_l; b++)\n                if (gfc.s3ind[b][1] > gfc.npart_l - 1)\n                    gfc.s3ind[b][1] = gfc.npart_l - 1;\n        }\n\n        /*\n         * prepare for ATH auto adjustment: we want to decrease the ATH by 12 dB\n         * per second\n         */\n        var frame_duration = (576. * gfc.mode_gr / sfreq);\n        gfc.ATH.decay = Math.pow(10., -12. / 10. * frame_duration);\n        gfc.ATH.adjust = 0.01;\n        /* minimum, for leading low loudness */\n        gfc.ATH.adjustLimit = 1.0;\n        /* on lead, allow adjust up to maximum */\n\n        assert$3(gfc.bo_l[Encoder_1.SBMAX_l - 1] <= gfc.npart_l);\n        assert$3(gfc.bo_s[Encoder_1.SBMAX_s - 1] <= gfc.npart_s);\n\n        if (gfp.ATHtype != -1) {\n            /* compute equal loudness weights (eql_w) */\n            var freq;\n            var freq_inc = gfp.out_samplerate\n                / (Encoder_1.BLKSIZE);\n            var eql_balance = 0.0;\n            freq = 0.0;\n            for (i = 0; i < Encoder_1.BLKSIZE / 2; ++i) {\n                /* convert ATH dB to relative power (not dB) */\n                /* to determine eql_w */\n                freq += freq_inc;\n                gfc.ATH.eql_w[i] = 1. / Math.pow(10, this.ATHformula(freq, gfp) / 10);\n                eql_balance += gfc.ATH.eql_w[i];\n            }\n            eql_balance = 1.0 / eql_balance;\n            for (i = Encoder_1.BLKSIZE / 2; --i >= 0;) { /* scale weights */\n                gfc.ATH.eql_w[i] *= eql_balance;\n            }\n        }\n        {\n            for (var b = j = 0; b < gfc.npart_s; ++b) {\n                for (i = 0; i < gfc.numlines_s[b]; ++i) {\n                    ++j;\n                }\n            }\n            assert$3(j == 129);\n            for (var b = j = 0; b < gfc.npart_l; ++b) {\n                for (i = 0; i < gfc.numlines_l[b]; ++i) {\n                    ++j;\n                }\n            }\n            assert$3(j == 513);\n        }\n        j = 0;\n        for (i = 0; i < gfc.npart_l; i++) {\n            var freq = sfreq * (j + gfc.numlines_l[i] / 2) / (1.0 * Encoder_1.BLKSIZE);\n            gfc.mld_cb_l[i] = stereo_demask(freq);\n            j += gfc.numlines_l[i];\n        }\n        for (; i < Encoder_1.CBANDS; ++i) {\n            gfc.mld_cb_l[i] = 1;\n        }\n        j = 0;\n        for (i = 0; i < gfc.npart_s; i++) {\n            var freq = sfreq * (j + gfc.numlines_s[i] / 2) / (1.0 * Encoder_1.BLKSIZE_s);\n            gfc.mld_cb_s[i] = stereo_demask(freq);\n            j += gfc.numlines_s[i];\n        }\n        for (; i < Encoder_1.CBANDS; ++i) {\n            gfc.mld_cb_s[i] = 1;\n        }\n        return 0;\n    };\n\n    /**\n     * Those ATH formulas are returning their minimum value for input = -1\n     */\n    function ATHformula_GB(f, value) {\n        /**\n         * <PRE>\n         *  from Painter & Spanias\n         *           modified by Gabriel Bouvigne to better fit the reality\n         *           ath =    3.640 * pow(f,-0.8)\n         *           - 6.800 * exp(-0.6*pow(f-3.4,2.0))\n         *           + 6.000 * exp(-0.15*pow(f-8.7,2.0))\n         *           + 0.6* 0.001 * pow(f,4.0);\n         *\n         *\n         *           In the past LAME was using the Painter &Spanias formula.\n         *           But we had some recurrent problems with HF content.\n         *           We measured real ATH values, and found the older formula\n         *           to be inaccurate in the higher part. So we made this new\n         *           formula and this solved most of HF problematic test cases.\n         *           The tradeoff is that in VBR mode it increases a lot the\n         *           bitrate.\n         * </PRE>\n         */\n\n        /*\n         * This curve can be adjusted according to the VBR scale: it adjusts\n         * from something close to Painter & Spanias on V9 up to Bouvigne's\n         * formula for V0. This way the VBR bitrate is more balanced according\n         * to the -V value.\n         */\n\n        // the following Hack allows to ask for the lowest value\n        if (f < -.3)\n            f = 3410;\n\n        // convert to khz\n        f /= 1000;\n        f = Math.max(0.1, f);\n        var ath = 3.640 * Math.pow(f, -0.8) - 6.800\n            * Math.exp(-0.6 * Math.pow(f - 3.4, 2.0)) + 6.000\n            * Math.exp(-0.15 * Math.pow(f - 8.7, 2.0))\n            + (0.6 + 0.04 * value) * 0.001 * Math.pow(f, 4.0);\n        return ath;\n    }\n\n    this.ATHformula = function (f, gfp) {\n        var ath;\n        switch (gfp.ATHtype) {\n            case 0:\n                ath = ATHformula_GB(f, 9);\n                break;\n            case 1:\n                // over sensitive, should probably be removed\n                ath = ATHformula_GB(f, -1);\n                break;\n            case 2:\n                ath = ATHformula_GB(f, 0);\n                break;\n            case 3:\n                // modification of GB formula by Roel\n                ath = ATHformula_GB(f, 1) + 6;\n                break;\n            case 4:\n                ath = ATHformula_GB(f, gfp.ATHcurve);\n                break;\n            default:\n                ath = ATHformula_GB(f, 0);\n                break;\n        }\n        return ath;\n    };\n\n}\n\nvar PsyModel_1 = PsyModel;\n\n//package mp3;\n\n/* MPEG modes */\nfunction MPEGMode$1(ordinal) {\n    var _ordinal = ordinal;\n    this.ordinal = function () {\n        return _ordinal;\n    };\n}\n\nMPEGMode$1.STEREO = new MPEGMode$1(0);\nMPEGMode$1.JOINT_STEREO = new MPEGMode$1(1);\nMPEGMode$1.DUAL_CHANNEL = new MPEGMode$1(2);\nMPEGMode$1.MONO = new MPEGMode$1(3);\nMPEGMode$1.NOT_SET = new MPEGMode$1(4);\n\nvar MPEGMode_1 = MPEGMode$1;\n\nfunction LameGlobalFlags() {\n\n    this.class_id = 0;\n\n    /* input description */\n\n    /**\n     * number of samples. default=-1\n     */\n    this.num_samples = 0;\n    /**\n     * input number of channels. default=2\n     */\n    this.num_channels = 0;\n    /**\n     * input_samp_rate in Hz. default=44.1 kHz\n     */\n    this.in_samplerate = 0;\n    /**\n     * output_samp_rate. default: LAME picks best value at least not used for\n     * MP3 decoding: Remember 44.1 kHz MP3s and AC97\n     */\n    this.out_samplerate = 0;\n    /**\n     * scale input by this amount before encoding at least not used for MP3\n     * decoding\n     */\n    this.scale = 0.;\n    /**\n     * scale input of channel 0 (left) by this amount before encoding\n     */\n    this.scale_left = 0.;\n    /**\n     * scale input of channel 1 (right) by this amount before encoding\n     */\n    this.scale_right = 0.;\n\n    /* general control params */\n    /**\n     * collect data for a MP3 frame analyzer?\n     */\n    this.analysis = false;\n    /**\n     * add Xing VBR tag?\n     */\n    this.bWriteVbrTag = false;\n\n    /**\n     * use lame/mpglib to convert mp3 to wav\n     */\n    this.decode_only = false;\n    /**\n     * quality setting 0=best, 9=worst default=5\n     */\n    this.quality = 0;\n    /**\n     * see enum default = LAME picks best value\n     */\n    this.mode = MPEGMode_1.STEREO;\n    /**\n     * force M/S mode. requires mode=1\n     */\n    this.force_ms = false;\n    /**\n     * use free format? default=0\n     */\n    this.free_format = false;\n    /**\n     * find the RG value? default=0\n     */\n    this.findReplayGain = false;\n    /**\n     * decode on the fly? default=0\n     */\n    this.decode_on_the_fly = false;\n    /**\n     * 1 (default) writes ID3 tags, 0 not\n     */\n    this.write_id3tag_automatic = false;\n\n    /*\n     * set either brate>0 or compression_ratio>0, LAME will compute the value of\n     * the variable not set. Default is compression_ratio = 11.025\n     */\n    /**\n     * bitrate\n     */\n    this.brate = 0;\n    /**\n     * sizeof(wav file)/sizeof(mp3 file)\n     */\n    this.compression_ratio = 0.;\n\n    /* frame params */\n    /**\n     * mark as copyright. default=0\n     */\n    this.copyright = 0;\n    /**\n     * mark as original. default=1\n     */\n    this.original = 0;\n    /**\n     * the MP3 'private extension' bit. Meaningless\n     */\n    this.extension = 0;\n    /**\n     * Input PCM is emphased PCM (for instance from one of the rarely emphased\n     * CDs), it is STRONGLY not recommended to use this, because psycho does not\n     * take it into account, and last but not least many decoders don't care\n     * about these bits\n     */\n    this.emphasis = 0;\n    /**\n     * use 2 bytes per frame for a CRC checksum. default=0\n     */\n    this.error_protection = 0;\n    /**\n     * enforce ISO spec as much as possible\n     */\n    this.strict_ISO = false;\n\n    /**\n     * use bit reservoir?\n     */\n    this.disable_reservoir = false;\n\n    /* quantization/noise shaping */\n    this.quant_comp = 0;\n    this.quant_comp_short = 0;\n    this.experimentalY = false;\n    this.experimentalZ = 0;\n    this.exp_nspsytune = 0;\n\n    this.preset = 0;\n\n    /* VBR control */\n    this.VBR = null;\n    /**\n     * Range [0,...,1[\n     */\n    this.VBR_q_frac = 0.;\n    /**\n     * Range [0,...,9]\n     */\n    this.VBR_q = 0;\n    this.VBR_mean_bitrate_kbps = 0;\n    this.VBR_min_bitrate_kbps = 0;\n    this.VBR_max_bitrate_kbps = 0;\n    /**\n     * strictly enforce VBR_min_bitrate normaly, it will be violated for analog\n     * silence\n     */\n    this.VBR_hard_min = 0;\n\n    /* resampling and filtering */\n\n    /**\n     * freq in Hz. 0=lame choses. -1=no filter\n     */\n    this.lowpassfreq = 0;\n    /**\n     * freq in Hz. 0=lame choses. -1=no filter\n     */\n    this.highpassfreq = 0;\n    /**\n     * freq width of filter, in Hz (default=15%)\n     */\n    this.lowpasswidth = 0;\n    /**\n     * freq width of filter, in Hz (default=15%)\n     */\n    this.highpasswidth = 0;\n\n    /*\n     * psycho acoustics and other arguments which you should not change unless\n     * you know what you are doing\n     */\n\n    this.maskingadjust = 0.;\n    this.maskingadjust_short = 0.;\n    /**\n     * only use ATH\n     */\n    this.ATHonly = false;\n    /**\n     * only use ATH for short blocks\n     */\n    this.ATHshort = false;\n    /**\n     * disable ATH\n     */\n    this.noATH = false;\n    /**\n     * select ATH formula\n     */\n    this.ATHtype = 0;\n    /**\n     * change ATH formula 4 shape\n     */\n    this.ATHcurve = 0.;\n    /**\n     * lower ATH by this many db\n     */\n    this.ATHlower = 0.;\n    /**\n     * select ATH auto-adjust scheme\n     */\n    this.athaa_type = 0;\n    /**\n     * select ATH auto-adjust loudness calc\n     */\n    this.athaa_loudapprox = 0;\n    /**\n     * dB, tune active region of auto-level\n     */\n    this.athaa_sensitivity = 0.;\n    this.short_blocks = null;\n    /**\n     * use temporal masking effect\n     */\n    this.useTemporal = false;\n    this.interChRatio = 0.;\n    /**\n     * Naoki's adjustment of Mid/Side maskings\n     */\n    this.msfix = 0.;\n\n    /**\n     * 0 off, 1 on\n     */\n    this.tune = false;\n    /**\n     * used to pass values for debugging and stuff\n     */\n    this.tune_value_a = 0.;\n\n    /************************************************************************/\n    /* internal variables, do not set... */\n    /* provided because they may be of use to calling application */\n    /************************************************************************/\n\n    /**\n     * 0=MPEG-2/2.5 1=MPEG-1\n     */\n    this.version = 0;\n    this.encoder_delay = 0;\n    /**\n     * number of samples of padding appended to input\n     */\n    this.encoder_padding = 0;\n    this.framesize = 0;\n    /**\n     * number of frames encoded\n     */\n    this.frameNum = 0;\n    /**\n     * is this struct owned by calling program or lame?\n     */\n    this.lame_allocated_gfp = 0;\n    /**************************************************************************/\n    /* more internal variables are stored in this structure: */\n    /**************************************************************************/\n    this.internal_flags = null;\n}\n\nvar LameGlobalFlags_1 = LameGlobalFlags;\n\nvar L3Side$1 = {};\n\n\n\t/**\n\t * max scalefactor band, max(SBMAX_l, SBMAX_s*3, (SBMAX_s-3)*3+8)\n\t */\nL3Side$1.SFBMAX = (Encoder_1.SBMAX_s * 3);\n\nvar L3Side_1 = L3Side$1;\n\nvar new_float$10 = common.new_float;\nvar new_int$10 = common.new_int;\nfunction GrInfo() {\n    //float xr[] = new float[576];\n    this.xr = new_float$10(576);\n    //int l3_enc[] = new int[576];\n    this.l3_enc = new_int$10(576);\n    //int scalefac[] = new int[L3Side.SFBMAX];\n    this.scalefac = new_int$10(L3Side_1.SFBMAX);\n    this.xrpow_max = 0.;\n\n    this.part2_3_length = 0;\n    this.big_values = 0;\n    this.count1 = 0;\n    this.global_gain = 0;\n    this.scalefac_compress = 0;\n    this.block_type = 0;\n    this.mixed_block_flag = 0;\n    this.table_select = new_int$10(3);\n    this.subblock_gain = new_int$10(3 + 1);\n    this.region0_count = 0;\n    this.region1_count = 0;\n    this.preflag = 0;\n    this.scalefac_scale = 0;\n    this.count1table_select = 0;\n\n    this.part2_length = 0;\n    this.sfb_lmax = 0;\n    this.sfb_smin = 0;\n    this.psy_lmax = 0;\n    this.sfbmax = 0;\n    this.psymax = 0;\n    this.sfbdivide = 0;\n    this.width = new_int$10(L3Side_1.SFBMAX);\n    this.window = new_int$10(L3Side_1.SFBMAX);\n    this.count1bits = 0;\n    /**\n     * added for LSF\n     */\n    this.sfb_partition_table = null;\n    this.slen = new_int$10(4);\n\n    this.max_nonzero_coeff = 0;\n\n    var self = this;\n    function clone_int(array) {\n        return new Int32Array(array);\n    }\n    function clone_float(array) {\n        return new Float32Array(array);\n    }\n    this.assign = function (other) {\n        self.xr = clone_float(other.xr); //.slice(0); //clone();\n        self.l3_enc = clone_int(other.l3_enc); //.slice(0); //clone();\n        self.scalefac = clone_int(other.scalefac);//.slice(0); //clone();\n        self.xrpow_max = other.xrpow_max;\n\n        self.part2_3_length = other.part2_3_length;\n        self.big_values = other.big_values;\n        self.count1 = other.count1;\n        self.global_gain = other.global_gain;\n        self.scalefac_compress = other.scalefac_compress;\n        self.block_type = other.block_type;\n        self.mixed_block_flag = other.mixed_block_flag;\n        self.table_select = clone_int(other.table_select);//.slice(0); //clone();\n        self.subblock_gain = clone_int(other.subblock_gain); //.slice(0); //.clone();\n        self.region0_count = other.region0_count;\n        self.region1_count = other.region1_count;\n        self.preflag = other.preflag;\n        self.scalefac_scale = other.scalefac_scale;\n        self.count1table_select = other.count1table_select;\n\n        self.part2_length = other.part2_length;\n        self.sfb_lmax = other.sfb_lmax;\n        self.sfb_smin = other.sfb_smin;\n        self.psy_lmax = other.psy_lmax;\n        self.sfbmax = other.sfbmax;\n        self.psymax = other.psymax;\n        self.sfbdivide = other.sfbdivide;\n        self.width = clone_int(other.width); //.slice(0); //.clone();\n        self.window = clone_int(other.window); //.slice(0); //.clone();\n        self.count1bits = other.count1bits;\n\n        self.sfb_partition_table = other.sfb_partition_table.slice(0); //.clone();\n        self.slen = clone_int(other.slen); //.slice(0); //.clone();\n        self.max_nonzero_coeff = other.max_nonzero_coeff;\n    };\n}\n\nvar GrInfo_1 = GrInfo;\n\nvar new_int$9 = common.new_int;\nfunction IIISideInfo() {\n    this.tt = [[null, null], [null, null]];\n    this.main_data_begin = 0;\n    this.private_bits = 0;\n    this.resvDrain_pre = 0;\n    this.resvDrain_post = 0;\n    this.scfsi = [new_int$9(4), new_int$9(4)];\n\n    for (var gr = 0; gr < 2; gr++) {\n        for (var ch = 0; ch < 2; ch++) {\n            this.tt[gr][ch] = new GrInfo_1();\n        }\n    }\n}\n\nvar IIISideInfo_1 = IIISideInfo;\n\n//package mp3;\n\n/**\n * Layer III side information.\n *\n * @author Ken\n *\n */\n\n\nvar System$11 = common.System;\nvar new_int$11 = common.new_int;\nfunction ScaleFac(arrL, arrS, arr21, arr12) {\n\n    this.l = new_int$11(1 + Encoder_1.SBMAX_l);\n    this.s = new_int$11(1 + Encoder_1.SBMAX_s);\n    this.psfb21 = new_int$11(1 + Encoder_1.PSFB21);\n    this.psfb12 = new_int$11(1 + Encoder_1.PSFB12);\n    var l = this.l;\n    var s = this.s;\n\n    if (arguments.length == 4) {\n        //public ScaleFac(final int[] arrL, final int[] arrS, final int[] arr21,\n        //    final int[] arr12) {\n        this.arrL = arguments[0];\n        this.arrS = arguments[1];\n        this.arr21 = arguments[2];\n        this.arr12 = arguments[3];\n\n        System$11.arraycopy(this.arrL, 0, l, 0, Math.min(this.arrL.length, this.l.length));\n        System$11.arraycopy(this.arrS, 0, s, 0, Math.min(this.arrS.length, this.s.length));\n        System$11.arraycopy(this.arr21, 0, this.psfb21, 0, Math.min(this.arr21.length, this.psfb21.length));\n        System$11.arraycopy(this.arr12, 0, this.psfb12, 0, Math.min(this.arr12.length, this.psfb12.length));\n    }\n}\n\nvar ScaleFac_1 = ScaleFac;\n\nvar new_float$12 = common.new_float;\nvar new_float_n$12 = common.new_float_n;\nvar new_int$12 = common.new_int;\n//package mp3;\n\n/**\n * Variables used for --nspsytune\n *\n * @author Ken\n *\n */\nfunction NsPsy() {\n    this.last_en_subshort = new_float_n$12([4, 9]);\n    this.lastAttacks = new_int$12(4);\n    this.pefirbuf = new_float$12(19);\n    this.longfact = new_float$12(Encoder_1.SBMAX_l);\n    this.shortfact = new_float$12(Encoder_1.SBMAX_s);\n\n    /**\n     * short block tuning\n     */\n    this.attackthre = 0.;\n    this.attackthre_s = 0.;\n}\n\nvar NsPsy_1 = NsPsy;\n\n//package mp3;\n\nfunction VBRSeekInfo() {\n    /**\n     * What we have seen so far.\n     */\n    this.sum = 0;\n    /**\n     * How many frames we have seen in this chunk.\n     */\n    this.seen = 0;\n    /**\n     * How many frames we want to collect into one chunk.\n     */\n    this.want = 0;\n    /**\n     * Actual position in our bag.\n     */\n    this.pos = 0;\n    /**\n     * Size of our bag.\n     */\n    this.size = 0;\n    /**\n     * Pointer to our bag.\n     */\n    this.bag = null;\n    this.nVbrNumFrames = 0;\n    this.nBytesWritten = 0;\n    /* VBR tag data */\n    this.TotalFrameSize = 0;\n}\n\nvar VBRSeekInfo_1 = VBRSeekInfo;\n\nvar new_byte$8 = common.new_byte;\nvar new_double$8 = common.new_double;\nvar new_float$8 = common.new_float;\nvar new_float_n$8 = common.new_float_n;\nvar new_int$8 = common.new_int;\nvar new_int_n$8 = common.new_int_n;\nLameInternalFlags$1.MFSIZE = (3 * 1152 + Encoder_1.ENCDELAY - Encoder_1.MDCTDELAY);\nLameInternalFlags$1.MAX_HEADER_BUF = 256;\nLameInternalFlags$1.MAX_BITS_PER_CHANNEL = 4095;\nLameInternalFlags$1.MAX_BITS_PER_GRANULE = 7680;\nLameInternalFlags$1.BPC = 320;\n\nfunction LameInternalFlags$1() {\n    var MAX_HEADER_LEN = 40;\n\n\n    /********************************************************************\n     * internal variables NOT set by calling program, and should not be *\n     * modified by the calling program *\n     ********************************************************************/\n\n    /**\n     * Some remarks to the Class_ID field: The Class ID is an Identifier for a\n     * pointer to this struct. It is very unlikely that a pointer to\n     * lame_global_flags has the same 32 bits in it's structure (large and other\n     * special properties, for instance prime).\n     *\n     * To test that the structure is right and initialized, use: if ( gfc .\n     * Class_ID == LAME_ID ) ... Other remark: If you set a flag to 0 for uninit\n     * data and 1 for init data, the right test should be \"if (flag == 1)\" and\n     * NOT \"if (flag)\". Unintended modification of this element will be\n     * otherwise misinterpreted as an init.\n     */\n    this.Class_ID = 0;\n\n    this.lame_encode_frame_init = 0;\n    this.iteration_init_init = 0;\n    this.fill_buffer_resample_init = 0;\n\n    //public float mfbuf[][] = new float[2][MFSIZE];\n    this.mfbuf = new_float_n$8([2, LameInternalFlags$1.MFSIZE]);\n\n    /**\n     * granules per frame\n     */\n    this.mode_gr = 0;\n    /**\n     * number of channels in the input data stream (PCM or decoded PCM)\n     */\n    this.channels_in = 0;\n    /**\n     * number of channels in the output data stream (not used for decoding)\n     */\n    this.channels_out = 0;\n    /**\n     * input_samp_rate/output_samp_rate\n     */\n        //public double resample_ratio;\n    this.resample_ratio = 0.;\n\n    this.mf_samples_to_encode = 0;\n    this.mf_size = 0;\n    /**\n     * min bitrate index\n     */\n    this.VBR_min_bitrate = 0;\n    /**\n     * max bitrate index\n     */\n    this.VBR_max_bitrate = 0;\n    this.bitrate_index = 0;\n    this.samplerate_index = 0;\n    this.mode_ext = 0;\n\n    /* lowpass and highpass filter control */\n    /**\n     * normalized frequency bounds of passband\n     */\n    this.lowpass1 = 0.;\n    this.lowpass2 = 0.;\n    /**\n     * normalized frequency bounds of passband\n     */\n    this.highpass1 = 0.;\n    this.highpass2 = 0.;\n\n    /**\n     * 0 = none 1 = ISO AAC model 2 = allow scalefac_select=1\n     */\n    this.noise_shaping = 0;\n\n    /**\n     * 0 = ISO model: amplify all distorted bands<BR>\n     * 1 = amplify within 50% of max (on db scale)<BR>\n     * 2 = amplify only most distorted band<BR>\n     * 3 = method 1 and refine with method 2<BR>\n     */\n    this.noise_shaping_amp = 0;\n    /**\n     * 0 = no substep<BR>\n     * 1 = use substep shaping at last step(VBR only)<BR>\n     * (not implemented yet)<BR>\n     * 2 = use substep inside loop<BR>\n     * 3 = use substep inside loop and last step<BR>\n     */\n    this.substep_shaping = 0;\n\n    /**\n     * 1 = gpsycho. 0 = none\n     */\n    this.psymodel = 0;\n    /**\n     * 0 = stop at over=0, all scalefacs amplified or<BR>\n     * a scalefac has reached max value<BR>\n     * 1 = stop when all scalefacs amplified or a scalefac has reached max value<BR>\n     * 2 = stop when all scalefacs amplified\n     */\n    this.noise_shaping_stop = 0;\n\n    /**\n     * 0 = no, 1 = yes\n     */\n    this.subblock_gain = 0;\n    /**\n     * 0 = no. 1=outside loop 2=inside loop(slow)\n     */\n    this.use_best_huffman = 0;\n\n    /**\n     * 0 = stop early after 0 distortion found. 1 = full search\n     */\n    this.full_outer_loop = 0;\n\n    //public IIISideInfo l3_side = new IIISideInfo();\n    this.l3_side = new IIISideInfo_1();\n    this.ms_ratio = new_float$8(2);\n\n    /* used for padding */\n    /**\n     * padding for the current frame?\n     */\n    this.padding = 0;\n    this.frac_SpF = 0;\n    this.slot_lag = 0;\n\n    /**\n     * optional ID3 tags\n     */\n        //public ID3TagSpec tag_spec;\n    this.tag_spec = null;\n    this.nMusicCRC = 0;\n\n    /* variables used by Quantize */\n    //public int OldValue[] = new int[2];\n    this.OldValue = new_int$8(2);\n    //public int CurrentStep[] = new int[2];\n    this.CurrentStep = new_int$8(2);\n\n    this.masking_lower = 0.;\n    //public int bv_scf[] = new int[576];\n    this.bv_scf = new_int$8(576);\n    //public int pseudohalf[] = new int[L3Side.SFBMAX];\n    this.pseudohalf = new_int$8(L3Side_1.SFBMAX);\n\n    /**\n     * will be set in lame_init_params\n     */\n    this.sfb21_extra = false;\n\n    /* BPC = maximum number of filter convolution windows to precompute */\n    //public float[][] inbuf_old = new float[2][];\n    this.inbuf_old = new Array(2);\n    //public float[][] blackfilt = new float[2 * BPC + 1][];\n    this.blackfilt = new Array(2 * LameInternalFlags$1.BPC + 1);\n    //public double itime[] = new double[2];\n    this.itime = new_double$8(2);\n    this.sideinfo_len = 0;\n\n    /* variables for newmdct.c */\n    //public float sb_sample[][][][] = new float[2][2][18][Encoder.SBLIMIT];\n    this.sb_sample = new_float_n$8([2, 2, 18, Encoder_1.SBLIMIT]);\n    this.amp_filter = new_float$8(32);\n\n    /* variables for BitStream */\n\n    /**\n     * <PRE>\n     * mpeg1: buffer=511 bytes  smallest frame: 96-38(sideinfo)=58\n     * max number of frames in reservoir:  8\n     * mpeg2: buffer=255 bytes.  smallest frame: 24-23bytes=1\n     * with VBR, if you are encoding all silence, it is possible to\n     * have 8kbs/24khz frames with 1byte of data each, which means we need\n     * to buffer up to 255 headers!\n     * </PRE>\n     */\n    /**\n     * also, max_header_buf has to be a power of two\n     */\n    /**\n     * max size of header is 38\n     */\n\n    function Header() {\n        this.write_timing = 0;\n        this.ptr = 0;\n        //public byte buf[] = new byte[MAX_HEADER_LEN];\n        this.buf = new_byte$8(MAX_HEADER_LEN);\n    }\n\n    this.header = new Array(LameInternalFlags$1.MAX_HEADER_BUF);\n\n    this.h_ptr = 0;\n    this.w_ptr = 0;\n    this.ancillary_flag = 0;\n\n    /* variables for Reservoir */\n    /**\n     * in bits\n     */\n    this.ResvSize = 0;\n    /**\n     * in bits\n     */\n    this.ResvMax = 0;\n\n    //public ScaleFac scalefac_band = new ScaleFac();\n    this.scalefac_band = new ScaleFac_1();\n\n    /* daa from PsyModel */\n    /* The static variables \"r\", \"phi_sav\", \"new\", \"old\" and \"oldest\" have */\n    /* to be remembered for the unpredictability measure. For \"r\" and */\n    /* \"phi_sav\", the first index from the left is the channel select and */\n    /* the second index is the \"age\" of the data. */\n    this.minval_l = new_float$8(Encoder_1.CBANDS);\n    this.minval_s = new_float$8(Encoder_1.CBANDS);\n    this.nb_1 = new_float_n$8([4, Encoder_1.CBANDS]);\n    this.nb_2 = new_float_n$8([4, Encoder_1.CBANDS]);\n    this.nb_s1 = new_float_n$8([4, Encoder_1.CBANDS]);\n    this.nb_s2 = new_float_n$8([4, Encoder_1.CBANDS]);\n    this.s3_ss = null;\n    this.s3_ll = null;\n    this.decay = 0.;\n\n    //public III_psy_xmin[] thm = new III_psy_xmin[4];\n    //public III_psy_xmin[] en = new III_psy_xmin[4];\n    this.thm = new Array(4);\n    this.en = new Array(4);\n\n    /**\n     * fft and energy calculation\n     */\n    this.tot_ener = new_float$8(4);\n\n    /* loudness calculation (for adaptive threshold of hearing) */\n    /**\n     * loudness^2 approx. per granule and channel\n     */\n    this.loudness_sq = new_float_n$8([2, 2]);\n    /**\n     * account for granule delay of L3psycho_anal\n     */\n    this.loudness_sq_save = new_float$8(2);\n\n    /**\n     * Scale Factor Bands\n     */\n    this.mld_l = new_float$8(Encoder_1.SBMAX_l);\n    this.mld_s = new_float$8(Encoder_1.SBMAX_s);\n    this.bm_l = new_int$8(Encoder_1.SBMAX_l);\n    this.bo_l = new_int$8(Encoder_1.SBMAX_l);\n    this.bm_s = new_int$8(Encoder_1.SBMAX_s);\n    this.bo_s = new_int$8(Encoder_1.SBMAX_s);\n    this.npart_l = 0;\n    this.npart_s = 0;\n\n    this.s3ind = new_int_n$8([Encoder_1.CBANDS, 2]);\n    this.s3ind_s = new_int_n$8([Encoder_1.CBANDS, 2]);\n\n    this.numlines_s = new_int$8(Encoder_1.CBANDS);\n    this.numlines_l = new_int$8(Encoder_1.CBANDS);\n    this.rnumlines_l = new_float$8(Encoder_1.CBANDS);\n    this.mld_cb_l = new_float$8(Encoder_1.CBANDS);\n    this.mld_cb_s = new_float$8(Encoder_1.CBANDS);\n    this.numlines_s_num1 = 0;\n    this.numlines_l_num1 = 0;\n\n    /* ratios */\n    this.pe = new_float$8(4);\n    this.ms_ratio_s_old = 0.;\n    this.ms_ratio_l_old = 0.;\n    this.ms_ener_ratio_old = 0.;\n\n    /**\n     * block type\n     */\n    this.blocktype_old = new_int$8(2);\n\n    /**\n     * variables used for --nspsytune\n     */\n    this.nsPsy = new NsPsy_1();\n\n    /**\n     * used for Xing VBR header\n     */\n    this.VBR_seek_table = new VBRSeekInfo_1();\n\n    /**\n     * all ATH related stuff\n     */\n        //public ATH ATH;\n    this.ATH = null;\n\n    this.PSY = null;\n\n    this.nogap_total = 0;\n    this.nogap_current = 0;\n\n    /* ReplayGain */\n    this.decode_on_the_fly = true;\n    this.findReplayGain = true;\n    this.findPeakSample = true;\n    this.PeakSample = 0.;\n    this.RadioGain = 0;\n    this.AudiophileGain = 0;\n    //public ReplayGain rgdata;\n    this.rgdata = null;\n\n    /**\n     * gain change required for preventing clipping\n     */\n    this.noclipGainChange = 0;\n    /**\n     * user-specified scale factor required for preventing clipping\n     */\n    this.noclipScale = 0.;\n\n    /* simple statistics */\n    this.bitrate_stereoMode_Hist = new_int_n$8([16, 4 + 1]);\n    /**\n     * norm/start/short/stop/mixed(short)/sum\n     */\n    this.bitrate_blockType_Hist = new_int_n$8([16, 4 + 1 + 1]);\n\n    //public PlottingData pinfo;\n    //public MPGLib.mpstr_tag hip;\n    this.pinfo = null;\n    this.hip = null;\n\n    this.in_buffer_nsamples = 0;\n    //public float[] in_buffer_0;\n    //public float[] in_buffer_1;\n    this.in_buffer_0 = null;\n    this.in_buffer_1 = null;\n\n    //public IIterationLoop iteration_loop;\n    this.iteration_loop = null;\n\n    for (var i = 0; i < this.en.length; i++) {\n        this.en[i] = new III_psy_xmin_1();\n    }\n    for (var i = 0; i < this.thm.length; i++) {\n        this.thm[i] = new III_psy_xmin_1();\n    }\n    for (var i = 0; i < this.header.length; i++) {\n        this.header[i] = new Header();\n    }\n\n}\n\nvar LameInternalFlags_1 = LameInternalFlags$1;\n\nvar new_float$13 = common.new_float;\n/**\n * ATH related stuff, if something new ATH related has to be added, please plug\n * it here into the ATH.\n */\nfunction ATH() {\n    /**\n     * Method for the auto adjustment.\n     */\n    this.useAdjust = 0;\n    /**\n     * factor for tuning the (sample power) point below which adaptive threshold\n     * of hearing adjustment occurs\n     */\n    this.aaSensitivityP = 0.;\n    /**\n     * Lowering based on peak volume, 1 = no lowering.\n     */\n    this.adjust = 0.;\n    /**\n     * Limit for dynamic ATH adjust.\n     */\n    this.adjustLimit = 0.;\n    /**\n     * Determined to lower x dB each second.\n     */\n    this.decay = 0.;\n    /**\n     * Lowest ATH value.\n     */\n    this.floor = 0.;\n    /**\n     * ATH for sfbs in long blocks.\n     */\n    this.l = new_float$13(Encoder_1.SBMAX_l);\n    /**\n     * ATH for sfbs in short blocks.\n     */\n    this.s = new_float$13(Encoder_1.SBMAX_s);\n    /**\n     * ATH for partitioned sfb21 in long blocks.\n     */\n    this.psfb21 = new_float$13(Encoder_1.PSFB21);\n    /**\n     * ATH for partitioned sfb12 in short blocks.\n     */\n    this.psfb12 = new_float$13(Encoder_1.PSFB12);\n    /**\n     * ATH for long block convolution bands.\n     */\n    this.cb_l = new_float$13(Encoder_1.CBANDS);\n    /**\n     * ATH for short block convolution bands.\n     */\n    this.cb_s = new_float$13(Encoder_1.CBANDS);\n    /**\n     * Equal loudness weights (based on ATH).\n     */\n    this.eql_w = new_float$13(Encoder_1.BLKSIZE / 2);\n}\n\nvar ATH_1 = ATH;\n\n/*\n *  ReplayGainAnalysis - analyzes input samples and give the recommended dB change\n *  Copyright (C) 2001 David Robinson and Glen Sawyer\n *  Improvements and optimizations added by Frank Klemm, and by Marcel Muller \n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n *  concept and filter values by David Robinson (David@Robinson.org)\n *    -- blame him if you think the idea is flawed\n *  original coding by Glen Sawyer (mp3gain@hotmail.com)\n *    -- blame him if you think this runs too slowly, or the coding is otherwise flawed\n *\n *  lots of code improvements by Frank Klemm ( http://www.uni-jena.de/~pfk/mpp/ )\n *    -- credit him for all the _good_ programming ;)\n *\n *\n *  For an explanation of the concepts and the basic algorithms involved, go to:\n *    http://www.replaygain.org/\n */\n\n/*\n *  Here's the deal. Call\n *\n *    InitGainAnalysis ( long samplefreq );\n *\n *  to initialize everything. Call\n *\n *    AnalyzeSamples ( var Float_t*  left_samples,\n *                     var Float_t*  right_samples,\n *                     size_t          num_samples,\n *                     int             num_channels );\n *\n *  as many times as you want, with as many or as few samples as you want.\n *  If mono, pass the sample buffer in through left_samples, leave\n *  right_samples NULL, and make sure num_channels = 1.\n *\n *    GetTitleGain()\n *\n *  will return the recommended dB level change for all samples analyzed\n *  SINCE THE LAST TIME you called GetTitleGain() OR InitGainAnalysis().\n *\n *    GetAlbumGain()\n *\n *  will return the recommended dB level change for all samples analyzed\n *  since InitGainAnalysis() was called and finalized with GetTitleGain().\n *\n *  Pseudo-code to process an album:\n *\n *    Float_t       l_samples [4096];\n *    Float_t       r_samples [4096];\n *    size_t        num_samples;\n *    unsigned int  num_songs;\n *    unsigned int  i;\n *\n *    InitGainAnalysis ( 44100 );\n *    for ( i = 1; i <= num_songs; i++ ) {\n *        while ( ( num_samples = getSongSamples ( song[i], left_samples, right_samples ) ) > 0 )\n *            AnalyzeSamples ( left_samples, right_samples, num_samples, 2 );\n *        fprintf (\"Recommended dB change for song %2d: %+6.2 dB\\n\", i, GetTitleGain() );\n *    }\n *    fprintf (\"Recommended dB change for whole album: %+6.2 dB\\n\", GetAlbumGain() );\n */\n\n/*\n *  So here's the main source of potential code confusion:\n *\n *  The filters applied to the incoming samples are IIR filters,\n *  meaning they rely on up to <filter order> number of previous samples\n *  AND up to <filter order> number of previous filtered samples.\n *\n *  I set up the AnalyzeSamples routine to minimize memory usage and interface\n *  complexity. The speed isn't compromised too much (I don't think), but the\n *  internal complexity is higher than it should be for such a relatively\n *  simple routine.\n *\n *  Optimization/clarity suggestions are welcome.\n */\n\nvar System$15 = common.System;\nvar Arrays$15 = common.Arrays;\n/**\n * Table entries per dB\n */\nGainAnalysis$1.STEPS_per_dB = 100.;\n/**\n * Table entries for 0...MAX_dB (normal max. values are 70...80 dB)\n */\nGainAnalysis$1.MAX_dB = 120.;\nGainAnalysis$1.GAIN_NOT_ENOUGH_SAMPLES = -24601;\nGainAnalysis$1.GAIN_ANALYSIS_ERROR = 0;\nGainAnalysis$1.GAIN_ANALYSIS_OK = 1;\nGainAnalysis$1.INIT_GAIN_ANALYSIS_ERROR = 0;\nGainAnalysis$1.INIT_GAIN_ANALYSIS_OK = 1;\n\nGainAnalysis$1.YULE_ORDER = 10;\nGainAnalysis$1.MAX_ORDER = GainAnalysis$1.YULE_ORDER;\n\nGainAnalysis$1.MAX_SAMP_FREQ = 48000;\nGainAnalysis$1.RMS_WINDOW_TIME_NUMERATOR = 1;\nGainAnalysis$1.RMS_WINDOW_TIME_DENOMINATOR = 20;\nGainAnalysis$1.MAX_SAMPLES_PER_WINDOW = ((GainAnalysis$1.MAX_SAMP_FREQ * GainAnalysis$1.RMS_WINDOW_TIME_NUMERATOR) / GainAnalysis$1.RMS_WINDOW_TIME_DENOMINATOR + 1);\n\nfunction GainAnalysis$1() {\n    /**\n     * calibration value for 89dB\n     */\n    var PINK_REF = 64.82;\n\n    var YULE_ORDER = GainAnalysis$1.YULE_ORDER;\n    /**\n     * percentile which is louder than the proposed level\n     */\n    var RMS_PERCENTILE = 0.95;\n    /**\n     * maximum allowed sample frequency [Hz]\n     */\n    var MAX_SAMP_FREQ = GainAnalysis$1.MAX_SAMP_FREQ;\n    var RMS_WINDOW_TIME_NUMERATOR = GainAnalysis$1.RMS_WINDOW_TIME_NUMERATOR;\n    /**\n     * numerator / denominator = time slice size [s]\n     */\n    var RMS_WINDOW_TIME_DENOMINATOR = GainAnalysis$1.RMS_WINDOW_TIME_DENOMINATOR;\n    /**\n     * max. Samples per Time slice\n     */\n    var MAX_SAMPLES_PER_WINDOW = GainAnalysis$1.MAX_SAMPLES_PER_WINDOW;\n\n\n    var ABYule = [\n        [0.03857599435200, -3.84664617118067, -0.02160367184185,\n            7.81501653005538, -0.00123395316851, -11.34170355132042,\n            -0.00009291677959, 13.05504219327545, -0.01655260341619,\n            -12.28759895145294, 0.02161526843274, 9.48293806319790,\n            -0.02074045215285, -5.87257861775999, 0.00594298065125,\n            2.75465861874613, 0.00306428023191, -0.86984376593551,\n            0.00012025322027, 0.13919314567432, 0.00288463683916],\n        [0.05418656406430, -3.47845948550071, -0.02911007808948,\n            6.36317777566148, -0.00848709379851, -8.54751527471874,\n            -0.00851165645469, 9.47693607801280, -0.00834990904936,\n            -8.81498681370155, 0.02245293253339, 6.85401540936998,\n            -0.02596338512915, -4.39470996079559, 0.01624864962975,\n            2.19611684890774, -0.00240879051584, -0.75104302451432,\n            0.00674613682247, 0.13149317958808, -0.00187763777362],\n        [0.15457299681924, -2.37898834973084, -0.09331049056315,\n            2.84868151156327, -0.06247880153653, -2.64577170229825,\n            0.02163541888798, 2.23697657451713, -0.05588393329856,\n            -1.67148153367602, 0.04781476674921, 1.00595954808547,\n            0.00222312597743, -0.45953458054983, 0.03174092540049,\n            0.16378164858596, -0.01390589421898, -0.05032077717131,\n            0.00651420667831, 0.02347897407020, -0.00881362733839],\n        [0.30296907319327, -1.61273165137247, -0.22613988682123,\n            1.07977492259970, -0.08587323730772, -0.25656257754070,\n            0.03282930172664, -0.16276719120440, -0.00915702933434,\n            -0.22638893773906, -0.02364141202522, 0.39120800788284,\n            -0.00584456039913, -0.22138138954925, 0.06276101321749,\n            0.04500235387352, -0.00000828086748, 0.02005851806501,\n            0.00205861885564, 0.00302439095741, -0.02950134983287],\n        [0.33642304856132, -1.49858979367799, -0.25572241425570,\n            0.87350271418188, -0.11828570177555, 0.12205022308084,\n            0.11921148675203, -0.80774944671438, -0.07834489609479,\n            0.47854794562326, -0.00469977914380, -0.12453458140019,\n            -0.00589500224440, -0.04067510197014, 0.05724228140351,\n            0.08333755284107, 0.00832043980773, -0.04237348025746,\n            -0.01635381384540, 0.02977207319925, -0.01760176568150],\n        [0.44915256608450, -0.62820619233671, -0.14351757464547,\n            0.29661783706366, -0.22784394429749, -0.37256372942400,\n            -0.01419140100551, 0.00213767857124, 0.04078262797139,\n            -0.42029820170918, -0.12398163381748, 0.22199650564824,\n            0.04097565135648, 0.00613424350682, 0.10478503600251,\n            0.06747620744683, -0.01863887810927, 0.05784820375801,\n            -0.03193428438915, 0.03222754072173, 0.00541907748707],\n        [0.56619470757641, -1.04800335126349, -0.75464456939302,\n            0.29156311971249, 0.16242137742230, -0.26806001042947,\n            0.16744243493672, 0.00819999645858, -0.18901604199609,\n            0.45054734505008, 0.30931782841830, -0.33032403314006,\n            -0.27562961986224, 0.06739368333110, 0.00647310677246,\n            -0.04784254229033, 0.08647503780351, 0.01639907836189,\n            -0.03788984554840, 0.01807364323573, -0.00588215443421],\n        [0.58100494960553, -0.51035327095184, -0.53174909058578,\n            -0.31863563325245, -0.14289799034253, -0.20256413484477,\n            0.17520704835522, 0.14728154134330, 0.02377945217615,\n            0.38952639978999, 0.15558449135573, -0.23313271880868,\n            -0.25344790059353, -0.05246019024463, 0.01628462406333,\n            -0.02505961724053, 0.06920467763959, 0.02442357316099,\n            -0.03721611395801, 0.01818801111503, -0.00749618797172],\n        [0.53648789255105, -0.25049871956020, -0.42163034350696,\n            -0.43193942311114, -0.00275953611929, -0.03424681017675,\n            0.04267842219415, -0.04678328784242, -0.10214864179676,\n            0.26408300200955, 0.14590772289388, 0.15113130533216,\n            -0.02459864859345, -0.17556493366449, -0.11202315195388,\n            -0.18823009262115, -0.04060034127000, 0.05477720428674,\n            0.04788665548180, 0.04704409688120, -0.02217936801134]];\n\n    var ABButter = [\n        [0.98621192462708, -1.97223372919527, -1.97242384925416,\n            0.97261396931306, 0.98621192462708],\n        [0.98500175787242, -1.96977855582618, -1.97000351574484,\n            0.97022847566350, 0.98500175787242],\n        [0.97938932735214, -1.95835380975398, -1.95877865470428,\n            0.95920349965459, 0.97938932735214],\n        [0.97531843204928, -1.95002759149878, -1.95063686409857,\n            0.95124613669835, 0.97531843204928],\n        [0.97316523498161, -1.94561023566527, -1.94633046996323,\n            0.94705070426118, 0.97316523498161],\n        [0.96454515552826, -1.92783286977036, -1.92909031105652,\n            0.93034775234268, 0.96454515552826],\n        [0.96009142950541, -1.91858953033784, -1.92018285901082,\n            0.92177618768381, 0.96009142950541],\n        [0.95856916599601, -1.91542108074780, -1.91713833199203,\n            0.91885558323625, 0.95856916599601],\n        [0.94597685600279, -1.88903307939452, -1.89195371200558,\n            0.89487434461664, 0.94597685600279]];\n\n\n    /**\n     * When calling this procedure, make sure that ip[-order] and op[-order]\n     * point to real data\n     */\n    //private void filterYule(final float[] input, int inputPos, float[] output,\n    //int outputPos, int nSamples, final float[] kernel) {\n    function filterYule(input, inputPos, output, outputPos, nSamples, kernel) {\n\n        while ((nSamples--) != 0) {\n            /* 1e-10 is a hack to avoid slowdown because of denormals */\n            output[outputPos] = 1e-10 + input[inputPos + 0] * kernel[0]\n                - output[outputPos - 1] * kernel[1] + input[inputPos - 1]\n                * kernel[2] - output[outputPos - 2] * kernel[3]\n                + input[inputPos - 2] * kernel[4] - output[outputPos - 3]\n                * kernel[5] + input[inputPos - 3] * kernel[6]\n                - output[outputPos - 4] * kernel[7] + input[inputPos - 4]\n                * kernel[8] - output[outputPos - 5] * kernel[9]\n                + input[inputPos - 5] * kernel[10] - output[outputPos - 6]\n                * kernel[11] + input[inputPos - 6] * kernel[12]\n                - output[outputPos - 7] * kernel[13] + input[inputPos - 7]\n                * kernel[14] - output[outputPos - 8] * kernel[15]\n                + input[inputPos - 8] * kernel[16] - output[outputPos - 9]\n                * kernel[17] + input[inputPos - 9] * kernel[18]\n                - output[outputPos - 10] * kernel[19]\n                + input[inputPos - 10] * kernel[20];\n            ++outputPos;\n            ++inputPos;\n        }\n    }\n\n//private void filterButter(final float[] input, int inputPos,\n//    float[] output, int outputPos, int nSamples, final float[] kernel) {\n    function filterButter(input, inputPos, output, outputPos, nSamples, kernel) {\n\n        while ((nSamples--) != 0) {\n            output[outputPos] = input[inputPos + 0] * kernel[0]\n                - output[outputPos - 1] * kernel[1] + input[inputPos - 1]\n                * kernel[2] - output[outputPos - 2] * kernel[3]\n                + input[inputPos - 2] * kernel[4];\n            ++outputPos;\n            ++inputPos;\n        }\n    }\n\n    /**\n     * @return INIT_GAIN_ANALYSIS_OK if successful, INIT_GAIN_ANALYSIS_ERROR if\n     *         not\n     */\n    function ResetSampleFrequency(rgData, samplefreq) {\n        /* zero out initial values */\n        for (var i = 0; i < MAX_ORDER; i++)\n            rgData.linprebuf[i] = rgData.lstepbuf[i] = rgData.loutbuf[i] = rgData.rinprebuf[i] = rgData.rstepbuf[i] = rgData.routbuf[i] = 0.;\n\n        switch (0 | (samplefreq)) {\n            case 48000:\n                rgData.reqindex = 0;\n                break;\n            case 44100:\n                rgData.reqindex = 1;\n                break;\n            case 32000:\n                rgData.reqindex = 2;\n                break;\n            case 24000:\n                rgData.reqindex = 3;\n                break;\n            case 22050:\n                rgData.reqindex = 4;\n                break;\n            case 16000:\n                rgData.reqindex = 5;\n                break;\n            case 12000:\n                rgData.reqindex = 6;\n                break;\n            case 11025:\n                rgData.reqindex = 7;\n                break;\n            case 8000:\n                rgData.reqindex = 8;\n                break;\n            default:\n                return INIT_GAIN_ANALYSIS_ERROR;\n        }\n\n        rgData.sampleWindow = 0 | ((samplefreq * RMS_WINDOW_TIME_NUMERATOR\n            + RMS_WINDOW_TIME_DENOMINATOR - 1) / RMS_WINDOW_TIME_DENOMINATOR);\n\n        rgData.lsum = 0.;\n        rgData.rsum = 0.;\n        rgData.totsamp = 0;\n\n        Arrays$15.ill(rgData.A, 0);\n\n        return INIT_GAIN_ANALYSIS_OK;\n    }\n\n    this.InitGainAnalysis = function (rgData, samplefreq) {\n        if (ResetSampleFrequency(rgData, samplefreq) != INIT_GAIN_ANALYSIS_OK) {\n            return INIT_GAIN_ANALYSIS_ERROR;\n        }\n\n        rgData.linpre = MAX_ORDER;\n        rgData.rinpre = MAX_ORDER;\n        rgData.lstep = MAX_ORDER;\n        rgData.rstep = MAX_ORDER;\n        rgData.lout = MAX_ORDER;\n        rgData.rout = MAX_ORDER;\n\n        Arrays$15.fill(rgData.B, 0);\n\n        return INIT_GAIN_ANALYSIS_OK;\n    };\n\n    /**\n     * square\n     */\n    function fsqr(d) {\n        return d * d;\n    }\n\n    this.AnalyzeSamples = function (rgData, left_samples, left_samplesPos, right_samples, right_samplesPos, num_samples,\n                                    num_channels) {\n        var curleft;\n        var curleftBase;\n        var curright;\n        var currightBase;\n        var batchsamples;\n        var cursamples;\n        var cursamplepos;\n\n        if (num_samples == 0)\n            return GAIN_ANALYSIS_OK;\n\n        cursamplepos = 0;\n        batchsamples = num_samples;\n\n        switch (num_channels) {\n            case 1:\n                right_samples = left_samples;\n                right_samplesPos = left_samplesPos;\n                break;\n            case 2:\n                break;\n            default:\n                return GAIN_ANALYSIS_ERROR;\n        }\n\n        if (num_samples < MAX_ORDER) {\n            System$15.arraycopy(left_samples, left_samplesPos, rgData.linprebuf,\n                MAX_ORDER, num_samples);\n            System$15.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf,\n                MAX_ORDER, num_samples);\n        } else {\n            System$15.arraycopy(left_samples, left_samplesPos, rgData.linprebuf,\n                MAX_ORDER, MAX_ORDER);\n            System$15.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf,\n                MAX_ORDER, MAX_ORDER);\n        }\n\n        while (batchsamples > 0) {\n            cursamples = batchsamples > rgData.sampleWindow - rgData.totsamp ? rgData.sampleWindow\n            - rgData.totsamp\n                : batchsamples;\n            if (cursamplepos < MAX_ORDER) {\n                curleft = rgData.linpre + cursamplepos;\n                curleftBase = rgData.linprebuf;\n                curright = rgData.rinpre + cursamplepos;\n                currightBase = rgData.rinprebuf;\n                if (cursamples > MAX_ORDER - cursamplepos)\n                    cursamples = MAX_ORDER - cursamplepos;\n            } else {\n                curleft = left_samplesPos + cursamplepos;\n                curleftBase = left_samples;\n                curright = right_samplesPos + cursamplepos;\n                currightBase = right_samples;\n            }\n\n            filterYule(curleftBase, curleft, rgData.lstepbuf, rgData.lstep\n                + rgData.totsamp, cursamples, ABYule[rgData.reqindex]);\n            filterYule(currightBase, curright, rgData.rstepbuf, rgData.rstep\n                + rgData.totsamp, cursamples, ABYule[rgData.reqindex]);\n\n            filterButter(rgData.lstepbuf, rgData.lstep + rgData.totsamp,\n                rgData.loutbuf, rgData.lout + rgData.totsamp, cursamples,\n                ABButter[rgData.reqindex]);\n            filterButter(rgData.rstepbuf, rgData.rstep + rgData.totsamp,\n                rgData.routbuf, rgData.rout + rgData.totsamp, cursamples,\n                ABButter[rgData.reqindex]);\n\n            curleft = rgData.lout + rgData.totsamp;\n            /* Get the squared values */\n            curleftBase = rgData.loutbuf;\n            curright = rgData.rout + rgData.totsamp;\n            currightBase = rgData.routbuf;\n\n            var i = cursamples % 8;\n            while ((i--) != 0) {\n                rgData.lsum += fsqr(curleftBase[curleft++]);\n                rgData.rsum += fsqr(currightBase[curright++]);\n            }\n            i = cursamples / 8;\n            while ((i--) != 0) {\n                rgData.lsum += fsqr(curleftBase[curleft + 0])\n                    + fsqr(curleftBase[curleft + 1])\n                    + fsqr(curleftBase[curleft + 2])\n                    + fsqr(curleftBase[curleft + 3])\n                    + fsqr(curleftBase[curleft + 4])\n                    + fsqr(curleftBase[curleft + 5])\n                    + fsqr(curleftBase[curleft + 6])\n                    + fsqr(curleftBase[curleft + 7]);\n                curleft += 8;\n                rgData.rsum += fsqr(currightBase[curright + 0])\n                    + fsqr(currightBase[curright + 1])\n                    + fsqr(currightBase[curright + 2])\n                    + fsqr(currightBase[curright + 3])\n                    + fsqr(currightBase[curright + 4])\n                    + fsqr(currightBase[curright + 5])\n                    + fsqr(currightBase[curright + 6])\n                    + fsqr(currightBase[curright + 7]);\n                curright += 8;\n            }\n\n            batchsamples -= cursamples;\n            cursamplepos += cursamples;\n            rgData.totsamp += cursamples;\n            if (rgData.totsamp == rgData.sampleWindow) {\n                /* Get the Root Mean Square (RMS) for this set of samples */\n                var val = GainAnalysis$1.STEPS_per_dB\n                    * 10.\n                    * Math.log10((rgData.lsum + rgData.rsum)\n                        / rgData.totsamp * 0.5 + 1.e-37);\n                var ival = (val <= 0) ? 0 : 0 | val;\n                if (ival >= rgData.A.length)\n                    ival = rgData.A.length - 1;\n                rgData.A[ival]++;\n                rgData.lsum = rgData.rsum = 0.;\n\n                System$15.arraycopy(rgData.loutbuf, rgData.totsamp,\n                    rgData.loutbuf, 0, MAX_ORDER);\n                System$15.arraycopy(rgData.routbuf, rgData.totsamp,\n                    rgData.routbuf, 0, MAX_ORDER);\n                System$15.arraycopy(rgData.lstepbuf, rgData.totsamp,\n                    rgData.lstepbuf, 0, MAX_ORDER);\n                System$15.arraycopy(rgData.rstepbuf, rgData.totsamp,\n                    rgData.rstepbuf, 0, MAX_ORDER);\n                rgData.totsamp = 0;\n            }\n            if (rgData.totsamp > rgData.sampleWindow) {\n                /*\n                 * somehow I really screwed up: Error in programming! Contact\n                 * author about totsamp > sampleWindow\n                 */\n                return GAIN_ANALYSIS_ERROR;\n            }\n        }\n        if (num_samples < MAX_ORDER) {\n            System$15.arraycopy(rgData.linprebuf, num_samples, rgData.linprebuf,\n                0, MAX_ORDER - num_samples);\n            System$15.arraycopy(rgData.rinprebuf, num_samples, rgData.rinprebuf,\n                0, MAX_ORDER - num_samples);\n            System$15.arraycopy(left_samples, left_samplesPos, rgData.linprebuf,\n                MAX_ORDER - num_samples, num_samples);\n            System$15.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf,\n                MAX_ORDER - num_samples, num_samples);\n        } else {\n            System$15.arraycopy(left_samples, left_samplesPos + num_samples\n                - MAX_ORDER, rgData.linprebuf, 0, MAX_ORDER);\n            System$15.arraycopy(right_samples, right_samplesPos + num_samples\n                - MAX_ORDER, rgData.rinprebuf, 0, MAX_ORDER);\n        }\n\n        return GAIN_ANALYSIS_OK;\n    };\n\n    function analyzeResult(Array, len) {\n        var i;\n\n        var elems = 0;\n        for (i = 0; i < len; i++)\n            elems += Array[i];\n        if (elems == 0)\n            return GAIN_NOT_ENOUGH_SAMPLES;\n\n        var upper = 0 | Math.ceil(elems * (1. - RMS_PERCENTILE));\n        for (i = len; i-- > 0;) {\n            if ((upper -= Array[i]) <= 0)\n                break;\n        }\n\n        //return (float) ((float) PINK_REF - (float) i / (float) STEPS_per_dB);\n        return (PINK_REF - i / GainAnalysis$1.STEPS_per_dB);\n    }\n\n    this.GetTitleGain = function (rgData) {\n        var retval = analyzeResult(rgData.A, rgData.A.length);\n\n        for (var i = 0; i < rgData.A.length; i++) {\n            rgData.B[i] += rgData.A[i];\n            rgData.A[i] = 0;\n        }\n\n        for (var i = 0; i < MAX_ORDER; i++)\n            rgData.linprebuf[i] = rgData.lstepbuf[i] = rgData.loutbuf[i] = rgData.rinprebuf[i] = rgData.rstepbuf[i] = rgData.routbuf[i] = 0.;\n\n        rgData.totsamp = 0;\n        rgData.lsum = rgData.rsum = 0.;\n        return retval;\n    };\n\n}\n\nvar GainAnalysis_1 = GainAnalysis$1;\n\nvar new_float$14 = common.new_float;\nvar new_int$14 = common.new_int;\nfunction ReplayGain() {\n    this.linprebuf = new_float$14(GainAnalysis_1.MAX_ORDER * 2);\n    /**\n     * left input samples, with pre-buffer\n     */\n    this.linpre = 0;\n    this.lstepbuf = new_float$14(GainAnalysis_1.MAX_SAMPLES_PER_WINDOW + GainAnalysis_1.MAX_ORDER);\n    /**\n     * left \"first step\" (i.e. post first filter) samples\n     */\n    this.lstep = 0;\n    this.loutbuf = new_float$14(GainAnalysis_1.MAX_SAMPLES_PER_WINDOW + GainAnalysis_1.MAX_ORDER);\n    /**\n     * left \"out\" (i.e. post second filter) samples\n     */\n    this.lout = 0;\n    this.rinprebuf = new_float$14(GainAnalysis_1.MAX_ORDER * 2);\n    /**\n     * right input samples ...\n     */\n    this.rinpre = 0;\n    this.rstepbuf = new_float$14(GainAnalysis_1.MAX_SAMPLES_PER_WINDOW + GainAnalysis_1.MAX_ORDER);\n    this.rstep = 0;\n    this.routbuf = new_float$14(GainAnalysis_1.MAX_SAMPLES_PER_WINDOW + GainAnalysis_1.MAX_ORDER);\n    this.rout = 0;\n    /**\n     * number of samples required to reach number of milliseconds required\n     * for RMS window\n     */\n    this.sampleWindow = 0;\n    this.totsamp = 0;\n    this.lsum = 0.;\n    this.rsum = 0.;\n    this.freqindex = 0;\n    this.first = 0;\n    this.A = new_int$14(0 | (GainAnalysis_1.STEPS_per_dB * GainAnalysis_1.MAX_dB));\n    this.B = new_int$14(0 | (GainAnalysis_1.STEPS_per_dB * GainAnalysis_1.MAX_dB));\n\n}\n\nvar ReplayGain_1 = ReplayGain;\n\nfunction MeanBits$1(meanBits) {\n    this.bits = meanBits;\n}\n\nvar MeanBits_1 = MeanBits$1;\n\nvar new_float$16 = common.new_float;\nvar new_int$16 = common.new_int;\nvar assert$16 = common.assert;\n\n\n\n\n\n\nfunction CBRNewIterationLoop(_quantize)  {\n    var quantize = _quantize;\n    this.quantize = quantize;\n\tthis.iteration_loop = function(gfp, pe, ms_ener_ratio, ratio) {\n\t\tvar gfc = gfp.internal_flags;\n        var l3_xmin = new_float$16(L3Side_1.SFBMAX);\n\t\tvar xrpow = new_float$16(576);\n\t\tvar targ_bits = new_int$16(2);\n\t\tvar mean_bits = 0, max_bits;\n\t\tvar l3_side = gfc.l3_side;\n\n\t\tvar mb = new MeanBits_1(mean_bits);\n\t\tthis.quantize.rv.ResvFrameBegin(gfp, mb);\n\t\tmean_bits = mb.bits;\n\n\t\t/* quantize! */\n\t\tfor (var gr = 0; gr < gfc.mode_gr; gr++) {\n\n\t\t\t/*\n\t\t\t * calculate needed bits\n\t\t\t */\n\t\t\tmax_bits = this.quantize.qupvt.on_pe(gfp, pe, targ_bits, mean_bits,\n\t\t\t\t\tgr, gr);\n\n\t\t\tif (gfc.mode_ext == Encoder_1.MPG_MD_MS_LR) {\n\t\t\t\tthis.quantize.ms_convert(gfc.l3_side, gr);\n\t\t\t\tthis.quantize.qupvt.reduce_side(targ_bits, ms_ener_ratio[gr],\n\t\t\t\t\t\tmean_bits, max_bits);\n\t\t\t}\n\n\t\t\tfor (var ch = 0; ch < gfc.channels_out; ch++) {\n\t\t\t\tvar adjust, masking_lower_db;\n\t\t\t\tvar cod_info = l3_side.tt[gr][ch];\n\n\t\t\t\tif (cod_info.block_type != Encoder_1.SHORT_TYPE) {\n\t\t\t\t\t// NORM, START or STOP type\n\t\t\t\t\tadjust = 0;\n\t\t\t\t\tmasking_lower_db = gfc.PSY.mask_adjust - adjust;\n\t\t\t\t} else {\n\t\t\t\t\tadjust = 0;\n\t\t\t\t\tmasking_lower_db = gfc.PSY.mask_adjust_short - adjust;\n\t\t\t\t}\n\t\t\t\tgfc.masking_lower =  Math.pow(10.0,\n\t\t\t\t\t\tmasking_lower_db * 0.1);\n\n\t\t\t\t/*\n\t\t\t\t * init_outer_loop sets up cod_info, scalefac and xrpow\n\t\t\t\t */\n\t\t\t\tthis.quantize.init_outer_loop(gfc, cod_info);\n\t\t\t\tif (this.quantize.init_xrpow(gfc, cod_info, xrpow)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * xr contains energy we will have to encode calculate the\n\t\t\t\t\t * masking abilities find some good quantization in\n\t\t\t\t\t * outer_loop\n\t\t\t\t\t */\n\t\t\t\t\tthis.quantize.qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info,\n\t\t\t\t\t\t\tl3_xmin);\n\t\t\t\t\tthis.quantize.outer_loop(gfp, cod_info, l3_xmin, xrpow, ch,\n\t\t\t\t\t\t\ttarg_bits[ch]);\n\t\t\t\t}\n\n\t\t\t\tthis.quantize.iteration_finish_one(gfc, gr, ch);\n\t\t\t\tassert$16 (cod_info.part2_3_length <= LameInternalFlags_1.MAX_BITS_PER_CHANNEL);\n\t\t\t\tassert$16 (cod_info.part2_3_length <= targ_bits[ch]);\n\t\t\t} /* for ch */\n\t\t} /* for gr */\n\n\t\tthis.quantize.rv.ResvFrameEnd(gfc, mean_bits);\n\t};\n}\nvar CBRNewIterationLoop_1 = CBRNewIterationLoop;\n\nfunction HuffCodeTab(len, max, tab, hl) {\n    this.xlen = len;\n    this.linmax = max;\n    this.table = tab;\n    this.hlen = hl;\n}\n\nvar Tables$1 = {};\n\n\nTables$1.t1HB = [\n    1, 1,\n    1, 0\n];\n\nTables$1.t2HB = [\n    1, 2, 1,\n    3, 1, 1,\n    3, 2, 0\n];\n\nTables$1.t3HB = [\n    3, 2, 1,\n    1, 1, 1,\n    3, 2, 0\n];\n\nTables$1.t5HB = [\n    1, 2, 6, 5,\n    3, 1, 4, 4,\n    7, 5, 7, 1,\n    6, 1, 1, 0\n];\n\nTables$1.t6HB = [\n    7, 3, 5, 1,\n    6, 2, 3, 2,\n    5, 4, 4, 1,\n    3, 3, 2, 0\n];\n\nTables$1.t7HB = [\n    1, 2, 10, 19, 16, 10,\n    3, 3, 7, 10, 5, 3,\n    11, 4, 13, 17, 8, 4,\n    12, 11, 18, 15, 11, 2,\n    7, 6, 9, 14, 3, 1,\n    6, 4, 5, 3, 2, 0\n];\n\nTables$1.t8HB = [\n    3, 4, 6, 18, 12, 5,\n    5, 1, 2, 16, 9, 3,\n    7, 3, 5, 14, 7, 3,\n    19, 17, 15, 13, 10, 4,\n    13, 5, 8, 11, 5, 1,\n    12, 4, 4, 1, 1, 0\n];\n\nTables$1.t9HB = [\n    7, 5, 9, 14, 15, 7,\n    6, 4, 5, 5, 6, 7,\n    7, 6, 8, 8, 8, 5,\n    15, 6, 9, 10, 5, 1,\n    11, 7, 9, 6, 4, 1,\n    14, 4, 6, 2, 6, 0\n];\n\nTables$1.t10HB = [\n    1, 2, 10, 23, 35, 30, 12, 17,\n    3, 3, 8, 12, 18, 21, 12, 7,\n    11, 9, 15, 21, 32, 40, 19, 6,\n    14, 13, 22, 34, 46, 23, 18, 7,\n    20, 19, 33, 47, 27, 22, 9, 3,\n    31, 22, 41, 26, 21, 20, 5, 3,\n    14, 13, 10, 11, 16, 6, 5, 1,\n    9, 8, 7, 8, 4, 4, 2, 0\n];\n\nTables$1.t11HB = [\n    3, 4, 10, 24, 34, 33, 21, 15,\n    5, 3, 4, 10, 32, 17, 11, 10,\n    11, 7, 13, 18, 30, 31, 20, 5,\n    25, 11, 19, 59, 27, 18, 12, 5,\n    35, 33, 31, 58, 30, 16, 7, 5,\n    28, 26, 32, 19, 17, 15, 8, 14,\n    14, 12, 9, 13, 14, 9, 4, 1,\n    11, 4, 6, 6, 6, 3, 2, 0\n];\n\nTables$1.t12HB = [\n    9, 6, 16, 33, 41, 39, 38, 26,\n    7, 5, 6, 9, 23, 16, 26, 11,\n    17, 7, 11, 14, 21, 30, 10, 7,\n    17, 10, 15, 12, 18, 28, 14, 5,\n    32, 13, 22, 19, 18, 16, 9, 5,\n    40, 17, 31, 29, 17, 13, 4, 2,\n    27, 12, 11, 15, 10, 7, 4, 1,\n    27, 12, 8, 12, 6, 3, 1, 0\n];\n\nTables$1.t13HB = [\n    1, 5, 14, 21, 34, 51, 46, 71, 42, 52, 68, 52, 67, 44, 43, 19,\n    3, 4, 12, 19, 31, 26, 44, 33, 31, 24, 32, 24, 31, 35, 22, 14,\n    15, 13, 23, 36, 59, 49, 77, 65, 29, 40, 30, 40, 27, 33, 42, 16,\n    22, 20, 37, 61, 56, 79, 73, 64, 43, 76, 56, 37, 26, 31, 25, 14,\n    35, 16, 60, 57, 97, 75, 114, 91, 54, 73, 55, 41, 48, 53, 23, 24,\n    58, 27, 50, 96, 76, 70, 93, 84, 77, 58, 79, 29, 74, 49, 41, 17,\n    47, 45, 78, 74, 115, 94, 90, 79, 69, 83, 71, 50, 59, 38, 36, 15,\n    72, 34, 56, 95, 92, 85, 91, 90, 86, 73, 77, 65, 51, 44, 43, 42,\n    43, 20, 30, 44, 55, 78, 72, 87, 78, 61, 46, 54, 37, 30, 20, 16,\n    53, 25, 41, 37, 44, 59, 54, 81, 66, 76, 57, 54, 37, 18, 39, 11,\n    35, 33, 31, 57, 42, 82, 72, 80, 47, 58, 55, 21, 22, 26, 38, 22,\n    53, 25, 23, 38, 70, 60, 51, 36, 55, 26, 34, 23, 27, 14, 9, 7,\n    34, 32, 28, 39, 49, 75, 30, 52, 48, 40, 52, 28, 18, 17, 9, 5,\n    45, 21, 34, 64, 56, 50, 49, 45, 31, 19, 12, 15, 10, 7, 6, 3,\n    48, 23, 20, 39, 36, 35, 53, 21, 16, 23, 13, 10, 6, 1, 4, 2,\n    16, 15, 17, 27, 25, 20, 29, 11, 17, 12, 16, 8, 1, 1, 0, 1\n];\n\nTables$1.t15HB = [\n    7, 12, 18, 53, 47, 76, 124, 108, 89, 123, 108, 119, 107, 81, 122, 63,\n    13, 5, 16, 27, 46, 36, 61, 51, 42, 70, 52, 83, 65, 41, 59, 36,\n    19, 17, 15, 24, 41, 34, 59, 48, 40, 64, 50, 78, 62, 80, 56, 33,\n    29, 28, 25, 43, 39, 63, 55, 93, 76, 59, 93, 72, 54, 75, 50, 29,\n    52, 22, 42, 40, 67, 57, 95, 79, 72, 57, 89, 69, 49, 66, 46, 27,\n    77, 37, 35, 66, 58, 52, 91, 74, 62, 48, 79, 63, 90, 62, 40, 38,\n    125, 32, 60, 56, 50, 92, 78, 65, 55, 87, 71, 51, 73, 51, 70, 30,\n    109, 53, 49, 94, 88, 75, 66, 122, 91, 73, 56, 42, 64, 44, 21, 25,\n    90, 43, 41, 77, 73, 63, 56, 92, 77, 66, 47, 67, 48, 53, 36, 20,\n    71, 34, 67, 60, 58, 49, 88, 76, 67, 106, 71, 54, 38, 39, 23, 15,\n    109, 53, 51, 47, 90, 82, 58, 57, 48, 72, 57, 41, 23, 27, 62, 9,\n    86, 42, 40, 37, 70, 64, 52, 43, 70, 55, 42, 25, 29, 18, 11, 11,\n    118, 68, 30, 55, 50, 46, 74, 65, 49, 39, 24, 16, 22, 13, 14, 7,\n    91, 44, 39, 38, 34, 63, 52, 45, 31, 52, 28, 19, 14, 8, 9, 3,\n    123, 60, 58, 53, 47, 43, 32, 22, 37, 24, 17, 12, 15, 10, 2, 1,\n    71, 37, 34, 30, 28, 20, 17, 26, 21, 16, 10, 6, 8, 6, 2, 0\n];\n\nTables$1.t16HB = [\n    1, 5, 14, 44, 74, 63, 110, 93, 172, 149, 138, 242, 225, 195, 376, 17,\n    3, 4, 12, 20, 35, 62, 53, 47, 83, 75, 68, 119, 201, 107, 207, 9,\n    15, 13, 23, 38, 67, 58, 103, 90, 161, 72, 127, 117, 110, 209, 206, 16,\n    45, 21, 39, 69, 64, 114, 99, 87, 158, 140, 252, 212, 199, 387, 365, 26,\n    75, 36, 68, 65, 115, 101, 179, 164, 155, 264, 246, 226, 395, 382, 362, 9,\n    66, 30, 59, 56, 102, 185, 173, 265, 142, 253, 232, 400, 388, 378, 445, 16,\n    111, 54, 52, 100, 184, 178, 160, 133, 257, 244, 228, 217, 385, 366, 715, 10,\n    98, 48, 91, 88, 165, 157, 148, 261, 248, 407, 397, 372, 380, 889, 884, 8,\n    85, 84, 81, 159, 156, 143, 260, 249, 427, 401, 392, 383, 727, 713, 708, 7,\n    154, 76, 73, 141, 131, 256, 245, 426, 406, 394, 384, 735, 359, 710, 352, 11,\n    139, 129, 67, 125, 247, 233, 229, 219, 393, 743, 737, 720, 885, 882, 439, 4,\n    243, 120, 118, 115, 227, 223, 396, 746, 742, 736, 721, 712, 706, 223, 436, 6,\n    202, 224, 222, 218, 216, 389, 386, 381, 364, 888, 443, 707, 440, 437, 1728, 4,\n    747, 211, 210, 208, 370, 379, 734, 723, 714, 1735, 883, 877, 876, 3459, 865, 2,\n    377, 369, 102, 187, 726, 722, 358, 711, 709, 866, 1734, 871, 3458, 870, 434, 0,\n    12, 10, 7, 11, 10, 17, 11, 9, 13, 12, 10, 7, 5, 3, 1, 3\n];\n\nTables$1.t24HB = [\n    15, 13, 46, 80, 146, 262, 248, 434, 426, 669, 653, 649, 621, 517, 1032, 88,\n    14, 12, 21, 38, 71, 130, 122, 216, 209, 198, 327, 345, 319, 297, 279, 42,\n    47, 22, 41, 74, 68, 128, 120, 221, 207, 194, 182, 340, 315, 295, 541, 18,\n    81, 39, 75, 70, 134, 125, 116, 220, 204, 190, 178, 325, 311, 293, 271, 16,\n    147, 72, 69, 135, 127, 118, 112, 210, 200, 188, 352, 323, 306, 285, 540, 14,\n    263, 66, 129, 126, 119, 114, 214, 202, 192, 180, 341, 317, 301, 281, 262, 12,\n    249, 123, 121, 117, 113, 215, 206, 195, 185, 347, 330, 308, 291, 272, 520, 10,\n    435, 115, 111, 109, 211, 203, 196, 187, 353, 332, 313, 298, 283, 531, 381, 17,\n    427, 212, 208, 205, 201, 193, 186, 177, 169, 320, 303, 286, 268, 514, 377, 16,\n    335, 199, 197, 191, 189, 181, 174, 333, 321, 305, 289, 275, 521, 379, 371, 11,\n    668, 184, 183, 179, 175, 344, 331, 314, 304, 290, 277, 530, 383, 373, 366, 10,\n    652, 346, 171, 168, 164, 318, 309, 299, 287, 276, 263, 513, 375, 368, 362, 6,\n    648, 322, 316, 312, 307, 302, 292, 284, 269, 261, 512, 376, 370, 364, 359, 4,\n    620, 300, 296, 294, 288, 282, 273, 266, 515, 380, 374, 369, 365, 361, 357, 2,\n    1033, 280, 278, 274, 267, 264, 259, 382, 378, 372, 367, 363, 360, 358, 356, 0,\n    43, 20, 19, 17, 15, 13, 11, 9, 7, 6, 4, 7, 5, 3, 1, 3\n];\n\nTables$1.t32HB = [\n    1 << 0, 5 << 1, 4 << 1, 5 << 2, 6 << 1, 5 << 2, 4 << 2, 4 << 3,\n    7 << 1, 3 << 2, 6 << 2, 0 << 3, 7 << 2, 2 << 3, 3 << 3, 1 << 4\n];\n\nTables$1.t33HB = [\n    15 << 0, 14 << 1, 13 << 1, 12 << 2, 11 << 1, 10 << 2, 9 << 2, 8 << 3,\n    7 << 1, 6 << 2, 5 << 2, 4 << 3, 3 << 2, 2 << 3, 1 << 3, 0 << 4\n];\n\nTables$1.t1l = [\n    1, 4,\n    3, 5\n];\n\nTables$1.t2l = [\n    1, 4, 7,\n    4, 5, 7,\n    6, 7, 8\n];\n\nTables$1.t3l = [\n    2, 3, 7,\n    4, 4, 7,\n    6, 7, 8\n];\n\nTables$1.t5l = [\n    1, 4, 7, 8,\n    4, 5, 8, 9,\n    7, 8, 9, 10,\n    8, 8, 9, 10\n];\n\nTables$1.t6l = [\n    3, 4, 6, 8,\n    4, 4, 6, 7,\n    5, 6, 7, 8,\n    7, 7, 8, 9\n];\n\nTables$1.t7l = [\n    1, 4, 7, 9, 9, 10,\n    4, 6, 8, 9, 9, 10,\n    7, 7, 9, 10, 10, 11,\n    8, 9, 10, 11, 11, 11,\n    8, 9, 10, 11, 11, 12,\n    9, 10, 11, 12, 12, 12\n];\n\nTables$1.t8l = [\n    2, 4, 7, 9, 9, 10,\n    4, 4, 6, 10, 10, 10,\n    7, 6, 8, 10, 10, 11,\n    9, 10, 10, 11, 11, 12,\n    9, 9, 10, 11, 12, 12,\n    10, 10, 11, 11, 13, 13\n];\n\nTables$1.t9l = [\n    3, 4, 6, 7, 9, 10,\n    4, 5, 6, 7, 8, 10,\n    5, 6, 7, 8, 9, 10,\n    7, 7, 8, 9, 9, 10,\n    8, 8, 9, 9, 10, 11,\n    9, 9, 10, 10, 11, 11\n];\n\nTables$1.t10l = [\n    1, 4, 7, 9, 10, 10, 10, 11,\n    4, 6, 8, 9, 10, 11, 10, 10,\n    7, 8, 9, 10, 11, 12, 11, 11,\n    8, 9, 10, 11, 12, 12, 11, 12,\n    9, 10, 11, 12, 12, 12, 12, 12,\n    10, 11, 12, 12, 13, 13, 12, 13,\n    9, 10, 11, 12, 12, 12, 13, 13,\n    10, 10, 11, 12, 12, 13, 13, 13\n];\n\nTables$1.t11l = [\n    2, 4, 6, 8, 9, 10, 9, 10,\n    4, 5, 6, 8, 10, 10, 9, 10,\n    6, 7, 8, 9, 10, 11, 10, 10,\n    8, 8, 9, 11, 10, 12, 10, 11,\n    9, 10, 10, 11, 11, 12, 11, 12,\n    9, 10, 11, 12, 12, 13, 12, 13,\n    9, 9, 9, 10, 11, 12, 12, 12,\n    9, 9, 10, 11, 12, 12, 12, 12\n];\n\nTables$1.t12l = [\n    4, 4, 6, 8, 9, 10, 10, 10,\n    4, 5, 6, 7, 9, 9, 10, 10,\n    6, 6, 7, 8, 9, 10, 9, 10,\n    7, 7, 8, 8, 9, 10, 10, 10,\n    8, 8, 9, 9, 10, 10, 10, 11,\n    9, 9, 10, 10, 10, 11, 10, 11,\n    9, 9, 9, 10, 10, 11, 11, 12,\n    10, 10, 10, 11, 11, 11, 11, 12\n];\n\nTables$1.t13l = [\n    1, 5, 7, 8, 9, 10, 10, 11, 10, 11, 12, 12, 13, 13, 14, 14,\n    4, 6, 8, 9, 10, 10, 11, 11, 11, 11, 12, 12, 13, 14, 14, 14,\n    7, 8, 9, 10, 11, 11, 12, 12, 11, 12, 12, 13, 13, 14, 15, 15,\n    8, 9, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 15, 15,\n    9, 9, 11, 11, 12, 12, 13, 13, 12, 13, 13, 14, 14, 15, 15, 16,\n    10, 10, 11, 12, 12, 12, 13, 13, 13, 13, 14, 13, 15, 15, 16, 16,\n    10, 11, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16,\n    11, 11, 12, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 16, 18, 18,\n    10, 10, 11, 12, 12, 13, 13, 14, 14, 14, 14, 15, 15, 16, 17, 17,\n    11, 11, 12, 12, 13, 13, 13, 15, 14, 15, 15, 16, 16, 16, 18, 17,\n    11, 12, 12, 13, 13, 14, 14, 15, 14, 15, 16, 15, 16, 17, 18, 19,\n    12, 12, 12, 13, 14, 14, 14, 14, 15, 15, 15, 16, 17, 17, 17, 18,\n    12, 13, 13, 14, 14, 15, 14, 15, 16, 16, 17, 17, 17, 18, 18, 18,\n    13, 13, 14, 15, 15, 15, 16, 16, 16, 16, 16, 17, 18, 17, 18, 18,\n    14, 14, 14, 15, 15, 15, 17, 16, 16, 19, 17, 17, 17, 19, 18, 18,\n    13, 14, 15, 16, 16, 16, 17, 16, 17, 17, 18, 18, 21, 20, 21, 18\n];\n\nTables$1.t15l = [\n    3, 5, 6, 8, 8, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 14,\n    5, 5, 7, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13,\n    6, 7, 7, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 13, 13, 13,\n    7, 8, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13,\n    8, 8, 9, 9, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 13, 13,\n    9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 14,\n    10, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 13, 14, 14,\n    10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 14,\n    10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 14, 14, 14,\n    10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14,\n    11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 15, 14,\n    11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15,\n    12, 12, 11, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 15, 15,\n    12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15,\n    13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 14, 15,\n    13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15\n];\n\nTables$1.t16_5l = [\n    1, 5, 7, 9, 10, 10, 11, 11, 12, 12, 12, 13, 13, 13, 14, 11,\n    4, 6, 8, 9, 10, 11, 11, 11, 12, 12, 12, 13, 14, 13, 14, 11,\n    7, 8, 9, 10, 11, 11, 12, 12, 13, 12, 13, 13, 13, 14, 14, 12,\n    9, 9, 10, 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 13,\n    10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 12,\n    10, 10, 11, 11, 12, 13, 13, 14, 13, 14, 14, 15, 15, 15, 16, 13,\n    11, 11, 11, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 16, 13,\n    11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 15, 17, 17, 13,\n    11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 13,\n    12, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 15, 16, 15, 14,\n    12, 13, 12, 13, 14, 14, 14, 14, 15, 16, 16, 16, 17, 17, 16, 13,\n    13, 13, 13, 13, 14, 14, 15, 16, 16, 16, 16, 16, 16, 15, 16, 14,\n    13, 14, 14, 14, 14, 15, 15, 15, 15, 17, 16, 16, 16, 16, 18, 14,\n    15, 14, 14, 14, 15, 15, 16, 16, 16, 18, 17, 17, 17, 19, 17, 14,\n    14, 15, 13, 14, 16, 16, 15, 16, 16, 17, 18, 17, 19, 17, 16, 14,\n    11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 12\n];\n\nTables$1.t16l = [\n    1, 5, 7, 9, 10, 10, 11, 11, 12, 12, 12, 13, 13, 13, 14, 10,\n    4, 6, 8, 9, 10, 11, 11, 11, 12, 12, 12, 13, 14, 13, 14, 10,\n    7, 8, 9, 10, 11, 11, 12, 12, 13, 12, 13, 13, 13, 14, 14, 11,\n    9, 9, 10, 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 12,\n    10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 11,\n    10, 10, 11, 11, 12, 13, 13, 14, 13, 14, 14, 15, 15, 15, 16, 12,\n    11, 11, 11, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 16, 12,\n    11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 15, 17, 17, 12,\n    11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 12,\n    12, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 15, 16, 15, 13,\n    12, 13, 12, 13, 14, 14, 14, 14, 15, 16, 16, 16, 17, 17, 16, 12,\n    13, 13, 13, 13, 14, 14, 15, 16, 16, 16, 16, 16, 16, 15, 16, 13,\n    13, 14, 14, 14, 14, 15, 15, 15, 15, 17, 16, 16, 16, 16, 18, 13,\n    15, 14, 14, 14, 15, 15, 16, 16, 16, 18, 17, 17, 17, 19, 17, 13,\n    14, 15, 13, 14, 16, 16, 15, 16, 16, 17, 18, 17, 19, 17, 16, 13,\n    10, 10, 10, 11, 11, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 10\n];\n\nTables$1.t24l = [\n    4, 5, 7, 8, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 13, 10,\n    5, 6, 7, 8, 9, 10, 10, 11, 11, 11, 12, 12, 12, 12, 12, 10,\n    7, 7, 8, 9, 9, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 9,\n    8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 9,\n    9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12, 13, 9,\n    10, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 9,\n    10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 9,\n    11, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 10,\n    11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 10,\n    11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 10,\n    12, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 10,\n    12, 12, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 10,\n    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 10,\n    12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 10,\n    13, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 10,\n    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 6\n];\n\nTables$1.t32l = [\n    1 + 0, 4 + 1, 4 + 1, 5 + 2, 4 + 1, 6 + 2, 5 + 2, 6 + 3,\n    4 + 1, 5 + 2, 5 + 2, 6 + 3, 5 + 2, 6 + 3, 6 + 3, 6 + 4\n];\n\nTables$1.t33l = [\n    4 + 0, 4 + 1, 4 + 1, 4 + 2, 4 + 1, 4 + 2, 4 + 2, 4 + 3,\n    4 + 1, 4 + 2, 4 + 2, 4 + 3, 4 + 2, 4 + 3, 4 + 3, 4 + 4\n];\n\nTables$1.ht = [\n    /* xlen, linmax, table, hlen */\n    new HuffCodeTab(0, 0, null, null),\n    new HuffCodeTab(2, 0, Tables$1.t1HB, Tables$1.t1l),\n    new HuffCodeTab(3, 0, Tables$1.t2HB, Tables$1.t2l),\n    new HuffCodeTab(3, 0, Tables$1.t3HB, Tables$1.t3l),\n    new HuffCodeTab(0, 0, null, null), /* Apparently not used */\n    new HuffCodeTab(4, 0, Tables$1.t5HB, Tables$1.t5l),\n    new HuffCodeTab(4, 0, Tables$1.t6HB, Tables$1.t6l),\n    new HuffCodeTab(6, 0, Tables$1.t7HB, Tables$1.t7l),\n    new HuffCodeTab(6, 0, Tables$1.t8HB, Tables$1.t8l),\n    new HuffCodeTab(6, 0, Tables$1.t9HB, Tables$1.t9l),\n    new HuffCodeTab(8, 0, Tables$1.t10HB, Tables$1.t10l),\n    new HuffCodeTab(8, 0, Tables$1.t11HB, Tables$1.t11l),\n    new HuffCodeTab(8, 0, Tables$1.t12HB, Tables$1.t12l),\n    new HuffCodeTab(16, 0, Tables$1.t13HB, Tables$1.t13l),\n    new HuffCodeTab(0, 0, null, Tables$1.t16_5l), /* Apparently not used */\n    new HuffCodeTab(16, 0, Tables$1.t15HB, Tables$1.t15l),\n\n    new HuffCodeTab(1, 1, Tables$1.t16HB, Tables$1.t16l),\n    new HuffCodeTab(2, 3, Tables$1.t16HB, Tables$1.t16l),\n    new HuffCodeTab(3, 7, Tables$1.t16HB, Tables$1.t16l),\n    new HuffCodeTab(4, 15, Tables$1.t16HB, Tables$1.t16l),\n    new HuffCodeTab(6, 63, Tables$1.t16HB, Tables$1.t16l),\n    new HuffCodeTab(8, 255, Tables$1.t16HB, Tables$1.t16l),\n    new HuffCodeTab(10, 1023, Tables$1.t16HB, Tables$1.t16l),\n    new HuffCodeTab(13, 8191, Tables$1.t16HB, Tables$1.t16l),\n\n    new HuffCodeTab(4, 15, Tables$1.t24HB, Tables$1.t24l),\n    new HuffCodeTab(5, 31, Tables$1.t24HB, Tables$1.t24l),\n    new HuffCodeTab(6, 63, Tables$1.t24HB, Tables$1.t24l),\n    new HuffCodeTab(7, 127, Tables$1.t24HB, Tables$1.t24l),\n    new HuffCodeTab(8, 255, Tables$1.t24HB, Tables$1.t24l),\n    new HuffCodeTab(9, 511, Tables$1.t24HB, Tables$1.t24l),\n    new HuffCodeTab(11, 2047, Tables$1.t24HB, Tables$1.t24l),\n    new HuffCodeTab(13, 8191, Tables$1.t24HB, Tables$1.t24l),\n\n    new HuffCodeTab(0, 0, Tables$1.t32HB, Tables$1.t32l),\n    new HuffCodeTab(0, 0, Tables$1.t33HB, Tables$1.t33l),\n];\n\n/**\n * <CODE>\n *  for (i = 0; i < 16*16; i++) [\n *      largetbl[i] = ((ht[16].hlen[i]) << 16) + ht[24].hlen[i];\n *  ]\n * </CODE>\n *\n */\nTables$1.largetbl = [\n    0x010004, 0x050005, 0x070007, 0x090008, 0x0a0009, 0x0a000a, 0x0b000a, 0x0b000b,\n    0x0c000b, 0x0c000c, 0x0c000c, 0x0d000c, 0x0d000c, 0x0d000c, 0x0e000d, 0x0a000a,\n    0x040005, 0x060006, 0x080007, 0x090008, 0x0a0009, 0x0b000a, 0x0b000a, 0x0b000b,\n    0x0c000b, 0x0c000b, 0x0c000c, 0x0d000c, 0x0e000c, 0x0d000c, 0x0e000c, 0x0a000a,\n    0x070007, 0x080007, 0x090008, 0x0a0009, 0x0b0009, 0x0b000a, 0x0c000a, 0x0c000b,\n    0x0d000b, 0x0c000b, 0x0d000b, 0x0d000c, 0x0d000c, 0x0e000c, 0x0e000d, 0x0b0009,\n    0x090008, 0x090008, 0x0a0009, 0x0b0009, 0x0b000a, 0x0c000a, 0x0c000a, 0x0c000b,\n    0x0d000b, 0x0d000b, 0x0e000b, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x0c0009,\n    0x0a0009, 0x0a0009, 0x0b0009, 0x0b000a, 0x0c000a, 0x0c000a, 0x0d000a, 0x0d000b,\n    0x0d000b, 0x0e000b, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x0f000d, 0x0b0009,\n    0x0a000a, 0x0a0009, 0x0b000a, 0x0b000a, 0x0c000a, 0x0d000a, 0x0d000b, 0x0e000b,\n    0x0d000b, 0x0e000b, 0x0e000c, 0x0f000c, 0x0f000c, 0x0f000c, 0x10000c, 0x0c0009,\n    0x0b000a, 0x0b000a, 0x0b000a, 0x0c000a, 0x0d000a, 0x0d000b, 0x0d000b, 0x0d000b,\n    0x0e000b, 0x0e000c, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x10000d, 0x0c0009,\n    0x0b000b, 0x0b000a, 0x0c000a, 0x0c000a, 0x0d000b, 0x0d000b, 0x0d000b, 0x0e000b,\n    0x0e000c, 0x0f000c, 0x0f000c, 0x0f000c, 0x0f000c, 0x11000d, 0x11000d, 0x0c000a,\n    0x0b000b, 0x0c000b, 0x0c000b, 0x0d000b, 0x0d000b, 0x0d000b, 0x0e000b, 0x0e000b,\n    0x0f000b, 0x0f000c, 0x0f000c, 0x0f000c, 0x10000c, 0x10000d, 0x10000d, 0x0c000a,\n    0x0c000b, 0x0c000b, 0x0c000b, 0x0d000b, 0x0d000b, 0x0e000b, 0x0e000b, 0x0f000c,\n    0x0f000c, 0x0f000c, 0x0f000c, 0x10000c, 0x0f000d, 0x10000d, 0x0f000d, 0x0d000a,\n    0x0c000c, 0x0d000b, 0x0c000b, 0x0d000b, 0x0e000b, 0x0e000c, 0x0e000c, 0x0e000c,\n    0x0f000c, 0x10000c, 0x10000c, 0x10000d, 0x11000d, 0x11000d, 0x10000d, 0x0c000a,\n    0x0d000c, 0x0d000c, 0x0d000b, 0x0d000b, 0x0e000b, 0x0e000c, 0x0f000c, 0x10000c,\n    0x10000c, 0x10000c, 0x10000c, 0x10000d, 0x10000d, 0x0f000d, 0x10000d, 0x0d000a,\n    0x0d000c, 0x0e000c, 0x0e000c, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x0f000c,\n    0x0f000c, 0x11000c, 0x10000d, 0x10000d, 0x10000d, 0x10000d, 0x12000d, 0x0d000a,\n    0x0f000c, 0x0e000c, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x10000c, 0x10000c,\n    0x10000d, 0x12000d, 0x11000d, 0x11000d, 0x11000d, 0x13000d, 0x11000d, 0x0d000a,\n    0x0e000d, 0x0f000c, 0x0d000c, 0x0e000c, 0x10000c, 0x10000c, 0x0f000c, 0x10000d,\n    0x10000d, 0x11000d, 0x12000d, 0x11000d, 0x13000d, 0x11000d, 0x10000d, 0x0d000a,\n    0x0a0009, 0x0a0009, 0x0a0009, 0x0b0009, 0x0b0009, 0x0c0009, 0x0c0009, 0x0c0009,\n    0x0d0009, 0x0d0009, 0x0d0009, 0x0d000a, 0x0d000a, 0x0d000a, 0x0d000a, 0x0a0006\n];\n/**\n * <CODE>\n *  for (i = 0; i < 3*3; i++) [\n *      table23[i] = ((ht[2].hlen[i]) << 16) + ht[3].hlen[i];\n *  ]\n * </CODE>\n *\n */\nTables$1.table23 = [\n    0x010002, 0x040003, 0x070007,\n    0x040004, 0x050004, 0x070007,\n    0x060006, 0x070007, 0x080008\n];\n\n/**\n * <CODE>\n *  for (i = 0; i < 4*4; i++) [\n *       table56[i] = ((ht[5].hlen[i]) << 16) + ht[6].hlen[i];\n *   ]\n * </CODE>\n *\n */\nTables$1.table56 = [\n    0x010003, 0x040004, 0x070006, 0x080008, 0x040004, 0x050004, 0x080006, 0x090007,\n    0x070005, 0x080006, 0x090007, 0x0a0008, 0x080007, 0x080007, 0x090008, 0x0a0009\n];\n\nTables$1.bitrate_table = [\n    [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1], /* MPEG 2 */\n    [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1], /* MPEG 1 */\n    [0, 8, 16, 24, 32, 40, 48, 56, 64, -1, -1, -1, -1, -1, -1, -1], /* MPEG 2.5 */\n];\n\n/**\n * MPEG 2, MPEG 1, MPEG 2.5.\n */\nTables$1.samplerate_table = [\n    [22050, 24000, 16000, -1],\n    [44100, 48000, 32000, -1],\n    [11025, 12000, 8000, -1],\n];\n\n/**\n * This is the scfsi_band table from 2.4.2.7 of the IS.\n */\nTables$1.scfsi_band = [0, 6, 11, 16, 21];\n\nvar Tables_1 = Tables$1;\n\nvar VbrMode$19 = common.VbrMode;\nvar Float$19 = common.Float;\nvar Util$19 = common.Util;\nvar new_float$19 = common.new_float;\nvar new_int$19 = common.new_int;\nvar assert$19 = common.assert;\n\n\n\n\n\nQuantizePVT$1.Q_MAX = (256 + 1);\nQuantizePVT$1.Q_MAX2 = 116;\nQuantizePVT$1.LARGE_BITS = 100000;\nQuantizePVT$1.IXMAX_VAL = 8206;\n\nfunction QuantizePVT$1() {\n\n    var tak = null;\n    var rv = null;\n    var psy = null;\n\n    this.setModules = function (_tk, _rv, _psy) {\n        tak = _tk;\n        rv = _rv;\n        psy = _psy;\n    };\n\n    function POW20(x) {\n        assert$19(0 <= (x + QuantizePVT$1.Q_MAX2) && x < QuantizePVT$1.Q_MAX);\n        return pow20[x + QuantizePVT$1.Q_MAX2];\n    }\n\n    this.IPOW20 = function (x) {\n        assert$19(0 <= x && x < QuantizePVT$1.Q_MAX);\n        return ipow20[x];\n    };\n\n    /**\n     * smallest such that 1.0+DBL_EPSILON != 1.0\n     */\n    var DBL_EPSILON = 2.2204460492503131e-016;\n\n    /**\n     * ix always <= 8191+15. see count_bits()\n     */\n    var IXMAX_VAL = QuantizePVT$1.IXMAX_VAL;\n\n    var PRECALC_SIZE = (IXMAX_VAL + 2);\n\n    var Q_MAX = QuantizePVT$1.Q_MAX;\n\n\n    /**\n     * <CODE>\n     * minimum possible number of\n     * -cod_info.global_gain + ((scalefac[] + (cod_info.preflag ? pretab[sfb] : 0))\n     * << (cod_info.scalefac_scale + 1)) + cod_info.subblock_gain[cod_info.window[sfb]] * 8;\n     *\n     * for long block, 0+((15+3)<<2) = 18*4 = 72\n     * for short block, 0+(15<<2)+7*8 = 15*4+56 = 116\n     * </CODE>\n     */\n    var Q_MAX2 = QuantizePVT$1.Q_MAX2;\n\n    var LARGE_BITS = QuantizePVT$1.LARGE_BITS;\n\n\n    /**\n     * Assuming dynamic range=96dB, this value should be 92\n     */\n    var NSATHSCALE = 100;\n\n    /**\n     * The following table is used to implement the scalefactor partitioning for\n     * MPEG2 as described in section 2.4.3.2 of the IS. The indexing corresponds\n     * to the way the tables are presented in the IS:\n     *\n     * [table_number][row_in_table][column of nr_of_sfb]\n     */\n    this.nr_of_sfb_block = [\n        [[6, 5, 5, 5], [9, 9, 9, 9], [6, 9, 9, 9]],\n        [[6, 5, 7, 3], [9, 9, 12, 6], [6, 9, 12, 6]],\n        [[11, 10, 0, 0], [18, 18, 0, 0], [15, 18, 0, 0]],\n        [[7, 7, 7, 0], [12, 12, 12, 0], [6, 15, 12, 0]],\n        [[6, 6, 6, 3], [12, 9, 9, 6], [6, 12, 9, 6]],\n        [[8, 8, 5, 0], [15, 12, 9, 0], [6, 18, 9, 0]]];\n\n    /**\n     * Table B.6: layer3 preemphasis\n     */\n    var pretab = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,\n        2, 2, 3, 3, 3, 2, 0];\n    this.pretab = pretab;\n\n    /**\n     * Here are MPEG1 Table B.8 and MPEG2 Table B.1 -- Layer III scalefactor\n     * bands. <BR>\n     * Index into this using a method such as:<BR>\n     * idx = fr_ps.header.sampling_frequency + (fr_ps.header.version * 3)\n     */\n    this.sfBandIndex = [\n        // Table B.2.b: 22.05 kHz\n        new ScaleFac_1([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464,\n                522, 576],\n            [0, 4, 8, 12, 18, 24, 32, 42, 56, 74, 100, 132, 174, 192]\n            , [0, 0, 0, 0, 0, 0, 0] //  sfb21 pseudo sub bands\n            , [0, 0, 0, 0, 0, 0, 0] //  sfb12 pseudo sub bands\n        ),\n        /* Table B.2.c: 24 kHz */ /* docs: 332. mpg123(broken): 330 */\n        new ScaleFac_1([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 114, 136, 162, 194, 232, 278, 332, 394, 464,\n                540, 576],\n            [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 136, 180, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* Table B.2.a: 16 kHz */\n        new ScaleFac_1([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464,\n                522, 576],\n            [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 134, 174, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* Table B.8.b: 44.1 kHz */\n        new ScaleFac_1([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 52, 62, 74, 90, 110, 134, 162, 196, 238, 288, 342, 418,\n                576],\n            [0, 4, 8, 12, 16, 22, 30, 40, 52, 66, 84, 106, 136, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* Table B.8.c: 48 kHz */\n        new ScaleFac_1([0, 4, 8, 12, 16, 20, 24, 30, 36, 42, 50, 60, 72, 88, 106, 128, 156, 190, 230, 276, 330, 384,\n                576],\n            [0, 4, 8, 12, 16, 22, 28, 38, 50, 64, 80, 100, 126, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* Table B.8.a: 32 kHz */\n        new ScaleFac_1([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 54, 66, 82, 102, 126, 156, 194, 240, 296, 364, 448, 550,\n                576],\n            [0, 4, 8, 12, 16, 22, 30, 42, 58, 78, 104, 138, 180, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* MPEG-2.5 11.025 kHz */\n        new ScaleFac_1([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464,\n                522, 576],\n            [0 / 3, 12 / 3, 24 / 3, 36 / 3, 54 / 3, 78 / 3, 108 / 3, 144 / 3, 186 / 3, 240 / 3, 312 / 3,\n                402 / 3, 522 / 3, 576 / 3]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* MPEG-2.5 12 kHz */\n        new ScaleFac_1([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464,\n                522, 576],\n            [0 / 3, 12 / 3, 24 / 3, 36 / 3, 54 / 3, 78 / 3, 108 / 3, 144 / 3, 186 / 3, 240 / 3, 312 / 3,\n                402 / 3, 522 / 3, 576 / 3]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* MPEG-2.5 8 kHz */\n        new ScaleFac_1([0, 12, 24, 36, 48, 60, 72, 88, 108, 132, 160, 192, 232, 280, 336, 400, 476, 566, 568, 570,\n                572, 574, 576],\n            [0 / 3, 24 / 3, 48 / 3, 72 / 3, 108 / 3, 156 / 3, 216 / 3, 288 / 3, 372 / 3, 480 / 3, 486 / 3,\n                492 / 3, 498 / 3, 576 / 3]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        )\n    ];\n\n    var pow20 = new_float$19(Q_MAX + Q_MAX2 + 1);\n    var ipow20 = new_float$19(Q_MAX);\n    var pow43 = new_float$19(PRECALC_SIZE);\n\n    var adj43 = new_float$19(PRECALC_SIZE);\n    this.adj43 = adj43;\n\n    /**\n     * <PRE>\n     * compute the ATH for each scalefactor band cd range: 0..96db\n     *\n     * Input: 3.3kHz signal 32767 amplitude (3.3kHz is where ATH is smallest =\n     * -5db) longblocks: sfb=12 en0/bw=-11db max_en0 = 1.3db shortblocks: sfb=5\n     * -9db 0db\n     *\n     * Input: 1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated) longblocks: amp=1\n     * sfb=12 en0/bw=-103 db max_en0 = -92db amp=32767 sfb=12 -12 db -1.4db\n     *\n     * Input: 1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated) shortblocks: amp=1\n     * sfb=5 en0/bw= -99 -86 amp=32767 sfb=5 -9 db 4db\n     *\n     *\n     * MAX energy of largest wave at 3.3kHz = 1db AVE energy of largest wave at\n     * 3.3kHz = -11db Let's take AVE: -11db = maximum signal in sfb=12. Dynamic\n     * range of CD: 96db. Therefor energy of smallest audible wave in sfb=12 =\n     * -11 - 96 = -107db = ATH at 3.3kHz.\n     *\n     * ATH formula for this wave: -5db. To adjust to LAME scaling, we need ATH =\n     * ATH_formula - 103 (db) ATH = ATH * 2.5e-10 (ener)\n     * </PRE>\n     */\n    function ATHmdct(gfp, f) {\n        var ath = psy.ATHformula(f, gfp);\n\n        ath -= NSATHSCALE;\n\n        /* modify the MDCT scaling for the ATH and convert to energy */\n        ath = Math.pow(10.0, ath / 10.0 + gfp.ATHlower);\n        return ath;\n    }\n\n    function compute_ath(gfp) {\n        var ATH_l = gfp.internal_flags.ATH.l;\n        var ATH_psfb21 = gfp.internal_flags.ATH.psfb21;\n        var ATH_s = gfp.internal_flags.ATH.s;\n        var ATH_psfb12 = gfp.internal_flags.ATH.psfb12;\n        var gfc = gfp.internal_flags;\n        var samp_freq = gfp.out_samplerate;\n\n        for (var sfb = 0; sfb < Encoder_1.SBMAX_l; sfb++) {\n            var start = gfc.scalefac_band.l[sfb];\n            var end = gfc.scalefac_band.l[sfb + 1];\n            ATH_l[sfb] = Float$19.MAX_VALUE;\n            for (var i = start; i < end; i++) {\n                var freq = i * samp_freq / (2 * 576);\n                var ATH_f = ATHmdct(gfp, freq);\n                /* freq in kHz */\n                ATH_l[sfb] = Math.min(ATH_l[sfb], ATH_f);\n            }\n        }\n\n        for (var sfb = 0; sfb < Encoder_1.PSFB21; sfb++) {\n            var start = gfc.scalefac_band.psfb21[sfb];\n            var end = gfc.scalefac_band.psfb21[sfb + 1];\n            ATH_psfb21[sfb] = Float$19.MAX_VALUE;\n            for (var i = start; i < end; i++) {\n                var freq = i * samp_freq / (2 * 576);\n                var ATH_f = ATHmdct(gfp, freq);\n                /* freq in kHz */\n                ATH_psfb21[sfb] = Math.min(ATH_psfb21[sfb], ATH_f);\n            }\n        }\n\n        for (var sfb = 0; sfb < Encoder_1.SBMAX_s; sfb++) {\n            var start = gfc.scalefac_band.s[sfb];\n            var end = gfc.scalefac_band.s[sfb + 1];\n            ATH_s[sfb] = Float$19.MAX_VALUE;\n            for (var i = start; i < end; i++) {\n                var freq = i * samp_freq / (2 * 192);\n                var ATH_f = ATHmdct(gfp, freq);\n                /* freq in kHz */\n                ATH_s[sfb] = Math.min(ATH_s[sfb], ATH_f);\n            }\n            ATH_s[sfb] *= (gfc.scalefac_band.s[sfb + 1] - gfc.scalefac_band.s[sfb]);\n        }\n\n        for (var sfb = 0; sfb < Encoder_1.PSFB12; sfb++) {\n            var start = gfc.scalefac_band.psfb12[sfb];\n            var end = gfc.scalefac_band.psfb12[sfb + 1];\n            ATH_psfb12[sfb] = Float$19.MAX_VALUE;\n            for (var i = start; i < end; i++) {\n                var freq = i * samp_freq / (2 * 192);\n                var ATH_f = ATHmdct(gfp, freq);\n                /* freq in kHz */\n                ATH_psfb12[sfb] = Math.min(ATH_psfb12[sfb], ATH_f);\n            }\n            /* not sure about the following */\n            ATH_psfb12[sfb] *= (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12]);\n        }\n\n        /*\n         * no-ATH mode: reduce ATH to -200 dB\n         */\n        if (gfp.noATH) {\n            for (var sfb = 0; sfb < Encoder_1.SBMAX_l; sfb++) {\n                ATH_l[sfb] = 1E-20;\n            }\n            for (var sfb = 0; sfb < Encoder_1.PSFB21; sfb++) {\n                ATH_psfb21[sfb] = 1E-20;\n            }\n            for (var sfb = 0; sfb < Encoder_1.SBMAX_s; sfb++) {\n                ATH_s[sfb] = 1E-20;\n            }\n            for (var sfb = 0; sfb < Encoder_1.PSFB12; sfb++) {\n                ATH_psfb12[sfb] = 1E-20;\n            }\n        }\n\n        /*\n         * work in progress, don't rely on it too much\n         */\n        gfc.ATH.floor = 10. * Math.log10(ATHmdct(gfp, -1.));\n    }\n\n    /**\n     * initialization for iteration_loop\n     */\n    this.iteration_init = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var l3_side = gfc.l3_side;\n        var i;\n\n        if (gfc.iteration_init_init == 0) {\n            gfc.iteration_init_init = 1;\n\n            l3_side.main_data_begin = 0;\n            compute_ath(gfp);\n\n            pow43[0] = 0.0;\n            for (i = 1; i < PRECALC_SIZE; i++)\n                pow43[i] = Math.pow(i, 4.0 / 3.0);\n\n            for (i = 0; i < PRECALC_SIZE - 1; i++)\n                adj43[i] = ((i + 1) - Math.pow(\n                    0.5 * (pow43[i] + pow43[i + 1]), 0.75));\n            adj43[i] = 0.5;\n\n            for (i = 0; i < Q_MAX; i++)\n                ipow20[i] = Math.pow(2.0, (i - 210) * -0.1875);\n            for (i = 0; i <= Q_MAX + Q_MAX2; i++)\n                pow20[i] = Math.pow(2.0, (i - 210 - Q_MAX2) * 0.25);\n\n            tak.huffman_init(gfc);\n\n            {\n                var bass, alto, treble, sfb21;\n\n                i = (gfp.exp_nspsytune >> 2) & 63;\n                if (i >= 32)\n                    i -= 64;\n                bass = Math.pow(10, i / 4.0 / 10.0);\n\n                i = (gfp.exp_nspsytune >> 8) & 63;\n                if (i >= 32)\n                    i -= 64;\n                alto = Math.pow(10, i / 4.0 / 10.0);\n\n                i = (gfp.exp_nspsytune >> 14) & 63;\n                if (i >= 32)\n                    i -= 64;\n                treble = Math.pow(10, i / 4.0 / 10.0);\n\n                /*\n                 * to be compatible with Naoki's original code, the next 6 bits\n                 * define only the amount of changing treble for sfb21\n                 */\n                i = (gfp.exp_nspsytune >> 20) & 63;\n                if (i >= 32)\n                    i -= 64;\n                sfb21 = treble * Math.pow(10, i / 4.0 / 10.0);\n                for (i = 0; i < Encoder_1.SBMAX_l; i++) {\n                    var f;\n                    if (i <= 6)\n                        f = bass;\n                    else if (i <= 13)\n                        f = alto;\n                    else if (i <= 20)\n                        f = treble;\n                    else\n                        f = sfb21;\n\n                    gfc.nsPsy.longfact[i] = f;\n                }\n                for (i = 0; i < Encoder_1.SBMAX_s; i++) {\n                    var f;\n                    if (i <= 5)\n                        f = bass;\n                    else if (i <= 10)\n                        f = alto;\n                    else if (i <= 11)\n                        f = treble;\n                    else\n                        f = sfb21;\n\n                    gfc.nsPsy.shortfact[i] = f;\n                }\n            }\n        }\n    };\n\n    /**\n     * allocate bits among 2 channels based on PE<BR>\n     * mt 6/99<BR>\n     * bugfixes rh 8/01: often allocated more than the allowed 4095 bits\n     */\n    this.on_pe = function (gfp, pe,\n                           targ_bits, mean_bits, gr, cbr) {\n        var gfc = gfp.internal_flags;\n        var tbits = 0, bits;\n        var add_bits = new_int$19(2);\n        var ch;\n\n        /* allocate targ_bits for granule */\n        var mb = new MeanBits_1(tbits);\n        var extra_bits = rv.ResvMaxBits(gfp, mean_bits, mb, cbr);\n        tbits = mb.bits;\n        /* maximum allowed bits for this granule */\n        var max_bits = tbits + extra_bits;\n        if (max_bits > LameInternalFlags_1.MAX_BITS_PER_GRANULE) {\n            // hard limit per granule\n            max_bits = LameInternalFlags_1.MAX_BITS_PER_GRANULE;\n        }\n        for (bits = 0, ch = 0; ch < gfc.channels_out; ++ch) {\n            /******************************************************************\n             * allocate bits for each channel\n             ******************************************************************/\n            targ_bits[ch] = Math.min(LameInternalFlags_1.MAX_BITS_PER_CHANNEL,\n                tbits / gfc.channels_out);\n\n            add_bits[ch] = 0 | (targ_bits[ch] * pe[gr][ch] / 700.0 - targ_bits[ch]);\n\n            /* at most increase bits by 1.5*average */\n            if (add_bits[ch] > mean_bits * 3 / 4)\n                add_bits[ch] = mean_bits * 3 / 4;\n            if (add_bits[ch] < 0)\n                add_bits[ch] = 0;\n\n            if (add_bits[ch] + targ_bits[ch] > LameInternalFlags_1.MAX_BITS_PER_CHANNEL)\n                add_bits[ch] = Math.max(0,\n                    LameInternalFlags_1.MAX_BITS_PER_CHANNEL - targ_bits[ch]);\n\n            bits += add_bits[ch];\n        }\n        if (bits > extra_bits) {\n            for (ch = 0; ch < gfc.channels_out; ++ch) {\n                add_bits[ch] = extra_bits * add_bits[ch] / bits;\n            }\n        }\n\n        for (ch = 0; ch < gfc.channels_out; ++ch) {\n            targ_bits[ch] += add_bits[ch];\n            extra_bits -= add_bits[ch];\n        }\n\n        for (bits = 0, ch = 0; ch < gfc.channels_out; ++ch) {\n            bits += targ_bits[ch];\n        }\n        if (bits > LameInternalFlags_1.MAX_BITS_PER_GRANULE) {\n            var sum = 0;\n            for (ch = 0; ch < gfc.channels_out; ++ch) {\n                targ_bits[ch] *= LameInternalFlags_1.MAX_BITS_PER_GRANULE;\n                targ_bits[ch] /= bits;\n                sum += targ_bits[ch];\n            }\n            assert$19(sum <= LameInternalFlags_1.MAX_BITS_PER_GRANULE);\n        }\n\n        return max_bits;\n    };\n\n    this.reduce_side = function (targ_bits, ms_ener_ratio, mean_bits, max_bits) {\n        assert$19(max_bits <= LameInternalFlags_1.MAX_BITS_PER_GRANULE);\n        assert$19(targ_bits[0] + targ_bits[1] <= LameInternalFlags_1.MAX_BITS_PER_GRANULE);\n\n        /*\n         * ms_ener_ratio = 0: allocate 66/33 mid/side fac=.33 ms_ener_ratio =.5:\n         * allocate 50/50 mid/side fac= 0\n         */\n        /* 75/25 split is fac=.5 */\n        var fac = .33 * (.5 - ms_ener_ratio) / .5;\n        if (fac < 0)\n            fac = 0;\n        if (fac > .5)\n            fac = .5;\n\n        /* number of bits to move from side channel to mid channel */\n        /* move_bits = fac*targ_bits[1]; */\n        var move_bits = 0 | (fac * .5 * (targ_bits[0] + targ_bits[1]));\n\n        if (move_bits > LameInternalFlags_1.MAX_BITS_PER_CHANNEL - targ_bits[0]) {\n            move_bits = LameInternalFlags_1.MAX_BITS_PER_CHANNEL - targ_bits[0];\n        }\n        if (move_bits < 0)\n            move_bits = 0;\n\n        if (targ_bits[1] >= 125) {\n            /* dont reduce side channel below 125 bits */\n            if (targ_bits[1] - move_bits > 125) {\n\n                /* if mid channel already has 2x more than average, dont bother */\n                /* mean_bits = bits per granule (for both channels) */\n                if (targ_bits[0] < mean_bits)\n                    targ_bits[0] += move_bits;\n                targ_bits[1] -= move_bits;\n            } else {\n                targ_bits[0] += targ_bits[1] - 125;\n                targ_bits[1] = 125;\n            }\n        }\n\n        move_bits = targ_bits[0] + targ_bits[1];\n        if (move_bits > max_bits) {\n            targ_bits[0] = (max_bits * targ_bits[0]) / move_bits;\n            targ_bits[1] = (max_bits * targ_bits[1]) / move_bits;\n        }\n        assert$19(targ_bits[0] <= LameInternalFlags_1.MAX_BITS_PER_CHANNEL);\n        assert$19(targ_bits[1] <= LameInternalFlags_1.MAX_BITS_PER_CHANNEL);\n        assert$19(targ_bits[0] + targ_bits[1] <= LameInternalFlags_1.MAX_BITS_PER_GRANULE);\n    };\n\n    /**\n     *  Robert Hegemann 2001-04-27:\n     *  this adjusts the ATH, keeping the original noise floor\n     *  affects the higher frequencies more than the lower ones\n     */\n    this.athAdjust = function (a, x, athFloor) {\n        /*\n         * work in progress\n         */\n        var o = 90.30873362;\n        var p = 94.82444863;\n        var u = Util$19.FAST_LOG10_X(x, 10.0);\n        var v = a * a;\n        var w = 0.0;\n        u -= athFloor;\n        /* undo scaling */\n        if (v > 1E-20)\n            w = 1. + Util$19.FAST_LOG10_X(v, 10.0 / o);\n        if (w < 0)\n            w = 0.;\n        u *= w;\n        u += athFloor + o - p;\n        /* redo scaling */\n\n        return Math.pow(10., 0.1 * u);\n    };\n\n    /**\n     * Calculate the allowed distortion for each scalefactor band, as determined\n     * by the psychoacoustic model. xmin(sb) = ratio(sb) * en(sb) / bw(sb)\n     *\n     * returns number of sfb's with energy > ATH\n     */\n    this.calc_xmin = function (gfp, ratio, cod_info, pxmin) {\n        var pxminPos = 0;\n        var gfc = gfp.internal_flags;\n        var gsfb, j = 0, ath_over = 0;\n        var ATH = gfc.ATH;\n        var xr = cod_info.xr;\n        var enable_athaa_fix = (gfp.VBR == VbrMode$19.vbr_mtrh) ? 1 : 0;\n        var masking_lower = gfc.masking_lower;\n\n        if (gfp.VBR == VbrMode$19.vbr_mtrh || gfp.VBR == VbrMode$19.vbr_mt) {\n            /* was already done in PSY-Model */\n            masking_lower = 1.0;\n        }\n\n        for (gsfb = 0; gsfb < cod_info.psy_lmax; gsfb++) {\n            var en0, xmin;\n            var rh1, rh2;\n            var width, l;\n\n            if (gfp.VBR == VbrMode$19.vbr_rh || gfp.VBR == VbrMode$19.vbr_mtrh)\n                xmin = athAdjust(ATH.adjust, ATH.l[gsfb], ATH.floor);\n            else\n                xmin = ATH.adjust * ATH.l[gsfb];\n\n            width = cod_info.width[gsfb];\n            rh1 = xmin / width;\n            rh2 = DBL_EPSILON;\n            l = width >> 1;\n            en0 = 0.0;\n            do {\n                var xa, xb;\n                xa = xr[j] * xr[j];\n                en0 += xa;\n                rh2 += (xa < rh1) ? xa : rh1;\n                j++;\n                xb = xr[j] * xr[j];\n                en0 += xb;\n                rh2 += (xb < rh1) ? xb : rh1;\n                j++;\n            } while (--l > 0);\n            if (en0 > xmin)\n                ath_over++;\n\n            if (gsfb == Encoder_1.SBPSY_l) {\n                var x = xmin * gfc.nsPsy.longfact[gsfb];\n                if (rh2 < x) {\n                    rh2 = x;\n                }\n            }\n            if (enable_athaa_fix != 0) {\n                xmin = rh2;\n            }\n            if (!gfp.ATHonly) {\n                var e = ratio.en.l[gsfb];\n                if (e > 0.0) {\n                    var x;\n                    x = en0 * ratio.thm.l[gsfb] * masking_lower / e;\n                    if (enable_athaa_fix != 0)\n                        x *= gfc.nsPsy.longfact[gsfb];\n                    if (xmin < x)\n                        xmin = x;\n                }\n            }\n            if (enable_athaa_fix != 0)\n                pxmin[pxminPos++] = xmin;\n            else\n                pxmin[pxminPos++] = xmin * gfc.nsPsy.longfact[gsfb];\n        }\n        /* end of long block loop */\n\n        /* use this function to determine the highest non-zero coeff */\n        var max_nonzero = 575;\n        if (cod_info.block_type != Encoder_1.SHORT_TYPE) {\n            // NORM, START or STOP type, but not SHORT\n            var k = 576;\n            while (k-- != 0 && BitStream.EQ(xr[k], 0)) {\n                max_nonzero = k;\n            }\n        }\n        cod_info.max_nonzero_coeff = max_nonzero;\n\n        for (var sfb = cod_info.sfb_smin; gsfb < cod_info.psymax; sfb++, gsfb += 3) {\n            var width, b;\n            var tmpATH;\n            if (gfp.VBR == VbrMode$19.vbr_rh || gfp.VBR == VbrMode$19.vbr_mtrh)\n                tmpATH = athAdjust(ATH.adjust, ATH.s[sfb], ATH.floor);\n            else\n                tmpATH = ATH.adjust * ATH.s[sfb];\n\n            width = cod_info.width[gsfb];\n            for (b = 0; b < 3; b++) {\n                var en0 = 0.0, xmin;\n                var rh1, rh2;\n                var l = width >> 1;\n\n                rh1 = tmpATH / width;\n                rh2 = DBL_EPSILON;\n                do {\n                    var xa, xb;\n                    xa = xr[j] * xr[j];\n                    en0 += xa;\n                    rh2 += (xa < rh1) ? xa : rh1;\n                    j++;\n                    xb = xr[j] * xr[j];\n                    en0 += xb;\n                    rh2 += (xb < rh1) ? xb : rh1;\n                    j++;\n                } while (--l > 0);\n                if (en0 > tmpATH)\n                    ath_over++;\n                if (sfb == Encoder_1.SBPSY_s) {\n                    var x = tmpATH * gfc.nsPsy.shortfact[sfb];\n                    if (rh2 < x) {\n                        rh2 = x;\n                    }\n                }\n                if (enable_athaa_fix != 0)\n                    xmin = rh2;\n                else\n                    xmin = tmpATH;\n\n                if (!gfp.ATHonly && !gfp.ATHshort) {\n                    var e = ratio.en.s[sfb][b];\n                    if (e > 0.0) {\n                        var x;\n                        x = en0 * ratio.thm.s[sfb][b] * masking_lower / e;\n                        if (enable_athaa_fix != 0)\n                            x *= gfc.nsPsy.shortfact[sfb];\n                        if (xmin < x)\n                            xmin = x;\n                    }\n                }\n                if (enable_athaa_fix != 0)\n                    pxmin[pxminPos++] = xmin;\n                else\n                    pxmin[pxminPos++] = xmin * gfc.nsPsy.shortfact[sfb];\n            }\n            /* b */\n            if (gfp.useTemporal) {\n                if (pxmin[pxminPos - 3] > pxmin[pxminPos - 3 + 1])\n                    pxmin[pxminPos - 3 + 1] += (pxmin[pxminPos - 3] - pxmin[pxminPos - 3 + 1])\n                        * gfc.decay;\n                if (pxmin[pxminPos - 3 + 1] > pxmin[pxminPos - 3 + 2])\n                    pxmin[pxminPos - 3 + 2] += (pxmin[pxminPos - 3 + 1] - pxmin[pxminPos - 3 + 2])\n                        * gfc.decay;\n            }\n        }\n        /* end of short block sfb loop */\n\n        return ath_over;\n    };\n\n    function StartLine(j) {\n        this.s = j;\n    }\n\n    this.calc_noise_core = function (cod_info, startline, l, step) {\n        var noise = 0;\n        var j = startline.s;\n        var ix = cod_info.l3_enc;\n\n        if (j > cod_info.count1) {\n            while ((l--) != 0) {\n                var temp;\n                temp = cod_info.xr[j];\n                j++;\n                noise += temp * temp;\n                temp = cod_info.xr[j];\n                j++;\n                noise += temp * temp;\n            }\n        } else if (j > cod_info.big_values) {\n            var ix01 = new_float$19(2);\n            ix01[0] = 0;\n            ix01[1] = step;\n            while ((l--) != 0) {\n                var temp;\n                temp = Math.abs(cod_info.xr[j]) - ix01[ix[j]];\n                j++;\n                noise += temp * temp;\n                temp = Math.abs(cod_info.xr[j]) - ix01[ix[j]];\n                j++;\n                noise += temp * temp;\n            }\n        } else {\n            while ((l--) != 0) {\n                var temp;\n                temp = Math.abs(cod_info.xr[j]) - pow43[ix[j]] * step;\n                j++;\n                noise += temp * temp;\n                temp = Math.abs(cod_info.xr[j]) - pow43[ix[j]] * step;\n                j++;\n                noise += temp * temp;\n            }\n        }\n\n        startline.s = j;\n        return noise;\n    };\n\n    /**\n     * <PRE>\n     * -oo dB  =>  -1.00\n     * - 6 dB  =>  -0.97\n     * - 3 dB  =>  -0.80\n     * - 2 dB  =>  -0.64\n     * - 1 dB  =>  -0.38\n     *   0 dB  =>   0.00\n     * + 1 dB  =>  +0.49\n     * + 2 dB  =>  +1.06\n     * + 3 dB  =>  +1.68\n     * + 6 dB  =>  +3.69\n     * +10 dB  =>  +6.45\n     * </PRE>\n     */\n    this.calc_noise = function (cod_info, l3_xmin, distort, res, prev_noise) {\n        var distortPos = 0;\n        var l3_xminPos = 0;\n        var sfb, l, over = 0;\n        var over_noise_db = 0;\n        /* 0 dB relative to masking */\n        var tot_noise_db = 0;\n        /* -200 dB relative to masking */\n        var max_noise = -20.0;\n        var j = 0;\n        var scalefac = cod_info.scalefac;\n        var scalefacPos = 0;\n\n        res.over_SSD = 0;\n\n        for (sfb = 0; sfb < cod_info.psymax; sfb++) {\n            var s = cod_info.global_gain\n                - (((scalefac[scalefacPos++]) + (cod_info.preflag != 0 ? pretab[sfb]\n                    : 0)) << (cod_info.scalefac_scale + 1))\n                - cod_info.subblock_gain[cod_info.window[sfb]] * 8;\n            var noise = 0.0;\n\n            if (prev_noise != null && (prev_noise.step[sfb] == s)) {\n\n                /* use previously computed values */\n                noise = prev_noise.noise[sfb];\n                j += cod_info.width[sfb];\n                distort[distortPos++] = noise / l3_xmin[l3_xminPos++];\n\n                noise = prev_noise.noise_log[sfb];\n\n            } else {\n                var step = POW20(s);\n                l = cod_info.width[sfb] >> 1;\n\n                if ((j + cod_info.width[sfb]) > cod_info.max_nonzero_coeff) {\n                    var usefullsize;\n                    usefullsize = cod_info.max_nonzero_coeff - j + 1;\n\n                    if (usefullsize > 0)\n                        l = usefullsize >> 1;\n                    else\n                        l = 0;\n                }\n\n                var sl = new StartLine(j);\n                noise = this.calc_noise_core(cod_info, sl, l, step);\n                j = sl.s;\n\n                if (prev_noise != null) {\n                    /* save noise values */\n                    prev_noise.step[sfb] = s;\n                    prev_noise.noise[sfb] = noise;\n                }\n\n                noise = distort[distortPos++] = noise / l3_xmin[l3_xminPos++];\n\n                /* multiplying here is adding in dB, but can overflow */\n                noise = Util$19.FAST_LOG10(Math.max(noise, 1E-20));\n\n                if (prev_noise != null) {\n                    /* save noise values */\n                    prev_noise.noise_log[sfb] = noise;\n                }\n            }\n\n            if (prev_noise != null) {\n                /* save noise values */\n                prev_noise.global_gain = cod_info.global_gain;\n            }\n\n            tot_noise_db += noise;\n\n            if (noise > 0.0) {\n                var tmp;\n\n                tmp = Math.max(0 | (noise * 10 + .5), 1);\n                res.over_SSD += tmp * tmp;\n\n                over++;\n                /* multiplying here is adding in dB -but can overflow */\n                /* over_noise *= noise; */\n                over_noise_db += noise;\n            }\n            max_noise = Math.max(max_noise, noise);\n\n        }\n\n        res.over_count = over;\n        res.tot_noise = tot_noise_db;\n        res.over_noise = over_noise_db;\n        res.max_noise = max_noise;\n\n        return over;\n    };\n\n    /**\n     * updates plotting data\n     *\n     * Mark Taylor 2000-??-??\n     *\n     * Robert Hegemann: moved noise/distortion calc into it\n     */\n    this.set_pinfo = function (gfp, cod_info, ratio, gr, ch) {\n        var gfc = gfp.internal_flags;\n        var sfb, sfb2;\n        var l;\n        var en0, en1;\n        var ifqstep = (cod_info.scalefac_scale == 0) ? .5 : 1.0;\n        var scalefac = cod_info.scalefac;\n\n        var l3_xmin = new_float$19(L3Side.SFBMAX);\n        var xfsf = new_float$19(L3Side.SFBMAX);\n        var noise = new CalcNoiseResult();\n\n        calc_xmin(gfp, ratio, cod_info, l3_xmin);\n        calc_noise(cod_info, l3_xmin, xfsf, noise, null);\n\n        var j = 0;\n        sfb2 = cod_info.sfb_lmax;\n        if (cod_info.block_type != Encoder_1.SHORT_TYPE\n            && 0 == cod_info.mixed_block_flag)\n            sfb2 = 22;\n        for (sfb = 0; sfb < sfb2; sfb++) {\n            var start = gfc.scalefac_band.l[sfb];\n            var end = gfc.scalefac_band.l[sfb + 1];\n            var bw = end - start;\n            for (en0 = 0.0; j < end; j++)\n                en0 += cod_info.xr[j] * cod_info.xr[j];\n            en0 /= bw;\n            /* convert to MDCT units */\n            /* scaling so it shows up on FFT plot */\n            en1 = 1e15;\n            gfc.pinfo.en[gr][ch][sfb] = en1 * en0;\n            gfc.pinfo.xfsf[gr][ch][sfb] = en1 * l3_xmin[sfb] * xfsf[sfb] / bw;\n\n            if (ratio.en.l[sfb] > 0 && !gfp.ATHonly)\n                en0 = en0 / ratio.en.l[sfb];\n            else\n                en0 = 0.0;\n\n            gfc.pinfo.thr[gr][ch][sfb] = en1\n                * Math.max(en0 * ratio.thm.l[sfb], gfc.ATH.l[sfb]);\n\n            /* there is no scalefactor bands >= SBPSY_l */\n            gfc.pinfo.LAMEsfb[gr][ch][sfb] = 0;\n            if (cod_info.preflag != 0 && sfb >= 11)\n                gfc.pinfo.LAMEsfb[gr][ch][sfb] = -ifqstep * pretab[sfb];\n\n            if (sfb < Encoder_1.SBPSY_l) {\n                /* scfsi should be decoded by caller side */\n                assert$19(scalefac[sfb] >= 0);\n                gfc.pinfo.LAMEsfb[gr][ch][sfb] -= ifqstep * scalefac[sfb];\n            }\n        }\n        /* for sfb */\n\n        if (cod_info.block_type == Encoder_1.SHORT_TYPE) {\n            sfb2 = sfb;\n            for (sfb = cod_info.sfb_smin; sfb < Encoder_1.SBMAX_s; sfb++) {\n                var start = gfc.scalefac_band.s[sfb];\n                var end = gfc.scalefac_band.s[sfb + 1];\n                var bw = end - start;\n                for (var i = 0; i < 3; i++) {\n                    for (en0 = 0.0, l = start; l < end; l++) {\n                        en0 += cod_info.xr[j] * cod_info.xr[j];\n                        j++;\n                    }\n                    en0 = Math.max(en0 / bw, 1e-20);\n                    /* convert to MDCT units */\n                    /* scaling so it shows up on FFT plot */\n                    en1 = 1e15;\n\n                    gfc.pinfo.en_s[gr][ch][3 * sfb + i] = en1 * en0;\n                    gfc.pinfo.xfsf_s[gr][ch][3 * sfb + i] = en1 * l3_xmin[sfb2]\n                        * xfsf[sfb2] / bw;\n                    if (ratio.en.s[sfb][i] > 0)\n                        en0 = en0 / ratio.en.s[sfb][i];\n                    else\n                        en0 = 0.0;\n                    if (gfp.ATHonly || gfp.ATHshort)\n                        en0 = 0;\n\n                    gfc.pinfo.thr_s[gr][ch][3 * sfb + i] = en1\n                        * Math.max(en0 * ratio.thm.s[sfb][i],\n                            gfc.ATH.s[sfb]);\n\n                    /* there is no scalefactor bands >= SBPSY_s */\n                    gfc.pinfo.LAMEsfb_s[gr][ch][3 * sfb + i] = -2.0\n                        * cod_info.subblock_gain[i];\n                    if (sfb < Encoder_1.SBPSY_s) {\n                        gfc.pinfo.LAMEsfb_s[gr][ch][3 * sfb + i] -= ifqstep\n                            * scalefac[sfb2];\n                    }\n                    sfb2++;\n                }\n            }\n        }\n        /* block type short */\n        gfc.pinfo.LAMEqss[gr][ch] = cod_info.global_gain;\n        gfc.pinfo.LAMEmainbits[gr][ch] = cod_info.part2_3_length\n            + cod_info.part2_length;\n        gfc.pinfo.LAMEsfbits[gr][ch] = cod_info.part2_length;\n\n        gfc.pinfo.over[gr][ch] = noise.over_count;\n        gfc.pinfo.max_noise[gr][ch] = noise.max_noise * 10.0;\n        gfc.pinfo.over_noise[gr][ch] = noise.over_noise * 10.0;\n        gfc.pinfo.tot_noise[gr][ch] = noise.tot_noise * 10.0;\n        gfc.pinfo.over_SSD[gr][ch] = noise.over_SSD;\n    };\n\n    /**\n     * updates plotting data for a whole frame\n     *\n     * Robert Hegemann 2000-10-21\n     */\n    \n\n}\n\nvar QuantizePVT_1 = QuantizePVT$1;\n\n/*\n *\tMP3 huffman table selecting and bit counting\n *\n *\tCopyright (c) 1999-2005 Takehiro TOMINAGA\n *\tCopyright (c) 2002-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Takehiro.java,v 1.26 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n//import java.util.Arrays;\n\nvar System$18 = common.System;\nvar Arrays$18 = common.Arrays;\nvar new_int$18 = common.new_int;\nvar assert$18 = common.assert;\n\n\n\n\n\n\n\nfunction Takehiro$1() {\n\n    var qupvt = null;\n    this.qupvt = null;\n\n    this.setModules = function (_qupvt) {\n        this.qupvt = _qupvt;\n        qupvt = _qupvt;\n    };\n\n    function Bits(b) {\n        this.bits = 0 | b;\n    }\n\n    var subdv_table = [[0, 0], /* 0 bands */\n        [0, 0], /* 1 bands */\n        [0, 0], /* 2 bands */\n        [0, 0], /* 3 bands */\n        [0, 0], /* 4 bands */\n        [0, 1], /* 5 bands */\n        [1, 1], /* 6 bands */\n        [1, 1], /* 7 bands */\n        [1, 2], /* 8 bands */\n        [2, 2], /* 9 bands */\n        [2, 3], /* 10 bands */\n        [2, 3], /* 11 bands */\n        [3, 4], /* 12 bands */\n        [3, 4], /* 13 bands */\n        [3, 4], /* 14 bands */\n        [4, 5], /* 15 bands */\n        [4, 5], /* 16 bands */\n        [4, 6], /* 17 bands */\n        [5, 6], /* 18 bands */\n        [5, 6], /* 19 bands */\n        [5, 7], /* 20 bands */\n        [6, 7], /* 21 bands */\n        [6, 7], /* 22 bands */\n    ];\n\n    /**\n     * nonlinear quantization of xr More accurate formula than the ISO formula.\n     * Takes into account the fact that we are quantizing xr . ix, but we want\n     * ix^4/3 to be as close as possible to x^4/3. (taking the nearest int would\n     * mean ix is as close as possible to xr, which is different.)\n     *\n     * From Segher Boessenkool <segher@eastsite.nl> 11/1999\n     *\n     * 09/2000: ASM code removed in favor of IEEE754 hack by Takehiro Tominaga.\n     * If you need the ASM code, check CVS circa Aug 2000.\n     *\n     * 01/2004: Optimizations by Gabriel Bouvigne\n     */\n    function quantize_lines_xrpow_01(l, istep, xr, xrPos, ix, ixPos) {\n        var compareval0 = (1.0 - 0.4054) / istep;\n\n        assert$18(l > 0);\n        l = l >> 1;\n        while ((l--) != 0) {\n            ix[ixPos++] = (compareval0 > xr[xrPos++]) ? 0 : 1;\n            ix[ixPos++] = (compareval0 > xr[xrPos++]) ? 0 : 1;\n        }\n    }\n\n    /**\n     * XRPOW_FTOI is a macro to convert floats to ints.<BR>\n     * if XRPOW_FTOI(x) = nearest_int(x), then QUANTFAC(x)=adj43asm[x]<BR>\n     * ROUNDFAC= -0.0946<BR>\n     *\n     * if XRPOW_FTOI(x) = floor(x), then QUANTFAC(x)=asj43[x]<BR>\n     * ROUNDFAC=0.4054<BR>\n     *\n     * Note: using floor() or 0| is extremely slow. On machines where the\n     * TAKEHIRO_IEEE754_HACK code above does not work, it is worthwile to write\n     * some ASM for XRPOW_FTOI().\n     */\n    function quantize_lines_xrpow(l, istep, xr, xrPos, ix, ixPos) {\n        assert$18(l > 0);\n\n        l = l >> 1;\n        var remaining = l % 2;\n        l = l >> 1;\n        while (l-- != 0) {\n            var x0, x1, x2, x3;\n            var rx0, rx1, rx2, rx3;\n\n            x0 = xr[xrPos++] * istep;\n            x1 = xr[xrPos++] * istep;\n            rx0 = 0 | x0;\n            x2 = xr[xrPos++] * istep;\n            rx1 = 0 | x1;\n            x3 = xr[xrPos++] * istep;\n            rx2 = 0 | x2;\n            x0 += qupvt.adj43[rx0];\n            rx3 = 0 | x3;\n            x1 += qupvt.adj43[rx1];\n            ix[ixPos++] = 0 | x0;\n            x2 += qupvt.adj43[rx2];\n            ix[ixPos++] = 0 | x1;\n            x3 += qupvt.adj43[rx3];\n            ix[ixPos++] = 0 | x2;\n            ix[ixPos++] = 0 | x3;\n        }\n        if (remaining != 0) {\n            var x0, x1;\n            var rx0, rx1;\n\n            x0 = xr[xrPos++] * istep;\n            x1 = xr[xrPos++] * istep;\n            rx0 = 0 | x0;\n            rx1 = 0 | x1;\n            x0 += qupvt.adj43[rx0];\n            x1 += qupvt.adj43[rx1];\n            ix[ixPos++] = 0 | x0;\n            ix[ixPos++] = 0 | x1;\n        }\n    }\n\n    /**\n     * Quantization function This function will select which lines to quantize\n     * and call the proper quantization function\n     */\n    function quantize_xrpow(xp, pi, istep, codInfo, prevNoise) {\n        /* quantize on xr^(3/4) instead of xr */\n        var sfb;\n        var sfbmax;\n        var j = 0;\n        var prev_data_use;\n        var accumulate = 0;\n        var accumulate01 = 0;\n        var xpPos = 0;\n        var iData = pi;\n        var iDataPos = 0;\n        var acc_iData = iData;\n        var acc_iDataPos = 0;\n        var acc_xp = xp;\n        var acc_xpPos = 0;\n\n        /*\n         * Reusing previously computed data does not seems to work if global\n         * gain is changed. Finding why it behaves this way would allow to use a\n         * cache of previously computed values (let's 10 cached values per sfb)\n         * that would probably provide a noticeable speedup\n         */\n        prev_data_use = (prevNoise != null && (codInfo.global_gain == prevNoise.global_gain));\n\n        if (codInfo.block_type == Encoder_1.SHORT_TYPE)\n            sfbmax = 38;\n        else\n            sfbmax = 21;\n\n        for (sfb = 0; sfb <= sfbmax; sfb++) {\n            var step = -1;\n\n            if (prev_data_use || codInfo.block_type == Encoder_1.NORM_TYPE) {\n                step = codInfo.global_gain\n                    - ((codInfo.scalefac[sfb] + (codInfo.preflag != 0 ? qupvt.pretab[sfb]\n                        : 0)) << (codInfo.scalefac_scale + 1))\n                    - codInfo.subblock_gain[codInfo.window[sfb]] * 8;\n            }\n            assert$18(codInfo.width[sfb] >= 0);\n            if (prev_data_use && (prevNoise.step[sfb] == step)) {\n                /*\n                 * do not recompute this part, but compute accumulated lines\n                 */\n                if (accumulate != 0) {\n                    quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos,\n                        acc_iData, acc_iDataPos);\n                    accumulate = 0;\n                }\n                if (accumulate01 != 0) {\n                    quantize_lines_xrpow_01(accumulate01, istep, acc_xp,\n                        acc_xpPos, acc_iData, acc_iDataPos);\n                    accumulate01 = 0;\n                }\n            } else { /* should compute this part */\n                var l = codInfo.width[sfb];\n\n                if ((j + codInfo.width[sfb]) > codInfo.max_nonzero_coeff) {\n                    /* do not compute upper zero part */\n                    var usefullsize;\n                    usefullsize = codInfo.max_nonzero_coeff - j + 1;\n                    Arrays$18.fill(pi, codInfo.max_nonzero_coeff, 576, 0);\n                    l = usefullsize;\n\n                    if (l < 0) {\n                        l = 0;\n                    }\n\n                    /* no need to compute higher sfb values */\n                    sfb = sfbmax + 1;\n                }\n\n                /* accumulate lines to quantize */\n                if (0 == accumulate && 0 == accumulate01) {\n                    acc_iData = iData;\n                    acc_iDataPos = iDataPos;\n                    acc_xp = xp;\n                    acc_xpPos = xpPos;\n                }\n                if (prevNoise != null && prevNoise.sfb_count1 > 0\n                    && sfb >= prevNoise.sfb_count1\n                    && prevNoise.step[sfb] > 0\n                    && step >= prevNoise.step[sfb]) {\n\n                    if (accumulate != 0) {\n                        quantize_lines_xrpow(accumulate, istep, acc_xp,\n                            acc_xpPos, acc_iData, acc_iDataPos);\n                        accumulate = 0;\n                        acc_iData = iData;\n                        acc_iDataPos = iDataPos;\n                        acc_xp = xp;\n                        acc_xpPos = xpPos;\n                    }\n                    accumulate01 += l;\n                } else {\n                    if (accumulate01 != 0) {\n                        quantize_lines_xrpow_01(accumulate01, istep, acc_xp,\n                            acc_xpPos, acc_iData, acc_iDataPos);\n                        accumulate01 = 0;\n                        acc_iData = iData;\n                        acc_iDataPos = iDataPos;\n                        acc_xp = xp;\n                        acc_xpPos = xpPos;\n                    }\n                    accumulate += l;\n                }\n\n                if (l <= 0) {\n                    /*\n                     * rh: 20040215 may happen due to \"prev_data_use\"\n                     * optimization\n                     */\n                    if (accumulate01 != 0) {\n                        quantize_lines_xrpow_01(accumulate01, istep, acc_xp,\n                            acc_xpPos, acc_iData, acc_iDataPos);\n                        accumulate01 = 0;\n                    }\n                    if (accumulate != 0) {\n                        quantize_lines_xrpow(accumulate, istep, acc_xp,\n                            acc_xpPos, acc_iData, acc_iDataPos);\n                        accumulate = 0;\n                    }\n\n                    break;\n                    /* ends for-loop */\n                }\n            }\n            if (sfb <= sfbmax) {\n                iDataPos += codInfo.width[sfb];\n                xpPos += codInfo.width[sfb];\n                j += codInfo.width[sfb];\n            }\n        }\n        if (accumulate != 0) { /* last data part */\n            quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos,\n                acc_iData, acc_iDataPos);\n            accumulate = 0;\n        }\n        if (accumulate01 != 0) { /* last data part */\n            quantize_lines_xrpow_01(accumulate01, istep, acc_xp, acc_xpPos,\n                acc_iData, acc_iDataPos);\n            accumulate01 = 0;\n        }\n\n    }\n\n    /**\n     * ix_max\n     */\n    function ix_max(ix, ixPos, endPos) {\n        var max1 = 0, max2 = 0;\n\n        do {\n            var x1 = ix[ixPos++];\n            var x2 = ix[ixPos++];\n            if (max1 < x1)\n                max1 = x1;\n\n            if (max2 < x2)\n                max2 = x2;\n        } while (ixPos < endPos);\n        if (max1 < max2)\n            max1 = max2;\n        return max1;\n    }\n\n    function count_bit_ESC(ix, ixPos, end, t1, t2, s) {\n        /* ESC-table is used */\n        var linbits = Tables_1.ht[t1].xlen * 65536 + Tables_1.ht[t2].xlen;\n        var sum = 0, sum2;\n\n        do {\n            var x = ix[ixPos++];\n            var y = ix[ixPos++];\n\n            if (x != 0) {\n                if (x > 14) {\n                    x = 15;\n                    sum += linbits;\n                }\n                x *= 16;\n            }\n\n            if (y != 0) {\n                if (y > 14) {\n                    y = 15;\n                    sum += linbits;\n                }\n                x += y;\n            }\n\n            sum += Tables_1.largetbl[x];\n        } while (ixPos < end);\n\n        sum2 = sum & 0xffff;\n        sum >>= 16;\n\n        if (sum > sum2) {\n            sum = sum2;\n            t1 = t2;\n        }\n\n        s.bits += sum;\n        return t1;\n    }\n\n    function count_bit_noESC(ix, ixPos, end, s) {\n        /* No ESC-words */\n        var sum1 = 0;\n        var hlen1 = Tables_1.ht[1].hlen;\n\n        do {\n            var x = ix[ixPos + 0] * 2 + ix[ixPos + 1];\n            ixPos += 2;\n            sum1 += hlen1[x];\n        } while (ixPos < end);\n\n        s.bits += sum1;\n        return 1;\n    }\n\n    function count_bit_noESC_from2(ix, ixPos, end, t1, s) {\n        /* No ESC-words */\n        var sum = 0, sum2;\n        var xlen = Tables_1.ht[t1].xlen;\n        var hlen;\n        if (t1 == 2)\n            hlen = Tables_1.table23;\n        else\n            hlen = Tables_1.table56;\n\n        do {\n            var x = ix[ixPos + 0] * xlen + ix[ixPos + 1];\n            ixPos += 2;\n            sum += hlen[x];\n        } while (ixPos < end);\n\n        sum2 = sum & 0xffff;\n        sum >>= 16;\n\n        if (sum > sum2) {\n            sum = sum2;\n            t1++;\n        }\n\n        s.bits += sum;\n        return t1;\n    }\n\n    function count_bit_noESC_from3(ix, ixPos, end, t1, s) {\n        /* No ESC-words */\n        var sum1 = 0;\n        var sum2 = 0;\n        var sum3 = 0;\n        var xlen = Tables_1.ht[t1].xlen;\n        var hlen1 = Tables_1.ht[t1].hlen;\n        var hlen2 = Tables_1.ht[t1 + 1].hlen;\n        var hlen3 = Tables_1.ht[t1 + 2].hlen;\n\n        do {\n            var x = ix[ixPos + 0] * xlen + ix[ixPos + 1];\n            ixPos += 2;\n            sum1 += hlen1[x];\n            sum2 += hlen2[x];\n            sum3 += hlen3[x];\n        } while (ixPos < end);\n        var t = t1;\n        if (sum1 > sum2) {\n            sum1 = sum2;\n            t++;\n        }\n        if (sum1 > sum3) {\n            sum1 = sum3;\n            t = t1 + 2;\n        }\n        s.bits += sum1;\n\n        return t;\n    }\n\n    /*************************************************************************/\n    /* choose table */\n    /*************************************************************************/\n\n    var huf_tbl_noESC = [1, 2, 5, 7, 7, 10, 10, 13, 13,\n        13, 13, 13, 13, 13, 13];\n\n    /**\n     * Choose the Huffman table that will encode ix[begin..end] with the fewest\n     * bits.\n     *\n     * Note: This code contains knowledge about the sizes and characteristics of\n     * the Huffman tables as defined in the IS (Table B.7), and will not work\n     * with any arbitrary tables.\n     */\n    function choose_table(ix, ixPos, endPos, s) {\n        var max = ix_max(ix, ixPos, endPos);\n\n        switch (max) {\n            case 0:\n                return max;\n\n            case 1:\n                return count_bit_noESC(ix, ixPos, endPos, s);\n\n            case 2:\n            case 3:\n                return count_bit_noESC_from2(ix, ixPos, endPos,\n                    huf_tbl_noESC[max - 1], s);\n\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n                return count_bit_noESC_from3(ix, ixPos, endPos,\n                    huf_tbl_noESC[max - 1], s);\n\n            default:\n                /* try tables with linbits */\n                if (max > QuantizePVT_1.IXMAX_VAL) {\n                    s.bits = QuantizePVT_1.LARGE_BITS;\n                    return -1;\n                }\n                max -= 15;\n                var choice2;\n                for (choice2 = 24; choice2 < 32; choice2++) {\n                    if (Tables_1.ht[choice2].linmax >= max) {\n                        break;\n                    }\n                }\n                var choice;\n                for (choice = choice2 - 8; choice < 24; choice++) {\n                    if (Tables_1.ht[choice].linmax >= max) {\n                        break;\n                    }\n                }\n                return count_bit_ESC(ix, ixPos, endPos, choice, choice2, s);\n        }\n    }\n\n    /**\n     * count_bit\n     */\n    this.noquant_count_bits = function (gfc, gi, prev_noise) {\n        var ix = gi.l3_enc;\n        var i = Math.min(576, ((gi.max_nonzero_coeff + 2) >> 1) << 1);\n\n        if (prev_noise != null)\n            prev_noise.sfb_count1 = 0;\n\n        /* Determine count1 region */\n        for (; i > 1; i -= 2)\n            if ((ix[i - 1] | ix[i - 2]) != 0)\n                break;\n        gi.count1 = i;\n\n        /* Determines the number of bits to encode the quadruples. */\n        var a1 = 0;\n        var a2 = 0;\n        for (; i > 3; i -= 4) {\n            var p;\n            /* hack to check if all values <= 1 */\n            //throw \"TODO: HACK         if ((((long) ix[i - 1] | (long) ix[i - 2] | (long) ix[i - 3] | (long) ix[i - 4]) & 0xffffffffL) > 1L        \"\n            //if (true) {\n            if (((ix[i - 1] | ix[i - 2] | ix[i - 3] | ix[i - 4]) & 0x7fffffff) > 1) {\n                break;\n            }\n            p = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2 + ix[i - 1];\n            a1 += Tables_1.t32l[p];\n            a2 += Tables_1.t33l[p];\n        }\n        var bits = a1;\n        gi.count1table_select = 0;\n        if (a1 > a2) {\n            bits = a2;\n            gi.count1table_select = 1;\n        }\n\n        gi.count1bits = bits;\n        gi.big_values = i;\n        if (i == 0)\n            return bits;\n\n        if (gi.block_type == Encoder_1.SHORT_TYPE) {\n            a1 = 3 * gfc.scalefac_band.s[3];\n            if (a1 > gi.big_values)\n                a1 = gi.big_values;\n            a2 = gi.big_values;\n\n        } else if (gi.block_type == Encoder_1.NORM_TYPE) {\n            assert$18(i <= 576);\n            /* bv_scf has 576 entries (0..575) */\n            a1 = gi.region0_count = gfc.bv_scf[i - 2];\n            a2 = gi.region1_count = gfc.bv_scf[i - 1];\n\n            assert$18(a1 + a2 + 2 < Encoder_1.SBPSY_l);\n            a2 = gfc.scalefac_band.l[a1 + a2 + 2];\n            a1 = gfc.scalefac_band.l[a1 + 1];\n            if (a2 < i) {\n                var bi = new Bits(bits);\n                gi.table_select[2] = choose_table(ix, a2, i, bi);\n                bits = bi.bits;\n            }\n        } else {\n            gi.region0_count = 7;\n            /* gi.region1_count = SBPSY_l - 7 - 1; */\n            gi.region1_count = Encoder_1.SBMAX_l - 1 - 7 - 1;\n            a1 = gfc.scalefac_band.l[7 + 1];\n            a2 = i;\n            if (a1 > a2) {\n                a1 = a2;\n            }\n        }\n\n        /* have to allow for the case when bigvalues < region0 < region1 */\n        /* (and region0, region1 are ignored) */\n        a1 = Math.min(a1, i);\n        a2 = Math.min(a2, i);\n\n        assert$18(a1 >= 0);\n        assert$18(a2 >= 0);\n\n        /* Count the number of bits necessary to code the bigvalues region. */\n        if (0 < a1) {\n            var bi = new Bits(bits);\n            gi.table_select[0] = choose_table(ix, 0, a1, bi);\n            bits = bi.bits;\n        }\n        if (a1 < a2) {\n            var bi = new Bits(bits);\n            gi.table_select[1] = choose_table(ix, a1, a2, bi);\n            bits = bi.bits;\n        }\n        if (gfc.use_best_huffman == 2) {\n            gi.part2_3_length = bits;\n            best_huffman_divide(gfc, gi);\n            bits = gi.part2_3_length;\n        }\n\n        if (prev_noise != null) {\n            if (gi.block_type == Encoder_1.NORM_TYPE) {\n                var sfb = 0;\n                while (gfc.scalefac_band.l[sfb] < gi.big_values) {\n                    sfb++;\n                }\n                prev_noise.sfb_count1 = sfb;\n            }\n        }\n\n        return bits;\n    };\n\n    this.count_bits = function (gfc, xr, gi, prev_noise) {\n        var ix = gi.l3_enc;\n\n        /* since quantize_xrpow uses table lookup, we need to check this first: */\n        var w = (QuantizePVT_1.IXMAX_VAL) / qupvt.IPOW20(gi.global_gain);\n\n        if (gi.xrpow_max > w)\n            return QuantizePVT_1.LARGE_BITS;\n\n        quantize_xrpow(xr, ix, qupvt.IPOW20(gi.global_gain), gi, prev_noise);\n\n        if ((gfc.substep_shaping & 2) != 0) {\n            var j = 0;\n            /* 0.634521682242439 = 0.5946*2**(.5*0.1875) */\n            var gain = gi.global_gain + gi.scalefac_scale;\n            var roundfac = 0.634521682242439 / qupvt.IPOW20(gain);\n            for (var sfb = 0; sfb < gi.sfbmax; sfb++) {\n                var width = gi.width[sfb];\n                assert$18(width >= 0);\n                if (0 == gfc.pseudohalf[sfb]) {\n                    j += width;\n                } else {\n                    var k;\n                    for (k = j, j += width; k < j; ++k) {\n                        ix[k] = (xr[k] >= roundfac) ? ix[k] : 0;\n                    }\n                }\n            }\n        }\n        return this.noquant_count_bits(gfc, gi, prev_noise);\n    };\n\n    /**\n     * re-calculate the best scalefac_compress using scfsi the saved bits are\n     * kept in the bit reservoir.\n     */\n    function recalc_divide_init(gfc, cod_info, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {\n        var bigv = cod_info.big_values;\n\n        for (var r0 = 0; r0 <= 7 + 15; r0++) {\n            r01_bits[r0] = QuantizePVT_1.LARGE_BITS;\n        }\n\n        for (var r0 = 0; r0 < 16; r0++) {\n            var a1 = gfc.scalefac_band.l[r0 + 1];\n            if (a1 >= bigv)\n                break;\n            var r0bits = 0;\n            var bi = new Bits(r0bits);\n            var r0t = choose_table(ix, 0, a1, bi);\n            r0bits = bi.bits;\n\n            for (var r1 = 0; r1 < 8; r1++) {\n                var a2 = gfc.scalefac_band.l[r0 + r1 + 2];\n                if (a2 >= bigv)\n                    break;\n                var bits = r0bits;\n                bi = new Bits(bits);\n                var r1t = choose_table(ix, a1, a2, bi);\n                bits = bi.bits;\n                if (r01_bits[r0 + r1] > bits) {\n                    r01_bits[r0 + r1] = bits;\n                    r01_div[r0 + r1] = r0;\n                    r0_tbl[r0 + r1] = r0t;\n                    r1_tbl[r0 + r1] = r1t;\n                }\n            }\n        }\n    }\n\n    function recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {\n        var bigv = cod_info2.big_values;\n\n        for (var r2 = 2; r2 < Encoder_1.SBMAX_l + 1; r2++) {\n            var a2 = gfc.scalefac_band.l[r2];\n            if (a2 >= bigv)\n                break;\n            var bits = r01_bits[r2 - 2] + cod_info2.count1bits;\n            if (gi.part2_3_length <= bits)\n                break;\n\n            var bi = new Bits(bits);\n            var r2t = choose_table(ix, a2, bigv, bi);\n            bits = bi.bits;\n            if (gi.part2_3_length <= bits)\n                continue;\n\n            gi.assign(cod_info2);\n            gi.part2_3_length = bits;\n            gi.region0_count = r01_div[r2 - 2];\n            gi.region1_count = r2 - 2 - r01_div[r2 - 2];\n            gi.table_select[0] = r0_tbl[r2 - 2];\n            gi.table_select[1] = r1_tbl[r2 - 2];\n            gi.table_select[2] = r2t;\n        }\n    }\n\n    this.best_huffman_divide = function (gfc, gi) {\n        var cod_info2 = new GrInfo_1();\n        var ix = gi.l3_enc;\n        var r01_bits = new_int$18(7 + 15 + 1);\n        var r01_div = new_int$18(7 + 15 + 1);\n        var r0_tbl = new_int$18(7 + 15 + 1);\n        var r1_tbl = new_int$18(7 + 15 + 1);\n\n        /* SHORT BLOCK stuff fails for MPEG2 */\n        if (gi.block_type == Encoder_1.SHORT_TYPE && gfc.mode_gr == 1)\n            return;\n\n        cod_info2.assign(gi);\n        if (gi.block_type == Encoder_1.NORM_TYPE) {\n            recalc_divide_init(gfc, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl);\n            recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div,\n                r0_tbl, r1_tbl);\n        }\n        var i = cod_info2.big_values;\n        if (i == 0 || (ix[i - 2] | ix[i - 1]) > 1)\n            return;\n\n        i = gi.count1 + 2;\n        if (i > 576)\n            return;\n\n        /* Determines the number of bits to encode the quadruples. */\n        cod_info2.assign(gi);\n        cod_info2.count1 = i;\n        var a1 = 0;\n        var a2 = 0;\n\n        assert$18(i <= 576);\n\n        for (; i > cod_info2.big_values; i -= 4) {\n            var p = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2\n                + ix[i - 1];\n            a1 += Tables_1.t32l[p];\n            a2 += Tables_1.t33l[p];\n        }\n        cod_info2.big_values = i;\n\n        cod_info2.count1table_select = 0;\n        if (a1 > a2) {\n            a1 = a2;\n            cod_info2.count1table_select = 1;\n        }\n\n        cod_info2.count1bits = a1;\n\n        if (cod_info2.block_type == Encoder_1.NORM_TYPE)\n            recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div,\n                r0_tbl, r1_tbl);\n        else {\n            /* Count the number of bits necessary to code the bigvalues region. */\n            cod_info2.part2_3_length = a1;\n            a1 = gfc.scalefac_band.l[7 + 1];\n            if (a1 > i) {\n                a1 = i;\n            }\n            if (a1 > 0) {\n                var bi = new Bits(cod_info2.part2_3_length);\n                cod_info2.table_select[0] = choose_table(ix, 0, a1, bi);\n                cod_info2.part2_3_length = bi.bits;\n            }\n            if (i > a1) {\n                var bi = new Bits(cod_info2.part2_3_length);\n                cod_info2.table_select[1] = choose_table(ix, a1, i, bi);\n                cod_info2.part2_3_length = bi.bits;\n            }\n            if (gi.part2_3_length > cod_info2.part2_3_length)\n                gi.assign(cod_info2);\n        }\n    };\n\n    var slen1_n = [1, 1, 1, 1, 8, 2, 2, 2, 4, 4, 4, 8, 8, 8, 16, 16];\n    var slen2_n = [1, 2, 4, 8, 1, 2, 4, 8, 2, 4, 8, 2, 4, 8, 4, 8];\n    var slen1_tab = [0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4];\n    var slen2_tab = [0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3];\n    Takehiro$1.slen1_tab = slen1_tab;\n    Takehiro$1.slen2_tab = slen2_tab;\n\n    function scfsi_calc(ch, l3_side) {\n        var sfb;\n        var gi = l3_side.tt[1][ch];\n        var g0 = l3_side.tt[0][ch];\n\n        for (var i = 0; i < Tables_1.scfsi_band.length - 1; i++) {\n            for (sfb = Tables_1.scfsi_band[i]; sfb < Tables_1.scfsi_band[i + 1]; sfb++) {\n                if (g0.scalefac[sfb] != gi.scalefac[sfb]\n                    && gi.scalefac[sfb] >= 0)\n                    break;\n            }\n            if (sfb == Tables_1.scfsi_band[i + 1]) {\n                for (sfb = Tables_1.scfsi_band[i]; sfb < Tables_1.scfsi_band[i + 1]; sfb++) {\n                    gi.scalefac[sfb] = -1;\n                }\n                l3_side.scfsi[ch][i] = 1;\n            }\n        }\n        var s1 = 0;\n        var c1 = 0;\n        for (sfb = 0; sfb < 11; sfb++) {\n            if (gi.scalefac[sfb] == -1)\n                continue;\n            c1++;\n            if (s1 < gi.scalefac[sfb])\n                s1 = gi.scalefac[sfb];\n        }\n        var s2 = 0;\n        var c2 = 0;\n        for (; sfb < Encoder_1.SBPSY_l; sfb++) {\n            if (gi.scalefac[sfb] == -1)\n                continue;\n            c2++;\n            if (s2 < gi.scalefac[sfb])\n                s2 = gi.scalefac[sfb];\n        }\n\n        for (var i = 0; i < 16; i++) {\n            if (s1 < slen1_n[i] && s2 < slen2_n[i]) {\n                var c = slen1_tab[i] * c1 + slen2_tab[i] * c2;\n                if (gi.part2_length > c) {\n                    gi.part2_length = c;\n                    gi.scalefac_compress = i;\n                }\n            }\n        }\n    }\n\n    /**\n     * Find the optimal way to store the scalefactors. Only call this routine\n     * after final scalefactors have been chosen and the channel/granule will\n     * not be re-encoded.\n     */\n    this.best_scalefac_store = function (gfc, gr, ch, l3_side) {\n        /* use scalefac_scale if we can */\n        var gi = l3_side.tt[gr][ch];\n        var sfb, i, j, l;\n        var recalc = 0;\n\n        /*\n         * remove scalefacs from bands with ix=0. This idea comes from the AAC\n         * ISO docs. added mt 3/00\n         */\n        /* check if l3_enc=0 */\n        j = 0;\n        for (sfb = 0; sfb < gi.sfbmax; sfb++) {\n            var width = gi.width[sfb];\n            assert$18(width >= 0);\n            j += width;\n            for (l = -width; l < 0; l++) {\n                if (gi.l3_enc[l + j] != 0)\n                    break;\n            }\n            if (l == 0)\n                gi.scalefac[sfb] = recalc = -2;\n            /* anything goes. */\n            /*\n             * only best_scalefac_store and calc_scfsi know--and only they\n             * should know--about the magic number -2.\n             */\n        }\n\n        if (0 == gi.scalefac_scale && 0 == gi.preflag) {\n            var s = 0;\n            for (sfb = 0; sfb < gi.sfbmax; sfb++)\n                if (gi.scalefac[sfb] > 0)\n                    s |= gi.scalefac[sfb];\n\n            if (0 == (s & 1) && s != 0) {\n                for (sfb = 0; sfb < gi.sfbmax; sfb++)\n                    if (gi.scalefac[sfb] > 0)\n                        gi.scalefac[sfb] >>= 1;\n\n                gi.scalefac_scale = recalc = 1;\n            }\n        }\n\n        if (0 == gi.preflag && gi.block_type != Encoder_1.SHORT_TYPE\n            && gfc.mode_gr == 2) {\n            for (sfb = 11; sfb < Encoder_1.SBPSY_l; sfb++)\n                if (gi.scalefac[sfb] < qupvt.pretab[sfb]\n                    && gi.scalefac[sfb] != -2)\n                    break;\n            if (sfb == Encoder_1.SBPSY_l) {\n                for (sfb = 11; sfb < Encoder_1.SBPSY_l; sfb++)\n                    if (gi.scalefac[sfb] > 0)\n                        gi.scalefac[sfb] -= qupvt.pretab[sfb];\n\n                gi.preflag = recalc = 1;\n            }\n        }\n\n        for (i = 0; i < 4; i++)\n            l3_side.scfsi[ch][i] = 0;\n\n        if (gfc.mode_gr == 2 && gr == 1\n            && l3_side.tt[0][ch].block_type != Encoder_1.SHORT_TYPE\n            && l3_side.tt[1][ch].block_type != Encoder_1.SHORT_TYPE) {\n            scfsi_calc(ch, l3_side);\n            recalc = 0;\n        }\n        for (sfb = 0; sfb < gi.sfbmax; sfb++) {\n            if (gi.scalefac[sfb] == -2) {\n                gi.scalefac[sfb] = 0;\n                /* if anything goes, then 0 is a good choice */\n            }\n        }\n        if (recalc != 0) {\n            if (gfc.mode_gr == 2) {\n                this.scale_bitcount(gi);\n            } else {\n                this.scale_bitcount_lsf(gfc, gi);\n            }\n        }\n    };\n\n    function all_scalefactors_not_negative(scalefac, n) {\n        for (var i = 0; i < n; ++i) {\n            if (scalefac[i] < 0)\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * number of bits used to encode scalefacs.\n     *\n     * 18*slen1_tab[i] + 18*slen2_tab[i]\n     */\n    var scale_short = [0, 18, 36, 54, 54, 36, 54, 72,\n        54, 72, 90, 72, 90, 108, 108, 126];\n\n    /**\n     * number of bits used to encode scalefacs.\n     *\n     * 17*slen1_tab[i] + 18*slen2_tab[i]\n     */\n    var scale_mixed = [0, 18, 36, 54, 51, 35, 53, 71,\n        52, 70, 88, 69, 87, 105, 104, 122];\n\n    /**\n     * number of bits used to encode scalefacs.\n     *\n     * 11*slen1_tab[i] + 10*slen2_tab[i]\n     */\n    var scale_long = [0, 10, 20, 30, 33, 21, 31, 41, 32, 42,\n        52, 43, 53, 63, 64, 74];\n\n    /**\n     * Also calculates the number of bits necessary to code the scalefactors.\n     */\n    this.scale_bitcount = function (cod_info) {\n        var k, sfb, max_slen1 = 0, max_slen2 = 0;\n\n        /* maximum values */\n        var tab;\n        var scalefac = cod_info.scalefac;\n\n        assert$18(all_scalefactors_not_negative(scalefac, cod_info.sfbmax));\n\n        if (cod_info.block_type == Encoder_1.SHORT_TYPE) {\n            tab = scale_short;\n            if (cod_info.mixed_block_flag != 0)\n                tab = scale_mixed;\n        } else { /* block_type == 1,2,or 3 */\n            tab = scale_long;\n            if (0 == cod_info.preflag) {\n                for (sfb = 11; sfb < Encoder_1.SBPSY_l; sfb++)\n                    if (scalefac[sfb] < qupvt.pretab[sfb])\n                        break;\n\n                if (sfb == Encoder_1.SBPSY_l) {\n                    cod_info.preflag = 1;\n                    for (sfb = 11; sfb < Encoder_1.SBPSY_l; sfb++)\n                        scalefac[sfb] -= qupvt.pretab[sfb];\n                }\n            }\n        }\n\n        for (sfb = 0; sfb < cod_info.sfbdivide; sfb++)\n            if (max_slen1 < scalefac[sfb])\n                max_slen1 = scalefac[sfb];\n\n        for (; sfb < cod_info.sfbmax; sfb++)\n            if (max_slen2 < scalefac[sfb])\n                max_slen2 = scalefac[sfb];\n\n        /*\n         * from Takehiro TOMINAGA <tominaga@isoternet.org> 10/99 loop over *all*\n         * posible values of scalefac_compress to find the one which uses the\n         * smallest number of bits. ISO would stop at first valid index\n         */\n        cod_info.part2_length = QuantizePVT_1.LARGE_BITS;\n        for (k = 0; k < 16; k++) {\n            if (max_slen1 < slen1_n[k] && max_slen2 < slen2_n[k]\n                && cod_info.part2_length > tab[k]) {\n                cod_info.part2_length = tab[k];\n                cod_info.scalefac_compress = k;\n            }\n        }\n        return cod_info.part2_length == QuantizePVT_1.LARGE_BITS;\n    };\n\n    /**\n     * table of largest scalefactor values for MPEG2\n     */\n    var max_range_sfac_tab = [[15, 15, 7, 7],\n        [15, 15, 7, 0], [7, 3, 0, 0], [15, 31, 31, 0],\n        [7, 7, 7, 0], [3, 3, 0, 0]];\n\n    /**\n     * Also counts the number of bits to encode the scalefacs but for MPEG 2\n     * Lower sampling frequencies (24, 22.05 and 16 kHz.)\n     *\n     * This is reverse-engineered from section 2.4.3.2 of the MPEG2 IS,\n     * \"Audio Decoding Layer III\"\n     */\n    this.scale_bitcount_lsf = function (gfc, cod_info) {\n        var table_number, row_in_table, partition, nr_sfb, window;\n        var over;\n        var i, sfb;\n        var max_sfac = new_int$18(4);\n//var partition_table;\n        var scalefac = cod_info.scalefac;\n\n        /*\n         * Set partition table. Note that should try to use table one, but do\n         * not yet...\n         */\n        if (cod_info.preflag != 0)\n            table_number = 2;\n        else\n            table_number = 0;\n\n        for (i = 0; i < 4; i++)\n            max_sfac[i] = 0;\n\n        if (cod_info.block_type == Encoder_1.SHORT_TYPE) {\n            row_in_table = 1;\n            var partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n            for (sfb = 0, partition = 0; partition < 4; partition++) {\n                nr_sfb = partition_table[partition] / 3;\n                for (i = 0; i < nr_sfb; i++, sfb++)\n                    for (window = 0; window < 3; window++)\n                        if (scalefac[sfb * 3 + window] > max_sfac[partition])\n                            max_sfac[partition] = scalefac[sfb * 3 + window];\n            }\n        } else {\n            row_in_table = 0;\n            var partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n            for (sfb = 0, partition = 0; partition < 4; partition++) {\n                nr_sfb = partition_table[partition];\n                for (i = 0; i < nr_sfb; i++, sfb++)\n                    if (scalefac[sfb] > max_sfac[partition])\n                        max_sfac[partition] = scalefac[sfb];\n            }\n        }\n\n        for (over = false, partition = 0; partition < 4; partition++) {\n            if (max_sfac[partition] > max_range_sfac_tab[table_number][partition])\n                over = true;\n        }\n        if (!over) {\n            var slen1, slen2, slen3, slen4;\n\n            cod_info.sfb_partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n            for (partition = 0; partition < 4; partition++)\n                cod_info.slen[partition] = log2tab[max_sfac[partition]];\n\n            /* set scalefac_compress */\n            slen1 = cod_info.slen[0];\n            slen2 = cod_info.slen[1];\n            slen3 = cod_info.slen[2];\n            slen4 = cod_info.slen[3];\n\n            switch (table_number) {\n                case 0:\n                    cod_info.scalefac_compress = (((slen1 * 5) + slen2) << 4)\n                        + (slen3 << 2) + slen4;\n                    break;\n\n                case 1:\n                    cod_info.scalefac_compress = 400 + (((slen1 * 5) + slen2) << 2)\n                        + slen3;\n                    break;\n\n                case 2:\n                    cod_info.scalefac_compress = 500 + (slen1 * 3) + slen2;\n                    break;\n\n                default:\n                    System$18.err.printf(\"intensity stereo not implemented yet\\n\");\n                    break;\n            }\n        }\n        if (!over) {\n            assert$18(cod_info.sfb_partition_table != null);\n            cod_info.part2_length = 0;\n            for (partition = 0; partition < 4; partition++)\n                cod_info.part2_length += cod_info.slen[partition]\n                    * cod_info.sfb_partition_table[partition];\n        }\n        return over;\n    };\n\n    /*\n     * Since no bands have been over-amplified, we can set scalefac_compress and\n     * slen[] for the formatter\n     */\n    var log2tab = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,\n        4, 4, 4, 4];\n\n    this.huffman_init = function (gfc) {\n        for (var i = 2; i <= 576; i += 2) {\n            var scfb_anz = 0, bv_index;\n            while (gfc.scalefac_band.l[++scfb_anz] < i)\n                ;\n\n            bv_index = subdv_table[scfb_anz][0]; // .region0_count\n            while (gfc.scalefac_band.l[bv_index + 1] > i)\n                bv_index--;\n\n            if (bv_index < 0) {\n                /*\n                 * this is an indication that everything is going to be encoded\n                 * as region0: bigvalues < region0 < region1 so lets set\n                 * region0, region1 to some value larger than bigvalues\n                 */\n                bv_index = subdv_table[scfb_anz][0]; // .region0_count\n            }\n\n            gfc.bv_scf[i - 2] = bv_index;\n\n            bv_index = subdv_table[scfb_anz][1]; // .region1_count\n            while (gfc.scalefac_band.l[bv_index + gfc.bv_scf[i - 2] + 2] > i)\n                bv_index--;\n\n            if (bv_index < 0) {\n                bv_index = subdv_table[scfb_anz][1]; // .region1_count\n            }\n\n            gfc.bv_scf[i - 1] = bv_index;\n        }\n    };\n}\n\nvar Takehiro_1 = Takehiro$1;\n\nvar System$17 = common.System;\nvar Arrays$17 = common.Arrays;\nvar new_byte$17 = common.new_byte;\nvar new_float_n$17 = common.new_float_n;\nvar new_int$17 = common.new_int;\nvar assert$17 = common.assert;\n\n\n\n\n\n\nBitStream$1.EQ = function (a, b) {\n    return (Math.abs(a) > Math.abs(b)) ? (Math.abs((a) - (b)) <= (Math\n        .abs(a) * 1e-6))\n        : (Math.abs((a) - (b)) <= (Math.abs(b) * 1e-6));\n};\n\nBitStream$1.NEQ = function (a, b) {\n    return !BitStream$1.EQ(a, b);\n};\n\nfunction BitStream$1() {\n    var self = this;\n    var CRC16_POLYNOMIAL = 0x8005;\n\n    /*\n     * we work with ints, so when doing bit manipulation, we limit ourselves to\n     * MAX_LENGTH-2 just to be on the safe side\n     */\n    var MAX_LENGTH = 32;\n\n    //GainAnalysis ga;\n    //MPGLib mpg;\n    //Version ver;\n    //VBRTag vbr;\n    var ga = null;\n    var mpg = null;\n    var ver = null;\n    var vbr = null;\n\n    //public final void setModules(GainAnalysis ga, MPGLib mpg, Version ver,\n    //\tVBRTag vbr) {\n\n    this.setModules = function (_ga, _mpg, _ver, _vbr) {\n        ga = _ga;\n        mpg = _mpg;\n        ver = _ver;\n        vbr = _vbr;\n    };\n\n    /**\n     * Bit stream buffer.\n     */\n    //private byte[] buf;\n    var buf = null;\n    /**\n     * Bit counter of bit stream.\n     */\n    var totbit = 0;\n    /**\n     * Pointer to top byte in buffer.\n     */\n    var bufByteIdx = 0;\n    /**\n     * Pointer to top bit of top byte in buffer.\n     */\n    var bufBitIdx = 0;\n\n    /**\n     * compute bitsperframe and mean_bits for a layer III frame\n     */\n    this.getframebits = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var bit_rate;\n\n        /* get bitrate in kbps [?] */\n        if (gfc.bitrate_index != 0)\n            bit_rate = Tables_1.bitrate_table[gfp.version][gfc.bitrate_index];\n        else\n            bit_rate = gfp.brate;\n        assert$17(8 <= bit_rate && bit_rate <= 640);\n\n        /* main encoding routine toggles padding on and off */\n        /* one Layer3 Slot consists of 8 bits */\n        var bytes = 0 | (gfp.version + 1) * 72000 * bit_rate / gfp.out_samplerate + gfc.padding;\n        return 8 * bytes;\n    };\n\n    function putheader_bits(gfc) {\n        System$17.arraycopy(gfc.header[gfc.w_ptr].buf, 0, buf, bufByteIdx, gfc.sideinfo_len);\n        bufByteIdx += gfc.sideinfo_len;\n        totbit += gfc.sideinfo_len * 8;\n        gfc.w_ptr = (gfc.w_ptr + 1) & (LameInternalFlags_1.MAX_HEADER_BUF - 1);\n    }\n\n    /**\n     * write j bits into the bit stream\n     */\n    function putbits2(gfc, val, j) {\n        assert$17(j < MAX_LENGTH - 2);\n\n        while (j > 0) {\n            var k;\n            if (bufBitIdx == 0) {\n                bufBitIdx = 8;\n                bufByteIdx++;\n                assert$17(bufByteIdx < Lame.LAME_MAXMP3BUFFER);\n                assert$17(gfc.header[gfc.w_ptr].write_timing >= totbit);\n                if (gfc.header[gfc.w_ptr].write_timing == totbit) {\n                    putheader_bits(gfc);\n                }\n                buf[bufByteIdx] = 0;\n            }\n\n            k = Math.min(j, bufBitIdx);\n            j -= k;\n\n            bufBitIdx -= k;\n\n            assert$17(j < MAX_LENGTH);\n            /* 32 too large on 32 bit machines */\n            assert$17(bufBitIdx < MAX_LENGTH);\n\n            buf[bufByteIdx] |= ((val >> j) << bufBitIdx);\n            totbit += k;\n        }\n    }\n\n    /**\n     * write j bits into the bit stream, ignoring frame headers\n     */\n    function putbits_noheaders(gfc, val, j) {\n        assert$17(j < MAX_LENGTH - 2);\n\n        while (j > 0) {\n            var k;\n            if (bufBitIdx == 0) {\n                bufBitIdx = 8;\n                bufByteIdx++;\n                assert$17(bufByteIdx < Lame.LAME_MAXMP3BUFFER);\n                buf[bufByteIdx] = 0;\n            }\n\n            k = Math.min(j, bufBitIdx);\n            j -= k;\n\n            bufBitIdx -= k;\n\n            assert$17(j < MAX_LENGTH);\n            /* 32 too large on 32 bit machines */\n            assert$17(bufBitIdx < MAX_LENGTH);\n\n            buf[bufByteIdx] |= ((val >> j) << bufBitIdx);\n            totbit += k;\n        }\n    }\n\n    /**\n     * Some combinations of bitrate, Fs, and stereo make it impossible to stuff\n     * out a frame using just main_data, due to the limited number of bits to\n     * indicate main_data_length. In these situations, we put stuffing bits into\n     * the ancillary data...\n     */\n    function drain_into_ancillary(gfp, remainingBits) {\n        var gfc = gfp.internal_flags;\n        var i;\n        assert$17(remainingBits >= 0);\n\n        if (remainingBits >= 8) {\n            putbits2(gfc, 0x4c, 8);\n            remainingBits -= 8;\n        }\n        if (remainingBits >= 8) {\n            putbits2(gfc, 0x41, 8);\n            remainingBits -= 8;\n        }\n        if (remainingBits >= 8) {\n            putbits2(gfc, 0x4d, 8);\n            remainingBits -= 8;\n        }\n        if (remainingBits >= 8) {\n            putbits2(gfc, 0x45, 8);\n            remainingBits -= 8;\n        }\n\n        if (remainingBits >= 32) {\n            var version = ver.getLameShortVersion();\n            if (remainingBits >= 32)\n                for (i = 0; i < version.length && remainingBits >= 8; ++i) {\n                    remainingBits -= 8;\n                    putbits2(gfc, version.charAt(i), 8);\n                }\n        }\n\n        for (; remainingBits >= 1; remainingBits -= 1) {\n            putbits2(gfc, gfc.ancillary_flag, 1);\n            gfc.ancillary_flag ^= (!gfp.disable_reservoir ? 1 : 0);\n        }\n\n        assert$17(remainingBits == 0);\n\n    }\n\n    /**\n     * write N bits into the header\n     */\n    function writeheader(gfc, val, j) {\n        var ptr = gfc.header[gfc.h_ptr].ptr;\n\n        while (j > 0) {\n            var k = Math.min(j, 8 - (ptr & 7));\n            j -= k;\n            assert$17(j < MAX_LENGTH);\n            /* >> 32 too large for 32 bit machines */\n\n            gfc.header[gfc.h_ptr].buf[ptr >> 3] |= ((val >> j)) << (8 - (ptr & 7) - k);\n            ptr += k;\n        }\n        gfc.header[gfc.h_ptr].ptr = ptr;\n    }\n\n    function CRC_update(value, crc) {\n        value <<= 8;\n        for (var i = 0; i < 8; i++) {\n            value <<= 1;\n            crc <<= 1;\n\n            if ((((crc ^ value) & 0x10000) != 0))\n                crc ^= CRC16_POLYNOMIAL;\n        }\n        return crc;\n    }\n\n    this.CRC_writeheader = function (gfc, header) {\n        var crc = 0xffff;\n        /* (jo) init crc16 for error_protection */\n\n        crc = CRC_update(header[2] & 0xff, crc);\n        crc = CRC_update(header[3] & 0xff, crc);\n        for (var i = 6; i < gfc.sideinfo_len; i++) {\n            crc = CRC_update(header[i] & 0xff, crc);\n        }\n\n        header[4] = (byte)(crc >> 8);\n        header[5] = (byte)(crc & 255);\n    };\n\n    function encodeSideInfo2(gfp, bitsPerFrame) {\n        var gfc = gfp.internal_flags;\n        var l3_side;\n        var gr, ch;\n\n        l3_side = gfc.l3_side;\n        gfc.header[gfc.h_ptr].ptr = 0;\n        Arrays$17.fill(gfc.header[gfc.h_ptr].buf, 0, gfc.sideinfo_len, 0);\n        if (gfp.out_samplerate < 16000)\n            writeheader(gfc, 0xffe, 12);\n        else\n            writeheader(gfc, 0xfff, 12);\n        writeheader(gfc, (gfp.version), 1);\n        writeheader(gfc, 4 - 3, 2);\n        writeheader(gfc, (!gfp.error_protection ? 1 : 0), 1);\n        writeheader(gfc, (gfc.bitrate_index), 4);\n        writeheader(gfc, (gfc.samplerate_index), 2);\n        writeheader(gfc, (gfc.padding), 1);\n        writeheader(gfc, (gfp.extension), 1);\n        writeheader(gfc, (gfp.mode.ordinal()), 2);\n        writeheader(gfc, (gfc.mode_ext), 2);\n        writeheader(gfc, (gfp.copyright), 1);\n        writeheader(gfc, (gfp.original), 1);\n        writeheader(gfc, (gfp.emphasis), 2);\n        if (gfp.error_protection) {\n            writeheader(gfc, 0, 16);\n            /* dummy */\n        }\n\n        if (gfp.version == 1) {\n            /* MPEG1 */\n            assert$17(l3_side.main_data_begin >= 0);\n            writeheader(gfc, (l3_side.main_data_begin), 9);\n\n            if (gfc.channels_out == 2)\n                writeheader(gfc, l3_side.private_bits, 3);\n            else\n                writeheader(gfc, l3_side.private_bits, 5);\n\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                var band;\n                for (band = 0; band < 4; band++) {\n                    writeheader(gfc, l3_side.scfsi[ch][band], 1);\n                }\n            }\n\n            for (gr = 0; gr < 2; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    var gi = l3_side.tt[gr][ch];\n                    writeheader(gfc, gi.part2_3_length + gi.part2_length, 12);\n                    writeheader(gfc, gi.big_values / 2, 9);\n                    writeheader(gfc, gi.global_gain, 8);\n                    writeheader(gfc, gi.scalefac_compress, 4);\n\n                    if (gi.block_type != Encoder_1.NORM_TYPE) {\n                        writeheader(gfc, 1, 1);\n                        /* window_switching_flag */\n                        writeheader(gfc, gi.block_type, 2);\n                        writeheader(gfc, gi.mixed_block_flag, 1);\n\n                        if (gi.table_select[0] == 14)\n                            gi.table_select[0] = 16;\n                        writeheader(gfc, gi.table_select[0], 5);\n                        if (gi.table_select[1] == 14)\n                            gi.table_select[1] = 16;\n                        writeheader(gfc, gi.table_select[1], 5);\n\n                        writeheader(gfc, gi.subblock_gain[0], 3);\n                        writeheader(gfc, gi.subblock_gain[1], 3);\n                        writeheader(gfc, gi.subblock_gain[2], 3);\n                    } else {\n                        writeheader(gfc, 0, 1);\n                        /* window_switching_flag */\n                        if (gi.table_select[0] == 14)\n                            gi.table_select[0] = 16;\n                        writeheader(gfc, gi.table_select[0], 5);\n                        if (gi.table_select[1] == 14)\n                            gi.table_select[1] = 16;\n                        writeheader(gfc, gi.table_select[1], 5);\n                        if (gi.table_select[2] == 14)\n                            gi.table_select[2] = 16;\n                        writeheader(gfc, gi.table_select[2], 5);\n\n                        assert$17(0 <= gi.region0_count && gi.region0_count < 16);\n                        assert$17(0 <= gi.region1_count && gi.region1_count < 8);\n                        writeheader(gfc, gi.region0_count, 4);\n                        writeheader(gfc, gi.region1_count, 3);\n                    }\n                    writeheader(gfc, gi.preflag, 1);\n                    writeheader(gfc, gi.scalefac_scale, 1);\n                    writeheader(gfc, gi.count1table_select, 1);\n                }\n            }\n        } else {\n            /* MPEG2 */\n            assert$17(l3_side.main_data_begin >= 0);\n            writeheader(gfc, (l3_side.main_data_begin), 8);\n            writeheader(gfc, l3_side.private_bits, gfc.channels_out);\n\n            gr = 0;\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                var gi = l3_side.tt[gr][ch];\n                writeheader(gfc, gi.part2_3_length + gi.part2_length, 12);\n                writeheader(gfc, gi.big_values / 2, 9);\n                writeheader(gfc, gi.global_gain, 8);\n                writeheader(gfc, gi.scalefac_compress, 9);\n\n                if (gi.block_type != Encoder_1.NORM_TYPE) {\n                    writeheader(gfc, 1, 1);\n                    /* window_switching_flag */\n                    writeheader(gfc, gi.block_type, 2);\n                    writeheader(gfc, gi.mixed_block_flag, 1);\n\n                    if (gi.table_select[0] == 14)\n                        gi.table_select[0] = 16;\n                    writeheader(gfc, gi.table_select[0], 5);\n                    if (gi.table_select[1] == 14)\n                        gi.table_select[1] = 16;\n                    writeheader(gfc, gi.table_select[1], 5);\n\n                    writeheader(gfc, gi.subblock_gain[0], 3);\n                    writeheader(gfc, gi.subblock_gain[1], 3);\n                    writeheader(gfc, gi.subblock_gain[2], 3);\n                } else {\n                    writeheader(gfc, 0, 1);\n                    /* window_switching_flag */\n                    if (gi.table_select[0] == 14)\n                        gi.table_select[0] = 16;\n                    writeheader(gfc, gi.table_select[0], 5);\n                    if (gi.table_select[1] == 14)\n                        gi.table_select[1] = 16;\n                    writeheader(gfc, gi.table_select[1], 5);\n                    if (gi.table_select[2] == 14)\n                        gi.table_select[2] = 16;\n                    writeheader(gfc, gi.table_select[2], 5);\n\n                    assert$17(0 <= gi.region0_count && gi.region0_count < 16);\n                    assert$17(0 <= gi.region1_count && gi.region1_count < 8);\n                    writeheader(gfc, gi.region0_count, 4);\n                    writeheader(gfc, gi.region1_count, 3);\n                }\n\n                writeheader(gfc, gi.scalefac_scale, 1);\n                writeheader(gfc, gi.count1table_select, 1);\n            }\n        }\n\n        if (gfp.error_protection) {\n            /* (jo) error_protection: add crc16 information to header */\n            CRC_writeheader(gfc, gfc.header[gfc.h_ptr].buf);\n        }\n\n        {\n            var old = gfc.h_ptr;\n            assert$17(gfc.header[old].ptr == gfc.sideinfo_len * 8);\n\n            gfc.h_ptr = (old + 1) & (LameInternalFlags_1.MAX_HEADER_BUF - 1);\n            gfc.header[gfc.h_ptr].write_timing = gfc.header[old].write_timing\n                + bitsPerFrame;\n\n            if (gfc.h_ptr == gfc.w_ptr) {\n                /* yikes! we are out of header buffer space */\n                System$17.err\n                    .println(\"Error: MAX_HEADER_BUF too small in bitstream.c \\n\");\n            }\n\n        }\n    }\n\n    function huffman_coder_count1(gfc, gi) {\n        /* Write count1 area */\n        var h = Tables_1.ht[gi.count1table_select + 32];\n        var i, bits = 0;\n\n        var ix = gi.big_values;\n        var xr = gi.big_values;\n        assert$17(gi.count1table_select < 2);\n\n        for (i = (gi.count1 - gi.big_values) / 4; i > 0; --i) {\n            var huffbits = 0;\n            var p = 0, v;\n\n            v = gi.l3_enc[ix + 0];\n            if (v != 0) {\n                p += 8;\n                if (gi.xr[xr + 0] < 0)\n                    huffbits++;\n                assert$17(v <= 1);\n            }\n\n            v = gi.l3_enc[ix + 1];\n            if (v != 0) {\n                p += 4;\n                huffbits *= 2;\n                if (gi.xr[xr + 1] < 0)\n                    huffbits++;\n                assert$17(v <= 1);\n            }\n\n            v = gi.l3_enc[ix + 2];\n            if (v != 0) {\n                p += 2;\n                huffbits *= 2;\n                if (gi.xr[xr + 2] < 0)\n                    huffbits++;\n                assert$17(v <= 1);\n            }\n\n            v = gi.l3_enc[ix + 3];\n            if (v != 0) {\n                p++;\n                huffbits *= 2;\n                if (gi.xr[xr + 3] < 0)\n                    huffbits++;\n                assert$17(v <= 1);\n            }\n\n            ix += 4;\n            xr += 4;\n            putbits2(gfc, huffbits + h.table[p], h.hlen[p]);\n            bits += h.hlen[p];\n        }\n        return bits;\n    }\n\n    /**\n     * Implements the pseudocode of page 98 of the IS\n     */\n    function Huffmancode(gfc, tableindex, start, end, gi) {\n        var h = Tables_1.ht[tableindex];\n        var bits = 0;\n\n        assert$17(tableindex < 32);\n        if (0 == tableindex)\n            return bits;\n\n        for (var i = start; i < end; i += 2) {\n            var cbits = 0;\n            var xbits = 0;\n            var linbits = h.xlen;\n            var xlen = h.xlen;\n            var ext = 0;\n            var x1 = gi.l3_enc[i];\n            var x2 = gi.l3_enc[i + 1];\n\n            if (x1 != 0) {\n                if (gi.xr[i] < 0)\n                    ext++;\n                cbits--;\n            }\n\n            if (tableindex > 15) {\n                /* use ESC-words */\n                if (x1 > 14) {\n                    var linbits_x1 = x1 - 15;\n                    assert$17(linbits_x1 <= h.linmax);\n                    ext |= linbits_x1 << 1;\n                    xbits = linbits;\n                    x1 = 15;\n                }\n\n                if (x2 > 14) {\n                    var linbits_x2 = x2 - 15;\n                    assert$17(linbits_x2 <= h.linmax);\n                    ext <<= linbits;\n                    ext |= linbits_x2;\n                    xbits += linbits;\n                    x2 = 15;\n                }\n                xlen = 16;\n            }\n\n            if (x2 != 0) {\n                ext <<= 1;\n                if (gi.xr[i + 1] < 0)\n                    ext++;\n                cbits--;\n            }\n\n            assert$17((x1 | x2) < 16);\n\n            x1 = x1 * xlen + x2;\n            xbits -= cbits;\n            cbits += h.hlen[x1];\n\n            assert$17(cbits <= MAX_LENGTH);\n            assert$17(xbits <= MAX_LENGTH);\n\n            putbits2(gfc, h.table[x1], cbits);\n            putbits2(gfc, ext, xbits);\n            bits += cbits + xbits;\n        }\n        return bits;\n    }\n\n    /**\n     * Note the discussion of huffmancodebits() on pages 28 and 29 of the IS, as\n     * well as the definitions of the side information on pages 26 and 27.\n     */\n    function ShortHuffmancodebits(gfc, gi) {\n        var region1Start = 3 * gfc.scalefac_band.s[3];\n        if (region1Start > gi.big_values)\n            region1Start = gi.big_values;\n\n        /* short blocks do not have a region2 */\n        var bits = Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);\n        bits += Huffmancode(gfc, gi.table_select[1], region1Start,\n            gi.big_values, gi);\n        return bits;\n    }\n\n    function LongHuffmancodebits(gfc, gi) {\n        var bigvalues, bits;\n        var region1Start, region2Start;\n\n        bigvalues = gi.big_values;\n        assert$17(0 <= bigvalues && bigvalues <= 576);\n\n        var i = gi.region0_count + 1;\n        assert$17(0 <= i);\n        assert$17(i < gfc.scalefac_band.l.length);\n        region1Start = gfc.scalefac_band.l[i];\n        i += gi.region1_count + 1;\n        assert$17(0 <= i);\n        assert$17(i < gfc.scalefac_band.l.length);\n        region2Start = gfc.scalefac_band.l[i];\n\n        if (region1Start > bigvalues)\n            region1Start = bigvalues;\n\n        if (region2Start > bigvalues)\n            region2Start = bigvalues;\n\n        bits = Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);\n        bits += Huffmancode(gfc, gi.table_select[1], region1Start,\n            region2Start, gi);\n        bits += Huffmancode(gfc, gi.table_select[2], region2Start, bigvalues,\n            gi);\n        return bits;\n    }\n\n    function writeMainData(gfp) {\n        var gr, ch, sfb, data_bits, tot_bits = 0;\n        var gfc = gfp.internal_flags;\n        var l3_side = gfc.l3_side;\n\n        if (gfp.version == 1) {\n            /* MPEG 1 */\n            for (gr = 0; gr < 2; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    var gi = l3_side.tt[gr][ch];\n                    var slen1 = Takehiro_1.slen1_tab[gi.scalefac_compress];\n                    var slen2 = Takehiro_1.slen2_tab[gi.scalefac_compress];\n                    data_bits = 0;\n                    for (sfb = 0; sfb < gi.sfbdivide; sfb++) {\n                        if (gi.scalefac[sfb] == -1)\n                            continue;\n                        /* scfsi is used */\n                        putbits2(gfc, gi.scalefac[sfb], slen1);\n                        data_bits += slen1;\n                    }\n                    for (; sfb < gi.sfbmax; sfb++) {\n                        if (gi.scalefac[sfb] == -1)\n                            continue;\n                        /* scfsi is used */\n                        putbits2(gfc, gi.scalefac[sfb], slen2);\n                        data_bits += slen2;\n                    }\n                    assert$17(data_bits == gi.part2_length);\n\n                    if (gi.block_type == Encoder_1.SHORT_TYPE) {\n                        data_bits += ShortHuffmancodebits(gfc, gi);\n                    } else {\n                        data_bits += LongHuffmancodebits(gfc, gi);\n                    }\n                    data_bits += huffman_coder_count1(gfc, gi);\n                    /* does bitcount in quantize.c agree with actual bit count? */\n                    assert$17(data_bits == gi.part2_3_length + gi.part2_length);\n                    tot_bits += data_bits;\n                }\n                /* for ch */\n            }\n            /* for gr */\n        } else {\n            /* MPEG 2 */\n            gr = 0;\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                var gi = l3_side.tt[gr][ch];\n                var i, sfb_partition, scale_bits = 0;\n                assert$17(gi.sfb_partition_table != null);\n                data_bits = 0;\n                sfb = 0;\n                sfb_partition = 0;\n\n                if (gi.block_type == Encoder_1.SHORT_TYPE) {\n                    for (; sfb_partition < 4; sfb_partition++) {\n                        var sfbs = gi.sfb_partition_table[sfb_partition] / 3;\n                        var slen = gi.slen[sfb_partition];\n                        for (i = 0; i < sfbs; i++, sfb++) {\n                            putbits2(gfc,\n                                Math.max(gi.scalefac[sfb * 3 + 0], 0), slen);\n                            putbits2(gfc,\n                                Math.max(gi.scalefac[sfb * 3 + 1], 0), slen);\n                            putbits2(gfc,\n                                Math.max(gi.scalefac[sfb * 3 + 2], 0), slen);\n                            scale_bits += 3 * slen;\n                        }\n                    }\n                    data_bits += ShortHuffmancodebits(gfc, gi);\n                } else {\n                    for (; sfb_partition < 4; sfb_partition++) {\n                        var sfbs = gi.sfb_partition_table[sfb_partition];\n                        var slen = gi.slen[sfb_partition];\n                        for (i = 0; i < sfbs; i++, sfb++) {\n                            putbits2(gfc, Math.max(gi.scalefac[sfb], 0), slen);\n                            scale_bits += slen;\n                        }\n                    }\n                    data_bits += LongHuffmancodebits(gfc, gi);\n                }\n                data_bits += huffman_coder_count1(gfc, gi);\n                /* does bitcount in quantize.c agree with actual bit count? */\n                assert$17(data_bits == gi.part2_3_length);\n                assert$17(scale_bits == gi.part2_length);\n                tot_bits += scale_bits + data_bits;\n            }\n            /* for ch */\n        }\n        /* for gf */\n        return tot_bits;\n    }\n\n    /* main_data */\n\n    function TotalBytes() {\n        this.total = 0;\n    }\n\n    /*\n     * compute the number of bits required to flush all mp3 frames currently in\n     * the buffer. This should be the same as the reservoir size. Only call this\n     * routine between frames - i.e. only after all headers and data have been\n     * added to the buffer by format_bitstream().\n     *\n     * Also compute total_bits_output = size of mp3 buffer (including frame\n     * headers which may not have yet been send to the mp3 buffer) + number of\n     * bits needed to flush all mp3 frames.\n     *\n     * total_bytes_output is the size of the mp3 output buffer if\n     * lame_encode_flush_nogap() was called right now.\n     */\n    function compute_flushbits(gfp, total_bytes_output) {\n        var gfc = gfp.internal_flags;\n        var flushbits, remaining_headers;\n        var bitsPerFrame;\n        var last_ptr, first_ptr;\n        first_ptr = gfc.w_ptr;\n        /* first header to add to bitstream */\n        last_ptr = gfc.h_ptr - 1;\n        /* last header to add to bitstream */\n        if (last_ptr == -1)\n            last_ptr = LameInternalFlags_1.MAX_HEADER_BUF - 1;\n\n        /* add this many bits to bitstream so we can flush all headers */\n        flushbits = gfc.header[last_ptr].write_timing - totbit;\n        total_bytes_output.total = flushbits;\n\n        if (flushbits >= 0) {\n            /* if flushbits >= 0, some headers have not yet been written */\n            /* reduce flushbits by the size of the headers */\n            remaining_headers = 1 + last_ptr - first_ptr;\n            if (last_ptr < first_ptr)\n                remaining_headers = 1 + last_ptr - first_ptr\n                    + LameInternalFlags_1.MAX_HEADER_BUF;\n            flushbits -= remaining_headers * 8 * gfc.sideinfo_len;\n        }\n\n        /*\n         * finally, add some bits so that the last frame is complete these bits\n         * are not necessary to decode the last frame, but some decoders will\n         * ignore last frame if these bits are missing\n         */\n        bitsPerFrame = self.getframebits(gfp);\n        flushbits += bitsPerFrame;\n        total_bytes_output.total += bitsPerFrame;\n        /* round up: */\n        if ((total_bytes_output.total % 8) != 0)\n            total_bytes_output.total = 1 + (total_bytes_output.total / 8);\n        else\n            total_bytes_output.total = (total_bytes_output.total / 8);\n        total_bytes_output.total += bufByteIdx + 1;\n\n        if (flushbits < 0) {\n            System$17.err.println(\"strange error flushing buffer ... \\n\");\n        }\n        return flushbits;\n    }\n\n    this.flush_bitstream = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var l3_side;\n        var flushbits;\n        var last_ptr = gfc.h_ptr - 1;\n        /* last header to add to bitstream */\n        if (last_ptr == -1)\n            last_ptr = LameInternalFlags_1.MAX_HEADER_BUF - 1;\n        l3_side = gfc.l3_side;\n\n        if ((flushbits = compute_flushbits(gfp, new TotalBytes())) < 0)\n            return;\n        drain_into_ancillary(gfp, flushbits);\n\n        /* check that the 100% of the last frame has been written to bitstream */\n        assert$17(gfc.header[last_ptr].write_timing + this.getframebits(gfp) == totbit);\n\n        /*\n         * we have padded out all frames with ancillary data, which is the same\n         * as filling the bitreservoir with ancillary data, so :\n         */\n        gfc.ResvSize = 0;\n        l3_side.main_data_begin = 0;\n\n        /* save the ReplayGain value */\n        if (gfc.findReplayGain) {\n            var RadioGain = ga.GetTitleGain(gfc.rgdata);\n            assert$17(NEQ(RadioGain, GainAnalysis.GAIN_NOT_ENOUGH_SAMPLES));\n            gfc.RadioGain = Math.floor(RadioGain * 10.0 + 0.5) | 0;\n            /* round to nearest */\n        }\n\n        /* find the gain and scale change required for no clipping */\n        if (gfc.findPeakSample) {\n            gfc.noclipGainChange = Math.ceil(Math\n                        .log10(gfc.PeakSample / 32767.0) * 20.0 * 10.0) | 0;\n            /* round up */\n\n            if (gfc.noclipGainChange > 0) {\n                /* clipping occurs */\n                if (EQ(gfp.scale, 1.0) || EQ(gfp.scale, 0.0))\n                    gfc.noclipScale = (Math\n                        .floor((32767.0 / gfc.PeakSample) * 100.0) / 100.0);\n                /* round down */\n                else {\n                    /*\n                     * the user specified his own scaling factor. We could\n                     * suggest the scaling factor of\n                     * (32767.0/gfp.PeakSample)*(gfp.scale) but it's usually\n                     * very inaccurate. So we'd rather not advice him on the\n                     * scaling factor.\n                     */\n                    gfc.noclipScale = -1;\n                }\n            } else\n            /* no clipping */\n                gfc.noclipScale = -1;\n        }\n    };\n\n    this.add_dummy_byte = function (gfp, val, n) {\n        var gfc = gfp.internal_flags;\n        var i;\n\n        while (n-- > 0) {\n            putbits_noheaders(gfc, val, 8);\n\n            for (i = 0; i < LameInternalFlags_1.MAX_HEADER_BUF; ++i)\n                gfc.header[i].write_timing += 8;\n        }\n    };\n\n    /**\n     * This is called after a frame of audio has been quantized and coded. It\n     * will write the encoded audio to the bitstream. Note that from a layer3\n     * encoder's perspective the bit stream is primarily a series of main_data()\n     * blocks, with header and side information inserted at the proper locations\n     * to maintain framing. (See Figure A.7 in the IS).\n     */\n    this.format_bitstream = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var l3_side;\n        l3_side = gfc.l3_side;\n\n        var bitsPerFrame = this.getframebits(gfp);\n        drain_into_ancillary(gfp, l3_side.resvDrain_pre);\n\n        encodeSideInfo2(gfp, bitsPerFrame);\n        var bits = 8 * gfc.sideinfo_len;\n        bits += writeMainData(gfp);\n        drain_into_ancillary(gfp, l3_side.resvDrain_post);\n        bits += l3_side.resvDrain_post;\n\n        l3_side.main_data_begin += (bitsPerFrame - bits) / 8;\n\n        /*\n         * compare number of bits needed to clear all buffered mp3 frames with\n         * what we think the resvsize is:\n         */\n        if (compute_flushbits(gfp, new TotalBytes()) != gfc.ResvSize) {\n            System$17.err.println(\"Internal buffer inconsistency. flushbits <> ResvSize\");\n        }\n\n        /*\n         * compare main_data_begin for the next frame with what we think the\n         * resvsize is:\n         */\n        if ((l3_side.main_data_begin * 8) != gfc.ResvSize) {\n            System$17.err.printf(\"bit reservoir error: \\n\"\n                + \"l3_side.main_data_begin: %d \\n\"\n                + \"Resvoir size:             %d \\n\"\n                + \"resv drain (post)         %d \\n\"\n                + \"resv drain (pre)          %d \\n\"\n                + \"header and sideinfo:      %d \\n\"\n                + \"data bits:                %d \\n\"\n                + \"total bits:               %d (remainder: %d) \\n\"\n                + \"bitsperframe:             %d \\n\",\n                8 * l3_side.main_data_begin, gfc.ResvSize,\n                l3_side.resvDrain_post, l3_side.resvDrain_pre,\n                8 * gfc.sideinfo_len, bits - l3_side.resvDrain_post - 8\n                * gfc.sideinfo_len, bits, bits % 8, bitsPerFrame);\n\n            System$17.err.println(\"This is a fatal error.  It has several possible causes:\");\n            System$17.err.println(\"90%%  LAME compiled with buggy version of gcc using advanced optimizations\");\n            System$17.err.println(\" 9%%  Your system is overclocked\");\n            System$17.err.println(\" 1%%  bug in LAME encoding library\");\n\n            gfc.ResvSize = l3_side.main_data_begin * 8;\n        }\n        //;\n        assert$17(totbit % 8 == 0);\n\n        if (totbit > 1000000000) {\n            /*\n             * to avoid totbit overflow, (at 8h encoding at 128kbs) lets reset\n             * bit counter\n             */\n            var i;\n            for (i = 0; i < LameInternalFlags_1.MAX_HEADER_BUF; ++i)\n                gfc.header[i].write_timing -= totbit;\n            totbit = 0;\n        }\n\n        return 0;\n    };\n\n    /**\n     * <PRE>\n     * copy data out of the internal MP3 bit buffer into a user supplied\n     *       unsigned char buffer.\n     *\n     *       mp3data=0      indicates data in buffer is an id3tags and VBR tags\n     *       mp3data=1      data is real mp3 frame data.\n     * </PRE>\n     */\n    this.copy_buffer = function (gfc, buffer, bufferPos, size, mp3data) {\n        var minimum = bufByteIdx + 1;\n        if (minimum <= 0)\n            return 0;\n        if (size != 0 && minimum > size) {\n            /* buffer is too small */\n            return -1;\n        }\n        System$17.arraycopy(buf, 0, buffer, bufferPos, minimum);\n        bufByteIdx = -1;\n        bufBitIdx = 0;\n\n        if (mp3data != 0) {\n            var crc = new_int$17(1);\n            crc[0] = gfc.nMusicCRC;\n            vbr.updateMusicCRC(crc, buffer, bufferPos, minimum);\n            gfc.nMusicCRC = crc[0];\n\n            /**\n             * sum number of bytes belonging to the mp3 stream this info will be\n             * written into the Xing/LAME header for seeking\n             */\n            if (minimum > 0) {\n                gfc.VBR_seek_table.nBytesWritten += minimum;\n            }\n\n            if (gfc.decode_on_the_fly) { /* decode the frame */\n                var pcm_buf = new_float_n$17([2, 1152]);\n                var mp3_in = minimum;\n                var samples_out = -1;\n                var i;\n\n                /* re-synthesis to pcm. Repeat until we get a samples_out=0 */\n                while (samples_out != 0) {\n\n                    samples_out = mpg.hip_decode1_unclipped(gfc.hip, buffer,\n                        bufferPos, mp3_in, pcm_buf[0], pcm_buf[1]);\n                    /*\n                     * samples_out = 0: need more data to decode samples_out =\n                     * -1: error. Lets assume 0 pcm output samples_out = number\n                     * of samples output\n                     */\n\n                    /*\n                     * set the lenght of the mp3 input buffer to zero, so that\n                     * in the next iteration of the loop we will be querying\n                     * mpglib about buffered data\n                     */\n                    mp3_in = 0;\n\n                    if (samples_out == -1) {\n                        /*\n                         * error decoding. Not fatal, but might screw up the\n                         * ReplayGain tag. What should we do? Ignore for now\n                         */\n                        samples_out = 0;\n                    }\n                    if (samples_out > 0) {\n                        /* process the PCM data */\n\n                        /*\n                         * this should not be possible, and indicates we have\n                         * overflown the pcm_buf buffer\n                         */\n                        assert$17(samples_out <= 1152);\n\n                        if (gfc.findPeakSample) {\n                            for (i = 0; i < samples_out; i++) {\n                                if (pcm_buf[0][i] > gfc.PeakSample)\n                                    gfc.PeakSample = pcm_buf[0][i];\n                                else if (-pcm_buf[0][i] > gfc.PeakSample)\n                                    gfc.PeakSample = -pcm_buf[0][i];\n                            }\n                            if (gfc.channels_out > 1)\n                                for (i = 0; i < samples_out; i++) {\n                                    if (pcm_buf[1][i] > gfc.PeakSample)\n                                        gfc.PeakSample = pcm_buf[1][i];\n                                    else if (-pcm_buf[1][i] > gfc.PeakSample)\n                                        gfc.PeakSample = -pcm_buf[1][i];\n                                }\n                        }\n\n                        if (gfc.findReplayGain)\n                            if (ga.AnalyzeSamples(gfc.rgdata, pcm_buf[0], 0,\n                                    pcm_buf[1], 0, samples_out,\n                                    gfc.channels_out) == GainAnalysis.GAIN_ANALYSIS_ERROR)\n                                return -6;\n\n                    }\n                    /* if (samples_out>0) */\n                }\n                /* while (samples_out!=0) */\n            }\n            /* if (gfc.decode_on_the_fly) */\n\n        }\n        /* if (mp3data) */\n        return minimum;\n    };\n\n    this.init_bit_stream_w = function (gfc) {\n        buf = new_byte$17(Lame.LAME_MAXMP3BUFFER);\n\n        gfc.h_ptr = gfc.w_ptr = 0;\n        gfc.header[gfc.h_ptr].write_timing = 0;\n        bufByteIdx = -1;\n        bufBitIdx = 0;\n        totbit = 0;\n    };\n\n    // From machine.h\n\n\n}\n\nvar BitStream_1 = BitStream$1;\n\nvar System$2 = common.System;\nvar VbrMode$2 = common.VbrMode;\nvar ShortBlock$2 = common.ShortBlock;\nvar new_float$2 = common.new_float;\nvar new_int_n$2 = common.new_int_n;\nvar new_short_n$1 = common.new_short_n;\nvar assert$2 = common.assert;\n\n\n\n\n\n\n\n\n\n\n\nfunction Lame$1() {\n    var self = this;\n    var LAME_MAXALBUMART = (128 * 1024);\n\n    Lame$1.V9 = 410;\n    Lame$1.V8 = 420;\n    Lame$1.V7 = 430;\n    Lame$1.V6 = 440;\n    Lame$1.V5 = 450;\n    Lame$1.V4 = 460;\n    Lame$1.V3 = 470;\n    Lame$1.V2 = 480;\n    Lame$1.V1 = 490;\n    Lame$1.V0 = 500;\n\n    /* still there for compatibility */\n\n    Lame$1.R3MIX = 1000;\n    Lame$1.STANDARD = 1001;\n    Lame$1.EXTREME = 1002;\n    Lame$1.INSANE = 1003;\n    Lame$1.STANDARD_FAST = 1004;\n    Lame$1.EXTREME_FAST = 1005;\n    Lame$1.MEDIUM = 1006;\n    Lame$1.MEDIUM_FAST = 1007;\n\n    /**\n     * maximum size of mp3buffer needed if you encode at most 1152 samples for\n     * each call to lame_encode_buffer. see lame_encode_buffer() below\n     * (LAME_MAXMP3BUFFER is now obsolete)\n     */\n    var LAME_MAXMP3BUFFER = (16384 + LAME_MAXALBUMART);\n    Lame$1.LAME_MAXMP3BUFFER = LAME_MAXMP3BUFFER;\n\n    var ga;\n    var bs;\n    var p;\n    var qupvt;\n    var qu;\n    var psy = new PsyModel_1();\n    var vbr;\n    var ver;\n    var id3;\n    var mpglib;\n    this.enc = new Encoder_1();\n\n    this.setModules = function (_ga, _bs, _p, _qupvt, _qu, _vbr, _ver, _id3, _mpglib) {\n        ga = _ga;\n        bs = _bs;\n        p = _p;\n        qupvt = _qupvt;\n        qu = _qu;\n        vbr = _vbr;\n        ver = _ver;\n        id3 = _id3;\n        mpglib = _mpglib;\n        this.enc.setModules(bs, psy, qupvt, vbr);\n    };\n\n    /**\n     * PSY Model related stuff\n     */\n    function PSY() {\n        /**\n         * The dbQ stuff.\n         */\n        this.mask_adjust = 0.;\n        /**\n         * The dbQ stuff.\n         */\n        this.mask_adjust_short = 0.;\n        /* at transition from one scalefactor band to next */\n        /**\n         * Band weight long scalefactor bands.\n         */\n        this.bo_l_weight = new_float$2(Encoder_1.SBMAX_l);\n        /**\n         * Band weight short scalefactor bands.\n         */\n        this.bo_s_weight = new_float$2(Encoder_1.SBMAX_s);\n    }\n\n    function LowPassHighPass() {\n        this.lowerlimit = 0.;\n    }\n\n    function BandPass(bitrate, lPass) {\n        this.lowpass = lPass;\n    }\n\n    var LAME_ID = 0xFFF88E3B;\n\n    function lame_init_old(gfp) {\n        var gfc;\n\n        gfp.class_id = LAME_ID;\n\n        gfc = gfp.internal_flags = new LameInternalFlags_1();\n\n        /* Global flags. set defaults here for non-zero values */\n        /* see lame.h for description */\n        /*\n         * set integer values to -1 to mean that LAME will compute the best\n         * value, UNLESS the calling program as set it (and the value is no\n         * longer -1)\n         */\n\n        gfp.mode = MPEGMode.NOT_SET;\n        gfp.original = 1;\n        gfp.in_samplerate = 44100;\n        gfp.num_channels = 2;\n        gfp.num_samples = -1;\n\n        gfp.bWriteVbrTag = true;\n        gfp.quality = -1;\n        gfp.short_blocks = null;\n        gfc.subblock_gain = -1;\n\n        gfp.lowpassfreq = 0;\n        gfp.highpassfreq = 0;\n        gfp.lowpasswidth = -1;\n        gfp.highpasswidth = -1;\n\n        gfp.VBR = VbrMode$2.vbr_off;\n        gfp.VBR_q = 4;\n        gfp.ATHcurve = -1;\n        gfp.VBR_mean_bitrate_kbps = 128;\n        gfp.VBR_min_bitrate_kbps = 0;\n        gfp.VBR_max_bitrate_kbps = 0;\n        gfp.VBR_hard_min = 0;\n        gfc.VBR_min_bitrate = 1;\n        /* not 0 ????? */\n        gfc.VBR_max_bitrate = 13;\n        /* not 14 ????? */\n\n        gfp.quant_comp = -1;\n        gfp.quant_comp_short = -1;\n\n        gfp.msfix = -1;\n\n        gfc.resample_ratio = 1;\n\n        gfc.OldValue[0] = 180;\n        gfc.OldValue[1] = 180;\n        gfc.CurrentStep[0] = 4;\n        gfc.CurrentStep[1] = 4;\n        gfc.masking_lower = 1;\n        gfc.nsPsy.attackthre = -1;\n        gfc.nsPsy.attackthre_s = -1;\n\n        gfp.scale = -1;\n\n        gfp.athaa_type = -1;\n        gfp.ATHtype = -1;\n        /* default = -1 = set in lame_init_params */\n        gfp.athaa_loudapprox = -1;\n        /* 1 = flat loudness approx. (total energy) */\n        /* 2 = equal loudness curve */\n        gfp.athaa_sensitivity = 0.0;\n        /* no offset */\n        gfp.useTemporal = null;\n        gfp.interChRatio = -1;\n\n        /*\n         * The reason for int mf_samples_to_encode = ENCDELAY + POSTDELAY;\n         * ENCDELAY = internal encoder delay. And then we have to add\n         * POSTDELAY=288 because of the 50% MDCT overlap. A 576 MDCT granule\n         * decodes to 1152 samples. To synthesize the 576 samples centered under\n         * this granule we need the previous granule for the first 288 samples\n         * (no problem), and the next granule for the next 288 samples (not\n         * possible if this is last granule). So we need to pad with 288 samples\n         * to make sure we can encode the 576 samples we are interested in.\n         */\n        gfc.mf_samples_to_encode = Encoder_1.ENCDELAY + Encoder_1.POSTDELAY;\n        gfp.encoder_padding = 0;\n        gfc.mf_size = Encoder_1.ENCDELAY - Encoder_1.MDCTDELAY;\n        /*\n         * we pad input with this many 0's\n         */\n\n        gfp.findReplayGain = false;\n        gfp.decode_on_the_fly = false;\n\n        gfc.decode_on_the_fly = false;\n        gfc.findReplayGain = false;\n        gfc.findPeakSample = false;\n\n        gfc.RadioGain = 0;\n        gfc.AudiophileGain = 0;\n        gfc.noclipGainChange = 0;\n        gfc.noclipScale = -1.0;\n\n        gfp.preset = 0;\n\n        gfp.write_id3tag_automatic = true;\n        return 0;\n    }\n\n    this.lame_init = function () {\n        var gfp = new LameGlobalFlags_1();\n\n        var ret = lame_init_old(gfp);\n        if (ret != 0) {\n            return null;\n        }\n\n        gfp.lame_allocated_gfp = 1;\n        return gfp;\n    };\n\n    function filter_coef(x) {\n        if (x > 1.0)\n            return 0.0;\n        if (x <= 0.0)\n            return 1.0;\n\n        return Math.cos(Math.PI / 2 * x);\n    }\n\n    this.nearestBitrateFullIndex = function (bitrate) {\n        /* borrowed from DM abr presets */\n\n        var full_bitrate_table = [8, 16, 24, 32, 40, 48, 56, 64, 80,\n            96, 112, 128, 160, 192, 224, 256, 320];\n\n        var lower_range = 0, lower_range_kbps = 0, upper_range = 0, upper_range_kbps = 0;\n\n        /* We assume specified bitrate will be 320kbps */\n        upper_range_kbps = full_bitrate_table[16];\n        upper_range = 16;\n        lower_range_kbps = full_bitrate_table[16];\n        lower_range = 16;\n\n        /*\n         * Determine which significant bitrates the value specified falls\n         * between, if loop ends without breaking then we were correct above\n         * that the value was 320\n         */\n        for (var b = 0; b < 16; b++) {\n            if ((Math.max(bitrate, full_bitrate_table[b + 1])) != bitrate) {\n                upper_range_kbps = full_bitrate_table[b + 1];\n                upper_range = b + 1;\n                lower_range_kbps = full_bitrate_table[b];\n                lower_range = (b);\n                break;\n                /* We found upper range */\n            }\n        }\n\n        /* Determine which range the value specified is closer to */\n        if ((upper_range_kbps - bitrate) > (bitrate - lower_range_kbps)) {\n            return lower_range;\n        }\n        return upper_range;\n    };\n\n    function optimum_samplefreq(lowpassfreq, input_samplefreq) {\n        /*\n         * Rules:\n         *\n         * - if possible, sfb21 should NOT be used\n         */\n        var suggested_samplefreq = 44100;\n\n        if (input_samplefreq >= 48000)\n            suggested_samplefreq = 48000;\n        else if (input_samplefreq >= 44100)\n            suggested_samplefreq = 44100;\n        else if (input_samplefreq >= 32000)\n            suggested_samplefreq = 32000;\n        else if (input_samplefreq >= 24000)\n            suggested_samplefreq = 24000;\n        else if (input_samplefreq >= 22050)\n            suggested_samplefreq = 22050;\n        else if (input_samplefreq >= 16000)\n            suggested_samplefreq = 16000;\n        else if (input_samplefreq >= 12000)\n            suggested_samplefreq = 12000;\n        else if (input_samplefreq >= 11025)\n            suggested_samplefreq = 11025;\n        else if (input_samplefreq >= 8000)\n            suggested_samplefreq = 8000;\n\n        if (lowpassfreq == -1)\n            return suggested_samplefreq;\n\n        if (lowpassfreq <= 15960)\n            suggested_samplefreq = 44100;\n        if (lowpassfreq <= 15250)\n            suggested_samplefreq = 32000;\n        if (lowpassfreq <= 11220)\n            suggested_samplefreq = 24000;\n        if (lowpassfreq <= 9970)\n            suggested_samplefreq = 22050;\n        if (lowpassfreq <= 7230)\n            suggested_samplefreq = 16000;\n        if (lowpassfreq <= 5420)\n            suggested_samplefreq = 12000;\n        if (lowpassfreq <= 4510)\n            suggested_samplefreq = 11025;\n        if (lowpassfreq <= 3970)\n            suggested_samplefreq = 8000;\n\n        if (input_samplefreq < suggested_samplefreq) {\n            /*\n             * choose a valid MPEG sample frequency above the input sample\n             * frequency to avoid SFB21/12 bitrate bloat rh 061115\n             */\n            if (input_samplefreq > 44100) {\n                return 48000;\n            }\n            if (input_samplefreq > 32000) {\n                return 44100;\n            }\n            if (input_samplefreq > 24000) {\n                return 32000;\n            }\n            if (input_samplefreq > 22050) {\n                return 24000;\n            }\n            if (input_samplefreq > 16000) {\n                return 22050;\n            }\n            if (input_samplefreq > 12000) {\n                return 16000;\n            }\n            if (input_samplefreq > 11025) {\n                return 12000;\n            }\n            if (input_samplefreq > 8000) {\n                return 11025;\n            }\n            return 8000;\n        }\n        return suggested_samplefreq;\n    }\n\n    /**\n     * convert samp freq in Hz to index\n     */\n    function SmpFrqIndex(sample_freq, gpf) {\n        switch (sample_freq) {\n            case 44100:\n                gpf.version = 1;\n                return 0;\n            case 48000:\n                gpf.version = 1;\n                return 1;\n            case 32000:\n                gpf.version = 1;\n                return 2;\n            case 22050:\n                gpf.version = 0;\n                return 0;\n            case 24000:\n                gpf.version = 0;\n                return 1;\n            case 16000:\n                gpf.version = 0;\n                return 2;\n            case 11025:\n                gpf.version = 0;\n                return 0;\n            case 12000:\n                gpf.version = 0;\n                return 1;\n            case 8000:\n                gpf.version = 0;\n                return 2;\n            default:\n                gpf.version = 0;\n                return -1;\n        }\n    }\n\n    /**\n     * @param bRate\n     *            legal rates from 8 to 320\n     */\n    function FindNearestBitrate(bRate, version, samplerate) {\n        /* MPEG-1 or MPEG-2 LSF */\n        if (samplerate < 16000)\n            version = 2;\n\n        var bitrate = Tables_1.bitrate_table[version][1];\n\n        for (var i = 2; i <= 14; i++) {\n            if (Tables_1.bitrate_table[version][i] > 0) {\n                if (Math.abs(Tables_1.bitrate_table[version][i] - bRate) < Math\n                        .abs(bitrate - bRate))\n                    bitrate = Tables_1.bitrate_table[version][i];\n            }\n        }\n        return bitrate;\n    }\n\n    /**\n     * @param bRate\n     *            legal rates from 32 to 448 kbps\n     * @param version\n     *            MPEG-1 or MPEG-2/2.5 LSF\n     */\n    function BitrateIndex(bRate, version, samplerate) {\n        /* convert bitrate in kbps to index */\n        if (samplerate < 16000)\n            version = 2;\n        for (var i = 0; i <= 14; i++) {\n            if (Tables_1.bitrate_table[version][i] > 0) {\n                if (Tables_1.bitrate_table[version][i] == bRate) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    function optimum_bandwidth(lh, bitrate) {\n        /**\n         * <PRE>\n         *  Input:\n         *      bitrate     total bitrate in kbps\n         *\n         *   Output:\n         *      lowerlimit: best lowpass frequency limit for input filter in Hz\n         *      upperlimit: best highpass frequency limit for input filter in Hz\n         * </PRE>\n         */\n        var freq_map = [new BandPass(8, 2000),\n            new BandPass(16, 3700), new BandPass(24, 3900),\n            new BandPass(32, 5500), new BandPass(40, 7000),\n            new BandPass(48, 7500), new BandPass(56, 10000),\n            new BandPass(64, 11000), new BandPass(80, 13500),\n            new BandPass(96, 15100), new BandPass(112, 15600),\n            new BandPass(128, 17000), new BandPass(160, 17500),\n            new BandPass(192, 18600), new BandPass(224, 19400),\n            new BandPass(256, 19700), new BandPass(320, 20500)];\n\n        var table_index = self.nearestBitrateFullIndex(bitrate);\n        lh.lowerlimit = freq_map[table_index].lowpass;\n    }\n\n    function lame_init_params_ppflt(gfp) {\n        var gfc = gfp.internal_flags;\n        /***************************************************************/\n        /* compute info needed for polyphase filter (filter type==0, default) */\n        /***************************************************************/\n\n        var lowpass_band = 32;\n        var highpass_band = -1;\n\n        if (gfc.lowpass1 > 0) {\n            var minband = 999;\n            for (var band = 0; band <= 31; band++) {\n                var freq = (band / 31.0);\n                /* this band and above will be zeroed: */\n                if (freq >= gfc.lowpass2) {\n                    lowpass_band = Math.min(lowpass_band, band);\n                }\n                if (gfc.lowpass1 < freq && freq < gfc.lowpass2) {\n                    minband = Math.min(minband, band);\n                }\n            }\n\n            /*\n             * compute the *actual* transition band implemented by the polyphase\n             * filter\n             */\n            if (minband == 999) {\n                gfc.lowpass1 = (lowpass_band - .75) / 31.0;\n            } else {\n                gfc.lowpass1 = (minband - .75) / 31.0;\n            }\n            gfc.lowpass2 = lowpass_band / 31.0;\n        }\n\n        /*\n         * make sure highpass filter is within 90% of what the effective\n         * highpass frequency will be\n         */\n        if (gfc.highpass2 > 0) {\n            if (gfc.highpass2 < .9 * (.75 / 31.0)) {\n                gfc.highpass1 = 0;\n                gfc.highpass2 = 0;\n                System$2.err.println(\"Warning: highpass filter disabled.  \"\n                    + \"highpass frequency too small\\n\");\n            }\n        }\n\n        if (gfc.highpass2 > 0) {\n            var maxband = -1;\n            for (var band = 0; band <= 31; band++) {\n                var freq = band / 31.0;\n                /* this band and below will be zereod */\n                if (freq <= gfc.highpass1) {\n                    highpass_band = Math.max(highpass_band, band);\n                }\n                if (gfc.highpass1 < freq && freq < gfc.highpass2) {\n                    maxband = Math.max(maxband, band);\n                }\n            }\n            /*\n             * compute the *actual* transition band implemented by the polyphase\n             * filter\n             */\n            gfc.highpass1 = highpass_band / 31.0;\n            if (maxband == -1) {\n                gfc.highpass2 = (highpass_band + .75) / 31.0;\n            } else {\n                gfc.highpass2 = (maxband + .75) / 31.0;\n            }\n        }\n\n        for (var band = 0; band < 32; band++) {\n            var fc1, fc2;\n            var freq = band / 31.0;\n            if (gfc.highpass2 > gfc.highpass1) {\n                fc1 = filter_coef((gfc.highpass2 - freq)\n                    / (gfc.highpass2 - gfc.highpass1 + 1e-20));\n            } else {\n                fc1 = 1.0;\n            }\n            if (gfc.lowpass2 > gfc.lowpass1) {\n                fc2 = filter_coef((freq - gfc.lowpass1)\n                    / (gfc.lowpass2 - gfc.lowpass1 + 1e-20));\n            } else {\n                fc2 = 1.0;\n            }\n            gfc.amp_filter[band] = (fc1 * fc2);\n        }\n    }\n\n    function lame_init_qval(gfp) {\n        var gfc = gfp.internal_flags;\n\n        switch (gfp.quality) {\n            default:\n            case 9: /* no psymodel, no noise shaping */\n                gfc.psymodel = 0;\n                gfc.noise_shaping = 0;\n                gfc.noise_shaping_amp = 0;\n                gfc.noise_shaping_stop = 0;\n                gfc.use_best_huffman = 0;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 8:\n                gfp.quality = 7;\n            //$FALL-THROUGH$\n            case 7:\n                /*\n                 * use psymodel (for short block and m/s switching), but no noise\n                 * shapping\n                 */\n                gfc.psymodel = 1;\n                gfc.noise_shaping = 0;\n                gfc.noise_shaping_amp = 0;\n                gfc.noise_shaping_stop = 0;\n                gfc.use_best_huffman = 0;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 6:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                gfc.noise_shaping_amp = 0;\n                gfc.noise_shaping_stop = 0;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 0;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 5:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                gfc.noise_shaping_amp = 0;\n                gfc.noise_shaping_stop = 0;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 0;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 4:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                gfc.noise_shaping_amp = 0;\n                gfc.noise_shaping_stop = 0;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 1;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 3:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                gfc.noise_shaping_amp = 1;\n                gfc.noise_shaping_stop = 1;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 1;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 2:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                if (gfc.substep_shaping == 0)\n                    gfc.substep_shaping = 2;\n                gfc.noise_shaping_amp = 1;\n                gfc.noise_shaping_stop = 1;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 1;\n                /* inner loop */\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 1:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                if (gfc.substep_shaping == 0)\n                    gfc.substep_shaping = 2;\n                gfc.noise_shaping_amp = 2;\n                gfc.noise_shaping_stop = 1;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 1;\n                gfc.full_outer_loop = 0;\n                break;\n\n            case 0:\n                gfc.psymodel = 1;\n                if (gfc.noise_shaping == 0)\n                    gfc.noise_shaping = 1;\n                if (gfc.substep_shaping == 0)\n                    gfc.substep_shaping = 2;\n                gfc.noise_shaping_amp = 2;\n                gfc.noise_shaping_stop = 1;\n                if (gfc.subblock_gain == -1)\n                    gfc.subblock_gain = 1;\n                gfc.use_best_huffman = 1;\n                /*\n                 * type 2 disabled because of it slowness, in favor of full outer\n                 * loop search\n                 */\n                gfc.full_outer_loop = 0;\n                /*\n                 * full outer loop search disabled because of audible distortions it\n                 * may generate rh 060629\n                 */\n                break;\n        }\n\n    }\n\n    function lame_init_bitstream(gfp) {\n        var gfc = gfp.internal_flags;\n        gfp.frameNum = 0;\n\n        if (gfp.write_id3tag_automatic) {\n            id3.id3tag_write_v2(gfp);\n        }\n        /* initialize histogram data optionally used by frontend */\n\n        gfc.bitrate_stereoMode_Hist = new_int_n$2([16, 4 + 1]);\n        gfc.bitrate_blockType_Hist = new_int_n$2([16, 4 + 1 + 1]);\n\n        gfc.PeakSample = 0.0;\n\n        /* Write initial VBR Header to bitstream and init VBR data */\n        if (gfp.bWriteVbrTag)\n            vbr.InitVbrTag(gfp);\n    }\n\n    /********************************************************************\n     * initialize internal params based on data in gf (globalflags struct filled\n     * in by calling program)\n     *\n     * OUTLINE:\n     *\n     * We first have some complex code to determine bitrate, output samplerate\n     * and mode. It is complicated by the fact that we allow the user to set\n     * some or all of these parameters, and need to determine best possible\n     * values for the rest of them:\n     *\n     * 1. set some CPU related flags 2. check if we are mono.mono, stereo.mono\n     * or stereo.stereo 3. compute bitrate and output samplerate: user may have\n     * set compression ratio user may have set a bitrate user may have set a\n     * output samplerate 4. set some options which depend on output samplerate\n     * 5. compute the actual compression ratio 6. set mode based on compression\n     * ratio\n     *\n     * The remaining code is much simpler - it just sets options based on the\n     * mode & compression ratio:\n     *\n     * set allow_diff_short based on mode select lowpass filter based on\n     * compression ratio & mode set the bitrate index, and min/max bitrates for\n     * VBR modes disable VBR tag if it is not appropriate initialize the\n     * bitstream initialize scalefac_band data set sideinfo_len (based on\n     * channels, CRC, out_samplerate) write an id3v2 tag into the bitstream\n     * write VBR tag into the bitstream set mpeg1/2 flag estimate the number of\n     * frames (based on a lot of data)\n     *\n     * now we set more flags: nspsytune: see code VBR modes see code CBR/ABR see\n     * code\n     *\n     * Finally, we set the algorithm flags based on the gfp.quality value\n     * lame_init_qval(gfp);\n     *\n     ********************************************************************/\n    this.lame_init_params = function (gfp) {\n        var gfc = gfp.internal_flags;\n\n        gfc.Class_ID = 0;\n        if (gfc.ATH == null)\n            gfc.ATH = new ATH_1();\n        if (gfc.PSY == null)\n            gfc.PSY = new PSY();\n        if (gfc.rgdata == null)\n            gfc.rgdata = new ReplayGain_1();\n\n        gfc.channels_in = gfp.num_channels;\n        if (gfc.channels_in == 1)\n            gfp.mode = MPEGMode.MONO;\n        gfc.channels_out = (gfp.mode == MPEGMode.MONO) ? 1 : 2;\n        gfc.mode_ext = Encoder_1.MPG_MD_MS_LR;\n        if (gfp.mode == MPEGMode.MONO)\n            gfp.force_ms = false;\n        /*\n         * don't allow forced mid/side stereo for mono output\n         */\n\n        if (gfp.VBR == VbrMode$2.vbr_off && gfp.VBR_mean_bitrate_kbps != 128\n            && gfp.brate == 0)\n            gfp.brate = gfp.VBR_mean_bitrate_kbps;\n\n        if (gfp.VBR == VbrMode$2.vbr_off || gfp.VBR == VbrMode$2.vbr_mtrh\n            || gfp.VBR == VbrMode$2.vbr_mt) {\n            /* these modes can handle free format condition */\n        } else {\n            gfp.free_format = false;\n            /* mode can't be mixed with free format */\n        }\n\n        if (gfp.VBR == VbrMode$2.vbr_off && gfp.brate == 0) {\n            /* no bitrate or compression ratio specified, use 11.025 */\n            if (BitStream_1.EQ(gfp.compression_ratio, 0))\n                gfp.compression_ratio = 11.025;\n            /*\n             * rate to compress a CD down to exactly 128000 bps\n             */\n        }\n\n        /* find bitrate if user specify a compression ratio */\n        if (gfp.VBR == VbrMode$2.vbr_off && gfp.compression_ratio > 0) {\n\n            if (gfp.out_samplerate == 0)\n                gfp.out_samplerate = map2MP3Frequency((int)(0.97 * gfp.in_samplerate));\n            /*\n             * round up with a margin of 3 %\n             */\n\n            /*\n             * choose a bitrate for the output samplerate which achieves\n             * specified compression ratio\n             */\n            gfp.brate = 0 | (gfp.out_samplerate * 16 * gfc.channels_out / (1.e3 * gfp.compression_ratio));\n\n            /* we need the version for the bitrate table look up */\n            gfc.samplerate_index = SmpFrqIndex(gfp.out_samplerate, gfp);\n\n            if (!gfp.free_format) /*\n             * for non Free Format find the nearest allowed\n             * bitrate\n             */\n                gfp.brate = FindNearestBitrate(gfp.brate, gfp.version,\n                    gfp.out_samplerate);\n        }\n\n        if (gfp.out_samplerate != 0) {\n            if (gfp.out_samplerate < 16000) {\n                gfp.VBR_mean_bitrate_kbps = Math.max(gfp.VBR_mean_bitrate_kbps,\n                    8);\n                gfp.VBR_mean_bitrate_kbps = Math.min(gfp.VBR_mean_bitrate_kbps,\n                    64);\n            } else if (gfp.out_samplerate < 32000) {\n                gfp.VBR_mean_bitrate_kbps = Math.max(gfp.VBR_mean_bitrate_kbps,\n                    8);\n                gfp.VBR_mean_bitrate_kbps = Math.min(gfp.VBR_mean_bitrate_kbps,\n                    160);\n            } else {\n                gfp.VBR_mean_bitrate_kbps = Math.max(gfp.VBR_mean_bitrate_kbps,\n                    32);\n                gfp.VBR_mean_bitrate_kbps = Math.min(gfp.VBR_mean_bitrate_kbps,\n                    320);\n            }\n        }\n\n        /****************************************************************/\n        /* if a filter has not been enabled, see if we should add one: */\n        /****************************************************************/\n        if (gfp.lowpassfreq == 0) {\n            var lowpass = 16000.;\n\n            switch (gfp.VBR) {\n                case VbrMode$2.vbr_off:\n                {\n                    var lh = new LowPassHighPass();\n                    optimum_bandwidth(lh, gfp.brate);\n                    lowpass = lh.lowerlimit;\n                    break;\n                }\n                case VbrMode$2.vbr_abr:\n                {\n                    var lh = new LowPassHighPass();\n                    optimum_bandwidth(lh, gfp.VBR_mean_bitrate_kbps);\n                    lowpass = lh.lowerlimit;\n                    break;\n                }\n                case VbrMode$2.vbr_rh:\n                {\n                    var x = [19500, 19000, 18600, 18000, 17500, 16000,\n                        15600, 14900, 12500, 10000, 3950];\n                    if (0 <= gfp.VBR_q && gfp.VBR_q <= 9) {\n                        var a = x[gfp.VBR_q], b = x[gfp.VBR_q + 1], m = gfp.VBR_q_frac;\n                        lowpass = linear_int(a, b, m);\n                    } else {\n                        lowpass = 19500;\n                    }\n                    break;\n                }\n                default:\n                {\n                    var x = [19500, 19000, 18500, 18000, 17500, 16500,\n                        15500, 14500, 12500, 9500, 3950];\n                    if (0 <= gfp.VBR_q && gfp.VBR_q <= 9) {\n                        var a = x[gfp.VBR_q], b = x[gfp.VBR_q + 1], m = gfp.VBR_q_frac;\n                        lowpass = linear_int(a, b, m);\n                    } else {\n                        lowpass = 19500;\n                    }\n                }\n            }\n            if (gfp.mode == MPEGMode.MONO\n                && (gfp.VBR == VbrMode$2.vbr_off || gfp.VBR == VbrMode$2.vbr_abr))\n                lowpass *= 1.5;\n\n            gfp.lowpassfreq = lowpass | 0;\n        }\n\n        if (gfp.out_samplerate == 0) {\n            if (2 * gfp.lowpassfreq > gfp.in_samplerate) {\n                gfp.lowpassfreq = gfp.in_samplerate / 2;\n            }\n            gfp.out_samplerate = optimum_samplefreq(gfp.lowpassfreq | 0,\n                gfp.in_samplerate);\n        }\n\n        gfp.lowpassfreq = Math.min(20500, gfp.lowpassfreq);\n        gfp.lowpassfreq = Math.min(gfp.out_samplerate / 2, gfp.lowpassfreq);\n\n        if (gfp.VBR == VbrMode$2.vbr_off) {\n            gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out\n                / (1.e3 * gfp.brate);\n        }\n        if (gfp.VBR == VbrMode$2.vbr_abr) {\n            gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out\n                / (1.e3 * gfp.VBR_mean_bitrate_kbps);\n        }\n\n        /*\n         * do not compute ReplayGain values and do not find the peak sample if\n         * we can't store them\n         */\n        if (!gfp.bWriteVbrTag) {\n            gfp.findReplayGain = false;\n            gfp.decode_on_the_fly = false;\n            gfc.findPeakSample = false;\n        }\n        gfc.findReplayGain = gfp.findReplayGain;\n        gfc.decode_on_the_fly = gfp.decode_on_the_fly;\n\n        if (gfc.decode_on_the_fly)\n            gfc.findPeakSample = true;\n\n        if (gfc.findReplayGain) {\n            if (ga.InitGainAnalysis(gfc.rgdata, gfp.out_samplerate) == GainAnalysis.INIT_GAIN_ANALYSIS_ERROR) {\n                gfp.internal_flags = null;\n                return -6;\n            }\n        }\n\n        if (gfc.decode_on_the_fly && !gfp.decode_only) {\n            if (gfc.hip != null) {\n                mpglib.hip_decode_exit(gfc.hip);\n            }\n            gfc.hip = mpglib.hip_decode_init();\n        }\n\n        gfc.mode_gr = gfp.out_samplerate <= 24000 ? 1 : 2;\n        /*\n         * Number of granules per frame\n         */\n        gfp.framesize = 576 * gfc.mode_gr;\n        gfp.encoder_delay = Encoder_1.ENCDELAY;\n\n        gfc.resample_ratio = gfp.in_samplerate / gfp.out_samplerate;\n\n        /**\n         * <PRE>\n         *  sample freq       bitrate     compression ratio\n         *     [kHz]      [kbps/channel]   for 16 bit input\n         *     44.1            56               12.6\n         *     44.1            64               11.025\n         *     44.1            80                8.82\n         *     22.05           24               14.7\n         *     22.05           32               11.025\n         *     22.05           40                8.82\n         *     16              16               16.0\n         *     16              24               10.667\n         * </PRE>\n         */\n        /**\n         * <PRE>\n         *  For VBR, take a guess at the compression_ratio.\n         *  For example:\n         *\n         *    VBR_q    compression     like\n         *     -        4.4         320 kbps/44 kHz\n         *   0...1      5.5         256 kbps/44 kHz\n         *     2        7.3         192 kbps/44 kHz\n         *     4        8.8         160 kbps/44 kHz\n         *     6       11           128 kbps/44 kHz\n         *     9       14.7          96 kbps\n         *\n         *  for lower bitrates, downsample with --resample\n         * </PRE>\n         */\n        switch (gfp.VBR) {\n            case VbrMode$2.vbr_mt:\n            case VbrMode$2.vbr_rh:\n            case VbrMode$2.vbr_mtrh:\n            {\n                /* numbers are a bit strange, but they determine the lowpass value */\n                var cmp = [5.7, 6.5, 7.3, 8.2, 10, 11.9, 13, 14,\n                    15, 16.5];\n                gfp.compression_ratio = cmp[gfp.VBR_q];\n            }\n                break;\n            case VbrMode$2.vbr_abr:\n                gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out\n                    / (1.e3 * gfp.VBR_mean_bitrate_kbps);\n                break;\n            default:\n                gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out\n                    / (1.e3 * gfp.brate);\n                break;\n        }\n\n        /*\n         * mode = -1 (not set by user) or mode = MONO (because of only 1 input\n         * channel). If mode has not been set, then select J-STEREO\n         */\n        if (gfp.mode == MPEGMode.NOT_SET) {\n            gfp.mode = MPEGMode.JOINT_STEREO;\n        }\n\n        /* apply user driven high pass filter */\n        if (gfp.highpassfreq > 0) {\n            gfc.highpass1 = 2. * gfp.highpassfreq;\n\n            if (gfp.highpasswidth >= 0)\n                gfc.highpass2 = 2. * (gfp.highpassfreq + gfp.highpasswidth);\n            else\n            /* 0% above on default */\n                gfc.highpass2 = (1 + 0.00) * 2. * gfp.highpassfreq;\n\n            gfc.highpass1 /= gfp.out_samplerate;\n            gfc.highpass2 /= gfp.out_samplerate;\n        } else {\n            gfc.highpass1 = 0;\n            gfc.highpass2 = 0;\n        }\n        /* apply user driven low pass filter */\n        if (gfp.lowpassfreq > 0) {\n            gfc.lowpass2 = 2. * gfp.lowpassfreq;\n            if (gfp.lowpasswidth >= 0) {\n                gfc.lowpass1 = 2. * (gfp.lowpassfreq - gfp.lowpasswidth);\n                if (gfc.lowpass1 < 0) /* has to be >= 0 */\n                    gfc.lowpass1 = 0;\n            } else { /* 0% below on default */\n                gfc.lowpass1 = (1 - 0.00) * 2. * gfp.lowpassfreq;\n            }\n            gfc.lowpass1 /= gfp.out_samplerate;\n            gfc.lowpass2 /= gfp.out_samplerate;\n        } else {\n            gfc.lowpass1 = 0;\n            gfc.lowpass2 = 0;\n        }\n\n        /**********************************************************************/\n        /* compute info needed for polyphase filter (filter type==0, default) */\n        /**********************************************************************/\n        lame_init_params_ppflt(gfp);\n        /*******************************************************\n         * samplerate and bitrate index\n         *******************************************************/\n        gfc.samplerate_index = SmpFrqIndex(gfp.out_samplerate, gfp);\n        if (gfc.samplerate_index < 0) {\n            gfp.internal_flags = null;\n            return -1;\n        }\n\n        if (gfp.VBR == VbrMode$2.vbr_off) {\n            if (gfp.free_format) {\n                gfc.bitrate_index = 0;\n            } else {\n                gfp.brate = FindNearestBitrate(gfp.brate, gfp.version,\n                    gfp.out_samplerate);\n                gfc.bitrate_index = BitrateIndex(gfp.brate, gfp.version,\n                    gfp.out_samplerate);\n                if (gfc.bitrate_index <= 0) {\n                    gfp.internal_flags = null;\n                    return -1;\n                }\n            }\n        } else {\n            gfc.bitrate_index = 1;\n        }\n\n        /* for CBR, we will write an \"info\" tag. */\n\n        if (gfp.analysis)\n            gfp.bWriteVbrTag = false;\n\n        /* some file options not allowed if output is: not specified or stdout */\n        if (gfc.pinfo != null)\n            gfp.bWriteVbrTag = false;\n        /* disable Xing VBR tag */\n\n        bs.init_bit_stream_w(gfc);\n\n        var j = gfc.samplerate_index + (3 * gfp.version) + 6\n            * (gfp.out_samplerate < 16000 ? 1 : 0);\n        for (var i = 0; i < Encoder_1.SBMAX_l + 1; i++)\n            gfc.scalefac_band.l[i] = qupvt.sfBandIndex[j].l[i];\n\n        for (var i = 0; i < Encoder_1.PSFB21 + 1; i++) {\n            var size = (gfc.scalefac_band.l[22] - gfc.scalefac_band.l[21])\n                / Encoder_1.PSFB21;\n            var start = gfc.scalefac_band.l[21] + i * size;\n            gfc.scalefac_band.psfb21[i] = start;\n        }\n        gfc.scalefac_band.psfb21[Encoder_1.PSFB21] = 576;\n\n        for (var i = 0; i < Encoder_1.SBMAX_s + 1; i++)\n            gfc.scalefac_band.s[i] = qupvt.sfBandIndex[j].s[i];\n\n        for (var i = 0; i < Encoder_1.PSFB12 + 1; i++) {\n            var size = (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12])\n                / Encoder_1.PSFB12;\n            var start = gfc.scalefac_band.s[12] + i * size;\n            gfc.scalefac_band.psfb12[i] = start;\n        }\n        gfc.scalefac_band.psfb12[Encoder_1.PSFB12] = 192;\n        /* determine the mean bitrate for main data */\n        if (gfp.version == 1) /* MPEG 1 */\n            gfc.sideinfo_len = (gfc.channels_out == 1) ? 4 + 17 : 4 + 32;\n        else\n        /* MPEG 2 */\n            gfc.sideinfo_len = (gfc.channels_out == 1) ? 4 + 9 : 4 + 17;\n\n        if (gfp.error_protection)\n            gfc.sideinfo_len += 2;\n\n        lame_init_bitstream(gfp);\n\n        gfc.Class_ID = LAME_ID;\n\n        {\n            var k;\n\n            for (k = 0; k < 19; k++)\n                gfc.nsPsy.pefirbuf[k] = 700 * gfc.mode_gr * gfc.channels_out;\n\n            if (gfp.ATHtype == -1)\n                gfp.ATHtype = 4;\n        }\n        assert$2(gfp.VBR_q <= 9);\n        assert$2(gfp.VBR_q >= 0);\n\n        switch (gfp.VBR) {\n\n            case VbrMode$2.vbr_mt:\n                gfp.VBR = VbrMode$2.vbr_mtrh;\n            //$FALL-THROUGH$\n            case VbrMode$2.vbr_mtrh:\n            {\n                if (gfp.useTemporal == null) {\n                    gfp.useTemporal = false;\n                    /* off by default for this VBR mode */\n                }\n\n                p.apply_preset(gfp, 500 - (gfp.VBR_q * 10), 0);\n                /**\n                 * <PRE>\n                 *   The newer VBR code supports only a limited\n                 *     subset of quality levels:\n                 *     9-5=5 are the same, uses x^3/4 quantization\n                 *   4-0=0 are the same  5 plus best huffman divide code\n                 * </PRE>\n                 */\n                if (gfp.quality < 0)\n                    gfp.quality = LAME_DEFAULT_QUALITY;\n                if (gfp.quality < 5)\n                    gfp.quality = 0;\n                if (gfp.quality > 5)\n                    gfp.quality = 5;\n\n                gfc.PSY.mask_adjust = gfp.maskingadjust;\n                gfc.PSY.mask_adjust_short = gfp.maskingadjust_short;\n\n                /*\n                 * sfb21 extra only with MPEG-1 at higher sampling rates\n                 */\n                if (gfp.experimentalY)\n                    gfc.sfb21_extra = false;\n                else\n                    gfc.sfb21_extra = (gfp.out_samplerate > 44000);\n\n                gfc.iteration_loop = new VBRNewIterationLoop(qu);\n                break;\n\n            }\n            case VbrMode$2.vbr_rh:\n            {\n\n                p.apply_preset(gfp, 500 - (gfp.VBR_q * 10), 0);\n\n                gfc.PSY.mask_adjust = gfp.maskingadjust;\n                gfc.PSY.mask_adjust_short = gfp.maskingadjust_short;\n\n                /*\n                 * sfb21 extra only with MPEG-1 at higher sampling rates\n                 */\n                if (gfp.experimentalY)\n                    gfc.sfb21_extra = false;\n                else\n                    gfc.sfb21_extra = (gfp.out_samplerate > 44000);\n\n                /*\n                 * VBR needs at least the output of GPSYCHO, so we have to garantee\n                 * that by setting a minimum quality level, actually level 6 does\n                 * it. down to level 6\n                 */\n                if (gfp.quality > 6)\n                    gfp.quality = 6;\n\n                if (gfp.quality < 0)\n                    gfp.quality = LAME_DEFAULT_QUALITY;\n\n                gfc.iteration_loop = new VBROldIterationLoop(qu);\n                break;\n            }\n\n            default: /* cbr/abr */\n            {\n                var vbrmode;\n\n                /*\n                 * no sfb21 extra with CBR code\n                 */\n                gfc.sfb21_extra = false;\n\n                if (gfp.quality < 0)\n                    gfp.quality = LAME_DEFAULT_QUALITY;\n\n                vbrmode = gfp.VBR;\n                if (vbrmode == VbrMode$2.vbr_off)\n                    gfp.VBR_mean_bitrate_kbps = gfp.brate;\n                /* second, set parameters depending on bitrate */\n                p.apply_preset(gfp, gfp.VBR_mean_bitrate_kbps, 0);\n                gfp.VBR = vbrmode;\n\n                gfc.PSY.mask_adjust = gfp.maskingadjust;\n                gfc.PSY.mask_adjust_short = gfp.maskingadjust_short;\n\n                if (vbrmode == VbrMode$2.vbr_off) {\n                    gfc.iteration_loop = new CBRNewIterationLoop_1(qu);\n                } else {\n                    gfc.iteration_loop = new ABRIterationLoop(qu);\n                }\n                break;\n            }\n        }\n        assert$2(gfp.scale >= 0);\n        /* initialize default values common for all modes */\n\n        if (gfp.VBR != VbrMode$2.vbr_off) { /* choose a min/max bitrate for VBR */\n            /* if the user didn't specify VBR_max_bitrate: */\n            gfc.VBR_min_bitrate = 1;\n            /*\n             * default: allow 8 kbps (MPEG-2) or 32 kbps (MPEG-1)\n             */\n            gfc.VBR_max_bitrate = 14;\n            /*\n             * default: allow 160 kbps (MPEG-2) or 320 kbps (MPEG-1)\n             */\n            if (gfp.out_samplerate < 16000)\n                gfc.VBR_max_bitrate = 8;\n            /* default: allow 64 kbps (MPEG-2.5) */\n            if (gfp.VBR_min_bitrate_kbps != 0) {\n                gfp.VBR_min_bitrate_kbps = FindNearestBitrate(\n                    gfp.VBR_min_bitrate_kbps, gfp.version,\n                    gfp.out_samplerate);\n                gfc.VBR_min_bitrate = BitrateIndex(gfp.VBR_min_bitrate_kbps,\n                    gfp.version, gfp.out_samplerate);\n                if (gfc.VBR_min_bitrate < 0)\n                    return -1;\n            }\n            if (gfp.VBR_max_bitrate_kbps != 0) {\n                gfp.VBR_max_bitrate_kbps = FindNearestBitrate(\n                    gfp.VBR_max_bitrate_kbps, gfp.version,\n                    gfp.out_samplerate);\n                gfc.VBR_max_bitrate = BitrateIndex(gfp.VBR_max_bitrate_kbps,\n                    gfp.version, gfp.out_samplerate);\n                if (gfc.VBR_max_bitrate < 0)\n                    return -1;\n            }\n            gfp.VBR_min_bitrate_kbps = Tables_1.bitrate_table[gfp.version][gfc.VBR_min_bitrate];\n            gfp.VBR_max_bitrate_kbps = Tables_1.bitrate_table[gfp.version][gfc.VBR_max_bitrate];\n            gfp.VBR_mean_bitrate_kbps = Math.min(\n                Tables_1.bitrate_table[gfp.version][gfc.VBR_max_bitrate],\n                gfp.VBR_mean_bitrate_kbps);\n            gfp.VBR_mean_bitrate_kbps = Math.max(\n                Tables_1.bitrate_table[gfp.version][gfc.VBR_min_bitrate],\n                gfp.VBR_mean_bitrate_kbps);\n        }\n\n        /* just another daily changing developer switch */\n        if (gfp.tune) {\n            gfc.PSY.mask_adjust += gfp.tune_value_a;\n            gfc.PSY.mask_adjust_short += gfp.tune_value_a;\n        }\n\n        /* initialize internal qval settings */\n        lame_init_qval(gfp);\n        assert$2(gfp.scale >= 0);\n        /*\n         * automatic ATH adjustment on\n         */\n        if (gfp.athaa_type < 0)\n            gfc.ATH.useAdjust = 3;\n        else\n            gfc.ATH.useAdjust = gfp.athaa_type;\n\n        /* initialize internal adaptive ATH settings -jd */\n        gfc.ATH.aaSensitivityP = Math.pow(10.0, gfp.athaa_sensitivity\n            / -10.0);\n\n        if (gfp.short_blocks == null) {\n            gfp.short_blocks = ShortBlock$2.short_block_allowed;\n        }\n\n        /*\n         * Note Jan/2003: Many hardware decoders cannot handle short blocks in\n         * regular stereo mode unless they are coupled (same type in both\n         * channels) it is a rare event (1 frame per min. or so) that LAME would\n         * use uncoupled short blocks, so lets turn them off until we decide how\n         * to handle this. No other encoders allow uncoupled short blocks, even\n         * though it is in the standard.\n         */\n        /*\n         * rh 20040217: coupling makes no sense for mono and dual-mono streams\n         */\n        if (gfp.short_blocks == ShortBlock$2.short_block_allowed\n            && (gfp.mode == MPEGMode.JOINT_STEREO || gfp.mode == MPEGMode.STEREO)) {\n            gfp.short_blocks = ShortBlock$2.short_block_coupled;\n        }\n\n        if (gfp.quant_comp < 0)\n            gfp.quant_comp = 1;\n        if (gfp.quant_comp_short < 0)\n            gfp.quant_comp_short = 0;\n\n        if (gfp.msfix < 0)\n            gfp.msfix = 0;\n\n        /* select psychoacoustic model */\n        gfp.exp_nspsytune = gfp.exp_nspsytune | 1;\n\n        if (gfp.internal_flags.nsPsy.attackthre < 0)\n            gfp.internal_flags.nsPsy.attackthre = PsyModel_1.NSATTACKTHRE;\n        if (gfp.internal_flags.nsPsy.attackthre_s < 0)\n            gfp.internal_flags.nsPsy.attackthre_s = PsyModel_1.NSATTACKTHRE_S;\n\n        assert$2(gfp.scale >= 0);\n\n        if (gfp.scale < 0)\n            gfp.scale = 1;\n\n        if (gfp.ATHtype < 0)\n            gfp.ATHtype = 4;\n\n        if (gfp.ATHcurve < 0)\n            gfp.ATHcurve = 4;\n\n        if (gfp.athaa_loudapprox < 0)\n            gfp.athaa_loudapprox = 2;\n\n        if (gfp.interChRatio < 0)\n            gfp.interChRatio = 0;\n\n        if (gfp.useTemporal == null)\n            gfp.useTemporal = true;\n        /* on by default */\n\n        /*\n         * padding method as described in\n         * \"MPEG-Layer3 / Bitstream Syntax and Decoding\" by Martin Sieler, Ralph\n         * Sperschneider\n         *\n         * note: there is no padding for the very first frame\n         *\n         * Robert Hegemann 2000-06-22\n         */\n        gfc.slot_lag = gfc.frac_SpF = 0;\n        if (gfp.VBR == VbrMode$2.vbr_off)\n            gfc.slot_lag = gfc.frac_SpF = (((gfp.version + 1) * 72000 * gfp.brate) % gfp.out_samplerate) | 0;\n\n        qupvt.iteration_init(gfp);\n        psy.psymodel_init(gfp);\n        assert$2(gfp.scale >= 0);\n        return 0;\n    };\n\n    function update_inbuffer_size(gfc, nsamples) {\n        if (gfc.in_buffer_0 == null || gfc.in_buffer_nsamples < nsamples) {\n            gfc.in_buffer_0 = new_float$2(nsamples);\n            gfc.in_buffer_1 = new_float$2(nsamples);\n            gfc.in_buffer_nsamples = nsamples;\n        }\n    }\n\n    this.lame_encode_flush = function (gfp, mp3buffer, mp3bufferPos, mp3buffer_size) {\n        var gfc = gfp.internal_flags;\n        var buffer = new_short_n$1([2, 1152]);\n        var imp3 = 0, mp3count, mp3buffer_size_remaining;\n\n        /*\n         * we always add POSTDELAY=288 padding to make sure granule with real\n         * data can be complety decoded (because of 50% overlap with next\n         * granule\n         */\n        var end_padding;\n        var frames_left;\n        var samples_to_encode = gfc.mf_samples_to_encode - Encoder_1.POSTDELAY;\n        var mf_needed = calcNeeded(gfp);\n\n        /* Was flush already called? */\n        if (gfc.mf_samples_to_encode < 1) {\n            return 0;\n        }\n        mp3count = 0;\n\n        if (gfp.in_samplerate != gfp.out_samplerate) {\n            /*\n             * delay due to resampling; needs to be fixed, if resampling code\n             * gets changed\n             */\n            samples_to_encode += 16. * gfp.out_samplerate / gfp.in_samplerate;\n        }\n        end_padding = gfp.framesize - (samples_to_encode % gfp.framesize);\n        if (end_padding < 576)\n            end_padding += gfp.framesize;\n        gfp.encoder_padding = end_padding;\n\n        frames_left = (samples_to_encode + end_padding) / gfp.framesize;\n\n        /*\n         * send in a frame of 0 padding until all internal sample buffers are\n         * flushed\n         */\n        while (frames_left > 0 && imp3 >= 0) {\n            var bunch = mf_needed - gfc.mf_size;\n            var frame_num = gfp.frameNum;\n\n            bunch *= gfp.in_samplerate;\n            bunch /= gfp.out_samplerate;\n            if (bunch > 1152)\n                bunch = 1152;\n            if (bunch < 1)\n                bunch = 1;\n\n            mp3buffer_size_remaining = mp3buffer_size - mp3count;\n\n            /* if user specifed buffer size = 0, dont check size */\n            if (mp3buffer_size == 0)\n                mp3buffer_size_remaining = 0;\n\n            imp3 = this.lame_encode_buffer(gfp, buffer[0], buffer[1], bunch,\n                mp3buffer, mp3bufferPos, mp3buffer_size_remaining);\n\n            mp3bufferPos += imp3;\n            mp3count += imp3;\n            frames_left -= (frame_num != gfp.frameNum) ? 1 : 0;\n        }\n        /*\n         * Set gfc.mf_samples_to_encode to 0, so we may detect and break loops\n         * calling it more than once in a row.\n         */\n        gfc.mf_samples_to_encode = 0;\n\n        if (imp3 < 0) {\n            /* some type of fatal error */\n            return imp3;\n        }\n\n        mp3buffer_size_remaining = mp3buffer_size - mp3count;\n        /* if user specifed buffer size = 0, dont check size */\n        if (mp3buffer_size == 0)\n            mp3buffer_size_remaining = 0;\n\n        /* mp3 related stuff. bit buffer might still contain some mp3 data */\n        bs.flush_bitstream(gfp);\n        imp3 = bs.copy_buffer(gfc, mp3buffer, mp3bufferPos,\n            mp3buffer_size_remaining, 1);\n        if (imp3 < 0) {\n            /* some type of fatal error */\n            return imp3;\n        }\n        mp3bufferPos += imp3;\n        mp3count += imp3;\n        mp3buffer_size_remaining = mp3buffer_size - mp3count;\n        /* if user specifed buffer size = 0, dont check size */\n        if (mp3buffer_size == 0)\n            mp3buffer_size_remaining = 0;\n\n        if (gfp.write_id3tag_automatic) {\n            /* write a id3 tag to the bitstream */\n            id3.id3tag_write_v1(gfp);\n\n            imp3 = bs.copy_buffer(gfc, mp3buffer, mp3bufferPos,\n                mp3buffer_size_remaining, 0);\n\n            if (imp3 < 0) {\n                return imp3;\n            }\n            mp3count += imp3;\n        }\n        return mp3count;\n    };\n\n    this.lame_encode_buffer = function (gfp, buffer_l, buffer_r, nsamples, mp3buf, mp3bufPos, mp3buf_size) {\n        var gfc = gfp.internal_flags;\n        var in_buffer = [null, null];\n\n        if (gfc.Class_ID != LAME_ID)\n            return -3;\n\n        if (nsamples == 0)\n            return 0;\n\n        update_inbuffer_size(gfc, nsamples);\n\n        in_buffer[0] = gfc.in_buffer_0;\n        in_buffer[1] = gfc.in_buffer_1;\n\n        /* make a copy of input buffer, changing type to sample_t */\n        for (var i = 0; i < nsamples; i++) {\n            in_buffer[0][i] = buffer_l[i];\n            if (gfc.channels_in > 1)\n                in_buffer[1][i] = buffer_r[i];\n        }\n\n        return lame_encode_buffer_sample(gfp, in_buffer[0], in_buffer[1],\n            nsamples, mp3buf, mp3bufPos, mp3buf_size);\n    };\n\n    function calcNeeded(gfp) {\n        var mf_needed = Encoder_1.BLKSIZE + gfp.framesize - Encoder_1.FFTOFFSET;\n        /*\n         * amount needed for FFT\n         */\n        mf_needed = Math.max(mf_needed, 512 + gfp.framesize - 32);\n        assert$2(LameInternalFlags_1.MFSIZE >= mf_needed);\n\n        return mf_needed;\n    }\n\n    function lame_encode_buffer_sample(gfp, buffer_l, buffer_r, nsamples, mp3buf, mp3bufPos, mp3buf_size) {\n        var gfc = gfp.internal_flags;\n        var mp3size = 0, ret, i, ch, mf_needed;\n        var mp3out;\n        var mfbuf = [null, null];\n        var in_buffer = [null, null];\n\n        if (gfc.Class_ID != LAME_ID)\n            return -3;\n\n        if (nsamples == 0)\n            return 0;\n\n        /* copy out any tags that may have been written into bitstream */\n        mp3out = bs.copy_buffer(gfc, mp3buf, mp3bufPos, mp3buf_size, 0);\n        if (mp3out < 0)\n            return mp3out;\n        /* not enough buffer space */\n        mp3bufPos += mp3out;\n        mp3size += mp3out;\n\n        in_buffer[0] = buffer_l;\n        in_buffer[1] = buffer_r;\n\n        /* Apply user defined re-scaling */\n\n        /* user selected scaling of the samples */\n        if (BitStream_1.NEQ(gfp.scale, 0) && BitStream_1.NEQ(gfp.scale, 1.0)) {\n            for (i = 0; i < nsamples; ++i) {\n                in_buffer[0][i] *= gfp.scale;\n                if (gfc.channels_out == 2)\n                    in_buffer[1][i] *= gfp.scale;\n            }\n        }\n\n        /* user selected scaling of the channel 0 (left) samples */\n        if (BitStream_1.NEQ(gfp.scale_left, 0)\n            && BitStream_1.NEQ(gfp.scale_left, 1.0)) {\n            for (i = 0; i < nsamples; ++i) {\n                in_buffer[0][i] *= gfp.scale_left;\n            }\n        }\n\n        /* user selected scaling of the channel 1 (right) samples */\n        if (BitStream_1.NEQ(gfp.scale_right, 0)\n            && BitStream_1.NEQ(gfp.scale_right, 1.0)) {\n            for (i = 0; i < nsamples; ++i) {\n                in_buffer[1][i] *= gfp.scale_right;\n            }\n        }\n\n        /* Downsample to Mono if 2 channels in and 1 channel out */\n        if (gfp.num_channels == 2 && gfc.channels_out == 1) {\n            for (i = 0; i < nsamples; ++i) {\n                in_buffer[0][i] = 0.5 * ( in_buffer[0][i] + in_buffer[1][i]);\n                in_buffer[1][i] = 0.0;\n            }\n        }\n\n        mf_needed = calcNeeded(gfp);\n\n        mfbuf[0] = gfc.mfbuf[0];\n        mfbuf[1] = gfc.mfbuf[1];\n\n        var in_bufferPos = 0;\n        while (nsamples > 0) {\n            var in_buffer_ptr = [null, null];\n            var n_in = 0;\n            /* number of input samples processed with fill_buffer */\n            var n_out = 0;\n            /* number of samples output with fill_buffer */\n            /* n_in <> n_out if we are resampling */\n\n            in_buffer_ptr[0] = in_buffer[0];\n            in_buffer_ptr[1] = in_buffer[1];\n            /* copy in new samples into mfbuf, with resampling */\n            var inOut = new InOut();\n            fill_buffer(gfp, mfbuf, in_buffer_ptr, in_bufferPos, nsamples,\n                inOut);\n            n_in = inOut.n_in;\n            n_out = inOut.n_out;\n\n            /* compute ReplayGain of resampled input if requested */\n            if (gfc.findReplayGain && !gfc.decode_on_the_fly)\n                if (ga.AnalyzeSamples(gfc.rgdata, mfbuf[0], gfc.mf_size,\n                        mfbuf[1], gfc.mf_size, n_out, gfc.channels_out) == GainAnalysis.GAIN_ANALYSIS_ERROR)\n                    return -6;\n\n            /* update in_buffer counters */\n            nsamples -= n_in;\n            in_bufferPos += n_in;\n            if (gfc.channels_out == 2)\n                ;// in_bufferPos += n_in;\n\n            /* update mfbuf[] counters */\n            gfc.mf_size += n_out;\n            assert$2(gfc.mf_size <= LameInternalFlags_1.MFSIZE);\n\n            /*\n             * lame_encode_flush may have set gfc.mf_sample_to_encode to 0 so we\n             * have to reinitialize it here when that happened.\n             */\n            if (gfc.mf_samples_to_encode < 1) {\n                gfc.mf_samples_to_encode = Encoder_1.ENCDELAY + Encoder_1.POSTDELAY;\n            }\n            gfc.mf_samples_to_encode += n_out;\n\n            if (gfc.mf_size >= mf_needed) {\n                /* encode the frame. */\n                /* mp3buf = pointer to current location in buffer */\n                /* mp3buf_size = size of original mp3 output buffer */\n                /* = 0 if we should not worry about the */\n                /* buffer size because calling program is */\n                /* to lazy to compute it */\n                /* mp3size = size of data written to buffer so far */\n                /* mp3buf_size-mp3size = amount of space avalable */\n\n                var buf_size = mp3buf_size - mp3size;\n                if (mp3buf_size == 0)\n                    buf_size = 0;\n\n                ret = lame_encode_frame(gfp, mfbuf[0], mfbuf[1], mp3buf,\n                    mp3bufPos, buf_size);\n\n                if (ret < 0)\n                    return ret;\n                mp3bufPos += ret;\n                mp3size += ret;\n\n                /* shift out old samples */\n                gfc.mf_size -= gfp.framesize;\n                gfc.mf_samples_to_encode -= gfp.framesize;\n                for (ch = 0; ch < gfc.channels_out; ch++)\n                    for (i = 0; i < gfc.mf_size; i++)\n                        mfbuf[ch][i] = mfbuf[ch][i + gfp.framesize];\n            }\n        }\n        assert$2(nsamples == 0);\n\n        return mp3size;\n    }\n\n    function lame_encode_frame(gfp, inbuf_l, inbuf_r, mp3buf, mp3bufPos, mp3buf_size) {\n        var ret = self.enc.lame_encode_mp3_frame(gfp, inbuf_l, inbuf_r, mp3buf,\n            mp3bufPos, mp3buf_size);\n        gfp.frameNum++;\n        return ret;\n    }\n\n    function InOut() {\n        this.n_in = 0;\n        this.n_out = 0;\n    }\n\n\n    function NumUsed() {\n        this.num_used = 0;\n    }\n\n    /**\n     * Greatest common divisor.\n     * <p>\n     * Joint work of Euclid and M. Hendry\n     */\n    function gcd(i, j) {\n        return j != 0 ? gcd(j, i % j) : i;\n    }\n\n    /**\n     * Resampling via FIR filter, blackman window.\n     */\n    function blackman(x, fcn, l) {\n        /*\n         * This algorithm from: SIGNAL PROCESSING ALGORITHMS IN FORTRAN AND C\n         * S.D. Stearns and R.A. David, Prentice-Hall, 1992\n         */\n        var wcn = (Math.PI * fcn);\n\n        x /= l;\n        if (x < 0)\n            x = 0;\n        if (x > 1)\n            x = 1;\n        var x2 = x - .5;\n\n        var bkwn = 0.42 - 0.5 * Math.cos(2 * x * Math.PI) + 0.08 * Math.cos(4 * x * Math.PI);\n        if (Math.abs(x2) < 1e-9)\n            return (wcn / Math.PI);\n        else\n            return (bkwn * Math.sin(l * wcn * x2) / (Math.PI * l * x2));\n    }\n\n    function fill_buffer_resample(gfp, outbuf, outbufPos, desired_len, inbuf, in_bufferPos, len, num_used, ch) {\n        var gfc = gfp.internal_flags;\n        var i, j = 0, k;\n        /* number of convolution functions to pre-compute */\n        var bpc = gfp.out_samplerate\n            / gcd(gfp.out_samplerate, gfp.in_samplerate);\n        if (bpc > LameInternalFlags_1.BPC)\n            bpc = LameInternalFlags_1.BPC;\n\n        var intratio = (Math.abs(gfc.resample_ratio\n            - Math.floor(.5 + gfc.resample_ratio)) < .0001) ? 1 : 0;\n        var fcn = 1.00 / gfc.resample_ratio;\n        if (fcn > 1.00)\n            fcn = 1.00;\n        var filter_l = 31;\n        if (0 == filter_l % 2)\n            --filter_l;\n        /* must be odd */\n        filter_l += intratio;\n        /* unless resample_ratio=int, it must be even */\n\n        var BLACKSIZE = filter_l + 1;\n        /* size of data needed for FIR */\n\n        if (gfc.fill_buffer_resample_init == 0) {\n            gfc.inbuf_old[0] = new_float$2(BLACKSIZE);\n            gfc.inbuf_old[1] = new_float$2(BLACKSIZE);\n            for (i = 0; i <= 2 * bpc; ++i)\n                gfc.blackfilt[i] = new_float$2(BLACKSIZE);\n\n            gfc.itime[0] = 0;\n            gfc.itime[1] = 0;\n\n            /* precompute blackman filter coefficients */\n            for (j = 0; j <= 2 * bpc; j++) {\n                var sum = 0.;\n                var offset = (j - bpc) / (2. * bpc);\n                for (i = 0; i <= filter_l; i++)\n                    sum += gfc.blackfilt[j][i] = blackman(i - offset, fcn,\n                        filter_l);\n                for (i = 0; i <= filter_l; i++)\n                    gfc.blackfilt[j][i] /= sum;\n            }\n            gfc.fill_buffer_resample_init = 1;\n        }\n\n        var inbuf_old = gfc.inbuf_old[ch];\n\n        /* time of j'th element in inbuf = itime + j/ifreq; */\n        /* time of k'th element in outbuf = j/ofreq */\n        for (k = 0; k < desired_len; k++) {\n            var time0;\n            var joff;\n\n            time0 = k * gfc.resample_ratio;\n            /* time of k'th output sample */\n            j = 0 | Math.floor(time0 - gfc.itime[ch]);\n\n            /* check if we need more input data */\n            if ((filter_l + j - filter_l / 2) >= len)\n                break;\n\n            /* blackman filter. by default, window centered at j+.5(filter_l%2) */\n            /* but we want a window centered at time0. */\n            var offset = (time0 - gfc.itime[ch] - (j + .5 * (filter_l % 2)));\n            assert$2(Math.abs(offset) <= .501);\n\n            /* find the closest precomputed window for this offset: */\n            joff = 0 | Math.floor((offset * 2 * bpc) + bpc + .5);\n            var xvalue = 0.;\n            for (i = 0; i <= filter_l; ++i) {\n                var j2 = i + j - filter_l / 2;\n                var y;\n                assert$2(j2 < len);\n                assert$2(j2 + BLACKSIZE >= 0);\n                y = (j2 < 0) ? inbuf_old[BLACKSIZE + j2] : inbuf[in_bufferPos\n                + j2];\n                xvalue += y * gfc.blackfilt[joff][i];\n            }\n            outbuf[outbufPos + k] = xvalue;\n        }\n\n        /* k = number of samples added to outbuf */\n        /* last k sample used data from [j-filter_l/2,j+filter_l-filter_l/2] */\n\n        /* how many samples of input data were used: */\n        num_used.num_used = Math.min(len, filter_l + j - filter_l / 2);\n\n        /*\n         * adjust our input time counter. Incriment by the number of samples\n         * used, then normalize so that next output sample is at time 0, next\n         * input buffer is at time itime[ch]\n         */\n        gfc.itime[ch] += num_used.num_used - k * gfc.resample_ratio;\n\n        /* save the last BLACKSIZE samples into the inbuf_old buffer */\n        if (num_used.num_used >= BLACKSIZE) {\n            for (i = 0; i < BLACKSIZE; i++)\n                inbuf_old[i] = inbuf[in_bufferPos + num_used.num_used + i\n                - BLACKSIZE];\n        } else {\n            /* shift in num_used.num_used samples into inbuf_old */\n            var n_shift = BLACKSIZE - num_used.num_used;\n            /*\n             * number of samples to\n             * shift\n             */\n\n            /*\n             * shift n_shift samples by num_used.num_used, to make room for the\n             * num_used new samples\n             */\n            for (i = 0; i < n_shift; ++i)\n                inbuf_old[i] = inbuf_old[i + num_used.num_used];\n\n            /* shift in the num_used.num_used samples */\n            for (j = 0; i < BLACKSIZE; ++i, ++j)\n                inbuf_old[i] = inbuf[in_bufferPos + j];\n\n            assert$2(j == num_used.num_used);\n        }\n        return k;\n        /* return the number samples created at the new samplerate */\n    }\n\n    function fill_buffer(gfp, mfbuf, in_buffer, in_bufferPos, nsamples, io) {\n        var gfc = gfp.internal_flags;\n\n        /* copy in new samples into mfbuf, with resampling if necessary */\n        if ((gfc.resample_ratio < .9999) || (gfc.resample_ratio > 1.0001)) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                var numUsed = new NumUsed();\n                io.n_out = fill_buffer_resample(gfp, mfbuf[ch], gfc.mf_size,\n                    gfp.framesize, in_buffer[ch], in_bufferPos, nsamples,\n                    numUsed, ch);\n                io.n_in = numUsed.num_used;\n            }\n        } else {\n            io.n_out = Math.min(gfp.framesize, nsamples);\n            io.n_in = io.n_out;\n            for (var i = 0; i < io.n_out; ++i) {\n                mfbuf[0][gfc.mf_size + i] = in_buffer[0][in_bufferPos + i];\n                if (gfc.channels_out == 2)\n                    mfbuf[1][gfc.mf_size + i] = in_buffer[1][in_bufferPos + i];\n            }\n        }\n    }\n\n}\n\nvar Lame_1 = Lame$1;\n\nvar VbrMode$20 = common.VbrMode;\nfunction Presets$1() {\n    function VBRPresets(qual, comp, compS,\n                        y, shThreshold, shThresholdS,\n                        adj, adjShort, lower,\n                        curve, sens, inter,\n                        joint, mod, fix) {\n        this.vbr_q = qual;\n        this.quant_comp = comp;\n        this.quant_comp_s = compS;\n        this.expY = y;\n        this.st_lrm = shThreshold;\n        this.st_s = shThresholdS;\n        this.masking_adj = adj;\n        this.masking_adj_short = adjShort;\n        this.ath_lower = lower;\n        this.ath_curve = curve;\n        this.ath_sensitivity = sens;\n        this.interch = inter;\n        this.safejoint = joint;\n        this.sfb21mod = mod;\n        this.msfix = fix;\n    }\n\n    function ABRPresets(kbps, comp, compS,\n                        joint, fix, shThreshold,\n                        shThresholdS, bass, sc,\n                        mask, lower, curve,\n                        interCh, sfScale) {\n        this.quant_comp = comp;\n        this.quant_comp_s = compS;\n        this.safejoint = joint;\n        this.nsmsfix = fix;\n        this.st_lrm = shThreshold;\n        this.st_s = shThresholdS;\n        this.nsbass = bass;\n        this.scale = sc;\n        this.masking_adj = mask;\n        this.ath_lower = lower;\n        this.ath_curve = curve;\n        this.interch = interCh;\n        this.sfscale = sfScale;\n    }\n\n    var lame;\n\n    this.setModules = function (_lame) {\n        lame = _lame;\n    };\n\n    /**\n     * <PRE>\n     * Switch mappings for VBR mode VBR_RH\n     *             vbr_q  qcomp_l  qcomp_s  expY  st_lrm   st_s  mask adj_l  adj_s  ath_lower  ath_curve  ath_sens  interChR  safejoint sfb21mod  msfix\n     * </PRE>\n     */\n    var vbr_old_switch_map = [\n        new VBRPresets(0, 9, 9, 0, 5.20, 125.0, -4.2, -6.3, 4.8, 1, 0, 0, 2, 21, 0.97),\n        new VBRPresets(1, 9, 9, 0, 5.30, 125.0, -3.6, -5.6, 4.5, 1.5, 0, 0, 2, 21, 1.35),\n        new VBRPresets(2, 9, 9, 0, 5.60, 125.0, -2.2, -3.5, 2.8, 2, 0, 0, 2, 21, 1.49),\n        new VBRPresets(3, 9, 9, 1, 5.80, 130.0, -1.8, -2.8, 2.6, 3, -4, 0, 2, 20, 1.64),\n        new VBRPresets(4, 9, 9, 1, 6.00, 135.0, -0.7, -1.1, 1.1, 3.5, -8, 0, 2, 0, 1.79),\n        new VBRPresets(5, 9, 9, 1, 6.40, 140.0, 0.5, 0.4, -7.5, 4, -12, 0.0002, 0, 0, 1.95),\n        new VBRPresets(6, 9, 9, 1, 6.60, 145.0, 0.67, 0.65, -14.7, 6.5, -19, 0.0004, 0, 0, 2.30),\n        new VBRPresets(7, 9, 9, 1, 6.60, 145.0, 0.8, 0.75, -19.7, 8, -22, 0.0006, 0, 0, 2.70),\n        new VBRPresets(8, 9, 9, 1, 6.60, 145.0, 1.2, 1.15, -27.5, 10, -23, 0.0007, 0, 0, 0),\n        new VBRPresets(9, 9, 9, 1, 6.60, 145.0, 1.6, 1.6, -36, 11, -25, 0.0008, 0, 0, 0),\n        new VBRPresets(10, 9, 9, 1, 6.60, 145.0, 2.0, 2.0, -36, 12, -25, 0.0008, 0, 0, 0)\n    ];\n\n    /**\n     * <PRE>\n     *                 vbr_q  qcomp_l  qcomp_s  expY  st_lrm   st_s  mask adj_l  adj_s  ath_lower  ath_curve  ath_sens  interChR  safejoint sfb21mod  msfix\n     * </PRE>\n     */\n    var vbr_psy_switch_map = [\n        new VBRPresets(0, 9, 9, 0, 4.20, 25.0, -7.0, -4.0, 7.5, 1, 0, 0, 2, 26, 0.97),\n        new VBRPresets(1, 9, 9, 0, 4.20, 25.0, -5.6, -3.6, 4.5, 1.5, 0, 0, 2, 21, 1.35),\n        new VBRPresets(2, 9, 9, 0, 4.20, 25.0, -4.4, -1.8, 2, 2, 0, 0, 2, 18, 1.49),\n        new VBRPresets(3, 9, 9, 1, 4.20, 25.0, -3.4, -1.25, 1.1, 3, -4, 0, 2, 15, 1.64),\n        new VBRPresets(4, 9, 9, 1, 4.20, 25.0, -2.2, 0.1, 0, 3.5, -8, 0, 2, 0, 1.79),\n        new VBRPresets(5, 9, 9, 1, 4.20, 25.0, -1.0, 1.65, -7.7, 4, -12, 0.0002, 0, 0, 1.95),\n        new VBRPresets(6, 9, 9, 1, 4.20, 25.0, -0.0, 2.47, -7.7, 6.5, -19, 0.0004, 0, 0, 2),\n        new VBRPresets(7, 9, 9, 1, 4.20, 25.0, 0.5, 2.0, -14.5, 8, -22, 0.0006, 0, 0, 2),\n        new VBRPresets(8, 9, 9, 1, 4.20, 25.0, 1.0, 2.4, -22.0, 10, -23, 0.0007, 0, 0, 2),\n        new VBRPresets(9, 9, 9, 1, 4.20, 25.0, 1.5, 2.95, -30.0, 11, -25, 0.0008, 0, 0, 2),\n        new VBRPresets(10, 9, 9, 1, 4.20, 25.0, 2.0, 2.95, -36.0, 12, -30, 0.0008, 0, 0, 2)\n    ];\n\n    function apply_vbr_preset(gfp, a, enforce) {\n        var vbr_preset = gfp.VBR == VbrMode$20.vbr_rh ? vbr_old_switch_map\n            : vbr_psy_switch_map;\n\n        var x = gfp.VBR_q_frac;\n        var p = vbr_preset[a];\n        var q = vbr_preset[a + 1];\n        var set = p;\n\n        // NOOP(vbr_q);\n        // NOOP(quant_comp);\n        // NOOP(quant_comp_s);\n        // NOOP(expY);\n        p.st_lrm = p.st_lrm + x * (q.st_lrm - p.st_lrm);\n        // LERP(st_lrm);\n        p.st_s = p.st_s + x * (q.st_s - p.st_s);\n        // LERP(st_s);\n        p.masking_adj = p.masking_adj + x * (q.masking_adj - p.masking_adj);\n        // LERP(masking_adj);\n        p.masking_adj_short = p.masking_adj_short + x\n            * (q.masking_adj_short - p.masking_adj_short);\n        // LERP(masking_adj_short);\n        p.ath_lower = p.ath_lower + x * (q.ath_lower - p.ath_lower);\n        // LERP(ath_lower);\n        p.ath_curve = p.ath_curve + x * (q.ath_curve - p.ath_curve);\n        // LERP(ath_curve);\n        p.ath_sensitivity = p.ath_sensitivity + x\n            * (q.ath_sensitivity - p.ath_sensitivity);\n        // LERP(ath_sensitivity);\n        p.interch = p.interch + x * (q.interch - p.interch);\n        // LERP(interch);\n        // NOOP(safejoint);\n        // NOOP(sfb21mod);\n        p.msfix = p.msfix + x * (q.msfix - p.msfix);\n        // LERP(msfix);\n\n        lame_set_VBR_q(gfp, set.vbr_q);\n\n        if (enforce != 0)\n            gfp.quant_comp = set.quant_comp;\n        else if (!(Math.abs(gfp.quant_comp - -1) > 0))\n            gfp.quant_comp = set.quant_comp;\n        // SET_OPTION(quant_comp, set.quant_comp, -1);\n        if (enforce != 0)\n            gfp.quant_comp_short = set.quant_comp_s;\n        else if (!(Math.abs(gfp.quant_comp_short - -1) > 0))\n            gfp.quant_comp_short = set.quant_comp_s;\n        // SET_OPTION(quant_comp_short, set.quant_comp_s, -1);\n        if (set.expY != 0) {\n            gfp.experimentalY = set.expY != 0;\n        }\n        if (enforce != 0)\n            gfp.internal_flags.nsPsy.attackthre = set.st_lrm;\n        else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre - -1) > 0))\n            gfp.internal_flags.nsPsy.attackthre = set.st_lrm;\n        // SET_OPTION(short_threshold_lrm, set.st_lrm, -1);\n        if (enforce != 0)\n            gfp.internal_flags.nsPsy.attackthre_s = set.st_s;\n        else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre_s - -1) > 0))\n            gfp.internal_flags.nsPsy.attackthre_s = set.st_s;\n        // SET_OPTION(short_threshold_s, set.st_s, -1);\n        if (enforce != 0)\n            gfp.maskingadjust = set.masking_adj;\n        else if (!(Math.abs(gfp.maskingadjust - 0) > 0))\n            gfp.maskingadjust = set.masking_adj;\n        // SET_OPTION(maskingadjust, set.masking_adj, 0);\n        if (enforce != 0)\n            gfp.maskingadjust_short = set.masking_adj_short;\n        else if (!(Math.abs(gfp.maskingadjust_short - 0) > 0))\n            gfp.maskingadjust_short = set.masking_adj_short;\n        // SET_OPTION(maskingadjust_short, set.masking_adj_short, 0);\n        if (enforce != 0)\n            gfp.ATHlower = -set.ath_lower / 10.0;\n        else if (!(Math.abs((-gfp.ATHlower * 10.0) - 0) > 0))\n            gfp.ATHlower = -set.ath_lower / 10.0;\n        // SET_OPTION(ATHlower, set.ath_lower, 0);\n        if (enforce != 0)\n            gfp.ATHcurve = set.ath_curve;\n        else if (!(Math.abs(gfp.ATHcurve - -1) > 0))\n            gfp.ATHcurve = set.ath_curve;\n        // SET_OPTION(ATHcurve, set.ath_curve, -1);\n        if (enforce != 0)\n            gfp.athaa_sensitivity = set.ath_sensitivity;\n        else if (!(Math.abs(gfp.athaa_sensitivity - -1) > 0))\n            gfp.athaa_sensitivity = set.ath_sensitivity;\n        // SET_OPTION(athaa_sensitivity, set.ath_sensitivity, 0);\n        if (set.interch > 0) {\n            if (enforce != 0)\n                gfp.interChRatio = set.interch;\n            else if (!(Math.abs(gfp.interChRatio - -1) > 0))\n                gfp.interChRatio = set.interch;\n            // SET_OPTION(interChRatio, set.interch, -1);\n        }\n\n        /* parameters for which there is no proper set/get interface */\n        if (set.safejoint > 0) {\n            gfp.exp_nspsytune = gfp.exp_nspsytune | set.safejoint;\n        }\n        if (set.sfb21mod > 0) {\n            gfp.exp_nspsytune = gfp.exp_nspsytune | (set.sfb21mod << 20);\n        }\n        if (enforce != 0)\n            gfp.msfix = set.msfix;\n        else if (!(Math.abs(gfp.msfix - -1) > 0))\n            gfp.msfix = set.msfix;\n        // SET_OPTION(msfix, set.msfix, -1);\n\n        if (enforce == 0) {\n            gfp.VBR_q = a;\n            gfp.VBR_q_frac = x;\n        }\n    }\n\n    /**\n     * <PRE>\n     *  Switch mappings for ABR mode\n     *\n     *              kbps  quant q_s safejoint nsmsfix st_lrm  st_s  ns-bass scale   msk ath_lwr ath_curve  interch , sfscale\n     * </PRE>\n     */\n    var abr_switch_map = [\n        new ABRPresets(8, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -30.0, 11, 0.0012, 1), /*   8, impossible to use in stereo */\n        new ABRPresets(16, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -25.0, 11, 0.0010, 1), /*  16 */\n        new ABRPresets(24, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -20.0, 11, 0.0010, 1), /*  24 */\n        new ABRPresets(32, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -15.0, 11, 0.0010, 1), /*  32 */\n        new ABRPresets(40, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -10.0, 11, 0.0009, 1), /*  40 */\n        new ABRPresets(48, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -10.0, 11, 0.0009, 1), /*  48 */\n        new ABRPresets(56, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -6.0, 11, 0.0008, 1), /*  56 */\n        new ABRPresets(64, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -2.0, 11, 0.0008, 1), /*  64 */\n        new ABRPresets(80, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, .0, 8, 0.0007, 1), /*  80 */\n        new ABRPresets(96, 9, 9, 0, 2.50, 6.60, 145, 0, 0.95, 0, 1.0, 5.5, 0.0006, 1), /*  96 */\n        new ABRPresets(112, 9, 9, 0, 2.25, 6.60, 145, 0, 0.95, 0, 2.0, 4.5, 0.0005, 1), /* 112 */\n        new ABRPresets(128, 9, 9, 0, 1.95, 6.40, 140, 0, 0.95, 0, 3.0, 4, 0.0002, 1), /* 128 */\n        new ABRPresets(160, 9, 9, 1, 1.79, 6.00, 135, 0, 0.95, -2, 5.0, 3.5, 0, 1), /* 160 */\n        new ABRPresets(192, 9, 9, 1, 1.49, 5.60, 125, 0, 0.97, -4, 7.0, 3, 0, 0), /* 192 */\n        new ABRPresets(224, 9, 9, 1, 1.25, 5.20, 125, 0, 0.98, -6, 9.0, 2, 0, 0), /* 224 */\n        new ABRPresets(256, 9, 9, 1, 0.97, 5.20, 125, 0, 1.00, -8, 10.0, 1, 0, 0), /* 256 */\n        new ABRPresets(320, 9, 9, 1, 0.90, 5.20, 125, 0, 1.00, -10, 12.0, 0, 0, 0)  /* 320 */\n    ];\n\n    function apply_abr_preset(gfp, preset, enforce) {\n        /* Variables for the ABR stuff */\n        var actual_bitrate = preset;\n\n        var r = lame.nearestBitrateFullIndex(preset);\n\n        gfp.VBR = VbrMode$20.vbr_abr;\n        gfp.VBR_mean_bitrate_kbps = actual_bitrate;\n        gfp.VBR_mean_bitrate_kbps = Math.min(gfp.VBR_mean_bitrate_kbps, 320);\n        gfp.VBR_mean_bitrate_kbps = Math.max(gfp.VBR_mean_bitrate_kbps, 8);\n        gfp.brate = gfp.VBR_mean_bitrate_kbps;\n        if (gfp.VBR_mean_bitrate_kbps > 320) {\n            gfp.disable_reservoir = true;\n        }\n\n        /* parameters for which there is no proper set/get interface */\n        if (abr_switch_map[r].safejoint > 0)\n            gfp.exp_nspsytune = gfp.exp_nspsytune | 2;\n        /* safejoint */\n\n        if (abr_switch_map[r].sfscale > 0) {\n            gfp.internal_flags.noise_shaping = 2;\n        }\n        /* ns-bass tweaks */\n        if (Math.abs(abr_switch_map[r].nsbass) > 0) {\n            var k = (int)(abr_switch_map[r].nsbass * 4);\n            if (k < 0)\n                k += 64;\n            gfp.exp_nspsytune = gfp.exp_nspsytune | (k << 2);\n        }\n\n        if (enforce != 0)\n            gfp.quant_comp = abr_switch_map[r].quant_comp;\n        else if (!(Math.abs(gfp.quant_comp - -1) > 0))\n            gfp.quant_comp = abr_switch_map[r].quant_comp;\n        // SET_OPTION(quant_comp, abr_switch_map[r].quant_comp, -1);\n        if (enforce != 0)\n            gfp.quant_comp_short = abr_switch_map[r].quant_comp_s;\n        else if (!(Math.abs(gfp.quant_comp_short - -1) > 0))\n            gfp.quant_comp_short = abr_switch_map[r].quant_comp_s;\n        // SET_OPTION(quant_comp_short, abr_switch_map[r].quant_comp_s, -1);\n\n        if (enforce != 0)\n            gfp.msfix = abr_switch_map[r].nsmsfix;\n        else if (!(Math.abs(gfp.msfix - -1) > 0))\n            gfp.msfix = abr_switch_map[r].nsmsfix;\n        // SET_OPTION(msfix, abr_switch_map[r].nsmsfix, -1);\n\n        if (enforce != 0)\n            gfp.internal_flags.nsPsy.attackthre = abr_switch_map[r].st_lrm;\n        else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre - -1) > 0))\n            gfp.internal_flags.nsPsy.attackthre = abr_switch_map[r].st_lrm;\n        // SET_OPTION(short_threshold_lrm, abr_switch_map[r].st_lrm, -1);\n        if (enforce != 0)\n            gfp.internal_flags.nsPsy.attackthre_s = abr_switch_map[r].st_s;\n        else if (!(Math.abs(gfp.internal_flags.nsPsy.attackthre_s - -1) > 0))\n            gfp.internal_flags.nsPsy.attackthre_s = abr_switch_map[r].st_s;\n        // SET_OPTION(short_threshold_s, abr_switch_map[r].st_s, -1);\n\n        /*\n         * ABR seems to have big problems with clipping, especially at low\n         * bitrates\n         */\n        /*\n         * so we compensate for that here by using a scale value depending on\n         * bitrate\n         */\n        if (enforce != 0)\n            gfp.scale = abr_switch_map[r].scale;\n        else if (!(Math.abs(gfp.scale - -1) > 0))\n            gfp.scale = abr_switch_map[r].scale;\n        // SET_OPTION(scale, abr_switch_map[r].scale, -1);\n\n        if (enforce != 0)\n            gfp.maskingadjust = abr_switch_map[r].masking_adj;\n        else if (!(Math.abs(gfp.maskingadjust - 0) > 0))\n            gfp.maskingadjust = abr_switch_map[r].masking_adj;\n        // SET_OPTION(maskingadjust, abr_switch_map[r].masking_adj, 0);\n        if (abr_switch_map[r].masking_adj > 0) {\n            if (enforce != 0)\n                gfp.maskingadjust_short = (abr_switch_map[r].masking_adj * .9);\n            else if (!(Math.abs(gfp.maskingadjust_short - 0) > 0))\n                gfp.maskingadjust_short = (abr_switch_map[r].masking_adj * .9);\n            // SET_OPTION(maskingadjust_short, abr_switch_map[r].masking_adj *\n            // .9, 0);\n        } else {\n            if (enforce != 0)\n                gfp.maskingadjust_short = (abr_switch_map[r].masking_adj * 1.1);\n            else if (!(Math.abs(gfp.maskingadjust_short - 0) > 0))\n                gfp.maskingadjust_short = (abr_switch_map[r].masking_adj * 1.1);\n            // SET_OPTION(maskingadjust_short, abr_switch_map[r].masking_adj *\n            // 1.1, 0);\n        }\n\n        if (enforce != 0)\n            gfp.ATHlower = -abr_switch_map[r].ath_lower / 10.;\n        else if (!(Math.abs((-gfp.ATHlower * 10.) - 0) > 0))\n            gfp.ATHlower = -abr_switch_map[r].ath_lower / 10.;\n        // SET_OPTION(ATHlower, abr_switch_map[r].ath_lower, 0);\n        if (enforce != 0)\n            gfp.ATHcurve = abr_switch_map[r].ath_curve;\n        else if (!(Math.abs(gfp.ATHcurve - -1) > 0))\n            gfp.ATHcurve = abr_switch_map[r].ath_curve;\n        // SET_OPTION(ATHcurve, abr_switch_map[r].ath_curve, -1);\n\n        if (enforce != 0)\n            gfp.interChRatio = abr_switch_map[r].interch;\n        else if (!(Math.abs(gfp.interChRatio - -1) > 0))\n            gfp.interChRatio = abr_switch_map[r].interch;\n        // SET_OPTION(interChRatio, abr_switch_map[r].interch, -1);\n\n        return preset;\n    }\n\n    this.apply_preset = function(gfp, preset, enforce) {\n        /* translate legacy presets */\n        switch (preset) {\n            case Lame.R3MIX:\n            {\n                preset = Lame.V3;\n                gfp.VBR = VbrMode$20.vbr_mtrh;\n                break;\n            }\n            case Lame.MEDIUM:\n            {\n                preset = Lame.V4;\n                gfp.VBR = VbrMode$20.vbr_rh;\n                break;\n            }\n            case Lame.MEDIUM_FAST:\n            {\n                preset = Lame.V4;\n                gfp.VBR = VbrMode$20.vbr_mtrh;\n                break;\n            }\n            case Lame.STANDARD:\n            {\n                preset = Lame.V2;\n                gfp.VBR = VbrMode$20.vbr_rh;\n                break;\n            }\n            case Lame.STANDARD_FAST:\n            {\n                preset = Lame.V2;\n                gfp.VBR = VbrMode$20.vbr_mtrh;\n                break;\n            }\n            case Lame.EXTREME:\n            {\n                preset = Lame.V0;\n                gfp.VBR = VbrMode$20.vbr_rh;\n                break;\n            }\n            case Lame.EXTREME_FAST:\n            {\n                preset = Lame.V0;\n                gfp.VBR = VbrMode$20.vbr_mtrh;\n                break;\n            }\n            case Lame.INSANE:\n            {\n                preset = 320;\n                gfp.preset = preset;\n                apply_abr_preset(gfp, preset, enforce);\n                gfp.VBR = VbrMode$20.vbr_off;\n                return preset;\n            }\n        }\n\n        gfp.preset = preset;\n        {\n            switch (preset) {\n                case Lame.V9:\n                    apply_vbr_preset(gfp, 9, enforce);\n                    return preset;\n                case Lame.V8:\n                    apply_vbr_preset(gfp, 8, enforce);\n                    return preset;\n                case Lame.V7:\n                    apply_vbr_preset(gfp, 7, enforce);\n                    return preset;\n                case Lame.V6:\n                    apply_vbr_preset(gfp, 6, enforce);\n                    return preset;\n                case Lame.V5:\n                    apply_vbr_preset(gfp, 5, enforce);\n                    return preset;\n                case Lame.V4:\n                    apply_vbr_preset(gfp, 4, enforce);\n                    return preset;\n                case Lame.V3:\n                    apply_vbr_preset(gfp, 3, enforce);\n                    return preset;\n                case Lame.V2:\n                    apply_vbr_preset(gfp, 2, enforce);\n                    return preset;\n                case Lame.V1:\n                    apply_vbr_preset(gfp, 1, enforce);\n                    return preset;\n                case Lame.V0:\n                    apply_vbr_preset(gfp, 0, enforce);\n                    return preset;\n                default:\n                    break;\n            }\n        }\n        if (8 <= preset && preset <= 320) {\n            return apply_abr_preset(gfp, preset, enforce);\n        }\n\n        /* no corresponding preset found */\n        gfp.preset = 0;\n        return preset;\n    };\n\n    // Rest from getset.c:\n\n    /**\n     * VBR quality level.<BR>\n     * 0 = highest<BR>\n     * 9 = lowest\n     */\n    function lame_set_VBR_q(gfp, VBR_q) {\n        var ret = 0;\n\n        if (0 > VBR_q) {\n            /* Unknown VBR quality level! */\n            ret = -1;\n            VBR_q = 0;\n        }\n        if (9 < VBR_q) {\n            ret = -1;\n            VBR_q = 9;\n        }\n\n        gfp.VBR_q = VBR_q;\n        gfp.VBR_q_frac = 0;\n        return ret;\n    }\n\n}\n\nvar Presets_1 = Presets$1;\n\nfunction VBRQuantize() {\n    var qupvt;\n    var tak;\n\n    this.setModules = function (_qupvt, _tk) {\n        qupvt = _qupvt;\n        tak = _tk;\n    };\n    //TODO\n\n}\n\nvar VBRQuantize_1 = VBRQuantize;\n\n//package mp3;\n\nfunction CalcNoiseResult$1() {\n    /**\n     * sum of quantization noise > masking\n     */\n    this.over_noise = 0.;\n    /**\n     * sum of all quantization noise\n     */\n    this.tot_noise = 0.;\n    /**\n     * max quantization noise\n     */\n    this.max_noise = 0.;\n    /**\n     * number of quantization noise > masking\n     */\n    this.over_count = 0;\n    /**\n     * SSD-like cost of distorted bands\n     */\n    this.over_SSD = 0;\n    this.bits = 0;\n}\n\nvar CalcNoiseResult_1 = CalcNoiseResult$1;\n\nvar new_float$22 = common.new_float;\nvar new_int$22 = common.new_int;\nfunction CalcNoiseData() {\n    this.global_gain = 0;\n    this.sfb_count1 = 0;\n    this.step = new_int$22(39);\n    this.noise = new_float$22(39);\n    this.noise_log = new_float$22(39);\n}\n\nvar CalcNoiseData_1 = CalcNoiseData;\n\n/*\n * MP3 quantization\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *      Copyright (c) 1999-2003 Takehiro Tominaga\n *      Copyright (c) 2000-2007 Robert Hegemann\n *      Copyright (c) 2001-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Quantize.java,v 1.24 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n//import java.util.Arrays;\n\nvar System$21 = common.System;\nvar VbrMode$21 = common.VbrMode;\nvar Util$21 = common.Util;\nvar Arrays$21 = common.Arrays;\nvar new_float$21 = common.new_float;\nvar assert$21 = common.assert;\n\n\n\n\n\n\n\n\nfunction Quantize$1() {\n    var bs;\n    this.rv = null;\n    var rv;\n    this.qupvt = null;\n    var qupvt;\n\n    var vbr = new VBRQuantize_1();\n    var tk;\n\n    this.setModules = function (_bs, _rv, _qupvt, _tk) {\n        bs = _bs;\n        rv = _rv;\n        this.rv = _rv;\n        qupvt = _qupvt;\n        this.qupvt = _qupvt;\n        tk = _tk;\n        vbr.setModules(qupvt, tk);\n    };\n\n    /**\n     * convert from L/R <. Mid/Side\n     */\n    this.ms_convert = function (l3_side, gr) {\n        for (var i = 0; i < 576; ++i) {\n            var l = l3_side.tt[gr][0].xr[i];\n            var r = l3_side.tt[gr][1].xr[i];\n            l3_side.tt[gr][0].xr[i] = (l + r) * (Util$21.SQRT2 * 0.5);\n            l3_side.tt[gr][1].xr[i] = (l - r) * (Util$21.SQRT2 * 0.5);\n        }\n    };\n\n    /**\n     * mt 6/99\n     *\n     * initializes cod_info, scalefac and xrpow\n     *\n     * returns 0 if all energies in xr are zero, else 1\n     */\n    function init_xrpow_core(cod_info, xrpow, upper, sum) {\n        sum = 0;\n        for (var i = 0; i <= upper; ++i) {\n            var tmp = Math.abs(cod_info.xr[i]);\n            sum += tmp;\n            xrpow[i] = Math.sqrt(tmp * Math.sqrt(tmp));\n\n            if (xrpow[i] > cod_info.xrpow_max)\n                cod_info.xrpow_max = xrpow[i];\n        }\n        return sum;\n    }\n\n    this.init_xrpow = function (gfc, cod_info, xrpow) {\n        var sum = 0;\n        var upper = 0 | cod_info.max_nonzero_coeff;\n\n        assert$21(xrpow != null);\n        cod_info.xrpow_max = 0;\n\n        /*\n         * check if there is some energy we have to quantize and calculate xrpow\n         * matching our fresh scalefactors\n         */\n        assert$21(0 <= upper && upper <= 575);\n\n        Arrays$21.fill(xrpow, upper, 576, 0);\n\n        sum = init_xrpow_core(cod_info, xrpow, upper, sum);\n\n        /*\n         * return 1 if we have something to quantize, else 0\n         */\n        if (sum > 1E-20) {\n            var j = 0;\n            if ((gfc.substep_shaping & 2) != 0)\n                j = 1;\n\n            for (var i = 0; i < cod_info.psymax; i++)\n                gfc.pseudohalf[i] = j;\n\n            return true;\n        }\n\n        Arrays$21.fill(cod_info.l3_enc, 0, 576, 0);\n        return false;\n    };\n\n    /**\n     * Gabriel Bouvigne feb/apr 2003<BR>\n     * Analog silence detection in partitionned sfb21 or sfb12 for short blocks\n     *\n     * From top to bottom of sfb, changes to 0 coeffs which are below ath. It\n     * stops on the first coeff higher than ath.\n     */\n    function psfb21_analogsilence(gfc, cod_info) {\n        var ath = gfc.ATH;\n        var xr = cod_info.xr;\n\n        if (cod_info.block_type != Encoder_1.SHORT_TYPE) {\n            /* NORM, START or STOP type, but not SHORT blocks */\n            var stop = false;\n            for (var gsfb = Encoder_1.PSFB21 - 1; gsfb >= 0 && !stop; gsfb--) {\n                var start = gfc.scalefac_band.psfb21[gsfb];\n                var end = gfc.scalefac_band.psfb21[gsfb + 1];\n                var ath21 = qupvt.athAdjust(ath.adjust, ath.psfb21[gsfb],\n                    ath.floor);\n\n                if (gfc.nsPsy.longfact[21] > 1e-12)\n                    ath21 *= gfc.nsPsy.longfact[21];\n\n                for (var j = end - 1; j >= start; j--) {\n                    if (Math.abs(xr[j]) < ath21)\n                        xr[j] = 0;\n                    else {\n                        stop = true;\n                        break;\n                    }\n                }\n            }\n        } else {\n            /* note: short blocks coeffs are reordered */\n            for (var block = 0; block < 3; block++) {\n                var stop = false;\n                for (var gsfb = Encoder_1.PSFB12 - 1; gsfb >= 0 && !stop; gsfb--) {\n                    var start = gfc.scalefac_band.s[12]\n                        * 3\n                        + (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12])\n                        * block\n                        + (gfc.scalefac_band.psfb12[gsfb] - gfc.scalefac_band.psfb12[0]);\n                    var end = start\n                        + (gfc.scalefac_band.psfb12[gsfb + 1] - gfc.scalefac_band.psfb12[gsfb]);\n                    var ath12 = qupvt.athAdjust(ath.adjust, ath.psfb12[gsfb],\n                        ath.floor);\n\n                    if (gfc.nsPsy.shortfact[12] > 1e-12)\n                        ath12 *= gfc.nsPsy.shortfact[12];\n\n                    for (var j = end - 1; j >= start; j--) {\n                        if (Math.abs(xr[j]) < ath12)\n                            xr[j] = 0;\n                        else {\n                            stop = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    this.init_outer_loop = function (gfc, cod_info) {\n        /*\n         * initialize fresh cod_info\n         */\n        cod_info.part2_3_length = 0;\n        cod_info.big_values = 0;\n        cod_info.count1 = 0;\n        cod_info.global_gain = 210;\n        cod_info.scalefac_compress = 0;\n        /* mixed_block_flag, block_type was set in psymodel.c */\n        cod_info.table_select[0] = 0;\n        cod_info.table_select[1] = 0;\n        cod_info.table_select[2] = 0;\n        cod_info.subblock_gain[0] = 0;\n        cod_info.subblock_gain[1] = 0;\n        cod_info.subblock_gain[2] = 0;\n        cod_info.subblock_gain[3] = 0;\n        /* this one is always 0 */\n        cod_info.region0_count = 0;\n        cod_info.region1_count = 0;\n        cod_info.preflag = 0;\n        cod_info.scalefac_scale = 0;\n        cod_info.count1table_select = 0;\n        cod_info.part2_length = 0;\n        cod_info.sfb_lmax = Encoder_1.SBPSY_l;\n        cod_info.sfb_smin = Encoder_1.SBPSY_s;\n        cod_info.psy_lmax = gfc.sfb21_extra ? Encoder_1.SBMAX_l : Encoder_1.SBPSY_l;\n        cod_info.psymax = cod_info.psy_lmax;\n        cod_info.sfbmax = cod_info.sfb_lmax;\n        cod_info.sfbdivide = 11;\n        for (var sfb = 0; sfb < Encoder_1.SBMAX_l; sfb++) {\n            cod_info.width[sfb] = gfc.scalefac_band.l[sfb + 1]\n                - gfc.scalefac_band.l[sfb];\n            /* which is always 0. */\n            cod_info.window[sfb] = 3;\n        }\n        if (cod_info.block_type == Encoder_1.SHORT_TYPE) {\n            var ixwork = new_float$21(576);\n\n            cod_info.sfb_smin = 0;\n            cod_info.sfb_lmax = 0;\n            if (cod_info.mixed_block_flag != 0) {\n                /*\n                 * MPEG-1: sfbs 0-7 long block, 3-12 short blocks MPEG-2(.5):\n                 * sfbs 0-5 long block, 3-12 short blocks\n                 */\n                cod_info.sfb_smin = 3;\n                cod_info.sfb_lmax = gfc.mode_gr * 2 + 4;\n            }\n            cod_info.psymax = cod_info.sfb_lmax\n                + 3\n                * ((gfc.sfb21_extra ? Encoder_1.SBMAX_s : Encoder_1.SBPSY_s) - cod_info.sfb_smin);\n            cod_info.sfbmax = cod_info.sfb_lmax + 3\n                * (Encoder_1.SBPSY_s - cod_info.sfb_smin);\n            cod_info.sfbdivide = cod_info.sfbmax - 18;\n            cod_info.psy_lmax = cod_info.sfb_lmax;\n            /* re-order the short blocks, for more efficient encoding below */\n            /* By Takehiro TOMINAGA */\n            /*\n             * Within each scalefactor band, data is given for successive time\n             * windows, beginning with window 0 and ending with window 2. Within\n             * each window, the quantized values are then arranged in order of\n             * increasing frequency...\n             */\n            var ix = gfc.scalefac_band.l[cod_info.sfb_lmax];\n            System$21.arraycopy(cod_info.xr, 0, ixwork, 0, 576);\n            for (var sfb = cod_info.sfb_smin; sfb < Encoder_1.SBMAX_s; sfb++) {\n                var start = gfc.scalefac_band.s[sfb];\n                var end = gfc.scalefac_band.s[sfb + 1];\n                for (var window = 0; window < 3; window++) {\n                    for (var l = start; l < end; l++) {\n                        cod_info.xr[ix++] = ixwork[3 * l + window];\n                    }\n                }\n            }\n\n            var j = cod_info.sfb_lmax;\n            for (var sfb = cod_info.sfb_smin; sfb < Encoder_1.SBMAX_s; sfb++) {\n                cod_info.width[j] = cod_info.width[j + 1] = cod_info.width[j + 2] = gfc.scalefac_band.s[sfb + 1]\n                    - gfc.scalefac_band.s[sfb];\n                cod_info.window[j] = 0;\n                cod_info.window[j + 1] = 1;\n                cod_info.window[j + 2] = 2;\n                j += 3;\n            }\n        }\n\n        cod_info.count1bits = 0;\n        cod_info.sfb_partition_table = qupvt.nr_of_sfb_block[0][0];\n        cod_info.slen[0] = 0;\n        cod_info.slen[1] = 0;\n        cod_info.slen[2] = 0;\n        cod_info.slen[3] = 0;\n\n        cod_info.max_nonzero_coeff = 575;\n\n        /*\n         * fresh scalefactors are all zero\n         */\n        Arrays$21.fill(cod_info.scalefac, 0);\n\n        psfb21_analogsilence(gfc, cod_info);\n    };\n\n    function BinSearchDirection(ordinal) {\n        this.ordinal = ordinal;\n    }\n\n    BinSearchDirection.BINSEARCH_NONE = new BinSearchDirection(0);\n    BinSearchDirection.BINSEARCH_UP = new BinSearchDirection(1);\n    BinSearchDirection.BINSEARCH_DOWN = new BinSearchDirection(2);\n\n    /**\n     * author/date??\n     *\n     * binary step size search used by outer_loop to get a quantizer step size\n     * to start with\n     */\n    function bin_search_StepSize(gfc, cod_info, desired_rate, ch, xrpow) {\n        var nBits;\n        var CurrentStep = gfc.CurrentStep[ch];\n        var flagGoneOver = false;\n        var start = gfc.OldValue[ch];\n        var Direction = BinSearchDirection.BINSEARCH_NONE;\n        cod_info.global_gain = start;\n        desired_rate -= cod_info.part2_length;\n\n        assert$21(CurrentStep != 0);\n        for (; ;) {\n            var step;\n            nBits = tk.count_bits(gfc, xrpow, cod_info, null);\n\n            if (CurrentStep == 1 || nBits == desired_rate)\n                break;\n            /* nothing to adjust anymore */\n\n            if (nBits > desired_rate) {\n                /* increase Quantize_StepSize */\n                if (Direction == BinSearchDirection.BINSEARCH_DOWN)\n                    flagGoneOver = true;\n\n                if (flagGoneOver)\n                    CurrentStep /= 2;\n                Direction = BinSearchDirection.BINSEARCH_UP;\n                step = CurrentStep;\n            } else {\n                /* decrease Quantize_StepSize */\n                if (Direction == BinSearchDirection.BINSEARCH_UP)\n                    flagGoneOver = true;\n\n                if (flagGoneOver)\n                    CurrentStep /= 2;\n                Direction = BinSearchDirection.BINSEARCH_DOWN;\n                step = -CurrentStep;\n            }\n            cod_info.global_gain += step;\n            if (cod_info.global_gain < 0) {\n                cod_info.global_gain = 0;\n                flagGoneOver = true;\n            }\n            if (cod_info.global_gain > 255) {\n                cod_info.global_gain = 255;\n                flagGoneOver = true;\n            }\n        }\n\n        assert$21(cod_info.global_gain >= 0);\n        assert$21(cod_info.global_gain < 256);\n\n        while (nBits > desired_rate && cod_info.global_gain < 255) {\n            cod_info.global_gain++;\n            nBits = tk.count_bits(gfc, xrpow, cod_info, null);\n        }\n        gfc.CurrentStep[ch] = (start - cod_info.global_gain >= 4) ? 4 : 2;\n        gfc.OldValue[ch] = cod_info.global_gain;\n        cod_info.part2_3_length = nBits;\n        return nBits;\n    }\n\n    this.trancate_smallspectrums = function (gfc, gi, l3_xmin, work) {\n        var distort = new_float$21(L3Side_1.SFBMAX);\n\n        if ((0 == (gfc.substep_shaping & 4) && gi.block_type == Encoder_1.SHORT_TYPE)\n            || (gfc.substep_shaping & 0x80) != 0)\n            return;\n        qupvt.calc_noise(gi, l3_xmin, distort, new CalcNoiseResult_1(), null);\n        for (var j = 0; j < 576; j++) {\n            var xr = 0.0;\n            if (gi.l3_enc[j] != 0)\n                xr = Math.abs(gi.xr[j]);\n            work[j] = xr;\n        }\n\n        var j = 0;\n        var sfb = 8;\n        if (gi.block_type == Encoder_1.SHORT_TYPE)\n            sfb = 6;\n        do {\n            var allowedNoise, trancateThreshold;\n            var nsame, start;\n\n            var width = gi.width[sfb];\n            j += width;\n            if (distort[sfb] >= 1.0)\n                continue;\n\n            Arrays$21.sort(work, j - width, width);\n            if (BitStream.EQ(work[j - 1], 0.0))\n                continue;\n            /* all zero sfb */\n\n            allowedNoise = (1.0 - distort[sfb]) * l3_xmin[sfb];\n            trancateThreshold = 0.0;\n            start = 0;\n            do {\n                var noise;\n                for (nsame = 1; start + nsame < width; nsame++)\n                    if (BitStream.NEQ(work[start + j - width], work[start + j\n                        + nsame - width]))\n                        break;\n\n                noise = work[start + j - width] * work[start + j - width]\n                    * nsame;\n                if (allowedNoise < noise) {\n                    if (start != 0)\n                        trancateThreshold = work[start + j - width - 1];\n                    break;\n                }\n                allowedNoise -= noise;\n                start += nsame;\n            } while (start < width);\n            if (BitStream.EQ(trancateThreshold, 0.0))\n                continue;\n\n            do {\n                if (Math.abs(gi.xr[j - width]) <= trancateThreshold)\n                    gi.l3_enc[j - width] = 0;\n            } while (--width > 0);\n        } while (++sfb < gi.psymax);\n\n        gi.part2_3_length = tk.noquant_count_bits(gfc, gi, null);\n    };\n\n    /**\n     * author/date??\n     *\n     * Function: Returns zero if there is a scalefac which has not been\n     * amplified. Otherwise it returns one.\n     */\n    function loop_break(cod_info) {\n        for (var sfb = 0; sfb < cod_info.sfbmax; sfb++)\n            if (cod_info.scalefac[sfb]\n                + cod_info.subblock_gain[cod_info.window[sfb]] == 0)\n                return false;\n\n        return true;\n    }\n\n    /* mt 5/99: Function: Improved calc_noise for a single channel */\n\n    function penalties(noise) {\n        return Util$21.FAST_LOG10((0.368 + 0.632 * noise * noise * noise));\n    }\n\n    /**\n     * author/date??\n     *\n     * several different codes to decide which quantization is better\n     */\n    function get_klemm_noise(distort, gi) {\n        var klemm_noise = 1E-37;\n        for (var sfb = 0; sfb < gi.psymax; sfb++)\n            klemm_noise += penalties(distort[sfb]);\n\n        return Math.max(1e-20, klemm_noise);\n    }\n\n    function quant_compare(quant_comp, best, calc, gi, distort) {\n        /**\n         * noise is given in decibels (dB) relative to masking thesholds.<BR>\n         *\n         * over_noise: ??? (the previous comment is fully wrong)<BR>\n         * tot_noise: ??? (the previous comment is fully wrong)<BR>\n         * max_noise: max quantization noise\n         */\n        var better;\n\n        switch (quant_comp) {\n            default:\n            case 9:\n            {\n                if (best.over_count > 0) {\n                    /* there are distorted sfb */\n                    better = calc.over_SSD <= best.over_SSD;\n                    if (calc.over_SSD == best.over_SSD)\n                        better = calc.bits < best.bits;\n                } else {\n                    /* no distorted sfb */\n                    better = ((calc.max_noise < 0) && ((calc.max_noise * 10 + calc.bits) <= (best.max_noise * 10 + best.bits)));\n                }\n                break;\n            }\n\n            case 0:\n                better = calc.over_count < best.over_count\n                    || (calc.over_count == best.over_count && calc.over_noise < best.over_noise)\n                    || (calc.over_count == best.over_count\n                    && BitStream.EQ(calc.over_noise, best.over_noise) && calc.tot_noise < best.tot_noise);\n                break;\n\n            case 8:\n                calc.max_noise = get_klemm_noise(distort, gi);\n            //$FALL-THROUGH$\n            case 1:\n                better = calc.max_noise < best.max_noise;\n                break;\n            case 2:\n                better = calc.tot_noise < best.tot_noise;\n                break;\n            case 3:\n                better = (calc.tot_noise < best.tot_noise)\n                    && (calc.max_noise < best.max_noise);\n                break;\n            case 4:\n                better = (calc.max_noise <= 0.0 && best.max_noise > 0.2)\n                    || (calc.max_noise <= 0.0 && best.max_noise < 0.0\n                    && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise)\n                    || (calc.max_noise <= 0.0 && best.max_noise > 0.0\n                    && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise\n                    + best.over_noise)\n                    || (calc.max_noise > 0.0 && best.max_noise > -0.05\n                    && best.max_noise > calc.max_noise - 0.1 && calc.tot_noise\n                    + calc.over_noise < best.tot_noise\n                    + best.over_noise)\n                    || (calc.max_noise > 0.0 && best.max_noise > -0.1\n                    && best.max_noise > calc.max_noise - 0.15 && calc.tot_noise\n                    + calc.over_noise + calc.over_noise < best.tot_noise\n                    + best.over_noise + best.over_noise);\n                break;\n            case 5:\n                better = calc.over_noise < best.over_noise\n                    || (BitStream.EQ(calc.over_noise, best.over_noise) && calc.tot_noise < best.tot_noise);\n                break;\n            case 6:\n                better = calc.over_noise < best.over_noise\n                    || (BitStream.EQ(calc.over_noise, best.over_noise) && (calc.max_noise < best.max_noise || (BitStream\n                        .EQ(calc.max_noise, best.max_noise) && calc.tot_noise <= best.tot_noise)));\n                break;\n            case 7:\n                better = calc.over_count < best.over_count\n                    || calc.over_noise < best.over_noise;\n                break;\n        }\n\n        if (best.over_count == 0) {\n            /*\n             * If no distorted bands, only use this quantization if it is\n             * better, and if it uses less bits. Unfortunately, part2_3_length\n             * is sometimes a poor estimator of the final size at low bitrates.\n             */\n            better = better && calc.bits < best.bits;\n        }\n\n        return better;\n    }\n\n    /**\n     * author/date??\n     *\n     * <PRE>\n     *  Amplify the scalefactor bands that violate the masking threshold.\n     *  See ISO 11172-3 Section C.1.5.4.3.5\n     *\n     *  distort[] = noise/masking\n     *  distort[] > 1   ==> noise is not masked\n     *  distort[] < 1   ==> noise is masked\n     *  max_dist = maximum value of distort[]\n     *\n     *  Three algorithms:\n     *  noise_shaping_amp\n     *        0             Amplify all bands with distort[]>1.\n     *\n     *        1             Amplify all bands with distort[] >= max_dist^(.5);\n     *                     ( 50% in the db scale)\n     *\n     *        2             Amplify first band with distort[] >= max_dist;\n     *\n     *\n     *  For algorithms 0 and 1, if max_dist < 1, then amplify all bands\n     *  with distort[] >= .95*max_dist.  This is to make sure we always\n     *  amplify at least one band.\n     * </PRE>\n     */\n    function amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine) {\n        var gfc = gfp.internal_flags;\n        var ifqstep34;\n\n        if (cod_info.scalefac_scale == 0) {\n            ifqstep34 = 1.29683955465100964055;\n            /* 2**(.75*.5) */\n        } else {\n            ifqstep34 = 1.68179283050742922612;\n            /* 2**(.75*1) */\n        }\n\n        /* compute maximum value of distort[] */\n        var trigger = 0;\n        for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            if (trigger < distort[sfb])\n                trigger = distort[sfb];\n        }\n\n        var noise_shaping_amp = gfc.noise_shaping_amp;\n        if (noise_shaping_amp == 3) {\n            if (bRefine)\n                noise_shaping_amp = 2;\n            else\n                noise_shaping_amp = 1;\n        }\n        switch (noise_shaping_amp) {\n            case 2:\n                /* amplify exactly 1 band */\n                break;\n\n            case 1:\n                /* amplify bands within 50% of max (on db scale) */\n                if (trigger > 1.0)\n                    trigger = Math.pow(trigger, .5);\n                else\n                    trigger *= .95;\n                break;\n\n            case 0:\n            default:\n                /* ISO algorithm. amplify all bands with distort>1 */\n                if (trigger > 1.0)\n                    trigger = 1.0;\n                else\n                    trigger *= .95;\n                break;\n        }\n\n        var j = 0;\n        for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            var width = cod_info.width[sfb];\n            var l;\n            j += width;\n            if (distort[sfb] < trigger)\n                continue;\n\n            if ((gfc.substep_shaping & 2) != 0) {\n                gfc.pseudohalf[sfb] = (0 == gfc.pseudohalf[sfb]) ? 1 : 0;\n                if (0 == gfc.pseudohalf[sfb] && gfc.noise_shaping_amp == 2)\n                    return;\n            }\n            cod_info.scalefac[sfb]++;\n            for (l = -width; l < 0; l++) {\n                xrpow[j + l] *= ifqstep34;\n                if (xrpow[j + l] > cod_info.xrpow_max)\n                    cod_info.xrpow_max = xrpow[j + l];\n            }\n\n            if (gfc.noise_shaping_amp == 2)\n                return;\n        }\n    }\n\n    /**\n     * Takehiro Tominaga 2000-xx-xx\n     *\n     * turns on scalefac scale and adjusts scalefactors\n     */\n    function inc_scalefac_scale(cod_info, xrpow) {\n        var ifqstep34 = 1.29683955465100964055;\n\n        var j = 0;\n        for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            var width = cod_info.width[sfb];\n            var s = cod_info.scalefac[sfb];\n            if (cod_info.preflag != 0)\n                s += qupvt.pretab[sfb];\n            j += width;\n            if ((s & 1) != 0) {\n                s++;\n                for (var l = -width; l < 0; l++) {\n                    xrpow[j + l] *= ifqstep34;\n                    if (xrpow[j + l] > cod_info.xrpow_max)\n                        cod_info.xrpow_max = xrpow[j + l];\n                }\n            }\n            cod_info.scalefac[sfb] = s >> 1;\n        }\n        cod_info.preflag = 0;\n        cod_info.scalefac_scale = 1;\n    }\n\n    /**\n     * Takehiro Tominaga 2000-xx-xx\n     *\n     * increases the subblock gain and adjusts scalefactors\n     */\n    function inc_subblock_gain(gfc, cod_info, xrpow) {\n        var sfb;\n        var scalefac = cod_info.scalefac;\n\n        /* subbloc_gain can't do anything in the long block region */\n        for (sfb = 0; sfb < cod_info.sfb_lmax; sfb++) {\n            if (scalefac[sfb] >= 16)\n                return true;\n        }\n\n        for (var window = 0; window < 3; window++) {\n            var s1 = 0;\n            var s2 = 0;\n\n            for (sfb = cod_info.sfb_lmax + window; sfb < cod_info.sfbdivide; sfb += 3) {\n                if (s1 < scalefac[sfb])\n                    s1 = scalefac[sfb];\n            }\n            for (; sfb < cod_info.sfbmax; sfb += 3) {\n                if (s2 < scalefac[sfb])\n                    s2 = scalefac[sfb];\n            }\n\n            if (s1 < 16 && s2 < 8)\n                continue;\n\n            if (cod_info.subblock_gain[window] >= 7)\n                return true;\n\n            /*\n             * even though there is no scalefactor for sfb12 subblock gain\n             * affects upper frequencies too, that's why we have to go up to\n             * SBMAX_s\n             */\n            cod_info.subblock_gain[window]++;\n            var j = gfc.scalefac_band.l[cod_info.sfb_lmax];\n            for (sfb = cod_info.sfb_lmax + window; sfb < cod_info.sfbmax; sfb += 3) {\n                var amp;\n                var width = cod_info.width[sfb];\n                var s = scalefac[sfb];\n                assert$21(s >= 0);\n                s = s - (4 >> cod_info.scalefac_scale);\n                if (s >= 0) {\n                    scalefac[sfb] = s;\n                    j += width * 3;\n                    continue;\n                }\n\n                scalefac[sfb] = 0;\n                {\n                    var gain = 210 + (s << (cod_info.scalefac_scale + 1));\n                    amp = qupvt.IPOW20(gain);\n                }\n                j += width * (window + 1);\n                for (var l = -width; l < 0; l++) {\n                    xrpow[j + l] *= amp;\n                    if (xrpow[j + l] > cod_info.xrpow_max)\n                        cod_info.xrpow_max = xrpow[j + l];\n                }\n                j += width * (3 - window - 1);\n            }\n\n            {\n                var amp = qupvt.IPOW20(202);\n                j += cod_info.width[sfb] * (window + 1);\n                for (var l = -cod_info.width[sfb]; l < 0; l++) {\n                    xrpow[j + l] *= amp;\n                    if (xrpow[j + l] > cod_info.xrpow_max)\n                        cod_info.xrpow_max = xrpow[j + l];\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * <PRE>\n     *  Takehiro Tominaga /date??\n     *  Robert Hegemann 2000-09-06: made a function of it\n     *\n     *  amplifies scalefactor bands,\n     *   - if all are already amplified returns 0\n     *   - if some bands are amplified too much:\n     *      * try to increase scalefac_scale\n     *      * if already scalefac_scale was set\n     *          try on short blocks to increase subblock gain\n     * </PRE>\n     */\n    function balance_noise(gfp, cod_info, distort, xrpow, bRefine) {\n        var gfc = gfp.internal_flags;\n\n        amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine);\n\n        /*\n         * check to make sure we have not amplified too much loop_break returns\n         * 0 if there is an unamplified scalefac scale_bitcount returns 0 if no\n         * scalefactors are too large\n         */\n\n        var status = loop_break(cod_info);\n\n        if (status)\n            return false;\n        /* all bands amplified */\n\n        /*\n         * not all scalefactors have been amplified. so these scalefacs are\n         * possibly valid. encode them:\n         */\n        if (gfc.mode_gr == 2)\n            status = tk.scale_bitcount(cod_info);\n        else\n            status = tk.scale_bitcount_lsf(gfc, cod_info);\n\n        if (!status)\n            return true;\n        /* amplified some bands not exceeding limits */\n\n        /*\n         * some scalefactors are too large. lets try setting scalefac_scale=1\n         */\n        if (gfc.noise_shaping > 1) {\n            Arrays$21.fill(gfc.pseudohalf, 0);\n            if (0 == cod_info.scalefac_scale) {\n                inc_scalefac_scale(cod_info, xrpow);\n                status = false;\n            } else {\n                if (cod_info.block_type == Encoder_1.SHORT_TYPE\n                    && gfc.subblock_gain > 0) {\n                    status = (inc_subblock_gain(gfc, cod_info, xrpow) || loop_break(cod_info));\n                }\n            }\n        }\n\n        if (!status) {\n            if (gfc.mode_gr == 2)\n                status = tk.scale_bitcount(cod_info);\n            else\n                status = tk.scale_bitcount_lsf(gfc, cod_info);\n        }\n        return !status;\n    }\n\n    /**\n     * <PRE>\n     *  Function: The outer iteration loop controls the masking conditions\n     *  of all scalefactorbands. It computes the best scalefac and\n     *  global gain. This module calls the inner iteration loop\n     *\n     *  mt 5/99 completely rewritten to allow for bit reservoir control,\n     *  mid/side channels with L/R or mid/side masking thresholds,\n     *  and chooses best quantization instead of last quantization when\n     *  no distortion free quantization can be found.\n     *\n     *  added VBR support mt 5/99\n     *\n     *  some code shuffle rh 9/00\n     * </PRE>\n     *\n     * @param l3_xmin\n     *            allowed distortion\n     * @param xrpow\n     *            coloured magnitudes of spectral\n     * @param targ_bits\n     *            maximum allowed bits\n     */\n    this.outer_loop = function (gfp, cod_info, l3_xmin, xrpow, ch, targ_bits) {\n        var gfc = gfp.internal_flags;\n        var cod_info_w = new GrInfo_1();\n        var save_xrpow = new_float$21(576);\n        var distort = new_float$21(L3Side_1.SFBMAX);\n        var best_noise_info = new CalcNoiseResult_1();\n        var better;\n        var prev_noise = new CalcNoiseData_1();\n        var best_part2_3_length = 9999999;\n        var bEndOfSearch = false;\n        var bRefine = false;\n        var best_ggain_pass1 = 0;\n\n        bin_search_StepSize(gfc, cod_info, targ_bits, ch, xrpow);\n\n        if (0 == gfc.noise_shaping)\n        /* fast mode, no noise shaping, we are ready */\n            return 100;\n        /* default noise_info.over_count */\n\n        /* compute the distortion in this quantization */\n        /* coefficients and thresholds both l/r (or both mid/side) */\n        qupvt.calc_noise(cod_info, l3_xmin, distort, best_noise_info,\n            prev_noise);\n        best_noise_info.bits = cod_info.part2_3_length;\n\n        cod_info_w.assign(cod_info);\n        var age = 0;\n        System$21.arraycopy(xrpow, 0, save_xrpow, 0, 576);\n\n        while (!bEndOfSearch) {\n            /* BEGIN MAIN LOOP */\n            do {\n                var noise_info = new CalcNoiseResult_1();\n                var search_limit;\n                var maxggain = 255;\n\n                /*\n                 * When quantization with no distorted bands is found, allow up\n                 * to X new unsuccesful tries in serial. This gives us more\n                 * possibilities for different quant_compare modes. Much more\n                 * than 3 makes not a big difference, it is only slower.\n                 */\n\n                if ((gfc.substep_shaping & 2) != 0) {\n                    search_limit = 20;\n                } else {\n                    search_limit = 3;\n                }\n\n                /*\n                 * Check if the last scalefactor band is distorted. in VBR mode\n                 * we can't get rid of the distortion, so quit now and VBR mode\n                 * will try again with more bits. (makes a 10% speed increase,\n                 * the files I tested were binary identical, 2000/05/20 Robert\n                 * Hegemann) distort[] > 1 means noise > allowed noise\n                 */\n                if (gfc.sfb21_extra) {\n                    if (distort[cod_info_w.sfbmax] > 1.0)\n                        break;\n                    if (cod_info_w.block_type == Encoder_1.SHORT_TYPE\n                        && (distort[cod_info_w.sfbmax + 1] > 1.0 || distort[cod_info_w.sfbmax + 2] > 1.0))\n                        break;\n                }\n\n                /* try a new scalefactor conbination on cod_info_w */\n                if (!balance_noise(gfp, cod_info_w, distort, xrpow, bRefine))\n                    break;\n                if (cod_info_w.scalefac_scale != 0)\n                    maxggain = 254;\n\n                /*\n                 * inner_loop starts with the initial quantization step computed\n                 * above and slowly increases until the bits < huff_bits. Thus\n                 * it is important not to start with too large of an inital\n                 * quantization step. Too small is ok, but inner_loop will take\n                 * longer\n                 */\n                var huff_bits = targ_bits - cod_info_w.part2_length;\n                if (huff_bits <= 0)\n                    break;\n\n                /*\n                 * increase quantizer stepsize until needed bits are below\n                 * maximum\n                 */\n                while ((cod_info_w.part2_3_length = tk.count_bits(gfc, xrpow,\n                    cod_info_w, prev_noise)) > huff_bits\n                && cod_info_w.global_gain <= maxggain)\n                    cod_info_w.global_gain++;\n\n                if (cod_info_w.global_gain > maxggain)\n                    break;\n\n                if (best_noise_info.over_count == 0) {\n\n                    while ((cod_info_w.part2_3_length = tk.count_bits(gfc,\n                        xrpow, cod_info_w, prev_noise)) > best_part2_3_length\n                    && cod_info_w.global_gain <= maxggain)\n                        cod_info_w.global_gain++;\n\n                    if (cod_info_w.global_gain > maxggain)\n                        break;\n                }\n\n                /* compute the distortion in this quantization */\n                qupvt.calc_noise(cod_info_w, l3_xmin, distort, noise_info,\n                    prev_noise);\n                noise_info.bits = cod_info_w.part2_3_length;\n\n                /*\n                 * check if this quantization is better than our saved\n                 * quantization\n                 */\n                if (cod_info.block_type != Encoder_1.SHORT_TYPE) {\n                    // NORM, START or STOP type\n                    better = gfp.quant_comp;\n                } else\n                    better = gfp.quant_comp_short;\n\n                better = quant_compare(better, best_noise_info, noise_info,\n                    cod_info_w, distort) ? 1 : 0;\n\n                /* save data so we can restore this quantization later */\n                if (better != 0) {\n                    best_part2_3_length = cod_info.part2_3_length;\n                    best_noise_info = noise_info;\n                    cod_info.assign(cod_info_w);\n                    age = 0;\n                    /* save data so we can restore this quantization later */\n                    /* store for later reuse */\n                    System$21.arraycopy(xrpow, 0, save_xrpow, 0, 576);\n                } else {\n                    /* early stop? */\n                    if (gfc.full_outer_loop == 0) {\n                        if (++age > search_limit\n                            && best_noise_info.over_count == 0)\n                            break;\n                        if ((gfc.noise_shaping_amp == 3) && bRefine && age > 30)\n                            break;\n                        if ((gfc.noise_shaping_amp == 3)\n                            && bRefine\n                            && (cod_info_w.global_gain - best_ggain_pass1) > 15)\n                            break;\n                    }\n                }\n            } while ((cod_info_w.global_gain + cod_info_w.scalefac_scale) < 255);\n\n            if (gfc.noise_shaping_amp == 3) {\n                if (!bRefine) {\n                    /* refine search */\n                    cod_info_w.assign(cod_info);\n                    System$21.arraycopy(save_xrpow, 0, xrpow, 0, 576);\n                    age = 0;\n                    best_ggain_pass1 = cod_info_w.global_gain;\n\n                    bRefine = true;\n                } else {\n                    /* search already refined, stop */\n                    bEndOfSearch = true;\n                }\n\n            } else {\n                bEndOfSearch = true;\n            }\n        }\n\n        assert$21((cod_info.global_gain + cod_info.scalefac_scale) <= 255);\n        /*\n         * finish up\n         */\n        if (gfp.VBR == VbrMode$21.vbr_rh || gfp.VBR == VbrMode$21.vbr_mtrh)\n        /* restore for reuse on next try */\n            System$21.arraycopy(save_xrpow, 0, xrpow, 0, 576);\n        /*\n         * do the 'substep shaping'\n         */\n        else if ((gfc.substep_shaping & 1) != 0)\n            trancate_smallspectrums(gfc, cod_info, l3_xmin, xrpow);\n\n        return best_noise_info.over_count;\n    };\n\n    /**\n     * Robert Hegemann 2000-09-06\n     *\n     * update reservoir status after FINAL quantization/bitrate\n     */\n    this.iteration_finish_one = function (gfc, gr, ch) {\n        var l3_side = gfc.l3_side;\n        var cod_info = l3_side.tt[gr][ch];\n\n        /*\n         * try some better scalefac storage\n         */\n        tk.best_scalefac_store(gfc, gr, ch, l3_side);\n\n        /*\n         * best huffman_divide may save some bits too\n         */\n        if (gfc.use_best_huffman == 1)\n            tk.best_huffman_divide(gfc, cod_info);\n\n        /*\n         * update reservoir status after FINAL quantization/bitrate\n         */\n        rv.ResvAdjust(gfc, cod_info);\n    };\n\n    /**\n     *\n     * 2000-09-04 Robert Hegemann\n     *\n     * @param l3_xmin\n     *            allowed distortion of the scalefactor\n     * @param xrpow\n     *            coloured magnitudes of spectral values\n     */\n    this.VBR_encode_granule = function (gfp, cod_info, l3_xmin, xrpow, ch, min_bits, max_bits) {\n        var gfc = gfp.internal_flags;\n        var bst_cod_info = new GrInfo_1();\n        var bst_xrpow = new_float$21(576);\n        var Max_bits = max_bits;\n        var real_bits = max_bits + 1;\n        var this_bits = (max_bits + min_bits) / 2;\n        var dbits, over, found = 0;\n        var sfb21_extra = gfc.sfb21_extra;\n\n        assert$21(Max_bits <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n        Arrays$21.fill(bst_cod_info.l3_enc, 0);\n\n        /*\n         * search within round about 40 bits of optimal\n         */\n        do {\n            assert$21(this_bits >= min_bits);\n            assert$21(this_bits <= max_bits);\n            assert$21(min_bits <= max_bits);\n\n            if (this_bits > Max_bits - 42)\n                gfc.sfb21_extra = false;\n            else\n                gfc.sfb21_extra = sfb21_extra;\n\n            over = outer_loop(gfp, cod_info, l3_xmin, xrpow, ch, this_bits);\n\n            /*\n             * is quantization as good as we are looking for ? in this case: is\n             * no scalefactor band distorted?\n             */\n            if (over <= 0) {\n                found = 1;\n                /*\n                 * now we know it can be done with \"real_bits\" and maybe we can\n                 * skip some iterations\n                 */\n                real_bits = cod_info.part2_3_length;\n\n                /*\n                 * store best quantization so far\n                 */\n                bst_cod_info.assign(cod_info);\n                System$21.arraycopy(xrpow, 0, bst_xrpow, 0, 576);\n\n                /*\n                 * try with fewer bits\n                 */\n                max_bits = real_bits - 32;\n                dbits = max_bits - min_bits;\n                this_bits = (max_bits + min_bits) / 2;\n            } else {\n                /*\n                 * try with more bits\n                 */\n                min_bits = this_bits + 32;\n                dbits = max_bits - min_bits;\n                this_bits = (max_bits + min_bits) / 2;\n\n                if (found != 0) {\n                    found = 2;\n                    /*\n                     * start again with best quantization so far\n                     */\n                    cod_info.assign(bst_cod_info);\n                    System$21.arraycopy(bst_xrpow, 0, xrpow, 0, 576);\n                }\n            }\n        } while (dbits > 12);\n\n        gfc.sfb21_extra = sfb21_extra;\n\n        /*\n         * found=0 => nothing found, use last one found=1 => we just found the\n         * best and left the loop found=2 => we restored a good one and have now\n         * l3_enc to restore too\n         */\n        if (found == 2) {\n            System$21.arraycopy(bst_cod_info.l3_enc, 0, cod_info.l3_enc, 0, 576);\n        }\n        assert$21(cod_info.part2_3_length <= Max_bits);\n    };\n\n    /**\n     * Robert Hegemann 2000-09-05\n     *\n     * calculates * how many bits are available for analog silent granules * how\n     * many bits to use for the lowest allowed bitrate * how many bits each\n     * bitrate would provide\n     */\n    this.get_framebits = function (gfp, frameBits) {\n        var gfc = gfp.internal_flags;\n\n        /*\n         * always use at least this many bits per granule per channel unless we\n         * detect analog silence, see below\n         */\n        gfc.bitrate_index = gfc.VBR_min_bitrate;\n        var bitsPerFrame = bs.getframebits(gfp);\n\n        /*\n         * bits for analog silence\n         */\n        gfc.bitrate_index = 1;\n        bitsPerFrame = bs.getframebits(gfp);\n\n        for (var i = 1; i <= gfc.VBR_max_bitrate; i++) {\n            gfc.bitrate_index = i;\n            var mb = new MeanBits(bitsPerFrame);\n            frameBits[i] = rv.ResvFrameBegin(gfp, mb);\n            bitsPerFrame = mb.bits;\n        }\n    };\n\n    /* RH: this one needs to be overhauled sometime */\n\n    /**\n     * <PRE>\n     *  2000-09-04 Robert Hegemann\n     *\n     *  * converts LR to MS coding when necessary\n     *  * calculates allowed/adjusted quantization noise amounts\n     *  * detects analog silent frames\n     *\n     *  some remarks:\n     *  - lower masking depending on Quality setting\n     *  - quality control together with adjusted ATH MDCT scaling\n     *    on lower quality setting allocate more noise from\n     *    ATH masking, and on higher quality setting allocate\n     *    less noise from ATH masking.\n     *  - experiments show that going more than 2dB over GPSYCHO's\n     *    limits ends up in very annoying artefacts\n     * </PRE>\n     */\n    this.VBR_old_prepare = function (gfp, pe, ms_ener_ratio, ratio, l3_xmin, frameBits, min_bits,\n                                     max_bits, bands) {\n        var gfc = gfp.internal_flags;\n\n        var masking_lower_db, adjust = 0.0;\n        var analog_silence = 1;\n        var bits = 0;\n\n        gfc.bitrate_index = gfc.VBR_max_bitrate;\n        var avg = rv.ResvFrameBegin(gfp, new MeanBits(0)) / gfc.mode_gr;\n\n        get_framebits(gfp, frameBits);\n\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            var mxb = qupvt.on_pe(gfp, pe, max_bits[gr], avg, gr, 0);\n            if (gfc.mode_ext == Encoder_1.MPG_MD_MS_LR) {\n                ms_convert(gfc.l3_side, gr);\n                qupvt.reduce_side(max_bits[gr], ms_ener_ratio[gr], avg, mxb);\n            }\n            for (var ch = 0; ch < gfc.channels_out; ++ch) {\n                var cod_info = gfc.l3_side.tt[gr][ch];\n\n                if (cod_info.block_type != Encoder_1.SHORT_TYPE) {\n                    // NORM, START or STOP type\n                    adjust = 1.28 / (1 + Math\n                            .exp(3.5 - pe[gr][ch] / 300.)) - 0.05;\n                    masking_lower_db = gfc.PSY.mask_adjust - adjust;\n                } else {\n                    adjust = 2.56 / (1 + Math\n                            .exp(3.5 - pe[gr][ch] / 300.)) - 0.14;\n                    masking_lower_db = gfc.PSY.mask_adjust_short - adjust;\n                }\n                gfc.masking_lower = Math.pow(10.0,\n                    masking_lower_db * 0.1);\n\n                init_outer_loop(gfc, cod_info);\n                bands[gr][ch] = qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info,\n                    l3_xmin[gr][ch]);\n                if (bands[gr][ch] != 0)\n                    analog_silence = 0;\n\n                min_bits[gr][ch] = 126;\n\n                bits += max_bits[gr][ch];\n            }\n        }\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                if (bits > frameBits[gfc.VBR_max_bitrate]) {\n                    max_bits[gr][ch] *= frameBits[gfc.VBR_max_bitrate];\n                    max_bits[gr][ch] /= bits;\n                }\n                if (min_bits[gr][ch] > max_bits[gr][ch])\n                    min_bits[gr][ch] = max_bits[gr][ch];\n\n            }\n            /* for ch */\n        }\n        /* for gr */\n\n        return analog_silence;\n    };\n\n    this.bitpressure_strategy = function (gfc, l3_xmin, min_bits, max_bits) {\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                var gi = gfc.l3_side.tt[gr][ch];\n                var pxmin = l3_xmin[gr][ch];\n                var pxminPos = 0;\n                for (var sfb = 0; sfb < gi.psy_lmax; sfb++)\n                    pxmin[pxminPos++] *= 1. + .029 * sfb * sfb\n                        / Encoder_1.SBMAX_l / Encoder_1.SBMAX_l;\n\n                if (gi.block_type == Encoder_1.SHORT_TYPE) {\n                    for (var sfb = gi.sfb_smin; sfb < Encoder_1.SBMAX_s; sfb++) {\n                        pxmin[pxminPos++] *= 1. + .029 * sfb * sfb\n                            / Encoder_1.SBMAX_s / Encoder_1.SBMAX_s;\n                        pxmin[pxminPos++] *= 1. + .029 * sfb * sfb\n                            / Encoder_1.SBMAX_s / Encoder_1.SBMAX_s;\n                        pxmin[pxminPos++] *= 1. + .029 * sfb * sfb\n                            / Encoder_1.SBMAX_s / Encoder_1.SBMAX_s;\n                    }\n                }\n                max_bits[gr][ch] = 0 | Math.max(min_bits[gr][ch],\n                        0.9 * max_bits[gr][ch]);\n            }\n        }\n    };\n\n    this.VBR_new_prepare = function (gfp, pe, ratio, l3_xmin, frameBits, max_bits) {\n        var gfc = gfp.internal_flags;\n\n        var analog_silence = 1;\n        var avg = 0, bits = 0;\n        var maximum_framebits;\n\n        if (!gfp.free_format) {\n            gfc.bitrate_index = gfc.VBR_max_bitrate;\n\n            var mb = new MeanBits(avg);\n            rv.ResvFrameBegin(gfp, mb);\n            avg = mb.bits;\n\n            get_framebits(gfp, frameBits);\n            maximum_framebits = frameBits[gfc.VBR_max_bitrate];\n        } else {\n            gfc.bitrate_index = 0;\n            var mb = new MeanBits(avg);\n            maximum_framebits = rv.ResvFrameBegin(gfp, mb);\n            avg = mb.bits;\n            frameBits[0] = maximum_framebits;\n        }\n\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            qupvt.on_pe(gfp, pe, max_bits[gr], avg, gr, 0);\n            if (gfc.mode_ext == Encoder_1.MPG_MD_MS_LR) {\n                ms_convert(gfc.l3_side, gr);\n            }\n            for (var ch = 0; ch < gfc.channels_out; ++ch) {\n                var cod_info = gfc.l3_side.tt[gr][ch];\n\n                gfc.masking_lower = Math.pow(10.0,\n                    gfc.PSY.mask_adjust * 0.1);\n\n                init_outer_loop(gfc, cod_info);\n                if (0 != qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info,\n                        l3_xmin[gr][ch]))\n                    analog_silence = 0;\n\n                bits += max_bits[gr][ch];\n            }\n        }\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                if (bits > maximum_framebits) {\n                    max_bits[gr][ch] *= maximum_framebits;\n                    max_bits[gr][ch] /= bits;\n                }\n\n            }\n            /* for ch */\n        }\n        /* for gr */\n\n        return analog_silence;\n    };\n\n    /**\n     * calculates target bits for ABR encoding\n     *\n     * mt 2000/05/31\n     */\n    this.calc_target_bits = function (gfp, pe, ms_ener_ratio, targ_bits, analog_silence_bits, max_frame_bits) {\n        var gfc = gfp.internal_flags;\n        var l3_side = gfc.l3_side;\n        var res_factor;\n        var gr, ch, totbits, mean_bits = 0;\n\n        gfc.bitrate_index = gfc.VBR_max_bitrate;\n        var mb = new MeanBits(mean_bits);\n        max_frame_bits[0] = rv.ResvFrameBegin(gfp, mb);\n        mean_bits = mb.bits;\n\n        gfc.bitrate_index = 1;\n        mean_bits = bs.getframebits(gfp) - gfc.sideinfo_len * 8;\n        analog_silence_bits[0] = mean_bits / (gfc.mode_gr * gfc.channels_out);\n\n        mean_bits = gfp.VBR_mean_bitrate_kbps * gfp.framesize * 1000;\n        if ((gfc.substep_shaping & 1) != 0)\n            mean_bits *= 1.09;\n        mean_bits /= gfp.out_samplerate;\n        mean_bits -= gfc.sideinfo_len * 8;\n        mean_bits /= (gfc.mode_gr * gfc.channels_out);\n\n        /**\n         * <PRE>\n         *           res_factor is the percentage of the target bitrate that should\n         *           be used on average.  the remaining bits are added to the\n         *           bitreservoir and used for difficult to encode frames.\n         *\n         *           Since we are tracking the average bitrate, we should adjust\n         *           res_factor \"on the fly\", increasing it if the average bitrate\n         *           is greater than the requested bitrate, and decreasing it\n         *           otherwise.  Reasonable ranges are from .9 to 1.0\n         *\n         *           Until we get the above suggestion working, we use the following\n         *           tuning:\n         *           compression ratio    res_factor\n         *           5.5  (256kbps)         1.0      no need for bitreservoir\n         *           11   (128kbps)         .93      7% held for reservoir\n         *\n         *           with linear interpolation for other values.\n         * </PRE>\n         */\n        res_factor = .93 + .07 * (11.0 - gfp.compression_ratio)\n            / (11.0 - 5.5);\n        if (res_factor < .90)\n            res_factor = .90;\n        if (res_factor > 1.00)\n            res_factor = 1.00;\n\n        for (gr = 0; gr < gfc.mode_gr; gr++) {\n            var sum = 0;\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                targ_bits[gr][ch] = (int)(res_factor * mean_bits);\n\n                if (pe[gr][ch] > 700) {\n                    var add_bits = (int)((pe[gr][ch] - 700) / 1.4);\n\n                    var cod_info = l3_side.tt[gr][ch];\n                    targ_bits[gr][ch] = (int)(res_factor * mean_bits);\n\n                    /* short blocks use a little extra, no matter what the pe */\n                    if (cod_info.block_type == Encoder_1.SHORT_TYPE) {\n                        if (add_bits < mean_bits / 2)\n                            add_bits = mean_bits / 2;\n                    }\n                    /* at most increase bits by 1.5*average */\n                    if (add_bits > mean_bits * 3 / 2)\n                        add_bits = mean_bits * 3 / 2;\n                    else if (add_bits < 0)\n                        add_bits = 0;\n\n                    targ_bits[gr][ch] += add_bits;\n                }\n                if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL) {\n                    targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;\n                }\n                sum += targ_bits[gr][ch];\n            }\n            /* for ch */\n            if (sum > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n                for (ch = 0; ch < gfc.channels_out; ++ch) {\n                    targ_bits[gr][ch] *= LameInternalFlags.MAX_BITS_PER_GRANULE;\n                    targ_bits[gr][ch] /= sum;\n                }\n            }\n        }\n        /* for gr */\n\n        if (gfc.mode_ext == Encoder_1.MPG_MD_MS_LR)\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                qupvt.reduce_side(targ_bits[gr], ms_ener_ratio[gr], mean_bits\n                    * gfc.channels_out,\n                    LameInternalFlags.MAX_BITS_PER_GRANULE);\n            }\n\n        /*\n         * sum target bits\n         */\n        totbits = 0;\n        for (gr = 0; gr < gfc.mode_gr; gr++) {\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL)\n                    targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;\n                totbits += targ_bits[gr][ch];\n            }\n        }\n\n        /*\n         * repartion target bits if needed\n         */\n        if (totbits > max_frame_bits[0]) {\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    targ_bits[gr][ch] *= max_frame_bits[0];\n                    targ_bits[gr][ch] /= totbits;\n                }\n            }\n        }\n    };\n\n}\n\nvar Quantize_1 = Quantize$1;\n\n/*\n *      bit reservoir source file\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Reservoir.java,v 1.9 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n/**\n * ResvFrameBegin:<BR>\n * Called (repeatedly) at the beginning of a frame. Updates the maximum size of\n * the reservoir, and checks to make sure main_data_begin was set properly by\n * the formatter<BR>\n * Background information:\n * \n * This is the original text from the ISO standard. Because of sooo many bugs\n * and irritations correcting comments are added in brackets []. A '^W' means\n * you should remove the last word.\n * \n * <PRE>\n *  1. The following rule can be used to calculate the maximum\n *     number of bits used for one granule [^W frame]:<BR>\n *     At the highest possible bitrate of Layer III (320 kbps\n *     per stereo signal [^W^W^W], 48 kHz) the frames must be of\n *     [^W^W^W are designed to have] constant length, i.e.\n *     one buffer [^W^W the frame] length is:<BR>\n * \n *         320 kbps * 1152/48 kHz = 7680 bit = 960 byte\n * \n *     This value is used as the maximum buffer per channel [^W^W] at\n *     lower bitrates [than 320 kbps]. At 64 kbps mono or 128 kbps\n *     stereo the main granule length is 64 kbps * 576/48 kHz = 768 bit\n *     [per granule and channel] at 48 kHz sampling frequency.\n *     This means that there is a maximum deviation (short time buffer\n *     [= reservoir]) of 7680 - 2*2*768 = 4608 bits is allowed at 64 kbps.\n *     The actual deviation is equal to the number of bytes [with the\n *     meaning of octets] denoted by the main_data_end offset pointer.\n *     The actual maximum deviation is (2^9-1)*8 bit = 4088 bits\n *     [for MPEG-1 and (2^8-1)*8 bit for MPEG-2, both are hard limits].\n *     ... The xchange of buffer bits between the left and right channel\n *     is allowed without restrictions [exception: dual channel].\n *     Because of the [constructed] constraint on the buffer size\n *     main_data_end is always set to 0 in the case of bit_rate_index==14,\n *     i.e. data rate 320 kbps per stereo signal [^W^W^W]. In this case\n *     all data are allocated between adjacent header [^W sync] words\n *     [, i.e. there is no buffering at all].\n * </PRE>\n */\n\n\nvar assert$23 = common.assert;\n\nfunction Reservoir$1() {\n\tvar bs;\n\n\tthis.setModules  = function(_bs) {\n\t\tbs = _bs;\n\t};\n\n\tthis.ResvFrameBegin = function(gfp, mean_bits) {\n\t\tvar gfc = gfp.internal_flags;\n\t\tvar maxmp3buf;\n\t\tvar l3_side = gfc.l3_side;\n\n\t\tvar frameLength = bs.getframebits(gfp);\n\t\tmean_bits.bits = (frameLength - gfc.sideinfo_len * 8) / gfc.mode_gr;\n\n\t\t/**\n\t\t * <PRE>\n\t\t *  Meaning of the variables:\n\t\t *      resvLimit: (0, 8, ..., 8*255 (MPEG-2), 8*511 (MPEG-1))\n\t\t *          Number of bits can be stored in previous frame(s) due to\n\t\t *          counter size constaints\n\t\t *      maxmp3buf: ( ??? ... 8*1951 (MPEG-1 and 2), 8*2047 (MPEG-2.5))\n\t\t *          Number of bits allowed to encode one frame (you can take 8*511 bit\n\t\t *          from the bit reservoir and at most 8*1440 bit from the current\n\t\t *          frame (320 kbps, 32 kHz), so 8*1951 bit is the largest possible\n\t\t *          value for MPEG-1 and -2)\n\t\t * \n\t\t *          maximum allowed granule/channel size times 4 = 8*2047 bits.,\n\t\t *          so this is the absolute maximum supported by the format.\n\t\t * \n\t\t * \n\t\t *      fullFrameBits:  maximum number of bits available for encoding\n\t\t *                      the current frame.\n\t\t * \n\t\t *      mean_bits:      target number of bits per granule.\n\t\t * \n\t\t *      frameLength:\n\t\t * \n\t\t *      gfc.ResvMax:   maximum allowed reservoir\n\t\t * \n\t\t *      gfc.ResvSize:  current reservoir size\n\t\t * \n\t\t *      l3_side.resvDrain_pre:\n\t\t *         ancillary data to be added to previous frame:\n\t\t *         (only usefull in VBR modes if it is possible to have\n\t\t *         maxmp3buf < fullFrameBits)).  Currently disabled,\n\t\t *         see #define NEW_DRAIN\n\t\t *         2010-02-13: RH now enabled, it seems to be needed for CBR too,\n\t\t *                     as there exists one example, where the FhG decoder\n\t\t *                     can't decode a -b320 CBR file anymore.\n\t\t * \n\t\t *      l3_side.resvDrain_post:\n\t\t *         ancillary data to be added to this frame:\n\t\t * \n\t\t * </PRE>\n\t\t */\n\n\t\t/* main_data_begin has 9 bits in MPEG-1, 8 bits MPEG-2 */\n\t\tvar resvLimit = (8 * 256) * gfc.mode_gr - 8;\n\n\t\t/*\n\t\t * maximum allowed frame size. dont use more than this number of bits,\n\t\t * even if the frame has the space for them:\n\t\t */\n\t\tif (gfp.brate > 320) {\n\t\t\t/* in freeformat the buffer is constant */\n\t\t\tmaxmp3buf = 8 * ((int) ((gfp.brate * 1000)\n\t\t\t\t\t/ (gfp.out_samplerate / 1152) / 8 + .5));\n\t\t} else {\n\t\t\t/*\n\t\t\t * all mp3 decoders should have enough buffer to handle this value:\n\t\t\t * size of a 320kbps 32kHz frame\n\t\t\t */\n\t\t\tmaxmp3buf = 8 * 1440;\n\n\t\t\t/*\n\t\t\t * Bouvigne suggests this more lax interpretation of the ISO doc\n\t\t\t * instead of using 8*960.\n\t\t\t */\n\n\t\t\tif (gfp.strict_ISO) {\n\t\t\t\tmaxmp3buf = 8 * ((int) (320000 / (gfp.out_samplerate / 1152) / 8 + .5));\n\t\t\t}\n\t\t}\n\n\t\tgfc.ResvMax = maxmp3buf - frameLength;\n\t\tif (gfc.ResvMax > resvLimit)\n\t\t\tgfc.ResvMax = resvLimit;\n\t\tif (gfc.ResvMax < 0 || gfp.disable_reservoir)\n\t\t\tgfc.ResvMax = 0;\n\n\t\tvar fullFrameBits = mean_bits.bits * gfc.mode_gr\n\t\t\t\t+ Math.min(gfc.ResvSize, gfc.ResvMax);\n\n\t\tif (fullFrameBits > maxmp3buf)\n\t\t\tfullFrameBits = maxmp3buf;\n\n\t\tassert$23 (0 == gfc.ResvMax % 8);\n\t\tassert$23 (gfc.ResvMax >= 0);\n\n\t\tl3_side.resvDrain_pre = 0;\n\n\t\t// frame analyzer code\n\t\tif (gfc.pinfo != null) {\n\t\t\t/*\n\t\t\t * expected bits per channel per granule [is this also right for\n\t\t\t * mono/stereo, MPEG-1/2 ?]\n\t\t\t */\n\t\t\tgfc.pinfo.mean_bits = mean_bits.bits / 2;\n\t\t\tgfc.pinfo.resvsize = gfc.ResvSize;\n\t\t}\n\n\t\treturn fullFrameBits;\n\t};\n\n\t/**\n\t * returns targ_bits: target number of bits to use for 1 granule<BR>\n\t * extra_bits: amount extra available from reservoir<BR>\n\t * Mark Taylor 4/99\n\t */\n\tthis.ResvMaxBits = function(gfp, mean_bits, targ_bits, cbr) {\n\t\tvar gfc = gfp.internal_flags;\n\t\tvar add_bits;\n        var ResvSize = gfc.ResvSize, ResvMax = gfc.ResvMax;\n\n\t\t/* compensate the saved bits used in the 1st granule */\n\t\tif (cbr != 0)\n\t\t\tResvSize += mean_bits;\n\n\t\tif ((gfc.substep_shaping & 1) != 0)\n\t\t\tResvMax *= 0.9;\n\n\t\ttarg_bits.bits = mean_bits;\n\n\t\t/* extra bits if the reservoir is almost full */\n\t\tif (ResvSize * 10 > ResvMax * 9) {\n\t\t\tadd_bits = ResvSize - (ResvMax * 9) / 10;\n\t\t\ttarg_bits.bits += add_bits;\n\t\t\tgfc.substep_shaping |= 0x80;\n\t\t} else {\n\t\t\tadd_bits = 0;\n\t\t\tgfc.substep_shaping &= 0x7f;\n\t\t\t/*\n\t\t\t * build up reservoir. this builds the reservoir a little slower\n\t\t\t * than FhG. It could simple be mean_bits/15, but this was rigged to\n\t\t\t * always produce 100 (the old value) at 128kbs\n\t\t\t */\n\t\t\tif (!gfp.disable_reservoir && 0 == (gfc.substep_shaping & 1))\n\t\t\t\ttarg_bits.bits -= .1 * mean_bits;\n\t\t}\n\n\t\t/* amount from the reservoir we are allowed to use. ISO says 6/10 */\n\t\tvar extra_bits = (ResvSize < (gfc.ResvMax * 6) / 10 ? ResvSize\n\t\t\t\t: (gfc.ResvMax * 6) / 10);\n\t\textra_bits -= add_bits;\n\n\t\tif (extra_bits < 0)\n\t\t\textra_bits = 0;\n\t\treturn extra_bits;\n\t};\n\n\t/**\n\t * Called after a granule's bit allocation. Readjusts the size of the\n\t * reservoir to reflect the granule's usage.\n\t */\n\tthis.ResvAdjust = function(gfc, gi) {\n\t\tgfc.ResvSize -= gi.part2_3_length + gi.part2_length;\n\t};\n\n\t/**\n\t * Called after all granules in a frame have been allocated. Makes sure that\n\t * the reservoir size is within limits, possibly by adding stuffing bits.\n\t */\n\tthis.ResvFrameEnd = function(gfc, mean_bits) {\n\t\tvar over_bits;\n\t\tvar l3_side = gfc.l3_side;\n\n\t\tgfc.ResvSize += mean_bits * gfc.mode_gr;\n\t\tvar stuffingBits = 0;\n\t\tl3_side.resvDrain_post = 0;\n\t\tl3_side.resvDrain_pre = 0;\n\n\t\t/* we must be byte aligned */\n\t\tif ((over_bits = gfc.ResvSize % 8) != 0)\n\t\t\tstuffingBits += over_bits;\n\n\t\tover_bits = (gfc.ResvSize - stuffingBits) - gfc.ResvMax;\n\t\tif (over_bits > 0) {\n\t\t\tassert$23 (0 == over_bits % 8);\n\t\t\tassert$23 (over_bits >= 0);\n\t\t\tstuffingBits += over_bits;\n\t\t}\n\n\t\t/*\n\t\t * NOTE: enabling the NEW_DRAIN code fixes some problems with FhG\n\t\t * decoder shipped with MS Windows operating systems. Using this, it is\n\t\t * even possible to use Gabriel's lax buffer consideration again, which\n\t\t * assumes, any decoder should have a buffer large enough for a 320 kbps\n\t\t * frame at 32 kHz sample rate.\n\t\t * \n\t\t * old drain code: lame -b320 BlackBird.wav --. does not play with\n\t\t * GraphEdit.exe using FhG decoder V1.5 Build 50\n\t\t * \n\t\t * new drain code: lame -b320 BlackBird.wav --. plays fine with\n\t\t * GraphEdit.exe using FhG decoder V1.5 Build 50\n\t\t * \n\t\t * Robert Hegemann, 2010-02-13.\n\t\t */\n\t\t/*\n\t\t * drain as many bits as possible into previous frame ancillary data In\n\t\t * particular, in VBR mode ResvMax may have changed, and we have to make\n\t\t * sure main_data_begin does not create a reservoir bigger than ResvMax\n\t\t * mt 4/00\n\t\t */\n\t\t{\n\t\t\tvar mdb_bytes = Math.min(l3_side.main_data_begin * 8, stuffingBits) / 8;\n\t\t\tl3_side.resvDrain_pre += 8 * mdb_bytes;\n\t\t\tstuffingBits -= 8 * mdb_bytes;\n\t\t\tgfc.ResvSize -= 8 * mdb_bytes;\n\t\t\tl3_side.main_data_begin -= mdb_bytes;\n\t\t}\n\t\t/* drain the rest into this frames ancillary data */\n\t\tl3_side.resvDrain_post += stuffingBits;\n\t\tgfc.ResvSize -= stuffingBits;\n\t};\n}\n\nvar Reservoir_1 = Reservoir$1;\n\nfunction Version() {\n\n    /**\n     * URL for the LAME website.\n     */\n    var LAME_URL = \"http://www.mp3dev.org/\";\n\n    /**\n     * Major version number.\n     */\n    var LAME_MAJOR_VERSION = 3;\n    /**\n     * Minor version number.\n     */\n    var LAME_MINOR_VERSION = 98;\n    /**\n     * Patch level.\n     */\n    var LAME_PATCH_VERSION = 4;\n\n    /**\n     * Major version number.\n     */\n    var PSY_MAJOR_VERSION = 0;\n    /**\n     * Minor version number.\n     */\n    var PSY_MINOR_VERSION = 93;\n\n    /**\n     * A string which describes the version of LAME.\n     *\n     * @return string which describes the version of LAME\n     */\n    this.getLameVersion = function () {\n        // primary to write screen reports\n        return (LAME_MAJOR_VERSION + \".\" + LAME_MINOR_VERSION + \".\" + LAME_PATCH_VERSION);\n    };\n\n    /**\n     * The short version of the LAME version string.\n     *\n     * @return short version of the LAME version string\n     */\n    this.getLameShortVersion = function () {\n        // Adding date and time to version string makes it harder for output\n        // validation\n        return (LAME_MAJOR_VERSION + \".\" + LAME_MINOR_VERSION + \".\" + LAME_PATCH_VERSION);\n    };\n\n    /**\n     * The shortest version of the LAME version string.\n     *\n     * @return shortest version of the LAME version string\n     */\n    this.getLameVeryShortVersion = function () {\n        // Adding date and time to version string makes it harder for output\n        return (\"LAME\" + LAME_MAJOR_VERSION + \".\" + LAME_MINOR_VERSION + \"r\");\n    };\n\n    /**\n     * String which describes the version of GPSYCHO\n     *\n     * @return string which describes the version of GPSYCHO\n     */\n    this.getPsyVersion = function () {\n        return (PSY_MAJOR_VERSION + \".\" + PSY_MINOR_VERSION);\n    };\n\n    /**\n     * String which is a URL for the LAME website.\n     *\n     * @return string which is a URL for the LAME website\n     */\n    this.getLameUrl = function () {\n        return LAME_URL;\n    };\n\n    /**\n     * Quite useless for a java version, however we are compatible ;-)\n     *\n     * @return \"32bits\"\n     */\n    this.getLameOsBitness = function () {\n        return \"32bits\";\n    };\n\n}\n\nvar Version_1 = Version;\n\nvar System$22 = common.System;\nvar VbrMode$22 = common.VbrMode;\nvar ShortBlock$22 = common.ShortBlock;\nvar Arrays$22 = common.Arrays;\nvar new_byte$22 = common.new_byte;\nvar assert$24 = common.assert;\n\n/**\n * A Vbr header may be present in the ancillary data field of the first frame of\n * an mp3 bitstream<BR>\n * The Vbr header (optionally) contains\n * <UL>\n * <LI>frames total number of audio frames in the bitstream\n * <LI>bytes total number of bytes in the bitstream\n * <LI>toc table of contents\n * </UL>\n *\n * toc (table of contents) gives seek points for random access.<BR>\n * The ith entry determines the seek point for i-percent duration.<BR>\n * seek point in bytes = (toc[i]/256.0) * total_bitstream_bytes<BR>\n * e.g. half duration seek point = (toc[50]/256.0) * total_bitstream_bytes\n */\nVBRTag.NUMTOCENTRIES = 100;\nVBRTag.MAXFRAMESIZE = 2880;\n\nfunction VBRTag() {\n\n    var lame;\n    var bs;\n    var v;\n\n    this.setModules = function (_lame, _bs, _v) {\n        lame = _lame;\n        bs = _bs;\n        v = _v;\n    };\n\n    var FRAMES_FLAG = 0x0001;\n    var BYTES_FLAG = 0x0002;\n    var TOC_FLAG = 0x0004;\n    var VBR_SCALE_FLAG = 0x0008;\n\n    var NUMTOCENTRIES = VBRTag.NUMTOCENTRIES;\n\n    /**\n     * (0xB40) the max freeformat 640 32kHz framesize.\n     */\n    var MAXFRAMESIZE = VBRTag.MAXFRAMESIZE;\n\n    /**\n     * <PRE>\n     *    4 bytes for Header Tag\n     *    4 bytes for Header Flags\n     *  100 bytes for entry (toc)\n     *    4 bytes for frame size\n     *    4 bytes for stream size\n     *    4 bytes for VBR scale. a VBR quality indicator: 0=best 100=worst\n     *   20 bytes for LAME tag.  for example, \"LAME3.12 (beta 6)\"\n     * ___________\n     *  140 bytes\n     * </PRE>\n     */\n    var VBRHEADERSIZE = (NUMTOCENTRIES + 4 + 4 + 4 + 4 + 4);\n\n    var LAMEHEADERSIZE = (VBRHEADERSIZE + 9 + 1 + 1 + 8\n    + 1 + 1 + 3 + 1 + 1 + 2 + 4 + 2 + 2);\n\n    /**\n     * The size of the Xing header MPEG-1, bit rate in kbps.\n     */\n    var XING_BITRATE1 = 128;\n    /**\n     * The size of the Xing header MPEG-2, bit rate in kbps.\n     */\n    var XING_BITRATE2 = 64;\n    /**\n     * The size of the Xing header MPEG-2.5, bit rate in kbps.\n     */\n    var XING_BITRATE25 = 32;\n\n    /**\n     * ISO-8859-1 charset for byte to string operations.\n     */\n    var ISO_8859_1 = null; //Charset.forName(\"ISO-8859-1\");\n\n    /**\n     * VBR header magic string.\n     */\n    var VBRTag0 = \"Xing\";\n    /**\n     * VBR header magic string (VBR == VBRMode.vbr_off).\n     */\n    var VBRTag1 = \"Info\";\n\n    /**\n     * Lookup table for fast CRC-16 computation. Uses the polynomial\n     * x^16+x^15+x^2+1\n     */\n    var crc16Lookup = [0x0000, 0xC0C1, 0xC181, 0x0140,\n        0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741,\n        0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0, 0x0D80, 0xCD41,\n        0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40,\n        0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941,\n        0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40,\n        0xDD01, 0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540,\n        0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341,\n        0x1100, 0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141,\n        0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740,\n        0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40,\n        0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41,\n        0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940,\n        0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41,\n        0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541,\n        0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340,\n        0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141,\n        0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740,\n        0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40,\n        0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41,\n        0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940,\n        0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41,\n        0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541,\n        0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340,\n        0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140,\n        0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741,\n        0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80, 0x9D41,\n        0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40,\n        0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0, 0x4980, 0x8941,\n        0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40,\n        0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581, 0x4540,\n        0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341,\n        0x4100, 0x81C1, 0x8081, 0x4040];\n\n    /***********************************************************************\n     * Robert Hegemann 2001-01-17\n     ***********************************************************************/\n\n    function addVbr(v, bitrate) {\n        v.nVbrNumFrames++;\n        v.sum += bitrate;\n        v.seen++;\n\n        if (v.seen < v.want) {\n            return;\n        }\n\n        if (v.pos < v.size) {\n            v.bag[v.pos] = v.sum;\n            v.pos++;\n            v.seen = 0;\n        }\n        if (v.pos == v.size) {\n            for (var i = 1; i < v.size; i += 2) {\n                v.bag[i / 2] = v.bag[i];\n            }\n            v.want *= 2;\n            v.pos /= 2;\n        }\n    }\n\n    function xingSeekTable(v, t) {\n        if (v.pos <= 0)\n            return;\n\n        for (var i = 1; i < NUMTOCENTRIES; ++i) {\n            var j = i / NUMTOCENTRIES, act, sum;\n            var indx = 0 | (Math.floor(j * v.pos));\n            if (indx > v.pos - 1)\n                indx = v.pos - 1;\n            act = v.bag[indx];\n            sum = v.sum;\n            var seek_point = 0 | (256. * act / sum);\n            if (seek_point > 255)\n                seek_point = 255;\n            t[i] = 0xff & seek_point;\n        }\n    }\n\n    /**\n     * Add VBR entry, used to fill the VBR TOC entries.\n     *\n     * @param gfp\n     *            global flags\n     */\n    this.addVbrFrame = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var kbps = Tables.bitrate_table[gfp.version][gfc.bitrate_index];\n        assert$24(gfc.VBR_seek_table.bag != null);\n        addVbr(gfc.VBR_seek_table, kbps);\n    };\n\n    /**\n     * Read big endian integer (4-bytes) from header.\n     *\n     * @param buf\n     *            header containing the integer\n     * @param bufPos\n     *            offset into the header\n     * @return extracted integer\n     */\n    function extractInteger(buf, bufPos) {\n        var x = buf[bufPos + 0] & 0xff;\n        x <<= 8;\n        x |= buf[bufPos + 1] & 0xff;\n        x <<= 8;\n        x |= buf[bufPos + 2] & 0xff;\n        x <<= 8;\n        x |= buf[bufPos + 3] & 0xff;\n        return x;\n    }\n\n    /**\n     * Write big endian integer (4-bytes) in the header.\n     *\n     * @param buf\n     *            header to write the integer into\n     * @param bufPos\n     *            offset into the header\n     * @param value\n     *            integer value to write\n     */\n    function createInteger(buf, bufPos, value) {\n        buf[bufPos + 0] = 0xff & ((value >> 24) & 0xff);\n        buf[bufPos + 1] = 0xff & ((value >> 16) & 0xff);\n        buf[bufPos + 2] = 0xff & ((value >> 8) & 0xff);\n        buf[bufPos + 3] = 0xff & (value & 0xff);\n    }\n\n    /**\n     * Write big endian short (2-bytes) in the header.\n     *\n     * @param buf\n     *            header to write the integer into\n     * @param bufPos\n     *            offset into the header\n     * @param value\n     *            integer value to write\n     */\n    function createShort(buf, bufPos, value) {\n        buf[bufPos + 0] = 0xff & ((value >> 8) & 0xff);\n        buf[bufPos + 1] = 0xff & (value & 0xff);\n    }\n\n    /**\n     * Check for magic strings (Xing/Info).\n     *\n     * @param buf\n     *            header to check\n     * @param bufPos\n     *            header offset to check\n     * @return magic string found\n     */\n    function isVbrTag(buf, bufPos) {\n        return new String(buf, bufPos, VBRTag0.length(), ISO_8859_1)\n                .equals(VBRTag0)\n            || new String(buf, bufPos, VBRTag1.length(), ISO_8859_1)\n                .equals(VBRTag1);\n    }\n\n    function shiftInBitsValue(x, n, v) {\n        return 0xff & ((x << n) | (v & ~(-1 << n)));\n    }\n\n    /**\n     * Construct the MP3 header using the settings of the global flags.\n     *\n     * <img src=\"1000px-Mp3filestructure.svg.png\">\n     *\n     * @param gfp\n     *            global flags\n     * @param buffer\n     *            header\n     */\n    function setLameTagFrameHeader(gfp, buffer) {\n        var gfc = gfp.internal_flags;\n\n        // MP3 Sync Word\n        buffer[0] = shiftInBitsValue(buffer[0], 8, 0xff);\n\n        buffer[1] = shiftInBitsValue(buffer[1], 3, 7);\n        buffer[1] = shiftInBitsValue(buffer[1], 1,\n            (gfp.out_samplerate < 16000) ? 0 : 1);\n        // Version\n        buffer[1] = shiftInBitsValue(buffer[1], 1, gfp.version);\n        // 01 == Layer 3\n        buffer[1] = shiftInBitsValue(buffer[1], 2, 4 - 3);\n        // Error protection\n        buffer[1] = shiftInBitsValue(buffer[1], 1, (!gfp.error_protection) ? 1\n            : 0);\n\n        // Bit rate\n        buffer[2] = shiftInBitsValue(buffer[2], 4, gfc.bitrate_index);\n        // Frequency\n        buffer[2] = shiftInBitsValue(buffer[2], 2, gfc.samplerate_index);\n        // Pad. Bit\n        buffer[2] = shiftInBitsValue(buffer[2], 1, 0);\n        // Priv. Bit\n        buffer[2] = shiftInBitsValue(buffer[2], 1, gfp.extension);\n\n        // Mode\n        buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.mode.ordinal());\n        // Mode extension (Used with Joint Stereo)\n        buffer[3] = shiftInBitsValue(buffer[3], 2, gfc.mode_ext);\n        // Copy\n        buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.copyright);\n        // Original\n        buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.original);\n        // Emphasis\n        buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.emphasis);\n\n        /* the default VBR header. 48 kbps layer III, no padding, no crc */\n        /* but sampling freq, mode and copyright/copy protection taken */\n        /* from first valid frame */\n        buffer[0] = 0xff;\n        var abyte = 0xff & (buffer[1] & 0xf1);\n        var bitrate;\n        if (1 == gfp.version) {\n            bitrate = XING_BITRATE1;\n        } else {\n            if (gfp.out_samplerate < 16000)\n                bitrate = XING_BITRATE25;\n            else\n                bitrate = XING_BITRATE2;\n        }\n\n        if (gfp.VBR == VbrMode$22.vbr_off)\n            bitrate = gfp.brate;\n\n        var bbyte;\n        if (gfp.free_format)\n            bbyte = 0x00;\n        else\n            bbyte = 0xff & (16 * lame.BitrateIndex(bitrate, gfp.version,\n                    gfp.out_samplerate));\n\n        /*\n         * Use as much of the info from the real frames in the Xing header:\n         * samplerate, channels, crc, etc...\n         */\n        if (gfp.version == 1) {\n            /* MPEG1 */\n            buffer[1] = 0xff & (abyte | 0x0a);\n            /* was 0x0b; */\n            abyte = 0xff & (buffer[2] & 0x0d);\n            /* AF keep also private bit */\n            buffer[2] = 0xff & (bbyte | abyte);\n            /* 64kbs MPEG1 frame */\n        } else {\n            /* MPEG2 */\n            buffer[1] = 0xff & (abyte | 0x02);\n            /* was 0x03; */\n            abyte = 0xff & (buffer[2] & 0x0d);\n            /* AF keep also private bit */\n            buffer[2] = 0xff & (bbyte | abyte);\n            /* 64kbs MPEG2 frame */\n        }\n    }\n\n    /**\n     * Get VBR tag information\n     *\n     * @param buf\n     *            header to analyze\n     * @param bufPos\n     *            offset into the header\n     * @return VBR tag data\n     */\n    this.getVbrTag = function (buf) {\n        var pTagData = new VBRTagData();\n        var bufPos = 0;\n\n        /* get Vbr header data */\n        pTagData.flags = 0;\n\n        /* get selected MPEG header data */\n        var hId = (buf[bufPos + 1] >> 3) & 1;\n        var hSrIndex = (buf[bufPos + 2] >> 2) & 3;\n        var hMode = (buf[bufPos + 3] >> 6) & 3;\n        var hBitrate = ((buf[bufPos + 2] >> 4) & 0xf);\n        hBitrate = Tables.bitrate_table[hId][hBitrate];\n\n        /* check for FFE syncword */\n        if ((buf[bufPos + 1] >> 4) == 0xE)\n            pTagData.samprate = Tables.samplerate_table[2][hSrIndex];\n        else\n            pTagData.samprate = Tables.samplerate_table[hId][hSrIndex];\n\n        /* determine offset of header */\n        if (hId != 0) {\n            /* mpeg1 */\n            if (hMode != 3)\n                bufPos += (32 + 4);\n            else\n                bufPos += (17 + 4);\n        } else {\n            /* mpeg2 */\n            if (hMode != 3)\n                bufPos += (17 + 4);\n            else\n                bufPos += (9 + 4);\n        }\n\n        if (!isVbrTag(buf, bufPos))\n            return null;\n\n        bufPos += 4;\n\n        pTagData.hId = hId;\n\n        /* get flags */\n        var head_flags = pTagData.flags = extractInteger(buf, bufPos);\n        bufPos += 4;\n\n        if ((head_flags & FRAMES_FLAG) != 0) {\n            pTagData.frames = extractInteger(buf, bufPos);\n            bufPos += 4;\n        }\n\n        if ((head_flags & BYTES_FLAG) != 0) {\n            pTagData.bytes = extractInteger(buf, bufPos);\n            bufPos += 4;\n        }\n\n        if ((head_flags & TOC_FLAG) != 0) {\n            if (pTagData.toc != null) {\n                for (var i = 0; i < NUMTOCENTRIES; i++)\n                    pTagData.toc[i] = buf[bufPos + i];\n            }\n            bufPos += NUMTOCENTRIES;\n        }\n\n        pTagData.vbrScale = -1;\n\n        if ((head_flags & VBR_SCALE_FLAG) != 0) {\n            pTagData.vbrScale = extractInteger(buf, bufPos);\n            bufPos += 4;\n        }\n\n        pTagData.headersize = ((hId + 1) * 72000 * hBitrate)\n            / pTagData.samprate;\n\n        bufPos += 21;\n        var encDelay = buf[bufPos + 0] << 4;\n        encDelay += buf[bufPos + 1] >> 4;\n        var encPadding = (buf[bufPos + 1] & 0x0F) << 8;\n        encPadding += buf[bufPos + 2] & 0xff;\n        /* check for reasonable values (this may be an old Xing header, */\n        /* not a INFO tag) */\n        if (encDelay < 0 || encDelay > 3000)\n            encDelay = -1;\n        if (encPadding < 0 || encPadding > 3000)\n            encPadding = -1;\n\n        pTagData.encDelay = encDelay;\n        pTagData.encPadding = encPadding;\n\n        /* success */\n        return pTagData;\n    };\n\n    /**\n     * Initializes the header\n     *\n     * @param gfp\n     *            global flags\n     */\n    this.InitVbrTag = function (gfp) {\n        var gfc = gfp.internal_flags;\n\n        /**\n         * <PRE>\n         * Xing VBR pretends to be a 48kbs layer III frame.  (at 44.1kHz).\n         * (at 48kHz they use 56kbs since 48kbs frame not big enough for\n         * table of contents)\n         * let's always embed Xing header inside a 64kbs layer III frame.\n         * this gives us enough room for a LAME version string too.\n         * size determined by sampling frequency (MPEG1)\n         * 32kHz:    216 bytes@48kbs    288bytes@ 64kbs\n         * 44.1kHz:  156 bytes          208bytes@64kbs     (+1 if padding = 1)\n         * 48kHz:    144 bytes          192\n         *\n         * MPEG 2 values are the same since the framesize and samplerate\n         * are each reduced by a factor of 2.\n         * </PRE>\n         */\n        var kbps_header;\n        if (1 == gfp.version) {\n            kbps_header = XING_BITRATE1;\n        } else {\n            if (gfp.out_samplerate < 16000)\n                kbps_header = XING_BITRATE25;\n            else\n                kbps_header = XING_BITRATE2;\n        }\n\n        if (gfp.VBR == VbrMode$22.vbr_off)\n            kbps_header = gfp.brate;\n\n        // make sure LAME Header fits into Frame\n        var totalFrameSize = ((gfp.version + 1) * 72000 * kbps_header)\n            / gfp.out_samplerate;\n        var headerSize = (gfc.sideinfo_len + LAMEHEADERSIZE);\n        gfc.VBR_seek_table.TotalFrameSize = totalFrameSize;\n        if (totalFrameSize < headerSize || totalFrameSize > MAXFRAMESIZE) {\n            /* disable tag, it wont fit */\n            gfp.bWriteVbrTag = false;\n            return;\n        }\n\n        gfc.VBR_seek_table.nVbrNumFrames = 0;\n        gfc.VBR_seek_table.nBytesWritten = 0;\n        gfc.VBR_seek_table.sum = 0;\n\n        gfc.VBR_seek_table.seen = 0;\n        gfc.VBR_seek_table.want = 1;\n        gfc.VBR_seek_table.pos = 0;\n\n        if (gfc.VBR_seek_table.bag == null) {\n            gfc.VBR_seek_table.bag = new int[400];\n            gfc.VBR_seek_table.size = 400;\n        }\n\n        // write dummy VBR tag of all 0's into bitstream\n        var buffer = new_byte$22(MAXFRAMESIZE);\n\n        setLameTagFrameHeader(gfp, buffer);\n        var n = gfc.VBR_seek_table.TotalFrameSize;\n        for (var i = 0; i < n; ++i) {\n            bs.add_dummy_byte(gfp, buffer[i] & 0xff, 1);\n        }\n    };\n\n    /**\n     * Fast CRC-16 computation (uses table crc16Lookup).\n     *\n     * @param value\n     * @param crc\n     * @return\n     */\n    function crcUpdateLookup(value, crc) {\n        var tmp = crc ^ value;\n        crc = (crc >> 8) ^ crc16Lookup[tmp & 0xff];\n        return crc;\n    }\n\n    this.updateMusicCRC = function (crc, buffer, bufferPos, size) {\n        for (var i = 0; i < size; ++i)\n            crc[0] = crcUpdateLookup(buffer[bufferPos + i], crc[0]);\n    };\n\n    /**\n     * Write LAME info: mini version + info on various switches used (Jonathan\n     * Dee 2001/08/31).\n     *\n     * @param gfp\n     *            global flags\n     * @param musicLength\n     *            music length\n     * @param streamBuffer\n     *            pointer to output buffer\n     * @param streamBufferPos\n     *            offset into the output buffer\n     * @param crc\n     *            computation of CRC-16 of Lame Tag so far (starting at frame\n     *            sync)\n     * @return number of bytes written to the stream\n     */\n    function putLameVBR(gfp, musicLength, streamBuffer, streamBufferPos, crc) {\n        var gfc = gfp.internal_flags;\n        var bytesWritten = 0;\n\n        /* encoder delay */\n        var encDelay = gfp.encoder_delay;\n        /* encoder padding */\n        var encPadding = gfp.encoder_padding;\n\n        /* recall: gfp.VBR_q is for example set by the switch -V */\n        /* gfp.quality by -q, -h, -f, etc */\n        var quality = (100 - 10 * gfp.VBR_q - gfp.quality);\n\n        var version = v.getLameVeryShortVersion();\n        var vbr;\n        var revision = 0x00;\n        var revMethod;\n        // numbering different in vbr_mode vs. Lame tag\n        var vbrTypeTranslator = [1, 5, 3, 2, 4, 0, 3];\n        var lowpass = 0 | (((gfp.lowpassfreq / 100.0) + .5) > 255 ? 255\n                : (gfp.lowpassfreq / 100.0) + .5);\n        var peakSignalAmplitude = 0;\n        var radioReplayGain = 0;\n        var audiophileReplayGain = 0;\n        var noiseShaping = gfp.internal_flags.noise_shaping;\n        var stereoMode = 0;\n        var nonOptimal = 0;\n        var sourceFreq = 0;\n        var misc = 0;\n        var musicCRC = 0;\n\n        // psy model type: Gpsycho or NsPsytune\n        var expNPsyTune = (gfp.exp_nspsytune & 1) != 0;\n        var safeJoint = (gfp.exp_nspsytune & 2) != 0;\n        var noGapMore = false;\n        var noGapPrevious = false;\n        var noGapCount = gfp.internal_flags.nogap_total;\n        var noGapCurr = gfp.internal_flags.nogap_current;\n\n        // 4 bits\n        var athType = gfp.ATHtype;\n        var flags = 0;\n\n        // vbr modes\n        var abrBitrate;\n        switch (gfp.VBR) {\n            case vbr_abr:\n                abrBitrate = gfp.VBR_mean_bitrate_kbps;\n                break;\n            case vbr_off:\n                abrBitrate = gfp.brate;\n                break;\n            default:\n                abrBitrate = gfp.VBR_min_bitrate_kbps;\n        }\n\n        // revision and vbr method\n        if (gfp.VBR.ordinal() < vbrTypeTranslator.length)\n            vbr = vbrTypeTranslator[gfp.VBR.ordinal()];\n        else\n            vbr = 0x00; // unknown\n\n        revMethod = 0x10 * revision + vbr;\n\n        // ReplayGain\n        if (gfc.findReplayGain) {\n            if (gfc.RadioGain > 0x1FE)\n                gfc.RadioGain = 0x1FE;\n            if (gfc.RadioGain < -0x1FE)\n                gfc.RadioGain = -0x1FE;\n\n            // set name code\n            radioReplayGain = 0x2000;\n            // set originator code to `determined automatically'\n            radioReplayGain |= 0xC00;\n\n            if (gfc.RadioGain >= 0) {\n                // set gain adjustment\n                radioReplayGain |= gfc.RadioGain;\n            } else {\n                // set the sign bit\n                radioReplayGain |= 0x200;\n                // set gain adjustment\n                radioReplayGain |= -gfc.RadioGain;\n            }\n        }\n\n        // peak sample\n        if (gfc.findPeakSample)\n            peakSignalAmplitude = Math\n                .abs(0 | ((( gfc.PeakSample) / 32767.0) * Math.pow(2, 23) + .5));\n\n        // nogap\n        if (noGapCount != -1) {\n            if (noGapCurr > 0)\n                noGapPrevious = true;\n\n            if (noGapCurr < noGapCount - 1)\n                noGapMore = true;\n        }\n\n        // flags\n        flags = athType + ((expNPsyTune ? 1 : 0) << 4)\n            + ((safeJoint ? 1 : 0) << 5) + ((noGapMore ? 1 : 0) << 6)\n            + ((noGapPrevious ? 1 : 0) << 7);\n\n        if (quality < 0)\n            quality = 0;\n\n        // stereo mode field (Intensity stereo is not implemented)\n        switch (gfp.mode) {\n            case MONO:\n                stereoMode = 0;\n                break;\n            case STEREO:\n                stereoMode = 1;\n                break;\n            case DUAL_CHANNEL:\n                stereoMode = 2;\n                break;\n            case JOINT_STEREO:\n                if (gfp.force_ms)\n                    stereoMode = 4;\n                else\n                    stereoMode = 3;\n                break;\n            case NOT_SET:\n            //$FALL-THROUGH$\n            default:\n                stereoMode = 7;\n                break;\n        }\n\n        if (gfp.in_samplerate <= 32000)\n            sourceFreq = 0x00;\n        else if (gfp.in_samplerate == 48000)\n            sourceFreq = 0x02;\n        else if (gfp.in_samplerate > 48000)\n            sourceFreq = 0x03;\n        else {\n            // default is 44100Hz\n            sourceFreq = 0x01;\n        }\n\n        // Check if the user overrided the default LAME behavior with some\n        // nasty options\n        if (gfp.short_blocks == ShortBlock$22.short_block_forced\n            || gfp.short_blocks == ShortBlock$22.short_block_dispensed\n            || ((gfp.lowpassfreq == -1) && (gfp.highpassfreq == -1)) || /* \"-k\" */\n            (gfp.scale_left < gfp.scale_right)\n            || (gfp.scale_left > gfp.scale_right)\n            || (gfp.disable_reservoir && gfp.brate < 320) || gfp.noATH\n            || gfp.ATHonly || (athType == 0) || gfp.in_samplerate <= 32000)\n            nonOptimal = 1;\n\n        misc = noiseShaping + (stereoMode << 2) + (nonOptimal << 5)\n            + (sourceFreq << 6);\n\n        musicCRC = gfc.nMusicCRC;\n\n        // Write all this information into the stream\n\n        createInteger(streamBuffer, streamBufferPos + bytesWritten, quality);\n        bytesWritten += 4;\n\n        for (var j = 0; j < 9; j++) {\n            streamBuffer[streamBufferPos + bytesWritten + j] = 0xff & version .charAt(j);\n        }\n        bytesWritten += 9;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & revMethod;\n        bytesWritten++;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & lowpass;\n        bytesWritten++;\n\n        createInteger(streamBuffer, streamBufferPos + bytesWritten,\n            peakSignalAmplitude);\n        bytesWritten += 4;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten,\n            radioReplayGain);\n        bytesWritten += 2;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten,\n            audiophileReplayGain);\n        bytesWritten += 2;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & flags;\n        bytesWritten++;\n\n        if (abrBitrate >= 255)\n            streamBuffer[streamBufferPos + bytesWritten] = 0xFF;\n        else\n            streamBuffer[streamBufferPos + bytesWritten] = 0xff & abrBitrate;\n        bytesWritten++;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & (encDelay >> 4);\n        streamBuffer[streamBufferPos + bytesWritten + 1] = 0xff & ((encDelay << 4) + (encPadding >> 8));\n        streamBuffer[streamBufferPos + bytesWritten + 2] = 0xff & encPadding;\n\n        bytesWritten += 3;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & misc;\n        bytesWritten++;\n\n        // unused in rev0\n        streamBuffer[streamBufferPos + bytesWritten++] = 0;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten, gfp.preset);\n        bytesWritten += 2;\n\n        createInteger(streamBuffer, streamBufferPos + bytesWritten, musicLength);\n        bytesWritten += 4;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten, musicCRC);\n        bytesWritten += 2;\n\n        // Calculate tag CRC.... must be done here, since it includes previous\n        // information\n\n        for (var i = 0; i < bytesWritten; i++)\n            crc = crcUpdateLookup(streamBuffer[streamBufferPos + i], crc);\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten, crc);\n        bytesWritten += 2;\n\n        return bytesWritten;\n    }\n\n    function skipId3v2(fpStream) {\n        // seek to the beginning of the stream\n        fpStream.seek(0);\n        // read 10 bytes in case there's an ID3 version 2 header here\n        var id3v2Header = new_byte$22(10);\n        fpStream.readFully(id3v2Header);\n        /* does the stream begin with the ID3 version 2 file identifier? */\n        var id3v2TagSize;\n        if (!new String(id3v2Header, \"ISO-8859-1\").startsWith(\"ID3\")) {\n            /*\n             * the tag size (minus the 10-byte header) is encoded into four\n             * bytes where the most significant bit is clear in each byte\n             */\n            id3v2TagSize = (((id3v2Header[6] & 0x7f) << 21)\n                | ((id3v2Header[7] & 0x7f) << 14)\n                | ((id3v2Header[8] & 0x7f) << 7) | (id3v2Header[9] & 0x7f))\n                + id3v2Header.length;\n        } else {\n            /* no ID3 version 2 tag in this stream */\n            id3v2TagSize = 0;\n        }\n        return id3v2TagSize;\n    }\n\n    this.getLameTagFrame = function (gfp, buffer) {\n        var gfc = gfp.internal_flags;\n\n        if (!gfp.bWriteVbrTag) {\n            return 0;\n        }\n        if (gfc.Class_ID != Lame.LAME_ID) {\n            return 0;\n        }\n        if (gfc.VBR_seek_table.pos <= 0) {\n            return 0;\n        }\n        if (buffer.length < gfc.VBR_seek_table.TotalFrameSize) {\n            return gfc.VBR_seek_table.TotalFrameSize;\n        }\n\n        Arrays$22.fill(buffer, 0, gfc.VBR_seek_table.TotalFrameSize, 0);\n\n        // 4 bytes frame header\n        setLameTagFrameHeader(gfp, buffer);\n\n        // Create TOC entries\n        var toc = new_byte$22(NUMTOCENTRIES);\n\n        if (gfp.free_format) {\n            for (var i = 1; i < NUMTOCENTRIES; ++i)\n                toc[i] = 0xff & (255 * i / 100);\n        } else {\n            xingSeekTable(gfc.VBR_seek_table, toc);\n        }\n\n        // Start writing the tag after the zero frame\n        var streamIndex = gfc.sideinfo_len;\n        /**\n         * Note: Xing header specifies that Xing data goes in the ancillary data\n         * with NO ERROR PROTECTION. If error protecton in enabled, the Xing\n         * data still starts at the same offset, and now it is in sideinfo data\n         * block, and thus will not decode correctly by non-Xing tag aware\n         * players\n         */\n        if (gfp.error_protection)\n            streamIndex -= 2;\n\n        // Put Vbr tag\n        if (gfp.VBR == VbrMode$22.vbr_off) {\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(0);\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(1);\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(2);\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(3);\n\n        } else {\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(0);\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(1);\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(2);\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(3);\n        }\n\n        // Put header flags\n        createInteger(buffer, streamIndex, FRAMES_FLAG + BYTES_FLAG + TOC_FLAG\n            + VBR_SCALE_FLAG);\n        streamIndex += 4;\n\n        // Put Total Number of frames\n        createInteger(buffer, streamIndex, gfc.VBR_seek_table.nVbrNumFrames);\n        streamIndex += 4;\n\n        // Put total audio stream size, including Xing/LAME Header\n        var streamSize = (gfc.VBR_seek_table.nBytesWritten + gfc.VBR_seek_table.TotalFrameSize);\n        createInteger(buffer, streamIndex, 0 | streamSize);\n        streamIndex += 4;\n\n        /* Put TOC */\n        System$22.arraycopy(toc, 0, buffer, streamIndex, toc.length);\n        streamIndex += toc.length;\n\n        if (gfp.error_protection) {\n            // (jo) error_protection: add crc16 information to header\n            bs.CRC_writeheader(gfc, buffer);\n        }\n\n        // work out CRC so far: initially crc = 0\n        var crc = 0x00;\n        for (var i = 0; i < streamIndex; i++)\n            crc = crcUpdateLookup(buffer[i], crc);\n        // Put LAME VBR info\n        streamIndex += putLameVBR(gfp, streamSize, buffer, streamIndex, crc);\n\n        return gfc.VBR_seek_table.TotalFrameSize;\n    };\n\n    /**\n     * Write final VBR tag to the file.\n     *\n     * @param gfp\n     *            global flags\n     * @param stream\n     *            stream to add the VBR tag to\n     * @return 0 (OK), -1 else\n     * @throws IOException\n     *             I/O error\n     */\n    this.putVbrTag = function (gfp, stream) {\n        var gfc = gfp.internal_flags;\n\n        if (gfc.VBR_seek_table.pos <= 0)\n            return -1;\n\n        // Seek to end of file\n        stream.seek(stream.length());\n\n        // Get file size, abort if file has zero length.\n        if (stream.length() == 0)\n            return -1;\n\n        // The VBR tag may NOT be located at the beginning of the stream. If an\n        // ID3 version 2 tag was added, then it must be skipped to write the VBR\n        // tag data.\n        var id3v2TagSize = skipId3v2(stream);\n\n        // Seek to the beginning of the stream\n        stream.seek(id3v2TagSize);\n\n        var buffer = new_byte$22(MAXFRAMESIZE);\n        var bytes = getLameTagFrame(gfp, buffer);\n        if (bytes > buffer.length) {\n            return -1;\n        }\n\n        if (bytes < 1) {\n            return 0;\n        }\n\n        // Put it all to disk again\n        stream.write(buffer, 0, bytes);\n        // success\n        return 0;\n    };\n\n}\n\nvar VBRTag_1 = VBRTag;\n\nvar new_byte = common.new_byte;\nvar assert = common.assert;\n\nLame = Lame_1;\nPresets = Presets_1;\nGainAnalysis = GainAnalysis_1;\nQuantizePVT = QuantizePVT_1;\nQuantize = Quantize_1;\nTakehiro = Takehiro_1;\nReservoir = Reservoir_1;\nMPEGMode = MPEGMode_1;\nBitStream = BitStream_1;\n\n\n\n\nfunction GetAudio() {\n    var parse;\n    var mpg;\n\n    this.setModules = function (parse2, mpg2) {\n        parse = parse2;\n        mpg = mpg2;\n    };\n}\n\n\nfunction Parse() {\n    var ver;\n    var id3;\n    var pre;\n\n    this.setModules = function (ver2, id32, pre2) {\n        ver = ver2;\n        id3 = id32;\n        pre = pre2;\n    };\n}\n\nfunction MPGLib() {\n}\n\nfunction ID3Tag() {\n    var bits;\n    var ver;\n\n    this.setModules = function (_bits, _ver) {\n        bits = _bits;\n        ver = _ver;\n    };\n}\n\nfunction Mp3Encoder(channels, samplerate, kbps) {\n    if (arguments.length != 3) {\n        console.error('WARN: Mp3Encoder(channels, samplerate, kbps) not specified');\n        channels = 1;\n        samplerate = 44100;\n        kbps = 128;\n    }\n    var lame = new Lame();\n    var gaud = new GetAudio();\n    var ga = new GainAnalysis();\n    var bs = new BitStream();\n    var p = new Presets();\n    var qupvt = new QuantizePVT();\n    var qu = new Quantize();\n    var vbr = new VBRTag_1();\n    var ver = new Version_1();\n    var id3 = new ID3Tag();\n    var rv = new Reservoir();\n    var tak = new Takehiro();\n    var parse = new Parse();\n    var mpg = new MPGLib();\n\n    lame.setModules(ga, bs, p, qupvt, qu, vbr, ver, id3, mpg);\n    bs.setModules(ga, mpg, ver, vbr);\n    id3.setModules(bs, ver);\n    p.setModules(lame);\n    qu.setModules(bs, rv, qupvt, tak);\n    qupvt.setModules(tak, rv, lame.enc.psy);\n    rv.setModules(bs);\n    tak.setModules(qupvt);\n    vbr.setModules(lame, bs, ver);\n    gaud.setModules(parse, mpg);\n    parse.setModules(ver, id3, p);\n\n    var gfp = lame.lame_init();\n\n    gfp.num_channels = channels;\n    gfp.in_samplerate = samplerate;\n    gfp.brate = kbps;\n    gfp.mode = MPEGMode.STEREO;\n    gfp.quality = 3;\n    gfp.bWriteVbrTag = false;\n    gfp.disable_reservoir = true;\n    gfp.write_id3tag_automatic = false;\n\n    var retcode = lame.lame_init_params(gfp);\n    assert(0 == retcode);\n    var maxSamples = 1152;\n    var mp3buf_size = 0 | (1.25 * maxSamples + 7200);\n    var mp3buf = new_byte(mp3buf_size);\n\n    this.encodeBuffer = function (left, right) {\n        if (channels == 1) {\n            right = left;\n        }\n        assert(left.length == right.length);\n        if (left.length > maxSamples) {\n            maxSamples = left.length;\n            mp3buf_size = 0 | (1.25 * maxSamples + 7200);\n            mp3buf = new_byte(mp3buf_size);\n        }\n\n        var _sz = lame.lame_encode_buffer(gfp, left, right, left.length, mp3buf, 0, mp3buf_size);\n        return new Int8Array(mp3buf.subarray(0, _sz));\n    };\n\n    this.flush = function () {\n        var _sz = lame.lame_encode_flush(gfp, mp3buf, 0, mp3buf_size);\n        return new Int8Array(mp3buf.subarray(0, _sz));\n    };\n}\n\nfunction WavHeader() {\n    this.dataOffset = 0;\n    this.dataLen = 0;\n    this.channels = 0;\n    this.sampleRate = 0;\n}\n\nfunction fourccToInt(fourcc) {\n    return fourcc.charCodeAt(0) << 24 | fourcc.charCodeAt(1) << 16 | fourcc.charCodeAt(2) << 8 | fourcc.charCodeAt(3);\n}\n\nWavHeader.RIFF = fourccToInt(\"RIFF\");\nWavHeader.WAVE = fourccToInt(\"WAVE\");\nWavHeader.fmt_ = fourccToInt(\"fmt \");\nWavHeader.data = fourccToInt(\"data\");\n\nWavHeader.readHeader = function (dataView) {\n    var w = new WavHeader();\n\n    var header = dataView.getUint32(0, false);\n    if (WavHeader.RIFF != header) {\n        return;\n    }\n    var fileLen = dataView.getUint32(4, true);\n    if (WavHeader.WAVE != dataView.getUint32(8, false)) {\n        return;\n    }\n    if (WavHeader.fmt_ != dataView.getUint32(12, false)) {\n        return;\n    }\n    var fmtLen = dataView.getUint32(16, true);\n    var pos = 16 + 4;\n    switch (fmtLen) {\n        case 16:\n        case 18:\n            w.channels = dataView.getUint16(pos + 2, true);\n            w.sampleRate = dataView.getUint32(pos + 4, true);\n            break;\n        default:\n            throw 'extended fmt chunk not implemented';\n    }\n    pos += fmtLen;\n    var data = WavHeader.data;\n    var len = 0;\n    while (data != header) {\n        header = dataView.getUint32(pos, false);\n        len = dataView.getUint32(pos + 4, true);\n        if (data == header) {\n            break;\n        }\n        pos += (len + 8);\n    }\n    w.dataLen = len;\n    w.dataOffset = pos + 8;\n    return w;\n};\n\nvar Mp3Encoder_1 = Mp3Encoder;\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar Encoder = function () {\n  function Encoder(config) {\n    classCallCheck(this, Encoder);\n\n    this.config = {\n      sampleRate: 44100,\n      bitRate: 128\n    };\n\n    Object.assign(this.config, config);\n\n    this.mp3Encoder = new Mp3Encoder_1(1, this.config.sampleRate, this.config.bitRate);\n\n    // Audio is processed by frames of 1152 samples per audio channel\n    // http://lame.sourceforge.net/tech-FAQ.txt\n    this.maxSamples = 1152;\n\n    this.samplesMono = null;\n    this.clearBuffer();\n  }\n\n  /**\n   * Clear active buffer\n   */\n\n\n  createClass(Encoder, [{\n    key: 'clearBuffer',\n    value: function clearBuffer() {\n      this.dataBuffer = [];\n    }\n\n    /**\n     * Append new audio buffer to current active buffer\n     * @param {Buffer} buffer\n     */\n\n  }, {\n    key: 'appendToBuffer',\n    value: function appendToBuffer(buffer) {\n      this.dataBuffer.push(new Int8Array(buffer));\n    }\n\n    /**\n     * Float current data to 16 bits PCM\n     * @param {Float32Array} input\n     * @param {Int16Array} output\n     */\n\n  }, {\n    key: 'floatTo16BitPCM',\n    value: function floatTo16BitPCM(input, output) {\n      for (var i = 0; i < input.length; i++) {\n        var s = Math.max(-1, Math.min(1, input[i]));\n        output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\n      }\n    }\n\n    /**\n     * Convert buffer to proper format\n     * @param {Array} arrayBuffer\n     */\n\n  }, {\n    key: 'convertBuffer',\n    value: function convertBuffer(arrayBuffer) {\n      var data = new Float32Array(arrayBuffer);\n      var out = new Int16Array(arrayBuffer.length);\n      this.floatTo16BitPCM(data, out);\n\n      return out;\n    }\n\n    /**\n     * Encode and append current buffer to dataBuffer\n     * @param {Array} arrayBuffer\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode(arrayBuffer) {\n      this.samplesMono = this.convertBuffer(arrayBuffer);\n      var remaining = this.samplesMono.length;\n\n      for (var i = 0; remaining >= 0; i += this.maxSamples) {\n        var left = this.samplesMono.subarray(i, i + this.maxSamples);\n        var mp3buffer = this.mp3Encoder.encodeBuffer(left);\n        this.appendToBuffer(mp3buffer);\n        remaining -= this.maxSamples;\n      }\n    }\n\n    /**\n     * Return full dataBuffer\n     */\n\n  }, {\n    key: 'finish',\n    value: function finish() {\n      this.appendToBuffer(this.mp3Encoder.flush());\n\n      return this.dataBuffer;\n    }\n  }]);\n  return Encoder;\n}();\n\nvar MicRecorder = function () {\n  function MicRecorder(config) {\n    classCallCheck(this, MicRecorder);\n\n    this.config = {\n      // 128 or 160 kbit/s – mid-range bitrate quality\n      bitRate: 128,\n\n      // There is a known issue with some macOS machines, where the recording\n      // will sometimes have a loud 'pop' or 'pop-click' sound. This flag\n      // prevents getting audio from the microphone a few milliseconds after\n      // the begining of the recording. It also helps to remove the mouse\n      // \"click\" sound from the output mp3 file.\n      startRecordingAt: 300,\n      deviceId: null\n    };\n\n    this.activeStream = null;\n    this.context = null;\n    this.microphone = null;\n    this.processor = null;\n    this.startTime = 0;\n\n    Object.assign(this.config, config);\n  }\n\n  /**\n   * Starts to listen for the microphone sound\n   * @param {MediaStream} stream\n   */\n\n\n  createClass(MicRecorder, [{\n    key: 'addMicrophoneListener',\n    value: function addMicrophoneListener(stream) {\n      var _this = this;\n\n      this.activeStream = stream;\n\n      // This prevents the weird noise once you start listening to the microphone\n      this.timerToStart = setTimeout(function () {\n        delete _this.timerToStart;\n      }, this.config.startRecordingAt);\n\n      // Set up Web Audio API to process data from the media stream (microphone).\n      this.microphone = this.context.createMediaStreamSource(stream);\n\n      // Settings a bufferSize of 0 instructs the browser to choose the best bufferSize\n      this.processor = this.context.createScriptProcessor(0, 1, 1);\n\n      // Add all buffers from LAME into an array.\n      this.processor.onaudioprocess = function (event) {\n        if (_this.timerToStart) {\n          return;\n        }\n\n        // Send microphone data to LAME for MP3 encoding while recording.\n        _this.lameEncoder.encode(event.inputBuffer.getChannelData(0));\n      };\n\n      // Begin retrieving microphone data.\n      this.microphone.connect(this.processor);\n      this.processor.connect(this.context.destination);\n    }\n  }, {\n    key: 'stop',\n\n\n    /**\n     * Disconnect microphone, processor and remove activeStream\n     */\n    value: function stop() {\n      if (this.processor && this.microphone) {\n        // Clean up the Web Audio API resources.\n        this.microphone.disconnect();\n        this.processor.disconnect();\n\n        // If all references using this.context are destroyed, context is closed\n        // automatically. DOMException is fired when trying to close again\n        if (this.context && this.context.state !== 'closed') {\n          this.context.close();\n        }\n\n        this.processor.onaudioprocess = null;\n\n        // Stop all audio tracks. Also, removes recording icon from chrome tab\n        this.activeStream.getAudioTracks().forEach(function (track) {\n          return track.stop();\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: 'start',\n\n\n    /**\n     * Requests access to the microphone and start recording\n     * @return Promise\n     */\n    value: function start() {\n      var _this2 = this;\n\n      var AudioContext = window.AudioContext || window.webkitAudioContext;\n      this.context = new AudioContext();\n      this.config.sampleRate = this.context.sampleRate;\n      this.lameEncoder = new Encoder(this.config);\n\n      var audio = this.config.deviceId ? { deviceId: { exact: this.config.deviceId } } : true;\n\n      return new Promise(function (resolve, reject) {\n        navigator.mediaDevices.getUserMedia({ audio: audio }).then(function (stream) {\n          _this2.addMicrophoneListener(stream);\n          resolve(stream);\n        }).catch(function (err) {\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: 'getMp3',\n\n\n    /**\n     * Return Mp3 Buffer and Blob with type mp3\n     * @return {Promise}\n     */\n    value: function getMp3() {\n      var _this3 = this;\n\n      var finalBuffer = this.lameEncoder.finish();\n\n      return new Promise(function (resolve, reject) {\n        if (finalBuffer.length === 0) {\n          reject(new Error('No buffer to send'));\n        } else {\n          resolve([finalBuffer, new Blob(finalBuffer, { type: 'audio/mp3' })]);\n          _this3.lameEncoder.clearBuffer();\n        }\n      });\n    }\n  }]);\n  return MicRecorder;\n}();\n\nreturn MicRecorder;\n\n})));\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWljLXJlY29yZGVyLXRvLW1wMy9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLENBQ2dDO0FBQ2pDLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0EsTUFBTTtBQUNOLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUMsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0MsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxjQUFjO0FBQ2QseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLGtCQUFrQjs7QUFFM0MsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0MsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0MsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLFFBQVE7QUFDaEM7O0FBRUE7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3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O0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3QkFBd0I7QUFDckQ7O0FBRUE7QUFDQTs7QUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RCwrQ0FBK0MsYUFBYTtBQUM1RCxrREFBa0QsYUFBYTtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFLDZEQUE2RCxhQUFhO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRCwrQ0FBK0MsYUFBYTtBQUM1RDs7QUFFQSx1RUFBdUU7QUFDdkUsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFFBQVE7QUFDN0IseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixlQUFlO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDOztBQUVBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBOztBQUVBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyx3QkFBd0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QywrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixlQUFlO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMENBQTBDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLFFBQVE7QUFDakMsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQyw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0Isd0NBQXdDO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdDQUF3QztBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EOztBQUVBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7O0FBRUEsd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixRQUFRO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7O0FBRUEsbURBQW1ELDBCQUEwQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsdUJBQXVCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLGtCQUFrQjtBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxZQUFZO0FBQzNCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLFlBQVksZ0NBQWdDOztBQUV2RjtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysd0RBQXdELG1CQUFtQjtBQUMzRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21pYy1yZWNvcmRlci10by1tcDMvZGlzdC9pbmRleC5qcz82YmQ2Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5NaWNSZWNvcmRlciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7XG5cbmZ1bmN0aW9uIG5ld19ieXRlJDEoY291bnQpIHtcbiAgICByZXR1cm4gbmV3IEludDhBcnJheShjb3VudCk7XG59XG5cbmZ1bmN0aW9uIG5ld19zaG9ydChjb3VudCkge1xuICAgIHJldHVybiBuZXcgSW50MTZBcnJheShjb3VudCk7XG59XG5cbmZ1bmN0aW9uIG5ld19pbnQkMShjb3VudCkge1xuICAgIHJldHVybiBuZXcgSW50MzJBcnJheShjb3VudCk7XG59XG5cbmZ1bmN0aW9uIG5ld19mbG9hdCQxKGNvdW50KSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoY291bnQpO1xufVxuXG5mdW5jdGlvbiBuZXdfZG91YmxlJDEoY291bnQpIHtcbiAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShjb3VudCk7XG59XG5cbmZ1bmN0aW9uIG5ld19mbG9hdF9uJDEoYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBuZXdfZmxvYXQkMShhcmdzWzBdKTtcbiAgICB9XG4gICAgdmFyIHN6ID0gYXJnc1swXTtcbiAgICBhcmdzID0gYXJncy5zbGljZSgxKTtcbiAgICB2YXIgQSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3o7IGkrKykge1xuICAgICAgICBBLnB1c2gobmV3X2Zsb2F0X24kMShhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxuZnVuY3Rpb24gbmV3X2ludF9uJDEoYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBuZXdfaW50JDEoYXJnc1swXSk7XG4gICAgfVxuICAgIHZhciBzeiA9IGFyZ3NbMF07XG4gICAgYXJncyA9IGFyZ3Muc2xpY2UoMSk7XG4gICAgdmFyIEEgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN6OyBpKyspIHtcbiAgICAgICAgQS5wdXNoKG5ld19pbnRfbiQxKGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIEE7XG59XG5cbmZ1bmN0aW9uIG5ld19zaG9ydF9uKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXR1cm4gbmV3X3Nob3J0KGFyZ3NbMF0pO1xuICAgIH1cbiAgICB2YXIgc3ogPSBhcmdzWzBdO1xuICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xuICAgIHZhciBBID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzejsgaSsrKSB7XG4gICAgICAgIEEucHVzaChuZXdfc2hvcnRfbihhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxuXG5mdW5jdGlvbiBuZXdfYXJyYXlfbiQxKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5KGFyZ3NbMF0pO1xuICAgIH1cbiAgICB2YXIgc3ogPSBhcmdzWzBdO1xuICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xuICAgIHZhciBBID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzejsgaSsrKSB7XG4gICAgICAgIEEucHVzaChuZXdfYXJyYXlfbiQxKGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIEE7XG59XG5cblxudmFyIEFycmF5cyQxID0ge307XG5cbkFycmF5cyQxLmZpbGwgPSBmdW5jdGlvbiAoYSwgZnJvbUluZGV4LCB0b0luZGV4LCB2YWwpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYVtpXSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXg7IGkgPCB0b0luZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGFbaV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgU3lzdGVtJDEgPSB7fTtcblxuU3lzdGVtJDEuYXJyYXljb3B5ID0gZnVuY3Rpb24gKHNyYywgc3JjUG9zLCBkZXN0LCBkZXN0UG9zLCBsZW5ndGgpIHtcbiAgICB2YXIgc3JjRW5kID0gc3JjUG9zICsgbGVuZ3RoO1xuICAgIHdoaWxlIChzcmNQb3MgPCBzcmNFbmQpXG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG59O1xuXG5cbnZhciBVdGlsJDEgPSB7fTtcblV0aWwkMS5TUVJUMiA9IDEuNDE0MjEzNTYyMzczMDk1MDQ4ODA7XG5VdGlsJDEuRkFTVF9MT0cxMCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nMTAoeCk7XG59O1xuXG5VdGlsJDEuRkFTVF9MT0cxMF9YID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gTWF0aC5sb2cxMCh4KSAqIHk7XG59O1xuXG5mdW5jdGlvbiBTaG9ydEJsb2NrJDEob3JkaW5hbCkge1xuICAgIHRoaXMub3JkaW5hbCA9IG9yZGluYWw7XG59XG4vKipcbiAqIExBTUUgbWF5IHVzZSB0aGVtLCBldmVuIGRpZmZlcmVudCBibG9jayB0eXBlcyBmb3IgTC9SLlxuICovXG5TaG9ydEJsb2NrJDEuc2hvcnRfYmxvY2tfYWxsb3dlZCA9IG5ldyBTaG9ydEJsb2NrJDEoMCk7XG4vKipcbiAqIExBTUUgbWF5IHVzZSB0aGVtLCBidXQgYWx3YXlzIHNhbWUgYmxvY2sgdHlwZXMgaW4gTC9SLlxuICovXG5TaG9ydEJsb2NrJDEuc2hvcnRfYmxvY2tfY291cGxlZCA9IG5ldyBTaG9ydEJsb2NrJDEoMSk7XG4vKipcbiAqIExBTUUgd2lsbCBub3QgdXNlIHNob3J0IGJsb2NrcywgbG9uZyBibG9ja3Mgb25seS5cbiAqL1xuU2hvcnRCbG9jayQxLnNob3J0X2Jsb2NrX2Rpc3BlbnNlZCA9IG5ldyBTaG9ydEJsb2NrJDEoMik7XG4vKipcbiAqIExBTUUgd2lsbCBub3QgdXNlIGxvbmcgYmxvY2tzLCBzaG9ydCBibG9ja3Mgb25seS5cbiAqL1xuU2hvcnRCbG9jayQxLnNob3J0X2Jsb2NrX2ZvcmNlZCA9IG5ldyBTaG9ydEJsb2NrJDEoMyk7XG5cbnZhciBGbG9hdCQxID0ge307XG5GbG9hdCQxLk1BWF9WQUxVRSA9IDMuNDAyODIzNWUrMzg7XG5cbmZ1bmN0aW9uIFZick1vZGUkMShvcmRpbmFsKSB7XG4gICAgdGhpcy5vcmRpbmFsID0gb3JkaW5hbDtcbn1cblZick1vZGUkMS52YnJfb2ZmID0gbmV3IFZick1vZGUkMSgwKTtcblZick1vZGUkMS52YnJfbXQgPSBuZXcgVmJyTW9kZSQxKDEpO1xuVmJyTW9kZSQxLnZicl9yaCA9IG5ldyBWYnJNb2RlJDEoMik7XG5WYnJNb2RlJDEudmJyX2FiciA9IG5ldyBWYnJNb2RlJDEoMyk7XG5WYnJNb2RlJDEudmJyX210cmggPSBuZXcgVmJyTW9kZSQxKDQpO1xuVmJyTW9kZSQxLnZicl9kZWZhdWx0ID0gVmJyTW9kZSQxLnZicl9tdHJoO1xuXG52YXIgYXNzZXJ0JDEgPSBmdW5jdGlvbiAoeCkge1xuICAgIC8vY29uc29sZS5hc3NlcnQoeCk7XG59O1xuXG52YXIgY29tbW9uID0ge1xuICAgIFwiU3lzdGVtXCI6IFN5c3RlbSQxLFxuICAgIFwiVmJyTW9kZVwiOiBWYnJNb2RlJDEsXG4gICAgXCJGbG9hdFwiOiBGbG9hdCQxLFxuICAgIFwiU2hvcnRCbG9ja1wiOiBTaG9ydEJsb2NrJDEsXG4gICAgXCJVdGlsXCI6IFV0aWwkMSxcbiAgICBcIkFycmF5c1wiOiBBcnJheXMkMSxcbiAgICBcIm5ld19hcnJheV9uXCI6IG5ld19hcnJheV9uJDEsXG4gICAgXCJuZXdfYnl0ZVwiOiBuZXdfYnl0ZSQxLFxuICAgIFwibmV3X2RvdWJsZVwiOiBuZXdfZG91YmxlJDEsXG4gICAgXCJuZXdfZmxvYXRcIjogbmV3X2Zsb2F0JDEsXG4gICAgXCJuZXdfZmxvYXRfblwiOiBuZXdfZmxvYXRfbiQxLFxuICAgIFwibmV3X2ludFwiOiBuZXdfaW50JDEsXG4gICAgXCJuZXdfaW50X25cIjogbmV3X2ludF9uJDEsXG4gICAgXCJuZXdfc2hvcnRcIjogbmV3X3Nob3J0LFxuICAgIFwibmV3X3Nob3J0X25cIjogbmV3X3Nob3J0X24sXG4gICAgXCJhc3NlcnRcIjogYXNzZXJ0JDFcbn07XG5cbi8qXG4gKiAgICAgIE1QMyB3aW5kb3cgc3ViYmFuZCAtPiBzdWJiYW5kIGZpbHRlcmluZyAtPiBtZGN0IHJvdXRpbmVcbiAqXG4gKiAgICAgIENvcHlyaWdodCAoYykgMTk5OS0yMDAwIFRha2VoaXJvIFRvbWluYWdhXG4gKlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAqIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlclxuICogdmVyc2lvbiAyIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gKiBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGVcbiAqIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLFxuICogQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4gKi9cbi8qXG4gKiAgICAgICAgIFNwZWNpYWwgVGhhbmtzIHRvIFBhdHJpY2sgRGUgU21ldCBmb3IgeW91ciBhZHZpY2VzLlxuICovXG5cbi8qICRJZDogTmV3TURDVC5qYXZhLHYgMS4xMSAyMDExLzA1LzI0IDIwOjQ4OjA2IGtlbmNoaXMgRXhwICQgKi9cblxuLy9wYWNrYWdlIG1wMztcblxuLy9pbXBvcnQgamF2YS51dGlsLkFycmF5cztcblxudmFyIFN5c3RlbSQ2ID0gY29tbW9uLlN5c3RlbTtcbnZhciBVdGlsJDYgPSBjb21tb24uVXRpbDtcbnZhciBBcnJheXMkNiA9IGNvbW1vbi5BcnJheXM7XG52YXIgbmV3X2Zsb2F0JDYgPSBjb21tb24ubmV3X2Zsb2F0O1xuZnVuY3Rpb24gTmV3TURDVCgpIHtcblxuXHR2YXIgZW53aW5kb3cgPSBbXG5cdFx0XHQtNC43N2UtMDcgKiAwLjc0MDk1MTEyNTM1NDk1OSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMDM5NTFlLTA0ICogMC43NDA5NTExMjUzNTQ5NTkgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjUzNjc0ZS0wNCAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0Mi44NDE0NzNlLTAzICogMC43NDA5NTExMjUzNTQ5NTkgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjU3NTg5NzJlLTAyICogMC43NDA5NTExMjUzNTQ5NTkgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjQwMTc1NmUtMDMgKiAwLjc0MDk1MTEyNTM1NDk1OSAvIDIuMzg0ZS0wNixcblx0XHRcdDkuODM3MTVlLTA0ICogMC43NDA5NTExMjUzNTQ5NTkgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjkxODJlLTA1ICogMC43NDA5NTExMjUzNTQ5NTkgLyAyLjM4NGUtMDYsIC8qIDE1ICovXG5cdFx0XHQxLjIzOThlLTA1ICogMC43NDA5NTExMjUzNTQ5NTkgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjkxMjEyZS0wNCAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0Mi4yODMwOTZlLTAzICogMC43NDA5NTExMjUzNTQ5NTkgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjY5OTQ0NzZlLTAyICogMC43NDA5NTExMjUzNTQ5NTkgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMS44NzU2ODY2ZS0wMiAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuNjMwNzExZS0wMyAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuNDc0NzhlLTA0ICogMC43NDA5NTExMjUzNTQ5NTkgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMS40NzgyZS0wNSAqIDAuNzQwOTUxMTI1MzU0OTU5IC8gMi4zODRlLTA2LFxuXHRcdFx0OS4wNjM0NzE2OTAxOTE0NzFlLTAxLCAxLjk2MDM0MjgwNjU5MTIxM2UtMDEsXG5cblx0XHRcdC00Ljc3ZS0wNyAqIDAuNzczMDEwNDUzMzYyNzM3IC8gMi4zODRlLTA2LFxuXHRcdFx0MS4wNTg1OGUtMDQgKiAwLjc3MzAxMDQ1MzM2MjczNyAvIDIuMzg0ZS0wNixcblx0XHRcdDkuMzA3ODZlLTA0ICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQyLjUyMTUxNWUtMDMgKiAwLjc3MzAxMDQ1MzM2MjczNyAvIDIuMzg0ZS0wNixcblx0XHRcdDMuNTY5NDEyMmUtMDIgKiAwLjc3MzAxMDQ1MzM2MjczNyAvIDIuMzg0ZS0wNixcblx0XHRcdDMuNjQzMDM2ZS0wMyAqIDAuNzczMDEwNDUzMzYyNzM3IC8gMi4zODRlLTA2LFxuXHRcdFx0OS45MTgyMWUtMDQgKiAwLjc3MzAxMDQ1MzM2MjczNyAvIDIuMzg0ZS0wNixcblx0XHRcdDkuNjMyMWUtMDUgKiAwLjc3MzAxMDQ1MzM2MjczNyAvIDIuMzg0ZS0wNiwgLyogMTQgKi9cblx0XHRcdDEuMTQ0NGUtMDUgKiAwLjc3MzAxMDQ1MzM2MjczNyAvIDIuMzg0ZS0wNixcblx0XHRcdDEuNjU0NjJlLTA0ICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQyLjExMDAwNGUtMDMgKiAwLjc3MzAxMDQ1MzM2MjczNyAvIDIuMzg0ZS0wNixcblx0XHRcdDEuNjExMjgwNGUtMDIgKiAwLjc3MzAxMDQ1MzM2MjczNyAvIDIuMzg0ZS0wNixcblx0XHRcdC0xLjk2MzQyNDdlLTAyICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi44MDMzMjZlLTAzICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi43NzA0MmUtMDQgKiAwLjc3MzAxMDQ1MzM2MjczNyAvIDIuMzg0ZS0wNixcblx0XHRcdC0xLjY2ODllLTA1ICogMC43NzMwMTA0NTMzNjI3MzcgLyAyLjM4NGUtMDYsXG5cdFx0XHQ4LjIwNjc4NzkwODI4NjYwMmUtMDEsIDMuOTAxODA2NDQwMzIyNTY3ZS0wMSxcblxuXHRcdFx0LTQuNzdlLTA3ICogMC44MDMyMDc1MzE0ODA2NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjA3Mjg4ZS0wNCAqIDAuODAzMjA3NTMxNDgwNjQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0OS4wMjY1M2UtMDQgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDIuMTc0ODU0ZS0wMyAqIDAuODAzMjA3NTMxNDgwNjQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0My41NTg2MzU3ZS0wMiAqIDAuODAzMjA3NTMxNDgwNjQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0My44NTg1NjZlLTAzICogMC44MDMyMDc1MzE0ODA2NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5Ljk1MTU5ZS0wNCAqIDAuODAzMjA3NTMxNDgwNjQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0OS4zNDYwZS0wNSAqIDAuODAzMjA3NTMxNDgwNjQ1IC8gMi4zODRlLTA2LCAvKiAxMyAqL1xuXHRcdFx0MS4wMDE0ZS0wNSAqIDAuODAzMjA3NTMxNDgwNjQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0MS40MDE5MGUtMDQgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuOTM3Mzg5ZS0wMyAqIDAuODAzMjA3NTMxNDgwNjQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0MS41MjMzNTE3ZS0wMiAqIDAuODAzMjA3NTMxNDgwNjQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuMDUwNjg1OWUtMDIgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjk3NDAzM2UtMDMgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdC0zLjA3NTYwZS0wNCAqIDAuODAzMjA3NTMxNDgwNjQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0LTEuODEyMGUtMDUgKiAwLjgwMzIwNzUzMTQ4MDY0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDcuNDE2NTA1NDYyNzIwMzUzZS0wMSwgNS44MDU2OTM1NDUwODkyNDllLTAxLFxuXG5cdFx0XHQtNC43N2UtMDcgKiAwLjgzMTQ2OTYxMjMwMjU0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMDgyNDJlLTA0ICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ4LjY4Nzk3ZS0wNCAqIDAuODMxNDY5NjEyMzAyNTQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0MS44MDA1MzdlLTAzICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjU0MzUyMDBlLTAyICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ0LjA0OTMwMWUtMDMgKiAwLjgzMTQ2OTYxMjMwMjU0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDkuOTQyMDVlLTA0ICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjA1OTllLTA1ICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsIC8qIDEyICovXG5cdFx0XHQ5LjA2MGUtMDYgKiAwLjgzMTQ2OTYxMjMwMjU0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMTYzNDhlLTA0ICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjc2NjY4MmUtMDMgKiAwLjgzMTQ2OTYxMjMwMjU0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuNDM1ODUyMWUtMDIgKiAwLjgzMTQ2OTYxMjMwMjU0NSAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjEzNzIzMThlLTAyICogMC44MzE0Njk2MTIzMDI1NDUgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMy4xNDE4OGUtMDMgKiAwLjgzMTQ2OTYxMjMwMjU0NSAvIDIuMzg0ZS0wNixcblx0XHRcdC0zLjM5MDMxZS0wNCAqIDAuODMxNDY5NjEyMzAyNTQ1IC8gMi4zODRlLTA2LFxuXHRcdFx0LTEuOTU1MGUtMDUgKiAwLjgzMTQ2OTYxMjMwMjU0NSAvIDIuMzg0ZS0wNixcblx0XHRcdDYuNjgxNzg2Mzc5MTkyOTg5ZS0wMSwgNy42NTM2Njg2NDczMDE3OTdlLTAxLFxuXG5cdFx0XHQtNC43N2UtMDcgKiAwLjg1NzcyODYxMDAwMDI3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMDg3MTllLTA0ICogMC44NTc3Mjg2MTAwMDAyNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQ4LjI5MjIwZS0wNCAqIDAuODU3NzI4NjEwMDAwMjcyIC8gMi4zODRlLTA2LFxuXHRcdFx0MS4zOTk1MTdlLTAzICogMC44NTc3Mjg2MTAwMDAyNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjUyNDIwODFlLTAyICogMC44NTc3Mjg2MTAwMDAyNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQ0LjIxNTI0MGUtMDMgKiAwLjg1NzcyODYxMDAwMDI3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDkuODk0MzdlLTA0ICogMC44NTc3Mjg2MTAwMDAyNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQ4LjcyNjFlLTA1ICogMC44NTc3Mjg2MTAwMDAyNzIgLyAyLjM4NGUtMDYsIC8qIDExICovXG5cdFx0XHQ4LjEwNmUtMDYgKiAwLjg1NzcyODYxMDAwMDI3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDkuMzkzN2UtMDUgKiAwLjg1NzcyODYxMDAwMDI3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDEuNTk3ODgxZS0wMyAqIDAuODU3NzI4NjEwMDAwMjcyIC8gMi4zODRlLTA2LFxuXHRcdFx0MS4zNDg5MjQ2ZS0wMiAqIDAuODU3NzI4NjEwMDAwMjcyIC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuMjIyODcxOGUtMDIgKiAwLjg1NzcyODYxMDAwMDI3MiAvIDIuMzg0ZS0wNixcblx0XHRcdC0zLjMwNjg2NmUtMDMgKiAwLjg1NzcyODYxMDAwMDI3MiAvIDIuMzg0ZS0wNixcblx0XHRcdC0zLjcxNDU2ZS0wNCAqIDAuODU3NzI4NjEwMDAwMjcyIC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuMTQ1OGUtMDUgKiAwLjg1NzcyODYxMDAwMDI3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDUuOTkzNzY5MzM2ODE5MjM3ZS0wMSwgOS40Mjc5MzQ3MzY1MTk5NTRlLTAxLFxuXG5cdFx0XHQtNC43N2UtMDcgKiAwLjg4MTkyMTI2NDM0ODM1NSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMDg3MTllLTA0ICogMC44ODE5MjEyNjQzNDgzNTUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ3LjgzOTJlLTA0ICogMC44ODE5MjEyNjQzNDgzNTUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjcxMzE3ZS0wNCAqIDAuODgxOTIxMjY0MzQ4MzU1IC8gMi4zODRlLTA2LFxuXHRcdFx0My41MDA3MDAwZS0wMiAqIDAuODgxOTIxMjY0MzQ4MzU1IC8gMi4zODRlLTA2LFxuXHRcdFx0NC4zNTc4MTVlLTAzICogMC44ODE5MjEyNjQzNDgzNTUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjgwODU0ZS0wNCAqIDAuODgxOTIxMjY0MzQ4MzU1IC8gMi4zODRlLTA2LFxuXHRcdFx0OC4zOTIzZS0wNSAqIDAuODgxOTIxMjY0MzQ4MzU1IC8gMi4zODRlLTA2LCAvKiAxMCAqL1xuXHRcdFx0Ny42MjllLTA2ICogMC44ODE5MjEyNjQzNDgzNTUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ3LjI5NTZlLTA1ICogMC44ODE5MjEyNjQzNDgzNTUgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjQzMjQxOWUtMDMgKiAwLjg4MTkyMTI2NDM0ODM1NSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMjYyNzYwMmUtMDIgKiAwLjg4MTkyMTI2NDM0ODM1NSAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjMwNzQxNTBlLTAyICogMC44ODE5MjEyNjQzNDgzNTUgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMy40NjcwODNlLTAzICogMC44ODE5MjEyNjQzNDgzNTUgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNC4wNDM1OGUtMDQgKiAwLjg4MTkyMTI2NDM0ODM1NSAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjMzNjVlLTA1ICogMC44ODE5MjEyNjQzNDgzNTUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ1LjM0NTExMTM1OTUwNzkxNmUtMDEsIDEuMTExMTQwNDY2MDM5MjA1ZSswMCxcblxuXHRcdFx0LTkuNTRlLTA3ICogMC45MDM5ODkyOTMxMjM0NDMgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjA4MjQyZS0wNCAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0Ny4zMTk0NWUtMDQgKiAwLjkwMzk4OTI5MzEyMzQ0MyAvIDIuMzg0ZS0wNixcblx0XHRcdDUuMTU5MzhlLTA0ICogMC45MDM5ODkyOTMxMjM0NDMgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjQ3MzA0MzRlLTAyICogMC45MDM5ODkyOTMxMjM0NDMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ0LjQ3NzAyNGUtMDMgKiAwLjkwMzk4OTI5MzEyMzQ0MyAvIDIuMzg0ZS0wNixcblx0XHRcdDkuNjg5MzNlLTA0ICogMC45MDM5ODkyOTMxMjM0NDMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ4LjA1ODVlLTA1ICogMC45MDM5ODkyOTMxMjM0NDMgLyAyLjM4NGUtMDYsIC8qIDkgKi9cblx0XHRcdDYuNjc2ZS0wNiAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0NS4yOTI5ZS0wNSAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0MS4yNjk4MTdlLTAzICogMC45MDM5ODkyOTMxMjM0NDMgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjE3NzUwMTdlLTAyICogMC45MDM5ODkyOTMxMjM0NDMgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi4zOTA3MTg1ZS0wMiAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0LTMuNjIyNTMyZS0wMyAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0LTQuMzgyMTNlLTA0ICogMC45MDM5ODkyOTMxMjM0NDMgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi41MjcyZS0wNSAqIDAuOTAzOTg5MjkzMTIzNDQzIC8gMi4zODRlLTA2LFxuXHRcdFx0NC43Mjk2NDc3NTg5MTMxOTllLTAxLCAxLjI2ODc4NjU2ODMyNzI5MWUrMDAsXG5cblx0XHRcdC05LjU0ZS0wNyAqIDAuOTIzODc5NTMyNTExMjg2NzU2MTMgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjA2ODEyZS0wNCAqIDAuOTIzODc5NTMyNTExMjg2NzU2MTMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ2Ljc0MjQ4ZS0wNCAqIDAuOTIzODc5NTMyNTExMjg2NzU2MTMgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjMzNzllLTA1ICogMC45MjM4Nzk1MzI1MTEyODY3NTYxMyAvIDIuMzg0ZS0wNixcblx0XHRcdDMuNDQxMjg2MWUtMDIgKiAwLjkyMzg3OTUzMjUxMTI4Njc1NjEzIC8gMi4zODRlLTA2LFxuXHRcdFx0NC41NzM4MjJlLTAzICogMC45MjM4Nzk1MzI1MTEyODY3NTYxMyAvIDIuMzg0ZS0wNixcblx0XHRcdDkuNTQxNTFlLTA0ICogMC45MjM4Nzk1MzI1MTEyODY3NTYxMyAvIDIuMzg0ZS0wNixcblx0XHRcdDcuNjc3MWUtMDUgKiAwLjkyMzg3OTUzMjUxMTI4Njc1NjEzIC8gMi4zODRlLTA2LFxuXHRcdFx0Ni4xOTllLTA2ICogMC45MjM4Nzk1MzI1MTEyODY3NTYxMyAvIDIuMzg0ZS0wNixcblx0XHRcdDMuNDMzMmUtMDUgKiAwLjkyMzg3OTUzMjUxMTI4Njc1NjEzIC8gMi4zODRlLTA2LFxuXHRcdFx0MS4xMTEwMzFlLTAzICogMC45MjM4Nzk1MzI1MTEyODY3NTYxMyAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMDkzMzM5OWUtMDIgKiAwLjkyMzg3OTUzMjUxMTI4Njc1NjEzIC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuNDcyNTQzN2UtMDIgKiAwLjkyMzg3OTUzMjUxMTI4Njc1NjEzIC8gMi4zODRlLTA2LFxuXHRcdFx0LTMuNzcxNzgyZS0wMyAqIDAuOTIzODc5NTMyNTExMjg2NzU2MTMgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNC43MjU0NmUtMDQgKiAwLjkyMzg3OTUzMjUxMTI4Njc1NjEzIC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuNzY1N2UtMDUgKiAwLjkyMzg3OTUzMjUxMTI4Njc1NjEzIC8gMi4zODRlLTA2LFxuXHRcdFx0NC4xNDIxMzU2MjM3MzA5NTA0ODc5ZS0wMSwgLyogdGFuKFBJLzgpICovXG5cdFx0XHQxLjQxNDIxMzU2MjM3MzA5NWUrMDAsXG5cblx0XHRcdC05LjU0ZS0wNyAqIDAuOTQxNTQ0MDY1MTgzMDIxIC8gMi4zODRlLTA2LFxuXHRcdFx0MS4wNTM4MWUtMDQgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNixcblx0XHRcdDYuMTAzNTJlLTA0ICogMC45NDE1NDQwNjUxODMwMjEgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNC43NTg4M2UtMDQgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNixcblx0XHRcdDMuNDA1NTcxMGUtMDIgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNixcblx0XHRcdDQuNjQ5MTYyZS0wMyAqIDAuOTQxNTQ0MDY1MTgzMDIxIC8gMi4zODRlLTA2LFxuXHRcdFx0OS4zNTU1NWUtMDQgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNixcblx0XHRcdDcuMzQzM2UtMDUgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNiwgLyogNyAqL1xuXHRcdFx0NS4yNDVlLTA2ICogMC45NDE1NDQwNjUxODMwMjEgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjcxNjZlLTA1ICogMC45NDE1NDQwNjUxODMwMjEgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjU2NTM1ZS0wNCAqIDAuOTQxNTQ0MDY1MTgzMDIxIC8gMi4zODRlLTA2LFxuXHRcdFx0MS4wMTAzNzAzZS0wMiAqIDAuOTQxNTQ0MDY1MTgzMDIxIC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuNTUyNzAwMGUtMDIgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNixcblx0XHRcdC0zLjkxNDM1NmUtMDMgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNixcblx0XHRcdC01LjA3MzU1ZS0wNCAqIDAuOTQxNTQ0MDY1MTgzMDIxIC8gMi4zODRlLTA2LFxuXHRcdFx0LTMuMDA0MWUtMDUgKiAwLjk0MTU0NDA2NTE4MzAyMSAvIDIuMzg0ZS0wNixcblx0XHRcdDMuNTc4MDU3MjEzMTQ1MjQxZS0wMSwgMS41NDYwMjA5MDY3MjU0NzRlKzAwLFxuXG5cdFx0XHQtOS41NGUtMDcgKiAwLjk1Njk0MDMzNTczMjIwOSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMDI1MjBlLTA0ICogMC45NTY5NDAzMzU3MzIyMDkgLyAyLjM4NGUtMDYsXG5cdFx0XHQ1LjM5MzAzZS0wNCAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0LTEuMDExODQ4ZS0wMyAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0My4zNjU5OTM1ZS0wMiAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0NC43MDMwNDVlLTAzICogMC45NTY5NDAzMzU3MzIyMDkgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjE1MDUxZS0wNCAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0Ny4wMDk1ZS0wNSAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LCAvKiA2ICovXG5cdFx0XHQ0Ljc2OGUtMDYgKiAwLjk1Njk0MDMzNTczMjIwOSAvIDIuMzg0ZS0wNixcblx0XHRcdDkuNTRlLTA3ICogMC45NTY5NDAzMzU3MzIyMDkgLyAyLjM4NGUtMDYsXG5cdFx0XHQ4LjA2ODA4ZS0wNCAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0OS4yODc4MzRlLTAzICogMC45NTY5NDAzMzU3MzIyMDkgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi42MzEwOTIxZS0wMiAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0LTQuMDQ4ODI0ZS0wMyAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0LTUuNDIxNjRlLTA0ICogMC45NTY5NDAzMzU3MzIyMDkgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMy4yNDI1ZS0wNSAqIDAuOTU2OTQwMzM1NzMyMjA5IC8gMi4zODRlLTA2LFxuXHRcdFx0My4wMzM0NjY4MzYwNzM0MjRlLTAxLCAxLjY2MjkzOTIyNDYwNTA5MGUrMDAsXG5cblx0XHRcdC0xLjQzMWUtMDYgKiAwLjk3MDAzMTI1MzE5NDU0NCAvIDIuMzg0ZS0wNixcblx0XHRcdDkuOTE4MmUtMDUgKiAwLjk3MDAzMTI1MzE5NDU0NCAvIDIuMzg0ZS0wNixcblx0XHRcdDQuNjI1MzJlLTA0ICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMS41NzM1NjNlLTAzICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjMyMjU1MzZlLTAyICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQ0LjczNzM3N2UtMDMgKiAwLjk3MDAzMTI1MzE5NDU0NCAvIDIuMzg0ZS0wNixcblx0XHRcdDguOTE2ODVlLTA0ICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQ2LjYyODBlLTA1ICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsIC8qIDUgKi9cblx0XHRcdDQuMjkyZS0wNiAqIDAuOTcwMDMxMjUzMTk0NTQ0IC8gMi4zODRlLTA2LFxuXHRcdFx0LTEuMzgyOGUtMDUgKiAwLjk3MDAzMTI1MzE5NDU0NCAvIDIuMzg0ZS0wNixcblx0XHRcdDYuNjE4NTBlLTA0ICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQ4LjQ4NzIyNWUtMDMgKiAwLjk3MDAzMTI1MzE5NDU0NCAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjcwNzM4NjBlLTAyICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNC4xNzQ3MDllLTAzICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNS43Njk3M2UtMDQgKiAwLjk3MDAzMTI1MzE5NDU0NCAvIDIuMzg0ZS0wNixcblx0XHRcdC0zLjQ4MDllLTA1ICogMC45NzAwMzEyNTMxOTQ1NDQgLyAyLjM4NGUtMDYsXG5cdFx0XHQyLjUwNDg2OTYwMTkxMzA1NWUtMDEsIDEuNzYzODQyNTI4Njk2NzEwZSswMCxcblxuXHRcdFx0LTEuNDMxZS0wNiAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjUzNjdlLTA1ICogMC45ODA3ODUyODA0MDMyMyAvIDIuMzg0ZS0wNixcblx0XHRcdDMuNzg2MDllLTA0ICogMC45ODA3ODUyODA0MDMyMyAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjE2MTUwM2UtMDMgKiAwLjk4MDc4NTI4MDQwMzIzIC8gMi4zODRlLTA2LFxuXHRcdFx0My4yNzU0ODk4ZS0wMiAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ0Ljc1MjE1OWUtMDMgKiAwLjk4MDc4NTI4MDQwMzIzIC8gMi4zODRlLTA2LFxuXHRcdFx0OC42NjQxM2UtMDQgKiAwLjk4MDc4NTI4MDQwMzIzIC8gMi4zODRlLTA2LFxuXHRcdFx0Ni4yOTQzZS0wNSAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsIC8qIDQgKi9cblx0XHRcdDMuODE1ZS0wNiAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi43MThlLTA1ICogMC45ODA3ODUyODA0MDMyMyAvIDIuMzg0ZS0wNixcblx0XHRcdDUuMjIxMzdlLTA0ICogMC45ODA3ODUyODA0MDMyMyAvIDIuMzg0ZS0wNixcblx0XHRcdDcuNzAzMzA0ZS0wMyAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi43ODE1MzQyZS0wMiAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNC4yOTA1ODFlLTAzICogMC45ODA3ODUyODA0MDMyMyAvIDIuMzg0ZS0wNixcblx0XHRcdC02LjExNzgyZS0wNCAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMy43NjcwZS0wNSAqIDAuOTgwNzg1MjgwNDAzMjMgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjk4OTEyMzY3Mzc5NjU4MGUtMDEsIDEuODQ3NzU5MDY1MDIyNTczZSswMCxcblxuXHRcdFx0LTEuOTA3ZS0wNiAqIDAuOTg5MTc2NTA5OTY0NzgxIC8gMi4zODRlLTA2LFxuXHRcdFx0OS4wMTIyZS0wNSAqIDAuOTg5MTc2NTA5OTY0NzgxIC8gMi4zODRlLTA2LFxuXHRcdFx0Mi44ODQ4NmUtMDQgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjc3NDIzOWUtMDMgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdDMuMjI0ODAyMGUtMDIgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdDQuNzQ4ODIxZS0wMyAqIDAuOTg5MTc2NTA5OTY0NzgxIC8gMi4zODRlLTA2LFxuXHRcdFx0OC4zODc1N2UtMDQgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdDUuOTYwNWUtMDUgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNiwgLyogMyAqL1xuXHRcdFx0My4zMzhlLTA2ICogMC45ODkxNzY1MDk5NjQ3ODEgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMy45NTc3ZS0wNSAqIDAuOTg5MTc2NTA5OTY0NzgxIC8gMi4zODRlLTA2LFxuXHRcdFx0My44ODE0NWUtMDQgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdDYuOTM3MDI3ZS0wMyAqIDAuOTg5MTc2NTA5OTY0NzgxIC8gMi4zODRlLTA2LFxuXHRcdFx0LTIuODUzMjk4MmUtMDIgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdC00LjM5NTk2MmUtMDMgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdC02LjQ2NTkxZS0wNCAqIDAuOTg5MTc2NTA5OTY0NzgxIC8gMi4zODRlLTA2LFxuXHRcdFx0LTQuMDUzMWUtMDUgKiAwLjk4OTE3NjUwOTk2NDc4MSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuNDgzMzU5ODc1MzgzNDc0ZS0wMSwgMS45MTM4ODA2NzE0NjQ0MThlKzAwLFxuXG5cdFx0XHQtMS45MDdlLTA2ICogMC45OTUxODQ3MjY2NzIxOTcgLyAyLjM4NGUtMDYsXG5cdFx0XHQ4LjQ0MDBlLTA1ICogMC45OTUxODQ3MjY2NzIxOTcgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjkxNjg5ZS0wNCAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0LTMuNDExMjkzZS0wMyAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0My4xNzA2ODEwZS0wMiAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0NC43MjgzMTdlLTAzICogMC45OTUxODQ3MjY2NzIxOTcgLyAyLjM4NGUtMDYsXG5cdFx0XHQ4LjA5NjY5ZS0wNCAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0NS41NzllLTA1ICogMC45OTUxODQ3MjY2NzIxOTcgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjMzOGUtMDYgKiAwLjk5NTE4NDcyNjY3MjE5NyAvIDIuMzg0ZS0wNixcblx0XHRcdC01LjA1NDVlLTA1ICogMC45OTUxODQ3MjY2NzIxOTcgLyAyLjM4NGUtMDYsXG5cdFx0XHQyLjU5ODc2ZS0wNCAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0Ni4xODkzNDZlLTAzICogMC45OTUxODQ3MjY2NzIxOTcgLyAyLjM4NGUtMDYsXG5cdFx0XHQtMi45MjI0ODczZS0wMiAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0LTQuNDg5ODk5ZS0wMyAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0LTYuODA5MjNlLTA0ICogMC45OTUxODQ3MjY2NzIxOTcgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNC4zMzkyZS0wNSAqIDAuOTk1MTg0NzI2NjcyMTk3IC8gMi4zODRlLTA2LFxuXHRcdFx0OS44NDkxNDAzMzU3MTY0MjVlLTAyLCAxLjk2MTU3MDU2MDgwNjQ2MWUrMDAsXG5cblx0XHRcdC0yLjM4NGUtMDYgKiAwLjk5ODc5NTQ1NjIwNTE3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDcuNzcyNGUtMDUgKiAwLjk5ODc5NTQ1NjIwNTE3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDguODIxNWUtMDUgKiAwLjk5ODc5NTQ1NjIwNTE3MiAvIDIuMzg0ZS0wNixcblx0XHRcdC00LjA3MjE4OWUtMDMgKiAwLjk5ODc5NTQ1NjIwNTE3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDMuMTEzMjY5OGUtMDIgKiAwLjk5ODc5NTQ1NjIwNTE3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDQuNjkxMTI0ZS0wMyAqIDAuOTk4Nzk1NDU2MjA1MTcyIC8gMi4zODRlLTA2LFxuXHRcdFx0Ny43OTE1MmUtMDQgKiAwLjk5ODc5NTQ1NjIwNTE3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDUuMjkyOWUtMDUgKiAwLjk5ODc5NTQ1NjIwNTE3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDIuODYxZS0wNiAqIDAuOTk4Nzk1NDU2MjA1MTcyIC8gMi4zODRlLTA2LFxuXHRcdFx0LTYuMDU1OGUtMDUgKiAwLjk5ODc5NTQ1NjIwNTE3MiAvIDIuMzg0ZS0wNixcblx0XHRcdDEuMzczMjllLTA0ICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQ1LjQ2MjE3MGUtMDMgKiAwLjk5ODc5NTQ1NjIwNTE3MiAvIDIuMzg0ZS0wNixcblx0XHRcdC0yLjk4OTAwNjBlLTAyICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNC41NzA0ODRlLTAzICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQtNy4xNDMwMmUtMDQgKiAwLjk5ODc5NTQ1NjIwNTE3MiAvIDIuMzg0ZS0wNixcblx0XHRcdC00LjYyNTNlLTA1ICogMC45OTg3OTU0NTYyMDUxNzIgLyAyLjM4NGUtMDYsXG5cdFx0XHQ0LjkxMjY4NDk3Njk0NjcyNWUtMDIsIDEuOTkwMzY5NDUzMzQ0Mzk0ZSswMCxcblxuXHRcdFx0My41NzgwOTA3ZS0wMiAqIFV0aWwkNi5TUVJUMiAqIDAuNSAvIDIuMzg0ZS0wNixcblx0XHRcdDEuNzg3NjE0OGUtMDIgKiBVdGlsJDYuU1FSVDIgKiAwLjUgLyAyLjM4NGUtMDYsXG5cdFx0XHQzLjEzNDcyN2UtMDMgKiBVdGlsJDYuU1FSVDIgKiAwLjUgLyAyLjM4NGUtMDYsXG5cdFx0XHQyLjQ1NzE0MmUtMDMgKiBVdGlsJDYuU1FSVDIgKiAwLjUgLyAyLjM4NGUtMDYsXG5cdFx0XHQ5LjcxMzE3ZS0wNCAqIFV0aWwkNi5TUVJUMiAqIDAuNSAvIDIuMzg0ZS0wNixcblx0XHRcdDIuMTg4NjhlLTA0ICogVXRpbCQ2LlNRUlQyICogMC41IC8gMi4zODRlLTA2LFxuXHRcdFx0MS4wMTU2NmUtMDQgKiBVdGlsJDYuU1FSVDIgKiAwLjUgLyAyLjM4NGUtMDYsXG5cdFx0XHQxLjM4MjhlLTA1ICogVXRpbCQ2LlNRUlQyICogMC41IC8gMi4zODRlLTA2LFxuXG5cdFx0XHQzLjA1MjY2MzhlLTAyIC8gMi4zODRlLTA2LCA0LjYzODE5NWUtMDMgLyAyLjM4NGUtMDYsXG5cdFx0XHQ3LjQ3MjA0ZS0wNCAvIDIuMzg0ZS0wNiwgNC45NTkxZS0wNSAvIDIuMzg0ZS0wNixcblx0XHRcdDQuNzU2NDUxZS0wMyAvIDIuMzg0ZS0wNiwgMi4xNDU4ZS0wNSAvIDIuMzg0ZS0wNixcblx0XHRcdC02Ljk2MThlLTA1IC8gMi4zODRlLTA2LCAvKiAyLjM4NGUtMDYvMi4zODRlLTA2ICovXG5cdF07XG5cblx0dmFyIE5TID0gMTI7XG5cdHZhciBOTCA9IDM2O1xuXG5cdHZhciB3aW4gPSBbXG5cdCAgICBbXG5cdCAgICAgMi4zODIxOTE3MzkzNDc5MTNlLTEzLFxuXHQgICAgIDYuNDIzMzA1ODcyMTQ3ODM0ZS0xMyxcblx0ICAgICA5LjQwMDg0OTA5NDA0OTY4OGUtMTMsXG5cdCAgICAgMS4xMjI0MzUwMjYwOTY1NTZlLTEyLFxuXHQgICAgIDEuMTgzODQwMzIxMjY3NDgxZS0xMixcblx0ICAgICAxLjEyMjQzNTAyNjA5NjU1NmUtMTIsXG5cdCAgICAgOS40MDA4NDkwOTQwNDk2OTBlLTEzLFxuXHQgICAgIDYuNDIzMzA1ODcyMTQ3ODM5ZS0xMyxcblx0ICAgICAyLjM4MjE5MTczOTM0NzkxOGUtMTMsXG5cblx0ICAgICA1LjQ1NjExNjEwODk0MzQxMmUtMTIsXG5cdCAgICAgNC44Nzg5ODUxOTk1NjU4NTJlLTEyLFxuXHQgICAgIDQuMjQwNDQ4OTk1MDE3MzY3ZS0xMixcblx0ICAgICAzLjU1OTkwOTA5NDc1ODI1MmUtMTIsXG5cdCAgICAgMi44NTgwNDMzNTkyODgwNzVlLTEyLFxuXHQgICAgIDIuMTU2MTc3NjIzODE3ODk4ZS0xMixcblx0ICAgICAxLjQ3NTYzNzcyMzU1ODc4M2UtMTIsXG5cdCAgICAgOC4zNzEwMTUxOTAxMDI5NzRlLTEzLFxuXHQgICAgIDIuNTk5NzA2MDk2MzI3Mzc2ZS0xMyxcblxuXHQgICAgIC01LjQ1NjExNjEwODk0MzQxMmUtMTIsXG5cdCAgICAgLTQuODc4OTg1MTk5NTY1ODUyZS0xMixcblx0ICAgICAtNC4yNDA0NDg5OTUwMTczNjdlLTEyLFxuXHQgICAgIC0zLjU1OTkwOTA5NDc1ODI1MmUtMTIsXG5cdCAgICAgLTIuODU4MDQzMzU5Mjg4MDc2ZS0xMixcblx0ICAgICAtMi4xNTYxNzc2MjM4MTc4OThlLTEyLFxuXHQgICAgIC0xLjQ3NTYzNzcyMzU1ODc4M2UtMTIsXG5cdCAgICAgLTguMzcxMDE1MTkwMTAyOTc1ZS0xMyxcblx0ICAgICAtMi41OTk3MDYwOTYzMjczNzZlLTEzLFxuXG5cdCAgICAgLTIuMzgyMTkxNzM5MzQ3OTIzZS0xMyxcblx0ICAgICAtNi40MjMzMDU4NzIxNDc4NDNlLTEzLFxuXHQgICAgIC05LjQwMDg0OTA5NDA0OTY5NmUtMTMsXG5cdCAgICAgLTEuMTIyNDM1MDI2MDk2NTU2ZS0xMixcblx0ICAgICAtMS4xODM4NDAzMjEyNjc0ODFlLTEyLFxuXHQgICAgIC0xLjEyMjQzNTAyNjA5NjU1NmUtMTIsXG5cdCAgICAgLTkuNDAwODQ5MDk0MDQ5Njk0ZS0xMyxcblx0ICAgICAtNi40MjMzMDU4NzIxNDc4NDBlLTEzLFxuXHQgICAgIC0yLjM4MjE5MTczOTM0NzkxOGUtMTMsXG5cdCAgICAgXSxcblx0ICAgIFtcblx0ICAgICAyLjM4MjE5MTczOTM0NzkxM2UtMTMsXG5cdCAgICAgNi40MjMzMDU4NzIxNDc4MzRlLTEzLFxuXHQgICAgIDkuNDAwODQ5MDk0MDQ5Njg4ZS0xMyxcblx0ICAgICAxLjEyMjQzNTAyNjA5NjU1NmUtMTIsXG5cdCAgICAgMS4xODM4NDAzMjEyNjc0ODFlLTEyLFxuXHQgICAgIDEuMTIyNDM1MDI2MDk2NTU2ZS0xMixcblx0ICAgICA5LjQwMDg0OTA5NDA0OTY4OGUtMTMsXG5cdCAgICAgNi40MjMzMDU4NzIxNDc4NDFlLTEzLFxuXHQgICAgIDIuMzgyMTkxNzM5MzQ3OTE4ZS0xMyxcblxuXHQgICAgIDUuNDU2MTE2MTA4OTQzNDEzZS0xMixcblx0ICAgICA0Ljg3ODk4NTE5OTU2NTg1MmUtMTIsXG5cdCAgICAgNC4yNDA0NDg5OTUwMTczNjdlLTEyLFxuXHQgICAgIDMuNTU5OTA5MDk0NzU4MjUzZS0xMixcblx0ICAgICAyLjg1ODA0MzM1OTI4ODA3NWUtMTIsXG5cdCAgICAgMi4xNTYxNzc2MjM4MTc4OThlLTEyLFxuXHQgICAgIDEuNDc1NjM3NzIzNTU4NzgyZS0xMixcblx0ICAgICA4LjM3MTAxNTE5MDEwMjk3NWUtMTMsXG5cdCAgICAgMi41OTk3MDYwOTYzMjczNzZlLTEzLFxuXG5cdCAgICAgLTUuNDYxMzE0MDY5ODA5NzU1ZS0xMixcblx0ICAgICAtNC45MjEwODU3NzA1MjQwNTVlLTEyLFxuXHQgICAgIC00LjM0MzQwNTAzNzA5MTgzOGUtMTIsXG5cdCAgICAgLTMuNzMyNjY4MzY4NzA3Njg3ZS0xMixcblx0ICAgICAtMy4wOTM1MjM4NDAxOTA4ODVlLTEyLFxuXHQgICAgIC0yLjQzMDgzNTcyNzMyOTQ2NWUtMTIsXG5cdCAgICAgLTEuNzM0Njc5MDEwMDA3NzUxZS0xMixcblx0ICAgICAtOS43NDgyNTM2NTY2MDkyODFlLTEzLFxuXHQgICAgIC0yLjc5NzQzNTEyMDE2ODMyNmUtMTMsXG5cblx0ICAgICAwLjAwMDAwMDAwMDAwMDAwMGUrMDAsXG5cdCAgICAgMC4wMDAwMDAwMDAwMDAwMDBlKzAwLFxuXHQgICAgIDAuMDAwMDAwMDAwMDAwMDAwZSswMCxcblx0ICAgICAwLjAwMDAwMDAwMDAwMDAwMGUrMDAsXG5cdCAgICAgMC4wMDAwMDAwMDAwMDAwMDBlKzAwLFxuXHQgICAgIDAuMDAwMDAwMDAwMDAwMDAwZSswMCxcblx0ICAgICAtMi4yODM3NDgyNDE3OTk1MzFlLTEzLFxuXHQgICAgIC00LjAzNzg1ODg3NDAyMDY4NmUtMTMsXG5cdCAgICAgLTIuMTQ2NTQ3NDY0ODI1MzIzZS0xMyxcblx0ICAgICBdLFxuXHQgICAgW1xuXHQgICAgIDEuMzE2NTI0OTc1ODczOTU4ZS0wMSwgLyogd2luW1NIT1JUX1RZUEVdICovXG5cdCAgICAgNC4xNDIxMzU2MjM3MzA5NTBlLTAxLFxuXHQgICAgIDcuNjczMjY5ODc5Nzg5NjAyZS0wMSxcblxuXHQgICAgIDEuMDkxMzA4NTAxMDY5MjcxZSswMCwgLyogdGFudGFiX2wgKi9cblx0ICAgICAxLjMwMzIyNTM3Mjg0MTIwNmUrMDAsXG5cdCAgICAgMS41Njk2ODU1NzcxMTc0OTBlKzAwLFxuXHQgICAgIDEuOTIwOTgyMTI2OTcxMTY2ZSswMCxcblx0ICAgICAyLjQxNDIxMzU2MjM3MzA5NGUrMDAsXG5cdCAgICAgMy4xNzE1OTQ4MDIzNjMyMTJlKzAwLFxuXHQgICAgIDQuNTEwNzA4NTAzNjYyMDU1ZSswMCxcblx0ICAgICA3LjU5NTc1NDExMjcyNTE0NmUrMDAsXG5cdCAgICAgMi4yOTAzNzY1NTQ4NDMxMTVlKzAxLFxuXG5cdCAgICAgMC45ODQ4MDc3NTMwMTIyMDgwMjAzMiwgLyogY3ggKi9cblx0ICAgICAwLjY0Mjc4NzYwOTY4NjUzOTM2MjkyLFxuXHQgICAgIDAuMzQyMDIwMTQzMzI1NjY4ODIzOTMsXG5cdCAgICAgMC45Mzk2OTI2MjA3ODU5MDg0Mjc5MSxcblx0ICAgICAtMC4xNzM2NDgxNzc2NjY5MzAzMDM0Myxcblx0ICAgICAtMC43NjYwNDQ0NDMxMTg5Nzc5MDI0Myxcblx0ICAgICAwLjg2NjAyNTQwMzc4NDQzODcwNzYxLFxuXHQgICAgIDAuNTAwMDAwMDAwMDAwMDAwZSswMCxcblxuXHQgICAgIC01LjE0NDk1NzU1NDI3NTI2NWUtMDEsIC8qIGNhICovXG5cdCAgICAgLTQuNzE3MzE5Njg1NjQ5NzIzZS0wMSxcblx0ICAgICAtMy4xMzM3NzQ1NDIwMzkwMTllLTAxLFxuXHQgICAgIC0xLjgxOTEzMTk5NjEwOTgxMmUtMDEsXG5cdCAgICAgLTkuNDU3NDE5MjUyNjQyMDY0ZS0wMixcblx0ICAgICAtNC4wOTY1NTgyODg1MzA0MDVlLTAyLFxuXHQgICAgIC0xLjQxOTg1Njg1NzI0NzExNWUtMDIsXG5cdCAgICAgLTMuNjk5OTc0NjczNzYwMDM3ZS0wMyxcblxuXHQgICAgIDguNTc0OTI5MjU3MTI1NDQyZS0wMSwgLyogY3MgKi9cblx0ICAgICA4LjgxNzQxOTk3MzE3NzA1MmUtMDEsXG5cdCAgICAgOS40OTYyODY0OTEwMjczMjllLTAxLFxuXHQgICAgIDkuODMzMTQ1OTI0OTE3OTAxZS0wMSxcblx0ICAgICA5Ljk1NTE3ODE2MDY3NTg1N2UtMDEsXG5cdCAgICAgOS45OTE2MDU1ODE3ODE0NzVlLTAxLFxuXHQgICAgIDkuOTk4OTkxOTUyNDQ0NDcwZS0wMSxcblx0ICAgICA5Ljk5OTkzMTU1MDcwMjgwMmUtMDEsXG5cdCAgICAgXSxcblx0ICAgIFtcblx0ICAgICAwLjAwMDAwMDAwMDAwMDAwMGUrMDAsXG5cdCAgICAgMC4wMDAwMDAwMDAwMDAwMDBlKzAwLFxuXHQgICAgIDAuMDAwMDAwMDAwMDAwMDAwZSswMCxcblx0ICAgICAwLjAwMDAwMDAwMDAwMDAwMGUrMDAsXG5cdCAgICAgMC4wMDAwMDAwMDAwMDAwMDBlKzAwLFxuXHQgICAgIDAuMDAwMDAwMDAwMDAwMDAwZSswMCxcblx0ICAgICAyLjI4Mzc0ODI0MTc5OTUzMWUtMTMsXG5cdCAgICAgNC4wMzc4NTg4NzQwMjA2ODZlLTEzLFxuXHQgICAgIDIuMTQ2NTQ3NDY0ODI1MzIzZS0xMyxcblxuXHQgICAgIDUuNDYxMzE0MDY5ODA5NzU1ZS0xMixcblx0ICAgICA0LjkyMTA4NTc3MDUyNDA1NWUtMTIsXG5cdCAgICAgNC4zNDM0MDUwMzcwOTE4MzhlLTEyLFxuXHQgICAgIDMuNzMyNjY4MzY4NzA3Njg3ZS0xMixcblx0ICAgICAzLjA5MzUyMzg0MDE5MDg4NWUtMTIsXG5cdCAgICAgMi40MzA4MzU3MjczMjk0NjZlLTEyLFxuXHQgICAgIDEuNzM0Njc5MDEwMDA3NzUxZS0xMixcblx0ICAgICA5Ljc0ODI1MzY1NjYwOTI4MWUtMTMsXG5cdCAgICAgMi43OTc0MzUxMjAxNjgzMjZlLTEzLFxuXG5cdCAgICAgLTUuNDU2MTE2MTA4OTQzNDEzZS0xMixcblx0ICAgICAtNC44Nzg5ODUxOTk1NjU4NTJlLTEyLFxuXHQgICAgIC00LjI0MDQ0ODk5NTAxNzM2N2UtMTIsXG5cdCAgICAgLTMuNTU5OTA5MDk0NzU4MjUzZS0xMixcblx0ICAgICAtMi44NTgwNDMzNTkyODgwNzVlLTEyLFxuXHQgICAgIC0yLjE1NjE3NzYyMzgxNzg5OGUtMTIsXG5cdCAgICAgLTEuNDc1NjM3NzIzNTU4NzgyZS0xMixcblx0ICAgICAtOC4zNzEwMTUxOTAxMDI5NzVlLTEzLFxuXHQgICAgIC0yLjU5OTcwNjA5NjMyNzM3NmUtMTMsXG5cblx0ICAgICAtMi4zODIxOTE3MzkzNDc5MTNlLTEzLFxuXHQgICAgIC02LjQyMzMwNTg3MjE0NzgzNGUtMTMsXG5cdCAgICAgLTkuNDAwODQ5MDk0MDQ5Njg4ZS0xMyxcblx0ICAgICAtMS4xMjI0MzUwMjYwOTY1NTZlLTEyLFxuXHQgICAgIC0xLjE4Mzg0MDMyMTI2NzQ4MWUtMTIsXG5cdCAgICAgLTEuMTIyNDM1MDI2MDk2NTU2ZS0xMixcblx0ICAgICAtOS40MDA4NDkwOTQwNDk2ODhlLTEzLFxuXHQgICAgIC02LjQyMzMwNTg3MjE0Nzg0MWUtMTMsXG5cdCAgICAgLTIuMzgyMTkxNzM5MzQ3OTE4ZS0xMyxcblx0ICAgICBdXG5cdF07XG5cblx0dmFyIHRhbnRhYl9sID0gd2luW0VuY29kZXJfMS5TSE9SVF9UWVBFXTtcblx0dmFyIGN4ID0gd2luW0VuY29kZXJfMS5TSE9SVF9UWVBFXTtcblx0dmFyIGNhID0gd2luW0VuY29kZXJfMS5TSE9SVF9UWVBFXTtcblx0dmFyIGNzID0gd2luW0VuY29kZXJfMS5TSE9SVF9UWVBFXTtcblxuXHQvKipcblx0ICogbmV3IElEQ1Qgcm91dGluZSB3cml0dGVuIGJ5IFRha2VoaXJvIFRPTUlOQUdBXG5cdCAqXG5cdCAqIFBVUlBPU0U6IE92ZXJsYXBwaW5nIHdpbmRvdyBvbiBQQ00gc2FtcGxlczxCUj5cblx0ICpcblx0ICogU0VNQU5USUNTOjxCUj5cblx0ICogMzIgMTYtYml0IHBjbSBzYW1wbGVzIGFyZSBzY2FsZWQgdG8gZnJhY3Rpb25hbCAyJ3MgY29tcGxlbWVudCBhbmRcblx0ICogY29uY2F0ZW5hdGVkIHRvIHRoZSBlbmQgb2YgdGhlIHdpbmRvdyBidWZmZXIgI3gjLiBUaGUgdXBkYXRlZCB3aW5kb3dcblx0ICogYnVmZmVyICN4IyBpcyB0aGVuIHdpbmRvd2VkIGJ5IHRoZSBhbmFseXNpcyB3aW5kb3cgI2MjIHRvIHByb2R1Y2UgdGhlXG5cdCAqIHdpbmRvd2VkIHNhbXBsZSAjeiNcblx0ICovXG5cdHZhciBvcmRlciA9IFtcblx0ICAgIDAsIDEsIDE2LCAxNywgOCwgOSwgMjQsIDI1LCA0LCA1LCAyMCwgMjEsIDEyLCAxMywgMjgsIDI5LFxuXHQgICAgMiwgMywgMTgsIDE5LCAxMCwgMTEsIDI2LCAyNywgNiwgNywgMjIsIDIzLCAxNCwgMTUsIDMwLCAzMVxuXHRdO1xuXG5cdC8qKlxuXHQgKiByZXR1cm5zIHN1bV9qPTBeMzEgYVtqXSpjb3MoUEkqaiooaysxLzIpLzMyKSwgMDw9azwzMlxuXHQgKi9cblx0ZnVuY3Rpb24gd2luZG93X3N1YmJhbmQoeDEsIHgxUG9zLCBhKSB7XG5cdFx0dmFyIHdwID0gMTA7XG5cblx0XHR2YXIgeDIgPSB4MVBvcyArIDIzOCAtIDE0IC0gMjg2O1xuXG5cdFx0Zm9yICh2YXIgaSA9IC0xNTsgaSA8IDA7IGkrKykge1xuXHRcdFx0dmFyIHcsIHMsIHQ7XG5cblx0XHRcdHcgPSBlbndpbmRvd1t3cCArIC0xMF07XG5cdFx0XHRzID0geDFbeDIgKyAtMjI0XSAqIHc7XG5cdFx0XHR0ID0geDFbeDFQb3MgKyAyMjRdICogdztcblx0XHRcdHcgPSBlbndpbmRvd1t3cCArIC05XTtcblx0XHRcdHMgKz0geDFbeDIgKyAtMTYwXSAqIHc7XG5cdFx0XHR0ICs9IHgxW3gxUG9zICsgMTYwXSAqIHc7XG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyAtOF07XG5cdFx0XHRzICs9IHgxW3gyICsgLTk2XSAqIHc7XG5cdFx0XHR0ICs9IHgxW3gxUG9zICsgOTZdICogdztcblx0XHRcdHcgPSBlbndpbmRvd1t3cCArIC03XTtcblx0XHRcdHMgKz0geDFbeDIgKyAtMzJdICogdztcblx0XHRcdHQgKz0geDFbeDFQb3MgKyAzMl0gKiB3O1xuXHRcdFx0dyA9IGVud2luZG93W3dwICsgLTZdO1xuXHRcdFx0cyArPSB4MVt4MiArIDMyXSAqIHc7XG5cdFx0XHR0ICs9IHgxW3gxUG9zICsgLTMyXSAqIHc7XG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyAtNV07XG5cdFx0XHRzICs9IHgxW3gyICsgOTZdICogdztcblx0XHRcdHQgKz0geDFbeDFQb3MgKyAtOTZdICogdztcblx0XHRcdHcgPSBlbndpbmRvd1t3cCArIC00XTtcblx0XHRcdHMgKz0geDFbeDIgKyAxNjBdICogdztcblx0XHRcdHQgKz0geDFbeDFQb3MgKyAtMTYwXSAqIHc7XG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyAtM107XG5cdFx0XHRzICs9IHgxW3gyICsgMjI0XSAqIHc7XG5cdFx0XHR0ICs9IHgxW3gxUG9zICsgLTIyNF0gKiB3O1xuXG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyAtMl07XG5cdFx0XHRzICs9IHgxW3gxUG9zICsgLTI1Nl0gKiB3O1xuXHRcdFx0dCAtPSB4MVt4MiArIDI1Nl0gKiB3O1xuXHRcdFx0dyA9IGVud2luZG93W3dwICsgLTFdO1xuXHRcdFx0cyArPSB4MVt4MVBvcyArIC0xOTJdICogdztcblx0XHRcdHQgLT0geDFbeDIgKyAxOTJdICogdztcblx0XHRcdHcgPSBlbndpbmRvd1t3cCArIDBdO1xuXHRcdFx0cyArPSB4MVt4MVBvcyArIC0xMjhdICogdztcblx0XHRcdHQgLT0geDFbeDIgKyAxMjhdICogdztcblx0XHRcdHcgPSBlbndpbmRvd1t3cCArIDFdO1xuXHRcdFx0cyArPSB4MVt4MVBvcyArIC02NF0gKiB3O1xuXHRcdFx0dCAtPSB4MVt4MiArIDY0XSAqIHc7XG5cdFx0XHR3ID0gZW53aW5kb3dbd3AgKyAyXTtcblx0XHRcdHMgKz0geDFbeDFQb3MgKyAwXSAqIHc7XG5cdFx0XHR0IC09IHgxW3gyICsgMF0gKiB3O1xuXHRcdFx0dyA9IGVud2luZG93W3dwICsgM107XG5cdFx0XHRzICs9IHgxW3gxUG9zICsgNjRdICogdztcblx0XHRcdHQgLT0geDFbeDIgKyAtNjRdICogdztcblx0XHRcdHcgPSBlbndpbmRvd1t3cCArIDRdO1xuXHRcdFx0cyArPSB4MVt4MVBvcyArIDEyOF0gKiB3O1xuXHRcdFx0dCAtPSB4MVt4MiArIC0xMjhdICogdztcblx0XHRcdHcgPSBlbndpbmRvd1t3cCArIDVdO1xuXHRcdFx0cyArPSB4MVt4MVBvcyArIDE5Ml0gKiB3O1xuXHRcdFx0dCAtPSB4MVt4MiArIC0xOTJdICogdztcblxuXHRcdFx0Lypcblx0XHRcdCAqIHRoaXMgbXVsdGlwbHllciBjb3VsZCBiZSByZW1vdmVkLCBidXQgaXQgbmVlZHMgbW9yZSAyNTYgRkxPQVRcblx0XHRcdCAqIGRhdGEuIHRoaW5raW5nIGFib3V0IHRoZSBkYXRhIGNhY2hlIHBlcmZvcm1hbmNlLCBJIHRoaW5rIHdlXG5cdFx0XHQgKiBzaG91bGQgbm90IHVzZSBzdWNoIGEgaHVnZSB0YWJsZS4gdHQgMjAwMC9PY3QvMjVcblx0XHRcdCAqL1xuXHRcdFx0cyAqPSBlbndpbmRvd1t3cCArIDZdO1xuXHRcdFx0dyA9IHQgLSBzO1xuXHRcdFx0YVszMCArIGkgKiAyXSA9IHQgKyBzO1xuXHRcdFx0YVszMSArIGkgKiAyXSA9IGVud2luZG93W3dwICsgN10gKiB3O1xuXHRcdFx0d3AgKz0gMTg7XG5cdFx0XHR4MVBvcy0tO1xuXHRcdFx0eDIrKztcblx0XHR9XG5cdFx0e1xuXHRcdFx0dmFyIHMsIHQsIHUsIHY7XG5cdFx0XHR0ID0geDFbeDFQb3MgKyAtMTZdICogZW53aW5kb3dbd3AgKyAtMTBdO1xuXHRcdFx0cyA9IHgxW3gxUG9zICsgLTMyXSAqIGVud2luZG93W3dwICsgLTJdO1xuXHRcdFx0dCArPSAoeDFbeDFQb3MgKyAtNDhdIC0geDFbeDFQb3MgKyAxNl0pICogZW53aW5kb3dbd3AgKyAtOV07XG5cdFx0XHRzICs9IHgxW3gxUG9zICsgLTk2XSAqIGVud2luZG93W3dwICsgLTFdO1xuXHRcdFx0dCArPSAoeDFbeDFQb3MgKyAtODBdICsgeDFbeDFQb3MgKyA0OF0pICogZW53aW5kb3dbd3AgKyAtOF07XG5cdFx0XHRzICs9IHgxW3gxUG9zICsgLTE2MF0gKiBlbndpbmRvd1t3cCArIDBdO1xuXHRcdFx0dCArPSAoeDFbeDFQb3MgKyAtMTEyXSAtIHgxW3gxUG9zICsgODBdKSAqIGVud2luZG93W3dwICsgLTddO1xuXHRcdFx0cyArPSB4MVt4MVBvcyArIC0yMjRdICogZW53aW5kb3dbd3AgKyAxXTtcblx0XHRcdHQgKz0gKHgxW3gxUG9zICsgLTE0NF0gKyB4MVt4MVBvcyArIDExMl0pICogZW53aW5kb3dbd3AgKyAtNl07XG5cdFx0XHRzIC09IHgxW3gxUG9zICsgMzJdICogZW53aW5kb3dbd3AgKyAyXTtcblx0XHRcdHQgKz0gKHgxW3gxUG9zICsgLTE3Nl0gLSB4MVt4MVBvcyArIDE0NF0pICogZW53aW5kb3dbd3AgKyAtNV07XG5cdFx0XHRzIC09IHgxW3gxUG9zICsgOTZdICogZW53aW5kb3dbd3AgKyAzXTtcblx0XHRcdHQgKz0gKHgxW3gxUG9zICsgLTIwOF0gKyB4MVt4MVBvcyArIDE3Nl0pICogZW53aW5kb3dbd3AgKyAtNF07XG5cdFx0XHRzIC09IHgxW3gxUG9zICsgMTYwXSAqIGVud2luZG93W3dwICsgNF07XG5cdFx0XHR0ICs9ICh4MVt4MVBvcyArIC0yNDBdIC0geDFbeDFQb3MgKyAyMDhdKSAqIGVud2luZG93W3dwICsgLTNdO1xuXHRcdFx0cyAtPSB4MVt4MVBvcyArIDIyNF07XG5cblx0XHRcdHUgPSBzIC0gdDtcblx0XHRcdHYgPSBzICsgdDtcblxuXHRcdFx0dCA9IGFbMTRdO1xuXHRcdFx0cyA9IGFbMTVdIC0gdDtcblxuXHRcdFx0YVszMV0gPSB2ICsgdDsgLyogQTAgKi9cblx0XHRcdGFbMzBdID0gdSArIHM7IC8qIEExICovXG5cdFx0XHRhWzE1XSA9IHUgLSBzOyAvKiBBMiAqL1xuXHRcdFx0YVsxNF0gPSB2IC0gdDsgLyogQTMgKi9cblx0XHR9XG5cdFx0e1xuXHRcdFx0dmFyIHhyO1xuXHRcdFx0eHIgPSBhWzI4XSAtIGFbMF07XG5cdFx0XHRhWzBdICs9IGFbMjhdO1xuXHRcdFx0YVsyOF0gPSB4ciAqIGVud2luZG93W3dwICsgLTIgKiAxOCArIDddO1xuXHRcdFx0eHIgPSBhWzI5XSAtIGFbMV07XG5cdFx0XHRhWzFdICs9IGFbMjldO1xuXHRcdFx0YVsyOV0gPSB4ciAqIGVud2luZG93W3dwICsgLTIgKiAxOCArIDddO1xuXG5cdFx0XHR4ciA9IGFbMjZdIC0gYVsyXTtcblx0XHRcdGFbMl0gKz0gYVsyNl07XG5cdFx0XHRhWzI2XSA9IHhyICogZW53aW5kb3dbd3AgKyAtNCAqIDE4ICsgN107XG5cdFx0XHR4ciA9IGFbMjddIC0gYVszXTtcblx0XHRcdGFbM10gKz0gYVsyN107XG5cdFx0XHRhWzI3XSA9IHhyICogZW53aW5kb3dbd3AgKyAtNCAqIDE4ICsgN107XG5cblx0XHRcdHhyID0gYVsyNF0gLSBhWzRdO1xuXHRcdFx0YVs0XSArPSBhWzI0XTtcblx0XHRcdGFbMjRdID0geHIgKiBlbndpbmRvd1t3cCArIC02ICogMTggKyA3XTtcblx0XHRcdHhyID0gYVsyNV0gLSBhWzVdO1xuXHRcdFx0YVs1XSArPSBhWzI1XTtcblx0XHRcdGFbMjVdID0geHIgKiBlbndpbmRvd1t3cCArIC02ICogMTggKyA3XTtcblxuXHRcdFx0eHIgPSBhWzIyXSAtIGFbNl07XG5cdFx0XHRhWzZdICs9IGFbMjJdO1xuXHRcdFx0YVsyMl0gPSB4ciAqIFV0aWwkNi5TUVJUMjtcblx0XHRcdHhyID0gYVsyM10gLSBhWzddO1xuXHRcdFx0YVs3XSArPSBhWzIzXTtcblx0XHRcdGFbMjNdID0geHIgKiBVdGlsJDYuU1FSVDIgLSBhWzddO1xuXHRcdFx0YVs3XSAtPSBhWzZdO1xuXHRcdFx0YVsyMl0gLT0gYVs3XTtcblx0XHRcdGFbMjNdIC09IGFbMjJdO1xuXG5cdFx0XHR4ciA9IGFbNl07XG5cdFx0XHRhWzZdID0gYVszMV0gLSB4cjtcblx0XHRcdGFbMzFdID0gYVszMV0gKyB4cjtcblx0XHRcdHhyID0gYVs3XTtcblx0XHRcdGFbN10gPSBhWzMwXSAtIHhyO1xuXHRcdFx0YVszMF0gPSBhWzMwXSArIHhyO1xuXHRcdFx0eHIgPSBhWzIyXTtcblx0XHRcdGFbMjJdID0gYVsxNV0gLSB4cjtcblx0XHRcdGFbMTVdID0gYVsxNV0gKyB4cjtcblx0XHRcdHhyID0gYVsyM107XG5cdFx0XHRhWzIzXSA9IGFbMTRdIC0geHI7XG5cdFx0XHRhWzE0XSA9IGFbMTRdICsgeHI7XG5cblx0XHRcdHhyID0gYVsyMF0gLSBhWzhdO1xuXHRcdFx0YVs4XSArPSBhWzIwXTtcblx0XHRcdGFbMjBdID0geHIgKiBlbndpbmRvd1t3cCArIC0xMCAqIDE4ICsgN107XG5cdFx0XHR4ciA9IGFbMjFdIC0gYVs5XTtcblx0XHRcdGFbOV0gKz0gYVsyMV07XG5cdFx0XHRhWzIxXSA9IHhyICogZW53aW5kb3dbd3AgKyAtMTAgKiAxOCArIDddO1xuXG5cdFx0XHR4ciA9IGFbMThdIC0gYVsxMF07XG5cdFx0XHRhWzEwXSArPSBhWzE4XTtcblx0XHRcdGFbMThdID0geHIgKiBlbndpbmRvd1t3cCArIC0xMiAqIDE4ICsgN107XG5cdFx0XHR4ciA9IGFbMTldIC0gYVsxMV07XG5cdFx0XHRhWzExXSArPSBhWzE5XTtcblx0XHRcdGFbMTldID0geHIgKiBlbndpbmRvd1t3cCArIC0xMiAqIDE4ICsgN107XG5cblx0XHRcdHhyID0gYVsxNl0gLSBhWzEyXTtcblx0XHRcdGFbMTJdICs9IGFbMTZdO1xuXHRcdFx0YVsxNl0gPSB4ciAqIGVud2luZG93W3dwICsgLTE0ICogMTggKyA3XTtcblx0XHRcdHhyID0gYVsxN10gLSBhWzEzXTtcblx0XHRcdGFbMTNdICs9IGFbMTddO1xuXHRcdFx0YVsxN10gPSB4ciAqIGVud2luZG93W3dwICsgLTE0ICogMTggKyA3XTtcblxuXHRcdFx0eHIgPSAtYVsyMF0gKyBhWzI0XTtcblx0XHRcdGFbMjBdICs9IGFbMjRdO1xuXHRcdFx0YVsyNF0gPSB4ciAqIGVud2luZG93W3dwICsgLTEyICogMTggKyA3XTtcblx0XHRcdHhyID0gLWFbMjFdICsgYVsyNV07XG5cdFx0XHRhWzIxXSArPSBhWzI1XTtcblx0XHRcdGFbMjVdID0geHIgKiBlbndpbmRvd1t3cCArIC0xMiAqIDE4ICsgN107XG5cblx0XHRcdHhyID0gYVs0XSAtIGFbOF07XG5cdFx0XHRhWzRdICs9IGFbOF07XG5cdFx0XHRhWzhdID0geHIgKiBlbndpbmRvd1t3cCArIC0xMiAqIDE4ICsgN107XG5cdFx0XHR4ciA9IGFbNV0gLSBhWzldO1xuXHRcdFx0YVs1XSArPSBhWzldO1xuXHRcdFx0YVs5XSA9IHhyICogZW53aW5kb3dbd3AgKyAtMTIgKiAxOCArIDddO1xuXG5cdFx0XHR4ciA9IGFbMF0gLSBhWzEyXTtcblx0XHRcdGFbMF0gKz0gYVsxMl07XG5cdFx0XHRhWzEyXSA9IHhyICogZW53aW5kb3dbd3AgKyAtNCAqIDE4ICsgN107XG5cdFx0XHR4ciA9IGFbMV0gLSBhWzEzXTtcblx0XHRcdGFbMV0gKz0gYVsxM107XG5cdFx0XHRhWzEzXSA9IHhyICogZW53aW5kb3dbd3AgKyAtNCAqIDE4ICsgN107XG5cdFx0XHR4ciA9IGFbMTZdIC0gYVsyOF07XG5cdFx0XHRhWzE2XSArPSBhWzI4XTtcblx0XHRcdGFbMjhdID0geHIgKiBlbndpbmRvd1t3cCArIC00ICogMTggKyA3XTtcblx0XHRcdHhyID0gLWFbMTddICsgYVsyOV07XG5cdFx0XHRhWzE3XSArPSBhWzI5XTtcblx0XHRcdGFbMjldID0geHIgKiBlbndpbmRvd1t3cCArIC00ICogMTggKyA3XTtcblxuXHRcdFx0eHIgPSBVdGlsJDYuU1FSVDIgKiAoYVsyXSAtIGFbMTBdKTtcblx0XHRcdGFbMl0gKz0gYVsxMF07XG5cdFx0XHRhWzEwXSA9IHhyO1xuXHRcdFx0eHIgPSBVdGlsJDYuU1FSVDIgKiAoYVszXSAtIGFbMTFdKTtcblx0XHRcdGFbM10gKz0gYVsxMV07XG5cdFx0XHRhWzExXSA9IHhyO1xuXHRcdFx0eHIgPSBVdGlsJDYuU1FSVDIgKiAoLWFbMThdICsgYVsyNl0pO1xuXHRcdFx0YVsxOF0gKz0gYVsyNl07XG5cdFx0XHRhWzI2XSA9IHhyIC0gYVsxOF07XG5cdFx0XHR4ciA9IFV0aWwkNi5TUVJUMiAqICgtYVsxOV0gKyBhWzI3XSk7XG5cdFx0XHRhWzE5XSArPSBhWzI3XTtcblx0XHRcdGFbMjddID0geHIgLSBhWzE5XTtcblxuXHRcdFx0eHIgPSBhWzJdO1xuXHRcdFx0YVsxOV0gLT0gYVszXTtcblx0XHRcdGFbM10gLT0geHI7XG5cdFx0XHRhWzJdID0gYVszMV0gLSB4cjtcblx0XHRcdGFbMzFdICs9IHhyO1xuXHRcdFx0eHIgPSBhWzNdO1xuXHRcdFx0YVsxMV0gLT0gYVsxOV07XG5cdFx0XHRhWzE4XSAtPSB4cjtcblx0XHRcdGFbM10gPSBhWzMwXSAtIHhyO1xuXHRcdFx0YVszMF0gKz0geHI7XG5cdFx0XHR4ciA9IGFbMThdO1xuXHRcdFx0YVsyN10gLT0gYVsxMV07XG5cdFx0XHRhWzE5XSAtPSB4cjtcblx0XHRcdGFbMThdID0gYVsxNV0gLSB4cjtcblx0XHRcdGFbMTVdICs9IHhyO1xuXG5cdFx0XHR4ciA9IGFbMTldO1xuXHRcdFx0YVsxMF0gLT0geHI7XG5cdFx0XHRhWzE5XSA9IGFbMTRdIC0geHI7XG5cdFx0XHRhWzE0XSArPSB4cjtcblx0XHRcdHhyID0gYVsxMF07XG5cdFx0XHRhWzExXSAtPSB4cjtcblx0XHRcdGFbMTBdID0gYVsyM10gLSB4cjtcblx0XHRcdGFbMjNdICs9IHhyO1xuXHRcdFx0eHIgPSBhWzExXTtcblx0XHRcdGFbMjZdIC09IHhyO1xuXHRcdFx0YVsxMV0gPSBhWzIyXSAtIHhyO1xuXHRcdFx0YVsyMl0gKz0geHI7XG5cdFx0XHR4ciA9IGFbMjZdO1xuXHRcdFx0YVsyN10gLT0geHI7XG5cdFx0XHRhWzI2XSA9IGFbN10gLSB4cjtcblx0XHRcdGFbN10gKz0geHI7XG5cblx0XHRcdHhyID0gYVsyN107XG5cdFx0XHRhWzI3XSA9IGFbNl0gLSB4cjtcblx0XHRcdGFbNl0gKz0geHI7XG5cblx0XHRcdHhyID0gVXRpbCQ2LlNRUlQyICogKGFbMF0gLSBhWzRdKTtcblx0XHRcdGFbMF0gKz0gYVs0XTtcblx0XHRcdGFbNF0gPSB4cjtcblx0XHRcdHhyID0gVXRpbCQ2LlNRUlQyICogKGFbMV0gLSBhWzVdKTtcblx0XHRcdGFbMV0gKz0gYVs1XTtcblx0XHRcdGFbNV0gPSB4cjtcblx0XHRcdHhyID0gVXRpbCQ2LlNRUlQyICogKGFbMTZdIC0gYVsyMF0pO1xuXHRcdFx0YVsxNl0gKz0gYVsyMF07XG5cdFx0XHRhWzIwXSA9IHhyO1xuXHRcdFx0eHIgPSBVdGlsJDYuU1FSVDIgKiAoYVsxN10gLSBhWzIxXSk7XG5cdFx0XHRhWzE3XSArPSBhWzIxXTtcblx0XHRcdGFbMjFdID0geHI7XG5cblx0XHRcdHhyID0gLVV0aWwkNi5TUVJUMiAqIChhWzhdIC0gYVsxMl0pO1xuXHRcdFx0YVs4XSArPSBhWzEyXTtcblx0XHRcdGFbMTJdID0geHIgLSBhWzhdO1xuXHRcdFx0eHIgPSAtVXRpbCQ2LlNRUlQyICogKGFbOV0gLSBhWzEzXSk7XG5cdFx0XHRhWzldICs9IGFbMTNdO1xuXHRcdFx0YVsxM10gPSB4ciAtIGFbOV07XG5cdFx0XHR4ciA9IC1VdGlsJDYuU1FSVDIgKiAoYVsyNV0gLSBhWzI5XSk7XG5cdFx0XHRhWzI1XSArPSBhWzI5XTtcblx0XHRcdGFbMjldID0geHIgLSBhWzI1XTtcblx0XHRcdHhyID0gLVV0aWwkNi5TUVJUMiAqIChhWzI0XSArIGFbMjhdKTtcblx0XHRcdGFbMjRdIC09IGFbMjhdO1xuXHRcdFx0YVsyOF0gPSB4ciAtIGFbMjRdO1xuXG5cdFx0XHR4ciA9IGFbMjRdIC0gYVsxNl07XG5cdFx0XHRhWzI0XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzIwXSAtIHhyO1xuXHRcdFx0YVsyMF0gPSB4cjtcblx0XHRcdHhyID0gYVsyOF0gLSB4cjtcblx0XHRcdGFbMjhdID0geHI7XG5cblx0XHRcdHhyID0gYVsyNV0gLSBhWzE3XTtcblx0XHRcdGFbMjVdID0geHI7XG5cdFx0XHR4ciA9IGFbMjFdIC0geHI7XG5cdFx0XHRhWzIxXSA9IHhyO1xuXHRcdFx0eHIgPSBhWzI5XSAtIHhyO1xuXHRcdFx0YVsyOV0gPSB4cjtcblxuXHRcdFx0eHIgPSBhWzE3XSAtIGFbMV07XG5cdFx0XHRhWzE3XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzldIC0geHI7XG5cdFx0XHRhWzldID0geHI7XG5cdFx0XHR4ciA9IGFbMjVdIC0geHI7XG5cdFx0XHRhWzI1XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzVdIC0geHI7XG5cdFx0XHRhWzVdID0geHI7XG5cdFx0XHR4ciA9IGFbMjFdIC0geHI7XG5cdFx0XHRhWzIxXSA9IHhyO1xuXHRcdFx0eHIgPSBhWzEzXSAtIHhyO1xuXHRcdFx0YVsxM10gPSB4cjtcblx0XHRcdHhyID0gYVsyOV0gLSB4cjtcblx0XHRcdGFbMjldID0geHI7XG5cblx0XHRcdHhyID0gYVsxXSAtIGFbMF07XG5cdFx0XHRhWzFdID0geHI7XG5cdFx0XHR4ciA9IGFbMTZdIC0geHI7XG5cdFx0XHRhWzE2XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzE3XSAtIHhyO1xuXHRcdFx0YVsxN10gPSB4cjtcblx0XHRcdHhyID0gYVs4XSAtIHhyO1xuXHRcdFx0YVs4XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzldIC0geHI7XG5cdFx0XHRhWzldID0geHI7XG5cdFx0XHR4ciA9IGFbMjRdIC0geHI7XG5cdFx0XHRhWzI0XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzI1XSAtIHhyO1xuXHRcdFx0YVsyNV0gPSB4cjtcblx0XHRcdHhyID0gYVs0XSAtIHhyO1xuXHRcdFx0YVs0XSA9IHhyO1xuXHRcdFx0eHIgPSBhWzVdIC0geHI7XG5cdFx0XHRhWzVdID0geHI7XG5cdFx0XHR4ciA9IGFbMjBdIC0geHI7XG5cdFx0XHRhWzIwXSA9IHhyO1xuXHRcdFx0eHIgPSBhWzIxXSAtIHhyO1xuXHRcdFx0YVsyMV0gPSB4cjtcblx0XHRcdHhyID0gYVsxMl0gLSB4cjtcblx0XHRcdGFbMTJdID0geHI7XG5cdFx0XHR4ciA9IGFbMTNdIC0geHI7XG5cdFx0XHRhWzEzXSA9IHhyO1xuXHRcdFx0eHIgPSBhWzI4XSAtIHhyO1xuXHRcdFx0YVsyOF0gPSB4cjtcblx0XHRcdHhyID0gYVsyOV0gLSB4cjtcblx0XHRcdGFbMjldID0geHI7XG5cblx0XHRcdHhyID0gYVswXTtcblx0XHRcdGFbMF0gKz0gYVszMV07XG5cdFx0XHRhWzMxXSAtPSB4cjtcblx0XHRcdHhyID0gYVsxXTtcblx0XHRcdGFbMV0gKz0gYVszMF07XG5cdFx0XHRhWzMwXSAtPSB4cjtcblx0XHRcdHhyID0gYVsxNl07XG5cdFx0XHRhWzE2XSArPSBhWzE1XTtcblx0XHRcdGFbMTVdIC09IHhyO1xuXHRcdFx0eHIgPSBhWzE3XTtcblx0XHRcdGFbMTddICs9IGFbMTRdO1xuXHRcdFx0YVsxNF0gLT0geHI7XG5cdFx0XHR4ciA9IGFbOF07XG5cdFx0XHRhWzhdICs9IGFbMjNdO1xuXHRcdFx0YVsyM10gLT0geHI7XG5cdFx0XHR4ciA9IGFbOV07XG5cdFx0XHRhWzldICs9IGFbMjJdO1xuXHRcdFx0YVsyMl0gLT0geHI7XG5cdFx0XHR4ciA9IGFbMjRdO1xuXHRcdFx0YVsyNF0gKz0gYVs3XTtcblx0XHRcdGFbN10gLT0geHI7XG5cdFx0XHR4ciA9IGFbMjVdO1xuXHRcdFx0YVsyNV0gKz0gYVs2XTtcblx0XHRcdGFbNl0gLT0geHI7XG5cdFx0XHR4ciA9IGFbNF07XG5cdFx0XHRhWzRdICs9IGFbMjddO1xuXHRcdFx0YVsyN10gLT0geHI7XG5cdFx0XHR4ciA9IGFbNV07XG5cdFx0XHRhWzVdICs9IGFbMjZdO1xuXHRcdFx0YVsyNl0gLT0geHI7XG5cdFx0XHR4ciA9IGFbMjBdO1xuXHRcdFx0YVsyMF0gKz0gYVsxMV07XG5cdFx0XHRhWzExXSAtPSB4cjtcblx0XHRcdHhyID0gYVsyMV07XG5cdFx0XHRhWzIxXSArPSBhWzEwXTtcblx0XHRcdGFbMTBdIC09IHhyO1xuXHRcdFx0eHIgPSBhWzEyXTtcblx0XHRcdGFbMTJdICs9IGFbMTldO1xuXHRcdFx0YVsxOV0gLT0geHI7XG5cdFx0XHR4ciA9IGFbMTNdO1xuXHRcdFx0YVsxM10gKz0gYVsxOF07XG5cdFx0XHRhWzE4XSAtPSB4cjtcblx0XHRcdHhyID0gYVsyOF07XG5cdFx0XHRhWzI4XSArPSBhWzNdO1xuXHRcdFx0YVszXSAtPSB4cjtcblx0XHRcdHhyID0gYVsyOV07XG5cdFx0XHRhWzI5XSArPSBhWzJdO1xuXHRcdFx0YVsyXSAtPSB4cjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRnVuY3Rpb246IENhbGN1bGF0aW9uIG9mIHRoZSBNRENUIEluIHRoZSBjYXNlIG9mIGxvbmcgYmxvY2tzICh0eXBlIDAsMSwzKVxuXHQgKiB0aGVyZSBhcmUgMzYgY29lZmZpY2VudHMgaW4gdGhlIHRpbWUgZG9tYWluIGFuZCAxOCBpbiB0aGUgZnJlcXVlbmN5XG5cdCAqIGRvbWFpbi48QlI+XG5cdCAqIEluIHRoZSBjYXNlIG9mIHNob3J0IGJsb2NrcyAodHlwZSAyKSB0aGVyZSBhcmUgMyB0cmFuc2Zvcm1hdGlvbnMgd2l0aFxuXHQgKiBzaG9ydCBsZW5ndGguIFRoaXMgbGVhZHMgdG8gMTIgY29lZmZpY2VudHMgaW4gdGhlIHRpbWUgYW5kIDYgaW4gdGhlXG5cdCAqIGZyZXF1ZW5jeSBkb21haW4uIEluIHRoaXMgY2FzZSB0aGUgcmVzdWx0cyBhcmUgc3RvcmVkIHNpZGUgYnkgc2lkZSBpbiB0aGVcblx0ICogdmVjdG9yIG91dFtdLlxuXHQgKlxuXHQgKiBOZXcgbGF5ZXIzXG5cdCAqL1xuXHRmdW5jdGlvbiBtZGN0X3Nob3J0KGlub3V0LCBpbm91dFBvcykge1xuXHRcdGZvciAodmFyIGwgPSAwOyBsIDwgMzsgbCsrKSB7XG5cdFx0XHR2YXIgdGMwLCB0YzEsIHRjMiwgdHMwLCB0czEsIHRzMjtcblxuXHRcdFx0dHMwID0gaW5vdXRbaW5vdXRQb3MgKyAyICogM10gKiB3aW5bRW5jb2Rlcl8xLlNIT1JUX1RZUEVdWzBdXG5cdFx0XHRcdFx0LSBpbm91dFtpbm91dFBvcyArIDUgKiAzXTtcblx0XHRcdHRjMCA9IGlub3V0W2lub3V0UG9zICsgMCAqIDNdICogd2luW0VuY29kZXJfMS5TSE9SVF9UWVBFXVsyXVxuXHRcdFx0XHRcdC0gaW5vdXRbaW5vdXRQb3MgKyAzICogM107XG5cdFx0XHR0YzEgPSB0czAgKyB0YzA7XG5cdFx0XHR0YzIgPSB0czAgLSB0YzA7XG5cblx0XHRcdHRzMCA9IGlub3V0W2lub3V0UG9zICsgNSAqIDNdICogd2luW0VuY29kZXJfMS5TSE9SVF9UWVBFXVswXVxuXHRcdFx0XHRcdCsgaW5vdXRbaW5vdXRQb3MgKyAyICogM107XG5cdFx0XHR0YzAgPSBpbm91dFtpbm91dFBvcyArIDMgKiAzXSAqIHdpbltFbmNvZGVyXzEuU0hPUlRfVFlQRV1bMl1cblx0XHRcdFx0XHQrIGlub3V0W2lub3V0UG9zICsgMCAqIDNdO1xuXHRcdFx0dHMxID0gdHMwICsgdGMwO1xuXHRcdFx0dHMyID0gLXRzMCArIHRjMDtcblxuXHRcdFx0dGMwID0gKGlub3V0W2lub3V0UG9zICsgMSAqIDNdICogd2luW0VuY29kZXJfMS5TSE9SVF9UWVBFXVsxXSAtIGlub3V0W2lub3V0UG9zICsgNCAqIDNdKSAqIDIuMDY5OTc4MTExOTUzMDg5ZS0xMTtcblx0XHRcdC8qXG5cdFx0XHQgKiB0cml0YWJfcyBbIDEgXVxuXHRcdFx0ICovXG5cdFx0XHR0czAgPSAoaW5vdXRbaW5vdXRQb3MgKyA0ICogM10gKiB3aW5bRW5jb2Rlcl8xLlNIT1JUX1RZUEVdWzFdICsgaW5vdXRbaW5vdXRQb3MgKyAxICogM10pICogMi4wNjk5NzgxMTE5NTMwODllLTExO1xuXHRcdFx0Lypcblx0XHRcdCAqIHRyaXRhYl9zIFsgMSBdXG5cdFx0XHQgKi9cblx0XHRcdGlub3V0W2lub3V0UG9zICsgMyAqIDBdID0gdGMxICogMS45MDc1MjUxOTE3MzcyODBlLTExICsgdGMwO1xuXHRcdFx0Lypcblx0XHRcdCAqIHRyaXRhYl9zWyAyIF1cblx0XHRcdCAqL1xuXHRcdFx0aW5vdXRbaW5vdXRQb3MgKyAzICogNV0gPSAtdHMxICogMS45MDc1MjUxOTE3MzcyODBlLTExICsgdHMwO1xuXHRcdFx0Lypcblx0XHRcdCAqIHRyaXRhYl9zWzAgXVxuXHRcdFx0ICovXG5cdFx0XHR0YzIgPSB0YzIgKiAwLjg2NjAyNTQwMzc4NDQzODcwNzYxICogMS45MDc1MjUxOTE3MzcyODFlLTExO1xuXHRcdFx0Lypcblx0XHRcdCAqIHRyaXRhYl9zWyAyXVxuXHRcdFx0ICovXG5cdFx0XHR0czEgPSB0czEgKiAwLjUgKiAxLjkwNzUyNTE5MTczNzI4MWUtMTEgKyB0czA7XG5cdFx0XHRpbm91dFtpbm91dFBvcyArIDMgKiAxXSA9IHRjMiAtIHRzMTtcblx0XHRcdGlub3V0W2lub3V0UG9zICsgMyAqIDJdID0gdGMyICsgdHMxO1xuXG5cdFx0XHR0YzEgPSB0YzEgKiAwLjUgKiAxLjkwNzUyNTE5MTczNzI4MWUtMTEgLSB0YzA7XG5cdFx0XHR0czIgPSB0czIgKiAwLjg2NjAyNTQwMzc4NDQzODcwNzYxICogMS45MDc1MjUxOTE3MzcyODFlLTExO1xuXHRcdFx0Lypcblx0XHRcdCAqIHRyaXRhYl9zWyAwXVxuXHRcdFx0ICovXG5cdFx0XHRpbm91dFtpbm91dFBvcyArIDMgKiAzXSA9IHRjMSArIHRzMjtcblx0XHRcdGlub3V0W2lub3V0UG9zICsgMyAqIDRdID0gdGMxIC0gdHMyO1xuXG5cdFx0XHRpbm91dFBvcysrO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1kY3RfbG9uZyhvdXQsIG91dFBvcywgX2luKSB7XG5cdFx0dmFyIGN0LCBzdDtcblx0XHR7XG5cdFx0XHR2YXIgdGMxLCB0YzIsIHRjMywgdGM0LCB0czUsIHRzNiwgdHM3LCB0czg7XG5cdFx0XHQvKiAxLDIsIDUsNiwgOSwxMCwgMTMsMTQsIDE3ICovXG5cdFx0XHR0YzEgPSBfaW5bMTddIC0gX2luWzldO1xuXHRcdFx0dGMzID0gX2luWzE1XSAtIF9pblsxMV07XG5cdFx0XHR0YzQgPSBfaW5bMTRdIC0gX2luWzEyXTtcblx0XHRcdHRzNSA9IF9pblswXSArIF9pbls4XTtcblx0XHRcdHRzNiA9IF9pblsxXSArIF9pbls3XTtcblx0XHRcdHRzNyA9IF9pblsyXSArIF9pbls2XTtcblx0XHRcdHRzOCA9IF9pblszXSArIF9pbls1XTtcblxuXHRcdFx0b3V0W291dFBvcyArIDE3XSA9ICh0czUgKyB0czcgLSB0czgpIC0gKHRzNiAtIF9pbls0XSk7XG5cdFx0XHRzdCA9ICh0czUgKyB0czcgLSB0czgpICogY3hbMTIgKyA3XSArICh0czYgLSBfaW5bNF0pO1xuXHRcdFx0Y3QgPSAodGMxIC0gdGMzIC0gdGM0KSAqIGN4WzEyICsgNl07XG5cdFx0XHRvdXRbb3V0UG9zICsgNV0gPSBjdCArIHN0O1xuXHRcdFx0b3V0W291dFBvcyArIDZdID0gY3QgLSBzdDtcblxuXHRcdFx0dGMyID0gKF9pblsxNl0gLSBfaW5bMTBdKSAqIGN4WzEyICsgNl07XG5cdFx0XHR0czYgPSB0czYgKiBjeFsxMiArIDddICsgX2luWzRdO1xuXHRcdFx0Y3QgPSB0YzEgKiBjeFsxMiArIDBdICsgdGMyICsgdGMzICogY3hbMTIgKyAxXSArIHRjNCAqIGN4WzEyICsgMl07XG5cdFx0XHRzdCA9IC10czUgKiBjeFsxMiArIDRdICsgdHM2IC0gdHM3ICogY3hbMTIgKyA1XSArIHRzOCAqIGN4WzEyICsgM107XG5cdFx0XHRvdXRbb3V0UG9zICsgMV0gPSBjdCArIHN0O1xuXHRcdFx0b3V0W291dFBvcyArIDJdID0gY3QgLSBzdDtcblxuXHRcdFx0Y3QgPSB0YzEgKiBjeFsxMiArIDFdIC0gdGMyIC0gdGMzICogY3hbMTIgKyAyXSArIHRjNCAqIGN4WzEyICsgMF07XG5cdFx0XHRzdCA9IC10czUgKiBjeFsxMiArIDVdICsgdHM2IC0gdHM3ICogY3hbMTIgKyAzXSArIHRzOCAqIGN4WzEyICsgNF07XG5cdFx0XHRvdXRbb3V0UG9zICsgOV0gPSBjdCArIHN0O1xuXHRcdFx0b3V0W291dFBvcyArIDEwXSA9IGN0IC0gc3Q7XG5cblx0XHRcdGN0ID0gdGMxICogY3hbMTIgKyAyXSAtIHRjMiArIHRjMyAqIGN4WzEyICsgMF0gLSB0YzQgKiBjeFsxMiArIDFdO1xuXHRcdFx0c3QgPSB0czUgKiBjeFsxMiArIDNdIC0gdHM2ICsgdHM3ICogY3hbMTIgKyA0XSAtIHRzOCAqIGN4WzEyICsgNV07XG5cdFx0XHRvdXRbb3V0UG9zICsgMTNdID0gY3QgKyBzdDtcblx0XHRcdG91dFtvdXRQb3MgKyAxNF0gPSBjdCAtIHN0O1xuXHRcdH1cblx0XHR7XG5cdFx0XHR2YXIgdHMxLCB0czIsIHRzMywgdHM0LCB0YzUsIHRjNiwgdGM3LCB0Yzg7XG5cblx0XHRcdHRzMSA9IF9pbls4XSAtIF9pblswXTtcblx0XHRcdHRzMyA9IF9pbls2XSAtIF9pblsyXTtcblx0XHRcdHRzNCA9IF9pbls1XSAtIF9pblszXTtcblx0XHRcdHRjNSA9IF9pblsxN10gKyBfaW5bOV07XG5cdFx0XHR0YzYgPSBfaW5bMTZdICsgX2luWzEwXTtcblx0XHRcdHRjNyA9IF9pblsxNV0gKyBfaW5bMTFdO1xuXHRcdFx0dGM4ID0gX2luWzE0XSArIF9pblsxMl07XG5cblx0XHRcdG91dFtvdXRQb3MgKyAwXSA9ICh0YzUgKyB0YzcgKyB0YzgpICsgKHRjNiArIF9pblsxM10pO1xuXHRcdFx0Y3QgPSAodGM1ICsgdGM3ICsgdGM4KSAqIGN4WzEyICsgN10gLSAodGM2ICsgX2luWzEzXSk7XG5cdFx0XHRzdCA9ICh0czEgLSB0czMgKyB0czQpICogY3hbMTIgKyA2XTtcblx0XHRcdG91dFtvdXRQb3MgKyAxMV0gPSBjdCArIHN0O1xuXHRcdFx0b3V0W291dFBvcyArIDEyXSA9IGN0IC0gc3Q7XG5cblx0XHRcdHRzMiA9IChfaW5bN10gLSBfaW5bMV0pICogY3hbMTIgKyA2XTtcblx0XHRcdHRjNiA9IF9pblsxM10gLSB0YzYgKiBjeFsxMiArIDddO1xuXHRcdFx0Y3QgPSB0YzUgKiBjeFsxMiArIDNdIC0gdGM2ICsgdGM3ICogY3hbMTIgKyA0XSArIHRjOCAqIGN4WzEyICsgNV07XG5cdFx0XHRzdCA9IHRzMSAqIGN4WzEyICsgMl0gKyB0czIgKyB0czMgKiBjeFsxMiArIDBdICsgdHM0ICogY3hbMTIgKyAxXTtcblx0XHRcdG91dFtvdXRQb3MgKyAzXSA9IGN0ICsgc3Q7XG5cdFx0XHRvdXRbb3V0UG9zICsgNF0gPSBjdCAtIHN0O1xuXG5cdFx0XHRjdCA9IC10YzUgKiBjeFsxMiArIDVdICsgdGM2IC0gdGM3ICogY3hbMTIgKyAzXSAtIHRjOCAqIGN4WzEyICsgNF07XG5cdFx0XHRzdCA9IHRzMSAqIGN4WzEyICsgMV0gKyB0czIgLSB0czMgKiBjeFsxMiArIDJdIC0gdHM0ICogY3hbMTIgKyAwXTtcblx0XHRcdG91dFtvdXRQb3MgKyA3XSA9IGN0ICsgc3Q7XG5cdFx0XHRvdXRbb3V0UG9zICsgOF0gPSBjdCAtIHN0O1xuXG5cdFx0XHRjdCA9IC10YzUgKiBjeFsxMiArIDRdICsgdGM2IC0gdGM3ICogY3hbMTIgKyA1XSAtIHRjOCAqIGN4WzEyICsgM107XG5cdFx0XHRzdCA9IHRzMSAqIGN4WzEyICsgMF0gLSB0czIgKyB0czMgKiBjeFsxMiArIDFdIC0gdHM0ICogY3hbMTIgKyAyXTtcblx0XHRcdG91dFtvdXRQb3MgKyAxNV0gPSBjdCArIHN0O1xuXHRcdFx0b3V0W291dFBvcyArIDE2XSA9IGN0IC0gc3Q7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5tZGN0X3N1YjQ4ID0gZnVuY3Rpb24oZ2ZjLCB3MCwgdzEpIHtcblx0XHR2YXIgd2sgPSB3MDtcblx0XHR2YXIgd2tQb3MgPSAyODY7XG5cdFx0LyogdGhpbmtpbmcgY2FjaGUgcGVyZm9ybWFuY2UsIGNoLT5nciBsb29wIGlzIGJldHRlciB0aGFuIGdyLT5jaCBsb29wICovXG5cdFx0Zm9yICh2YXIgY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcblx0XHRcdGZvciAodmFyIGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuXHRcdFx0XHR2YXIgYmFuZDtcblx0XHRcdFx0dmFyIGdpID0gKGdmYy5sM19zaWRlLnR0W2dyXVtjaF0pO1xuXHRcdFx0XHR2YXIgbWRjdF9lbmMgPSBnaS54cjtcblx0XHRcdFx0dmFyIG1kY3RfZW5jUG9zID0gMDtcblx0XHRcdFx0dmFyIHNhbXAgPSBnZmMuc2Jfc2FtcGxlW2NoXVsxIC0gZ3JdO1xuXHRcdFx0XHR2YXIgc2FtcFBvcyA9IDA7XG5cblx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCAxOCAvIDI7IGsrKykge1xuXHRcdFx0XHRcdHdpbmRvd19zdWJiYW5kKHdrLCB3a1Bvcywgc2FtcFtzYW1wUG9zXSk7XG5cdFx0XHRcdFx0d2luZG93X3N1YmJhbmQod2ssIHdrUG9zICsgMzIsIHNhbXBbc2FtcFBvcyArIDFdKTtcblx0XHRcdFx0XHRzYW1wUG9zICs9IDI7XG5cdFx0XHRcdFx0d2tQb3MgKz0gNjQ7XG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHQgKiBDb21wZW5zYXRlIGZvciBpbnZlcnNpb24gaW4gdGhlIGFuYWx5c2lzIGZpbHRlclxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdGZvciAoYmFuZCA9IDE7IGJhbmQgPCAzMjsgYmFuZCArPSAyKSB7XG5cdFx0XHRcdFx0XHRzYW1wW3NhbXBQb3MgLSAxXVtiYW5kXSAqPSAtMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKlxuXHRcdFx0XHQgKiBQZXJmb3JtIGltZGN0IG9mIDE4IHByZXZpb3VzIHN1YmJhbmQgc2FtcGxlcyArIDE4IGN1cnJlbnRcblx0XHRcdFx0ICogc3ViYmFuZCBzYW1wbGVzXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRmb3IgKGJhbmQgPSAwOyBiYW5kIDwgMzI7IGJhbmQrKywgbWRjdF9lbmNQb3MgKz0gMTgpIHtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IGdpLmJsb2NrX3R5cGU7XG5cdFx0XHRcdFx0dmFyIGJhbmQwID0gZ2ZjLnNiX3NhbXBsZVtjaF1bZ3JdO1xuXHRcdFx0XHRcdHZhciBiYW5kMSA9IGdmYy5zYl9zYW1wbGVbY2hdWzEgLSBncl07XG5cdFx0XHRcdFx0aWYgKGdpLm1peGVkX2Jsb2NrX2ZsYWcgIT0gMCAmJiBiYW5kIDwgMilcblx0XHRcdFx0XHRcdHR5cGUgPSAwO1xuXHRcdFx0XHRcdGlmIChnZmMuYW1wX2ZpbHRlcltiYW5kXSA8IDFlLTEyKSB7XG5cdFx0XHRcdFx0XHRBcnJheXMkNi5maWxsKG1kY3RfZW5jLCBtZGN0X2VuY1BvcyArIDAsXG5cdFx0XHRcdFx0XHRcdFx0bWRjdF9lbmNQb3MgKyAxOCwgMCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChnZmMuYW1wX2ZpbHRlcltiYW5kXSA8IDEuMCkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IDE4OyBrKyspXG5cdFx0XHRcdFx0XHRcdFx0YmFuZDFba11bb3JkZXJbYmFuZF1dICo9IGdmYy5hbXBfZmlsdGVyW2JhbmRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHR5cGUgPT0gRW5jb2Rlcl8xLlNIT1JUX1RZUEUpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IC1OUyAvIDQ7IGsgPCAwOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgdyA9IHdpbltFbmNvZGVyXzEuU0hPUlRfVFlQRV1bayArIDNdO1xuXHRcdFx0XHRcdFx0XHRcdG1kY3RfZW5jW21kY3RfZW5jUG9zICsgayAqIDMgKyA5XSA9IGJhbmQwWzkgKyBrXVtvcmRlcltiYW5kXV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0KiB3IC0gYmFuZDBbOCAtIGtdW29yZGVyW2JhbmRdXTtcblx0XHRcdFx0XHRcdFx0XHRtZGN0X2VuY1ttZGN0X2VuY1BvcyArIGsgKiAzICsgMThdID0gYmFuZDBbMTQgLSBrXVtvcmRlcltiYW5kXV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0KiB3ICsgYmFuZDBbMTUgKyBrXVtvcmRlcltiYW5kXV07XG5cdFx0XHRcdFx0XHRcdFx0bWRjdF9lbmNbbWRjdF9lbmNQb3MgKyBrICogMyArIDEwXSA9IGJhbmQwWzE1ICsga11bb3JkZXJbYmFuZF1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCogdyAtIGJhbmQwWzE0IC0ga11bb3JkZXJbYmFuZF1dO1xuXHRcdFx0XHRcdFx0XHRcdG1kY3RfZW5jW21kY3RfZW5jUG9zICsgayAqIDMgKyAxOV0gPSBiYW5kMVsyIC0ga11bb3JkZXJbYmFuZF1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCogdyArIGJhbmQxWzMgKyBrXVtvcmRlcltiYW5kXV07XG5cdFx0XHRcdFx0XHRcdFx0bWRjdF9lbmNbbWRjdF9lbmNQb3MgKyBrICogMyArIDExXSA9IGJhbmQxWzMgKyBrXVtvcmRlcltiYW5kXV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0KiB3IC0gYmFuZDFbMiAtIGtdW29yZGVyW2JhbmRdXTtcblx0XHRcdFx0XHRcdFx0XHRtZGN0X2VuY1ttZGN0X2VuY1BvcyArIGsgKiAzICsgMjBdID0gYmFuZDFbOCAtIGtdW29yZGVyW2JhbmRdXVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQqIHcgKyBiYW5kMVs5ICsga11bb3JkZXJbYmFuZF1dO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdG1kY3Rfc2hvcnQobWRjdF9lbmMsIG1kY3RfZW5jUG9zKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciB3b3JrID0gbmV3X2Zsb2F0JDYoMTgpO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gLU5MIC8gNDsgayA8IDA7IGsrKykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBhLCBiO1xuXHRcdFx0XHRcdFx0XHRcdGEgPSB3aW5bdHlwZV1bayArIDI3XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQqIGJhbmQxW2sgKyA5XVtvcmRlcltiYW5kXV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0KyB3aW5bdHlwZV1bayArIDM2XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQqIGJhbmQxWzggLSBrXVtvcmRlcltiYW5kXV07XG5cdFx0XHRcdFx0XHRcdFx0YiA9IHdpblt0eXBlXVtrICsgOV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0KiBiYW5kMFtrICsgOV1bb3JkZXJbYmFuZF1dXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC0gd2luW3R5cGVdW2sgKyAxOF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0KiBiYW5kMFs4IC0ga11bb3JkZXJbYmFuZF1dO1xuXHRcdFx0XHRcdFx0XHRcdHdvcmtbayArIDldID0gYSAtIGIgKiB0YW50YWJfbFszICsgayArIDldO1xuXHRcdFx0XHRcdFx0XHRcdHdvcmtbayArIDE4XSA9IGEgKiB0YW50YWJfbFszICsgayArIDldICsgYjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdG1kY3RfbG9uZyhtZGN0X2VuYywgbWRjdF9lbmNQb3MsIHdvcmspO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdCAqIFBlcmZvcm0gYWxpYXNpbmcgcmVkdWN0aW9uIGJ1dHRlcmZseVxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdGlmICh0eXBlICE9IEVuY29kZXJfMS5TSE9SVF9UWVBFICYmIGJhbmQgIT0gMCkge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDc7IGsgPj0gMDsgLS1rKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBidSwgYmQ7XG5cdFx0XHRcdFx0XHRcdGJ1ID0gbWRjdF9lbmNbbWRjdF9lbmNQb3MgKyBrXSAqIGNhWzIwICsga11cblx0XHRcdFx0XHRcdFx0XHRcdCsgbWRjdF9lbmNbbWRjdF9lbmNQb3MgKyAtMSAtIGtdXG5cdFx0XHRcdFx0XHRcdFx0XHQqIGNzWzI4ICsga107XG5cdFx0XHRcdFx0XHRcdGJkID0gbWRjdF9lbmNbbWRjdF9lbmNQb3MgKyBrXSAqIGNzWzI4ICsga11cblx0XHRcdFx0XHRcdFx0XHRcdC0gbWRjdF9lbmNbbWRjdF9lbmNQb3MgKyAtMSAtIGtdXG5cdFx0XHRcdFx0XHRcdFx0XHQqIGNhWzIwICsga107XG5cblx0XHRcdFx0XHRcdFx0bWRjdF9lbmNbbWRjdF9lbmNQb3MgKyAtMSAtIGtdID0gYnU7XG5cdFx0XHRcdFx0XHRcdG1kY3RfZW5jW21kY3RfZW5jUG9zICsga10gPSBiZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdrID0gdzE7XG5cdFx0XHR3a1BvcyA9IDI4Njtcblx0XHRcdGlmIChnZmMubW9kZV9nciA9PSAxKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTg7IGkrKykge1xuXHRcdFx0XHRcdFN5c3RlbSQ2LmFycmF5Y29weShnZmMuc2Jfc2FtcGxlW2NoXVsxXVtpXSwgMCxcblx0XHRcdFx0XHRcdFx0Z2ZjLnNiX3NhbXBsZVtjaF1bMF1baV0sIDAsIDMyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxudmFyIE5ld01EQ1RfMSA9IE5ld01EQ1Q7XG5cbnZhciBTeXN0ZW0kNyA9IGNvbW1vbi5TeXN0ZW07XG52YXIgbmV3X2Zsb2F0JDcgPSBjb21tb24ubmV3X2Zsb2F0O1xudmFyIG5ld19mbG9hdF9uJDcgPSBjb21tb24ubmV3X2Zsb2F0X247XG5mdW5jdGlvbiBJSUlfcHN5X3htaW4oKSB7XG4gICAgdGhpcy5sID0gbmV3X2Zsb2F0JDcoRW5jb2Rlcl8xLlNCTUFYX2wpO1xuICAgIHRoaXMucyA9IG5ld19mbG9hdF9uJDcoW0VuY29kZXJfMS5TQk1BWF9zLCAzXSk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5hc3NpZ24gPSBmdW5jdGlvbiAoaWlpX3BzeV94bWluKSB7XG4gICAgICAgIFN5c3RlbSQ3LmFycmF5Y29weShpaWlfcHN5X3htaW4ubCwgMCwgc2VsZi5sLCAwLCBFbmNvZGVyXzEuU0JNQVhfbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRW5jb2Rlcl8xLlNCTUFYX3M7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNbaV1bal0gPSBpaWlfcHN5X3htaW4uc1tpXVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbnZhciBJSUlfcHN5X3htaW5fMSA9IElJSV9wc3lfeG1pbjtcblxuLy9wYWNrYWdlIG1wMztcblxuXG5cbmZ1bmN0aW9uIElJSV9wc3lfcmF0aW8oKSB7XG5cdHRoaXMudGhtID0gbmV3IElJSV9wc3lfeG1pbl8xKCk7XG5cdHRoaXMuZW4gPSBuZXcgSUlJX3BzeV94bWluXzEoKTtcbn1cblxudmFyIElJSV9wc3lfcmF0aW9fMSA9IElJSV9wc3lfcmF0aW87XG5cbnZhciBTeXN0ZW0kNSA9IGNvbW1vbi5TeXN0ZW07XG52YXIgVmJyTW9kZSQ1ID0gY29tbW9uLlZick1vZGU7XG52YXIgbmV3X2FycmF5X24kNSA9IGNvbW1vbi5uZXdfYXJyYXlfbjtcbnZhciBuZXdfZmxvYXQkNSA9IGNvbW1vbi5uZXdfZmxvYXQ7XG52YXIgbmV3X2Zsb2F0X24kNSA9IGNvbW1vbi5uZXdfZmxvYXRfbjtcbnZhciBuZXdfaW50JDUgPSBjb21tb24ubmV3X2ludDtcbnZhciBhc3NlcnQkNSA9IGNvbW1vbi5hc3NlcnQ7XG5cbi8qKlxuICogRU5DREVMQVkgVGhlIGVuY29kZXIgZGVsYXkuXG4gKlxuICogTWluaW11bSBhbGxvd2VkIGlzIE1EQ1RERUxBWSAoc2VlIGJlbG93KVxuICpcbiAqIFRoZSBmaXJzdCA5NiBzYW1wbGVzIHdpbGwgYmUgYXR0ZW51YXRlZCwgc28gdXNpbmcgYSB2YWx1ZSBsZXNzIHRoYW4gOTZcbiAqIHdpbGwgcmVzdWx0IGluIGNvcnJ1cHQgZGF0YSBmb3IgdGhlIGZpcnN0IDk2LUVOQ0RFTEFZIHNhbXBsZXMuXG4gKlxuICogc3VnZ2VzdGVkOiA1NzYgc2V0IHRvIDExNjAgdG8gc3luYyB3aXRoIEZoRy5cbiAqL1xuRW5jb2RlciQyLkVOQ0RFTEFZID0gNTc2O1xuLyoqXG4gKiBtYWtlIHN1cmUgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGNvbXBsZXRlIGZyYW1lIGFmdGVyIHRoZSBsYXN0IGZyYW1lXG4gKiBjb250YWluaW5nIHJlYWwgZGF0YVxuICpcbiAqIFVzaW5nIGEgdmFsdWUgb2YgMjg4IHdvdWxkIGJlIHN1ZmZpY2llbnQgZm9yIGEgYSB2ZXJ5IHNvcGhpc3RpY2F0ZWRcbiAqIGRlY29kZXIgdGhhdCBjYW4gZGVjb2RlIGdyYW51bGUtYnktZ3JhbnVsZSBpbnN0ZWFkIG9mIGZyYW1lIGJ5IGZyYW1lLiBCdXRcbiAqIGxldHMgbm90IGFzc3VtZSB0aGlzLCBhbmQgYXNzdW1lIHRoZSBkZWNvZGVyIHdpbGwgbm90IGRlY29kZSBmcmFtZSBOXG4gKiB1bmxlc3MgaXQgYWxzbyBoYXMgZGF0YSBmb3IgZnJhbWUgTisxXG4gKi9cbkVuY29kZXIkMi5QT1NUREVMQVkgPSAxMTUyO1xuXG4vKipcbiAqIGRlbGF5IG9mIHRoZSBNRENUIHVzZWQgaW4gbWRjdC5jIG9yaWdpbmFsIElTTyByb3V0aW5lcyBoYWQgYSBkZWxheSBvZlxuICogNTI4ISBUYWtlaGlybydzIHJvdXRpbmVzOlxuICovXG5FbmNvZGVyJDIuTURDVERFTEFZID0gNDg7XG5FbmNvZGVyJDIuRkZUT0ZGU0VUID0gKDIyNCArIEVuY29kZXIkMi5NRENUREVMQVkpO1xuXG4vKipcbiAqIE1vc3QgZGVjb2RlcnMsIGluY2x1ZGluZyB0aGUgb25lIHdlIHVzZSwgaGF2ZSBhIGRlbGF5IG9mIDUyOCBzYW1wbGVzLlxuICovXG5FbmNvZGVyJDIuREVDREVMQVkgPSA1Mjg7XG5cbi8qKlxuICogbnVtYmVyIG9mIHN1YmJhbmRzXG4gKi9cbkVuY29kZXIkMi5TQkxJTUlUID0gMzI7XG5cbi8qKlxuICogcGFyaXRpb24gYmFuZHMgYmFuZHNcbiAqL1xuRW5jb2RlciQyLkNCQU5EUyA9IDY0O1xuXG4vKipcbiAqIG51bWJlciBvZiBjcml0aWNhbCBiYW5kcy9zY2FsZSBmYWN0b3IgYmFuZHMgd2hlcmUgbWFza2luZyBpcyBjb21wdXRlZFxuICovXG5FbmNvZGVyJDIuU0JQU1lfbCA9IDIxO1xuRW5jb2RlciQyLlNCUFNZX3MgPSAxMjtcblxuLyoqXG4gKiB0b3RhbCBudW1iZXIgb2Ygc2NhbGVmYWN0b3IgYmFuZHMgZW5jb2RlZFxuICovXG5FbmNvZGVyJDIuU0JNQVhfbCA9IDIyO1xuRW5jb2RlciQyLlNCTUFYX3MgPSAxMztcbkVuY29kZXIkMi5QU0ZCMjEgPSA2O1xuRW5jb2RlciQyLlBTRkIxMiA9IDY7XG5cbi8qKlxuICogRkZUIHNpemVzXG4gKi9cbkVuY29kZXIkMi5CTEtTSVpFID0gMTAyNDtcbkVuY29kZXIkMi5IQkxLU0laRSA9IChFbmNvZGVyJDIuQkxLU0laRSAvIDIgKyAxKTtcbkVuY29kZXIkMi5CTEtTSVpFX3MgPSAyNTY7XG5FbmNvZGVyJDIuSEJMS1NJWkVfcyA9IChFbmNvZGVyJDIuQkxLU0laRV9zIC8gMiArIDEpO1xuXG5FbmNvZGVyJDIuTk9STV9UWVBFID0gMDtcbkVuY29kZXIkMi5TVEFSVF9UWVBFID0gMTtcbkVuY29kZXIkMi5TSE9SVF9UWVBFID0gMjtcbkVuY29kZXIkMi5TVE9QX1RZUEUgPSAzO1xuXG4vKipcbiAqIDxQUkU+XG4gKiBNb2RlIEV4dGVudGlvbjpcbiAqIFdoZW4gd2UgYXJlIGluIHN0ZXJlbyBtb2RlLCB0aGVyZSBhcmUgNCBwb3NzaWJsZSBtZXRob2RzIHRvIHN0b3JlIHRoZXNlXG4gKiB0d28gY2hhbm5lbHMuIFRoZSBzdGVyZW8gbW9kZXMgLW0/IGFyZSB1c2luZyBhIHN1YnNldCBvZiB0aGVtLlxuICpcbiAqICAtbXM6IE1QR19NRF9MUl9MUlxuICogIC1tajogTVBHX01EX0xSX0xSIGFuZCBNUEdfTURfTVNfTFJcbiAqICAtbWY6IE1QR19NRF9NU19MUlxuICogIC1taTogYWxsXG4gKiA8L1BSRT5cbiAqL1xuRW5jb2RlciQyLk1QR19NRF9MUl9MUiA9IDA7XG5FbmNvZGVyJDIuTVBHX01EX0xSX0kgPSAxO1xuRW5jb2RlciQyLk1QR19NRF9NU19MUiA9IDI7XG5FbmNvZGVyJDIuTVBHX01EX01TX0kgPSAzO1xuXG5FbmNvZGVyJDIuZmlyY29lZiA9IFstMC4wMjA3ODg3ICogNSwgLTAuMDM3ODQxMyAqIDUsXG4gICAgLTAuMDQzMjQ3MiAqIDUsIC0wLjAzMTE4MyAqIDUsIDcuNzk2MDllLTE4ICogNSwgMC4wNDY3NzQ1ICogNSxcbiAgICAwLjEwMDkxICogNSwgMC4xNTEzNjUgKiA1LCAwLjE4NzA5OCAqIDVdO1xuXG5mdW5jdGlvbiBFbmNvZGVyJDIoKSB7XG4gICAgdmFyIE5ld01EQ1QgPSBOZXdNRENUXzE7XG4gICAgdmFyIElJSV9wc3lfcmF0aW8gPSBJSUlfcHN5X3JhdGlvXzE7XG5cbiAgICB2YXIgRkZUT0ZGU0VUID0gRW5jb2RlciQyLkZGVE9GRlNFVDtcbiAgICB2YXIgTVBHX01EX01TX0xSID0gRW5jb2RlciQyLk1QR19NRF9NU19MUjtcbiAgICAvL0JpdFN0cmVhbSBicztcbiAgICAvL1BzeU1vZGVsIHBzeTtcbiAgICAvL1ZCUlRhZyB2YnI7XG4gICAgLy9RdWFudGl6ZVBWVCBxdXB2dDtcbiAgICB2YXIgYnMgPSBudWxsO1xuICAgIHRoaXMucHN5ID0gbnVsbDtcbiAgICB2YXIgcHN5ID0gbnVsbDtcbiAgICB2YXIgdmJyID0gbnVsbDtcbiAgICB2YXIgcXVwdnQgPSBudWxsO1xuXG4gICAgLy9wdWJsaWMgZmluYWwgdm9pZCBzZXRNb2R1bGVzKEJpdFN0cmVhbSBicywgUHN5TW9kZWwgcHN5LCBRdWFudGl6ZVBWVCBxdXB2dCxcbiAgICAvLyAgICBWQlJUYWcgdmJyKSB7XG4gICAgdGhpcy5zZXRNb2R1bGVzID0gZnVuY3Rpb24gKF9icywgX3BzeSwgX3F1cHZ0LCBfdmJyKSB7XG4gICAgICAgIGJzID0gX2JzO1xuICAgICAgICB0aGlzLnBzeSA9IF9wc3k7XG4gICAgICAgIHBzeSA9IF9wc3k7XG4gICAgICAgIHZiciA9IF92YnI7XG4gICAgICAgIHF1cHZ0ID0gX3F1cHZ0O1xuICAgIH07XG5cbiAgICB2YXIgbmV3TURDVCA9IG5ldyBOZXdNRENUKCk7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlxuICAgICAqIGVuY29kZXIgYW5kIGRlY29kZXIgZGVsYXlzXG4gICAgICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiA8UFJFPlxuICAgICAqIGxheWVyIElJSSBlbmMtPmRlYyBkZWxheTogIDEwNTYgKDEwNTc/KSAgIChvYnNlcnZlZClcbiAgICAgKiBsYXllciAgSUkgZW5jLT5kZWMgZGVsYXk6ICAgNDgwICAoNDgxPykgICAob2JzZXJ2ZWQpXG4gICAgICpcbiAgICAgKiBwb2x5cGhhc2UgMjU2LTE2ICAgICAgICAgICAgIChkZWMgb3IgZW5jKSAgICAgICAgPSAyNDBcbiAgICAgKiBtZGN0ICAgICAgMjU2KzMyICAoOSozMikgICAgIChkZWMgb3IgZW5jKSAgICAgICAgPSAyODhcbiAgICAgKiB0b3RhbDogICAgNTEyKzE2XG4gICAgICpcbiAgICAgKiBNeSBndWVzcyBpcyB0aGF0IGRlbGF5IG9mIHBvbHlwaGFzZSBmaWx0ZXJiYW5rIGlzIGFjdHVhbHkgMjQwLjVcbiAgICAgKiAodGhlcmUgYXJlIHRlY2huaWNhbCByZWFzb25zIGZvciB0aGlzLCBzZWUgcG9zdGluZ3MgaW4gbXAzZW5jb2RlcikuXG4gICAgICogU28gdG90YWwgRW5jb2RlK0RlY29kZSBkZWxheSA9IEVOQ0RFTEFZICsgNTI4ICsgMVxuICAgICAqIDwvUFJFPlxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBhdXRvLWFkanVzdCBvZiBBVEgsIHVzZWZ1bCBmb3IgbG93IHZvbHVtZSBHYWJyaWVsIEJvdXZpZ25lIDMgZmViIDIwMDFcbiAgICAgKlxuICAgICAqIG1vZGlmaWVzIHNvbWUgdmFsdWVzIGluIGdmcC5pbnRlcm5hbF9mbGFncy5BVEggKGdmYy5BVEgpXG4gICAgICovXG4vL3ByaXZhdGUgdm9pZCBhZGp1c3RfQVRIKGZpbmFsIExhbWVJbnRlcm5hbEZsYWdzIGdmYykge1xuICAgIGZ1bmN0aW9uIGFkanVzdF9BVEgoZ2ZjKSB7XG4gICAgICAgIHZhciBncjJfbWF4LCBtYXhfcG93O1xuXG4gICAgICAgIGlmIChnZmMuQVRILnVzZUFkanVzdCA9PSAwKSB7XG4gICAgICAgICAgICBnZmMuQVRILmFkanVzdCA9IDEuMDtcbiAgICAgICAgICAgIC8qIG5vIGFkanVzdG1lbnQgKi9cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGpkIC0gMjAwMSBtYXIgMTIsIDI3LCBqdW4gMzAgKi9cbiAgICAgICAgLyogbG91ZG5lc3MgYmFzZWQgb24gZXF1YWwgbG91ZG5lc3MgY3VydmU7ICovXG4gICAgICAgIC8qIHVzZSBncmFudWxlIHdpdGggbWF4aW11bSBjb21iaW5lZCBsb3VkbmVzcyAqL1xuICAgICAgICBtYXhfcG93ID0gZ2ZjLmxvdWRuZXNzX3NxWzBdWzBdO1xuICAgICAgICBncjJfbWF4ID0gZ2ZjLmxvdWRuZXNzX3NxWzFdWzBdO1xuICAgICAgICBpZiAoZ2ZjLmNoYW5uZWxzX291dCA9PSAyKSB7XG4gICAgICAgICAgICBtYXhfcG93ICs9IGdmYy5sb3VkbmVzc19zcVswXVsxXTtcbiAgICAgICAgICAgIGdyMl9tYXggKz0gZ2ZjLmxvdWRuZXNzX3NxWzFdWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF4X3BvdyArPSBtYXhfcG93O1xuICAgICAgICAgICAgZ3IyX21heCArPSBncjJfbWF4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZmMubW9kZV9nciA9PSAyKSB7XG4gICAgICAgICAgICBtYXhfcG93ID0gTWF0aC5tYXgobWF4X3BvdywgZ3IyX21heCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4X3BvdyAqPSAwLjU7XG4gICAgICAgIC8qIG1heF9wb3cgYXBwcm9hY2hlcyAxLjAgZm9yIGZ1bGwgYmFuZCBub2lzZSAqL1xuXG4gICAgICAgIC8qIGpkIC0gMjAwMSBtYXIgMzEsIGp1biAzMCAqL1xuICAgICAgICAvKiB1c2VyIHR1bmluZyBvZiBBVEggYWRqdXN0bWVudCByZWdpb24gKi9cbiAgICAgICAgbWF4X3BvdyAqPSBnZmMuQVRILmFhU2Vuc2l0aXZpdHlQO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGFkanVzdCBBVEggZGVwZW5kaW5nIG9uIHJhbmdlIG9mIG1heGltdW0gdmFsdWVcbiAgICAgICAgICovXG5cbiAgICAgICAgLyogamQgLSAyMDAxIGZlYjI3LCBtYXIxMiwyMCwganVuMzAsIGp1bDIyICovXG4gICAgICAgIC8qIGNvbnRpbnVvdXMgY3VydmVzIGJhc2VkIG9uIGFwcHJveGltYXRpb24gKi9cbiAgICAgICAgLyogdG8gR0IncyBvcmlnaW5hbCB2YWx1ZXMuICovXG4gICAgICAgIC8qIEZvciBhbiBpbmNyZWFzZSBpbiBhcHByb3hpbWF0ZSBsb3VkbmVzcywgKi9cbiAgICAgICAgLyogc2V0IEFUSCBhZGp1c3QgdG8gYWRqdXN0X2xpbWl0IGltbWVkaWF0ZWx5ICovXG4gICAgICAgIC8qIGFmdGVyIGEgZGVsYXkgb2Ygb25lIGZyYW1lLiAqL1xuICAgICAgICAvKiBGb3IgYSBsb3VkbmVzcyBkZWNyZWFzZSwgcmVkdWNlIEFUSCBhZGp1c3QgKi9cbiAgICAgICAgLyogdG93YXJkcyBhZGp1c3RfbGltaXQgZ3JhZHVhbGx5LiAqL1xuICAgICAgICAvKiBtYXhfcG93IGlzIGEgbG91ZG5lc3Mgc3F1YXJlZCBvciBhIHBvd2VyLiAqL1xuICAgICAgICBpZiAobWF4X3BvdyA+IDAuMDMxMjUpIHsgLyogKCgxIC0gMC4wMDA2MjUpLyAzMS45OCkgZnJvbSBjdXJ2ZSBiZWxvdyAqL1xuICAgICAgICAgICAgaWYgKGdmYy5BVEguYWRqdXN0ID49IDEuMCkge1xuICAgICAgICAgICAgICAgIGdmYy5BVEguYWRqdXN0ID0gMS4wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBwcmVjZWRpbmcgZnJhbWUgaGFzIGxvd2VyIEFUSCBhZGp1c3Q7ICovXG4gICAgICAgICAgICAgICAgLyogYXNjZW5kIG9ubHkgdG8gdGhlIHByZWNlZGluZyBhZGp1c3RfbGltaXQgKi9cbiAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHRoZXJlIGlzIGxlYWRpbmcgbG93IHZvbHVtZSAqL1xuICAgICAgICAgICAgICAgIGlmIChnZmMuQVRILmFkanVzdCA8IGdmYy5BVEguYWRqdXN0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLkFUSC5hZGp1c3QgPSBnZmMuQVRILmFkanVzdExpbWl0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdmYy5BVEguYWRqdXN0TGltaXQgPSAxLjA7XG4gICAgICAgIH0gZWxzZSB7IC8qIGFkanVzdG1lbnQgY3VydmUgKi9cbiAgICAgICAgICAgIC8qIGFib3V0IDMyIGRCIG1heGltdW0gYWRqdXN0ICgwLjAwMDYyNSkgKi9cbiAgICAgICAgICAgIHZhciBhZGpfbGltX25ldyA9IDMxLjk4ICogbWF4X3BvdyArIDAuMDAwNjI1O1xuICAgICAgICAgICAgaWYgKGdmYy5BVEguYWRqdXN0ID49IGFkal9saW1fbmV3KSB7IC8qIGRlc2NlbmQgZ3JhZHVhbGx5ICovXG4gICAgICAgICAgICAgICAgZ2ZjLkFUSC5hZGp1c3QgKj0gYWRqX2xpbV9uZXcgKiAwLjA3NSArIDAuOTI1O1xuICAgICAgICAgICAgICAgIGlmIChnZmMuQVRILmFkanVzdCA8IGFkal9saW1fbmV3KSB7IC8qIHN0b3AgZGVzY2VudCAqL1xuICAgICAgICAgICAgICAgICAgICBnZmMuQVRILmFkanVzdCA9IGFkal9saW1fbmV3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7IC8qIGFzY2VuZCAqL1xuICAgICAgICAgICAgICAgIGlmIChnZmMuQVRILmFkanVzdExpbWl0ID49IGFkal9saW1fbmV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGdmYy5BVEguYWRqdXN0ID0gYWRqX2xpbV9uZXc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogcHJlY2VkaW5nIGZyYW1lIGhhcyBsb3dlciBBVEggYWRqdXN0OyAqL1xuICAgICAgICAgICAgICAgICAgICAvKiBhc2NlbmQgb25seSB0byB0aGUgcHJlY2VkaW5nIGFkanVzdF9saW1pdCAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2ZjLkFUSC5hZGp1c3QgPCBnZmMuQVRILmFkanVzdExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZmMuQVRILmFkanVzdCA9IGdmYy5BVEguYWRqdXN0TGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZmMuQVRILmFkanVzdExpbWl0ID0gYWRqX2xpbV9uZXc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8UFJFPlxuICAgICAqICBzb21lIHNpbXBsZSBzdGF0aXN0aWNzXG4gICAgICpcbiAgICAgKiAgYml0cmF0ZSBpbmRleCAwOiBmcmVlIGJpdHJhdGUgLiBub3QgYWxsb3dlZCBpbiBWQlIgbW9kZVxuICAgICAqICA6IGJpdHJhdGVzLCBrYnBzIGRlcGVuZGluZyBvbiBNUEVHIHZlcnNpb25cbiAgICAgKiAgYml0cmF0ZSBpbmRleCAxNTogZm9yYmlkZGVuXG4gICAgICpcbiAgICAgKiAgbW9kZV9leHQ6XG4gICAgICogIDA6ICBMUlxuICAgICAqICAxOiAgTFItaVxuICAgICAqICAyOiAgTVNcbiAgICAgKiAgMzogIE1TLWlcbiAgICAgKiA8L1BSRT5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVTdGF0cyhnZmMpIHtcbiAgICAgICAgdmFyIGdyLCBjaDtcbiAgICAgICAgYXNzZXJ0JDUoMCA8PSBnZmMuYml0cmF0ZV9pbmRleCAmJiBnZmMuYml0cmF0ZV9pbmRleCA8IDE2KTtcbiAgICAgICAgYXNzZXJ0JDUoMCA8PSBnZmMubW9kZV9leHQgJiYgZ2ZjLm1vZGVfZXh0IDwgNCk7XG5cbiAgICAgICAgLyogY291bnQgYml0cmF0ZSBpbmRpY2VzICovXG4gICAgICAgIGdmYy5iaXRyYXRlX3N0ZXJlb01vZGVfSGlzdFtnZmMuYml0cmF0ZV9pbmRleF1bNF0rKztcbiAgICAgICAgZ2ZjLmJpdHJhdGVfc3RlcmVvTW9kZV9IaXN0WzE1XVs0XSsrO1xuXG4gICAgICAgIC8qIGNvdW50ICdlbSBmb3IgZXZlcnkgbW9kZSBleHRlbnNpb24gaW4gY2FzZSBvZiAyIGNoYW5uZWwgZW5jb2RpbmcgKi9cbiAgICAgICAgaWYgKGdmYy5jaGFubmVsc19vdXQgPT0gMikge1xuICAgICAgICAgICAgZ2ZjLmJpdHJhdGVfc3RlcmVvTW9kZV9IaXN0W2dmYy5iaXRyYXRlX2luZGV4XVtnZmMubW9kZV9leHRdKys7XG4gICAgICAgICAgICBnZmMuYml0cmF0ZV9zdGVyZW9Nb2RlX0hpc3RbMTVdW2dmYy5tb2RlX2V4dF0rKztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgKytncikge1xuICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgKytjaCkge1xuICAgICAgICAgICAgICAgIHZhciBidCA9IGdmYy5sM19zaWRlLnR0W2dyXVtjaF0uYmxvY2tfdHlwZSB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5sM19zaWRlLnR0W2dyXVtjaF0ubWl4ZWRfYmxvY2tfZmxhZyAhPSAwKVxuICAgICAgICAgICAgICAgICAgICBidCA9IDQ7XG4gICAgICAgICAgICAgICAgZ2ZjLmJpdHJhdGVfYmxvY2tUeXBlX0hpc3RbZ2ZjLmJpdHJhdGVfaW5kZXhdW2J0XSsrO1xuICAgICAgICAgICAgICAgIGdmYy5iaXRyYXRlX2Jsb2NrVHlwZV9IaXN0W2dmYy5iaXRyYXRlX2luZGV4XVs1XSsrO1xuICAgICAgICAgICAgICAgIGdmYy5iaXRyYXRlX2Jsb2NrVHlwZV9IaXN0WzE1XVtidF0rKztcbiAgICAgICAgICAgICAgICBnZmMuYml0cmF0ZV9ibG9ja1R5cGVfSGlzdFsxNV1bNV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxhbWVfZW5jb2RlX2ZyYW1lX2luaXQoZ2ZwLCBpbmJ1Zikge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXG4gICAgICAgIHZhciBjaCwgZ3I7XG5cbiAgICAgICAgaWYgKGdmYy5sYW1lX2VuY29kZV9mcmFtZV9pbml0ID09IDApIHtcbiAgICAgICAgICAgIC8qIHByaW1lIHRoZSBNRENUL3BvbHlwaGFzZSBmaWx0ZXJiYW5rIHdpdGggYSBzaG9ydCBibG9jayAqL1xuICAgICAgICAgICAgdmFyIGksIGo7XG4gICAgICAgICAgICB2YXIgcHJpbWVidWZmMCA9IG5ld19mbG9hdCQ1KDI4NiArIDExNTIgKyA1NzYpO1xuICAgICAgICAgICAgdmFyIHByaW1lYnVmZjEgPSBuZXdfZmxvYXQkNSgyODYgKyAxMTUyICsgNTc2KTtcbiAgICAgICAgICAgIGdmYy5sYW1lX2VuY29kZV9mcmFtZV9pbml0ID0gMTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgMjg2ICsgNTc2ICogKDEgKyBnZmMubW9kZV9ncik7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgNTc2ICogZ2ZjLm1vZGVfZ3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbWVidWZmMFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZmMuY2hhbm5lbHNfb3V0ID09IDIpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltZWJ1ZmYxW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmltZWJ1ZmYwW2ldID0gaW5idWZbMF1bal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZmMuY2hhbm5lbHNfb3V0ID09IDIpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltZWJ1ZmYxW2ldID0gaW5idWZbMV1bal07XG4gICAgICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBwb2x5cGhhc2UgZmlsdGVyaW5nIC8gbWRjdCAqL1xuICAgICAgICAgICAgZm9yIChnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdmYy5sM19zaWRlLnR0W2dyXVtjaF0uYmxvY2tfdHlwZSA9IEVuY29kZXIkMi5TSE9SVF9UWVBFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld01EQ1QubWRjdF9zdWI0OChnZmMsIHByaW1lYnVmZjAsIHByaW1lYnVmZjEpO1xuXG4gICAgICAgICAgICAvKiBjaGVjayBGRlQgd2lsbCBub3QgdXNlIGEgbmVnYXRpdmUgc3RhcnRpbmcgb2Zmc2V0ICovXG4gICAgICAgICAgICBhc3NlcnQkNSg1NzYgPj0gRW5jb2RlciQyLkZGVE9GRlNFVCk7XG4gICAgICAgICAgICAvKiBjaGVjayBpZiB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciBGRlQgKi9cbiAgICAgICAgICAgIGFzc2VydCQ1KGdmYy5tZl9zaXplID49IChFbmNvZGVyJDIuQkxLU0laRSArIGdmcC5mcmFtZXNpemUgLSBFbmNvZGVyJDIuRkZUT0ZGU0VUKSk7XG4gICAgICAgICAgICAvKiBjaGVjayBpZiB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciBwb2x5cGhhc2UgZmlsdGVyYmFuayAqL1xuICAgICAgICAgICAgYXNzZXJ0JDUoZ2ZjLm1mX3NpemUgPj0gKDUxMiArIGdmcC5mcmFtZXNpemUgLSAzMikpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8UFJFPlxuICAgICAqIGVuY29kZWZyYW1lKCkgICAgICAgICAgIExheWVyIDNcbiAgICAgKlxuICAgICAqIGVuY29kZSBhIHNpbmdsZSBmcmFtZVxuICAgICAqXG4gICAgICpcbiAgICAgKiAgICBsYW1lX2VuY29kZV9mcmFtZSgpXG4gICAgICpcbiAgICAgKlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3IgMCAgICAgICAgICAgIGdyIDFcbiAgICAgKiAgICBpbmJ1ZjogICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXxcbiAgICAgKlxuICAgICAqXG4gICAgICogICAgUG9seXBoYXNlICgxOCB3aW5kb3dzLCBlYWNoIHNoaWZ0ZWQgMzIpXG4gICAgICogICAgZ3IgMDpcbiAgICAgKiAgICB3aW5kb3cxICAgICAgICAgIDwtLS0tNTEyLS0tLlxuICAgICAqICAgIHdpbmRvdzE4ICAgICAgICAgICAgICAgICA8LS0tLTUxMi0tLS5cbiAgICAgKlxuICAgICAqICAgIGdyIDE6XG4gICAgICogICAgd2luZG93MSAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tLTUxMi0tLS5cbiAgICAgKiAgICB3aW5kb3cxOCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tLS01MTItLS0uXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICogICAgTURDVCBvdXRwdXQ6ICB8LS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS18XG4gICAgICpcbiAgICAgKiAgICBGRlQncyAgICAgICAgICAgICAgICAgICAgPC0tLS0tLS0tLTEwMjQtLS0tLS0tLS0uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tLS0tLS0tMTAyNC0tLS0tLS0uXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICogICAgICAgIGluYnVmID0gYnVmZmVyIG9mIFBDTSBkYXRhIHNpemU9TVAzIGZyYW1lc2l6ZVxuICAgICAqICAgICAgICBlbmNvZGVyIGFjdHMgb24gaW5idWZbY2hdWzBdLCBidXQgb3V0cHV0IGlzIGRlbGF5ZWQgYnkgTURDVERFTEFZXG4gICAgICogICAgICAgIHNvIHRoZSBNRENUIGNvZWZmaWNpbnRzIGFyZSBmcm9tIGluYnVmW2NoXVstTURDVERFTEFZXVxuICAgICAqXG4gICAgICogICAgICAgIHBzeS1tb2RlbCBGRlQgaGFzIGEgMSBncmFudWxlIGRlbGF5LCBzbyB3ZSBmZWVkIGl0IGRhdGEgZm9yIHRoZVxuICAgICAqICAgICAgICBuZXh0IGdyYW51bGUuXG4gICAgICogICAgICAgIEZGVCBpcyBjZW50ZXJlZCBvdmVyIGdyYW51bGU6ICAyMjQrNTc2KzIyNFxuICAgICAqICAgICAgICBTbyBGRlQgc3RhcnRzIGF0OiAgIDU3Ni0yMjQtTURDVERFTEFZXG4gICAgICpcbiAgICAgKiAgICAgICAgTVBFRzI6ICBGRlQgZW5kcyBhdDogIEJMS1NJWkUrNTc2LTIyNC1NRENUREVMQVkgICAgICAoMTMyOClcbiAgICAgKiAgICAgICAgTVBFRzE6ICBGRlQgZW5kcyBhdDogIEJMS1NJWkUrMio1NzYtMjI0LU1EQ1RERUxBWSAgICAoMTkwNClcbiAgICAgKlxuICAgICAqICAgICAgICBNUEVHMjogIHBvbHlwaGFzZSBmaXJzdCB3aW5kb3c6ICBbMC4uNTExXVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAxOHRoIHdpbmRvdzogICBbNTQ0Li4xMDU1XSAgICAgICAgICAoMTA1NilcbiAgICAgKiAgICAgICAgTVBFRzE6ICAgICAgICAgICAgMzZ0aCB3aW5kb3c6ICAgWzExMjAuLjE2MzFdICAgICAgICAgKDE2MzIpXG4gICAgICogICAgICAgICAgICAgICAgZGF0YSBuZWVkZWQ6ICA1MTIrZnJhbWVzaXplLTMyXG4gICAgICpcbiAgICAgKiAgICAgICAgQSBjbG9zZSBsb29rIG5ld21kY3QuYyBzaG93cyB0aGF0IHRoZSBwb2x5cGhhc2UgZmlsdGVyYmFua1xuICAgICAqICAgICAgICBvbmx5IHVzZXMgZGF0YSBmcm9tIFswLi41MTBdIGZvciBlYWNoIHdpbmRvdy4gIFBlcmhhcHMgYmVjYXVzZSB0aGUgd2luZG93XG4gICAgICogICAgICAgIHVzZWQgYnkgdGhlIGZpbHRlcmJhbmsgaXMgemVybyBmb3IgdGhlIGxhc3QgcG9pbnQsIHNvIFRha2VoaXJvJ3NcbiAgICAgKiAgICAgICAgY29kZSBkb2Vzbid0IGJvdGhlciB0byBjb21wdXRlIHdpdGggaXQuXG4gICAgICpcbiAgICAgKiAgICAgICAgRkZUIHN0YXJ0cyBhdCA1NzYtMjI0LU1EQ1RERUxBWSAoMzA0KSAgPSA1NzYtRkZUT0ZGU0VUXG4gICAgICpcbiAgICAgKiA8L1BSRT5cbiAgICAgKi9cblxuXG4gICAgdGhpcy5sYW1lX2VuY29kZV9tcDNfZnJhbWUgPSBmdW5jdGlvbiAoZ2ZwLCBpbmJ1Zl9sLCBpbmJ1Zl9yLCBtcDNidWYsIG1wM2J1ZlBvcywgbXAzYnVmX3NpemUpIHtcbiAgICAgICAgdmFyIG1wM2NvdW50O1xuICAgICAgICB2YXIgbWFza2luZ19MUiA9IG5ld19hcnJheV9uJDUoWzIsIDJdKTtcbiAgICAgICAgLypcbiAgICAgICAgICogTFIgbWFza2luZyAmXG4gICAgICAgICAqIGVuZXJneVxuICAgICAgICAgKi9cbiAgICAgICAgbWFza2luZ19MUlswXVswXSA9IG5ldyBJSUlfcHN5X3JhdGlvKCk7XG4gICAgICAgIG1hc2tpbmdfTFJbMF1bMV0gPSBuZXcgSUlJX3BzeV9yYXRpbygpO1xuICAgICAgICBtYXNraW5nX0xSWzFdWzBdID0gbmV3IElJSV9wc3lfcmF0aW8oKTtcbiAgICAgICAgbWFza2luZ19MUlsxXVsxXSA9IG5ldyBJSUlfcHN5X3JhdGlvKCk7XG4gICAgICAgIHZhciBtYXNraW5nX01TID0gbmV3X2FycmF5X24kNShbMiwgMl0pO1xuICAgICAgICAvKiBNUyBtYXNraW5nICYgZW5lcmd5ICovXG4gICAgICAgIG1hc2tpbmdfTVNbMF1bMF0gPSBuZXcgSUlJX3BzeV9yYXRpbygpO1xuICAgICAgICBtYXNraW5nX01TWzBdWzFdID0gbmV3IElJSV9wc3lfcmF0aW8oKTtcbiAgICAgICAgbWFza2luZ19NU1sxXVswXSA9IG5ldyBJSUlfcHN5X3JhdGlvKCk7XG4gICAgICAgIG1hc2tpbmdfTVNbMV1bMV0gPSBuZXcgSUlJX3BzeV9yYXRpbygpO1xuICAgICAgICAvL0lJSV9wc3lfcmF0aW8gbWFza2luZ1tdW107XG4gICAgICAgIHZhciBtYXNraW5nO1xuICAgICAgICAvKiBwb2ludGVyIHRvIHNlbGVjdGVkIG1hc2tpbmdzICovXG4gICAgICAgIHZhciBpbmJ1ZiA9IFtudWxsLCBudWxsXTtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblxuICAgICAgICB2YXIgdG90X2VuZXIgPSBuZXdfZmxvYXRfbiQ1KFsyLCA0XSk7XG4gICAgICAgIHZhciBtc19lbmVyX3JhdGlvID0gWy41LCAuNV07XG4gICAgICAgIHZhciBwZSA9IFtbMC4sIDAuXSwgWzAuLCAwLl1dO1xuICAgICAgICB2YXIgcGVfTVMgPSBbWzAuLCAwLl0sIFswLiwgMC5dXTtcblxuLy9mbG9hdFtdW10gcGVfdXNlO1xuICAgICAgICB2YXIgcGVfdXNlO1xuXG4gICAgICAgIHZhciBjaCwgZ3I7XG5cbiAgICAgICAgaW5idWZbMF0gPSBpbmJ1Zl9sO1xuICAgICAgICBpbmJ1ZlsxXSA9IGluYnVmX3I7XG5cbiAgICAgICAgaWYgKGdmYy5sYW1lX2VuY29kZV9mcmFtZV9pbml0ID09IDApIHtcbiAgICAgICAgICAgIC8qIGZpcnN0IHJ1bj8gKi9cbiAgICAgICAgICAgIGxhbWVfZW5jb2RlX2ZyYW1lX2luaXQoZ2ZwLCBpbmJ1Zik7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqIHBhZGRpbmcgKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8UFJFPlxuICAgICAgICAgKiBwYWRkaW5nIG1ldGhvZCBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgICogXCJNUEVHLUxheWVyMyAvIEJpdHN0cmVhbSBTeW50YXggYW5kIERlY29kaW5nXCJcbiAgICAgICAgICogYnkgTWFydGluIFNpZWxlciwgUmFscGggU3BlcnNjaG5laWRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBub3RlOiB0aGVyZSBpcyBubyBwYWRkaW5nIGZvciB0aGUgdmVyeSBmaXJzdCBmcmFtZVxuICAgICAgICAgKlxuICAgICAgICAgKiBSb2JlcnQgSGVnZW1hbm4gMjAwMC0wNi0yMlxuICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICovXG4gICAgICAgIGdmYy5wYWRkaW5nID0gMDtcbiAgICAgICAgaWYgKChnZmMuc2xvdF9sYWcgLT0gZ2ZjLmZyYWNfU3BGKSA8IDApIHtcbiAgICAgICAgICAgIGdmYy5zbG90X2xhZyArPSBnZnAub3V0X3NhbXBsZXJhdGU7XG4gICAgICAgICAgICBnZmMucGFkZGluZyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBTdGFnZSAxOiBwc3ljaG9hY291c3RpYyBtb2RlbCAqXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIGlmIChnZmMucHN5bW9kZWwgIT0gMCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHBzeWNob2Fjb3VzdGljIG1vZGVsIHBzeSBtb2RlbCBoYXMgYSAxIGdyYW51bGUgKDU3NikgZGVsYXkgdGhhdFxuICAgICAgICAgICAgICogd2UgbXVzdCBjb21wZW5zYXRlIGZvciAobXQgNi85OSkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICB2YXIgYnVmcCA9IFtudWxsLCBudWxsXTtcbiAgICAgICAgICAgIC8qIGFkZHJlc3Mgb2YgYmVnaW5uaW5nIG9mIGxlZnQgJiByaWdodCBncmFudWxlICovXG4gICAgICAgICAgICB2YXIgYnVmcFBvcyA9IDA7XG4gICAgICAgICAgICAvKiBhZGRyZXNzIG9mIGJlZ2lubmluZyBvZiBsZWZ0ICYgcmlnaHQgZ3JhbnVsZSAqL1xuICAgICAgICAgICAgdmFyIGJsb2NrdHlwZSA9IG5ld19pbnQkNSgyKTtcblxuICAgICAgICAgICAgZm9yIChnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcblxuICAgICAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmcFtjaF0gPSBpbmJ1ZltjaF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZnBQb3MgPSA1NzYgKyBnciAqIDU3NiAtIEVuY29kZXIkMi5GRlRPRkZTRVQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZnAuVkJSID09IFZick1vZGUkNS52YnJfbXRyaCB8fCBnZnAuVkJSID09IFZick1vZGUkNS52YnJfbXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHN5LkwzcHN5Y2hvX2FuYWxfdmJyKGdmcCwgYnVmcCwgYnVmcFBvcywgZ3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNraW5nX0xSLCBtYXNraW5nX01TLCBwZVtncl0sIHBlX01TW2dyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdF9lbmVyW2dyXSwgYmxvY2t0eXBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBwc3kuTDNwc3ljaG9fYW5hbF9ucyhnZnAsIGJ1ZnAsIGJ1ZnBQb3MsIGdyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFza2luZ19MUiwgbWFza2luZ19NUywgcGVbZ3JdLCBwZV9NU1tncl0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RfZW5lcltncl0sIGJsb2NrdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXQgIT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC00O1xuXG4gICAgICAgICAgICAgICAgaWYgKGdmcC5tb2RlID09IE1QRUdNb2RlLkpPSU5UX1NURVJFTykge1xuICAgICAgICAgICAgICAgICAgICBtc19lbmVyX3JhdGlvW2dyXSA9IHRvdF9lbmVyW2dyXVsyXSArIHRvdF9lbmVyW2dyXVszXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zX2VuZXJfcmF0aW9bZ3JdID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zX2VuZXJfcmF0aW9bZ3JdID0gdG90X2VuZXJbZ3JdWzNdIC8gbXNfZW5lcl9yYXRpb1tncl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogYmxvY2sgdHlwZSBmbGFncyAqL1xuICAgICAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZF9pbmZvID0gZ2ZjLmwzX3NpZGUudHRbZ3JdW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgY29kX2luZm8uYmxvY2tfdHlwZSA9IGJsb2NrdHlwZVtjaF07XG4gICAgICAgICAgICAgICAgICAgIGNvZF9pbmZvLm1peGVkX2Jsb2NrX2ZsYWcgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIG5vIHBzeSBtb2RlbCAqL1xuICAgICAgICAgICAgZm9yIChnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspXG4gICAgICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgICAgICBnZmMubDNfc2lkZS50dFtncl1bY2hdLmJsb2NrX3R5cGUgPSBFbmNvZGVyJDIuTk9STV9UWVBFO1xuICAgICAgICAgICAgICAgICAgICBnZmMubDNfc2lkZS50dFtncl1bY2hdLm1peGVkX2Jsb2NrX2ZsYWcgPSAwO1xuICAgICAgICAgICAgICAgICAgICBwZV9NU1tncl1bY2hdID0gcGVbZ3JdW2NoXSA9IDcwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBhdXRvLWFkanVzdCBvZiBBVEgsIHVzZWZ1bCBmb3IgbG93IHZvbHVtZSAqL1xuICAgICAgICBhZGp1c3RfQVRIKGdmYyk7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogU3RhZ2UgMjogTURDVCAqXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qIHBvbHlwaGFzZSBmaWx0ZXJpbmcgLyBtZGN0ICovXG4gICAgICAgIG5ld01EQ1QubWRjdF9zdWI0OChnZmMsIGluYnVmWzBdLCBpbmJ1ZlsxXSk7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogU3RhZ2UgMzogTVMvTFIgZGVjaXNpb24gKlxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiBIZXJlIHdpbGwgYmUgc2VsZWN0ZWQgTVMgb3IgTFIgY29kaW5nIG9mIHRoZSAyIHN0ZXJlbyBjaGFubmVscyAqL1xuICAgICAgICBnZmMubW9kZV9leHQgPSBFbmNvZGVyJDIuTVBHX01EX0xSX0xSO1xuXG4gICAgICAgIGlmIChnZnAuZm9yY2VfbXMpIHtcbiAgICAgICAgICAgIGdmYy5tb2RlX2V4dCA9IEVuY29kZXIkMi5NUEdfTURfTVNfTFI7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2ZwLm1vZGUgPT0gTVBFR01vZGUuSk9JTlRfU1RFUkVPKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogbXNfcmF0aW8gPSBpcyBzY2FsZWQsIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIHRvIGxvb2sgbGlrZSBhXG4gICAgICAgICAgICAgKiByYXRpbyBvZiBzaWRlX2NoYW5uZWwgLyB0b3RhbC4gMCA9IHNpZ25hbCBpcyAxMDAlIG1vbm8gLjUgPSBMICYgUlxuICAgICAgICAgICAgICogdW5jb3JyZWxhdGVkXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiA8UFJFPlxuICAgICAgICAgICAgICogWzBdIGFuZCBbMV0gYXJlIHRoZSByZXN1bHRzIGZvciB0aGUgdHdvIGdyYW51bGVzIGluIE1QRUctMSxcbiAgICAgICAgICAgICAqIGluIE1QRUctMiBpdCdzIG9ubHkgYSBmYWtlZCBhdmVyYWdpbmcgb2YgdGhlIHNhbWUgdmFsdWVcbiAgICAgICAgICAgICAqIF9wcmV2IGlzIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBncmFudWxlIG9mIHRoZSBwcmV2aW91cyBmcmFtZVxuICAgICAgICAgICAgICogX25leHQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBncmFudWxlIG9mIHRoZSBuZXh0IGZyYW1lXG4gICAgICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB2YXIgc3VtX3BlX01TID0gMC47XG4gICAgICAgICAgICB2YXIgc3VtX3BlX0xSID0gMC47XG4gICAgICAgICAgICBmb3IgKGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuICAgICAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtX3BlX01TICs9IHBlX01TW2dyXVtjaF07XG4gICAgICAgICAgICAgICAgICAgIHN1bV9wZV9MUiArPSBwZVtncl1bY2hdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogYmFzZWQgb24gUEU6IE0vUyBjb2Rpbmcgd291bGQgbm90IHVzZSBtdWNoIG1vcmUgYml0cyB0aGFuIEwvUiAqL1xuICAgICAgICAgICAgaWYgKHN1bV9wZV9NUyA8PSAxLjAwICogc3VtX3BlX0xSKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2kwID0gZ2ZjLmwzX3NpZGUudHRbMF07XG4gICAgICAgICAgICAgICAgdmFyIGdpMSA9IGdmYy5sM19zaWRlLnR0W2dmYy5tb2RlX2dyIC0gMV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2kwWzBdLmJsb2NrX3R5cGUgPT0gZ2kwWzFdLmJsb2NrX3R5cGVcbiAgICAgICAgICAgICAgICAgICAgJiYgZ2kxWzBdLmJsb2NrX3R5cGUgPT0gZ2kxWzFdLmJsb2NrX3R5cGUpIHtcblxuICAgICAgICAgICAgICAgICAgICBnZmMubW9kZV9leHQgPSBFbmNvZGVyJDIuTVBHX01EX01TX0xSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJpdCBhbmQgbm9pc2UgYWxsb2NhdGlvbiAqL1xuICAgICAgICBpZiAoZ2ZjLm1vZGVfZXh0ID09IE1QR19NRF9NU19MUikge1xuICAgICAgICAgICAgbWFza2luZyA9IG1hc2tpbmdfTVM7XG4gICAgICAgICAgICAvKiB1c2UgTVMgbWFza2luZyAqL1xuICAgICAgICAgICAgcGVfdXNlID0gcGVfTVM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXNraW5nID0gbWFza2luZ19MUjtcbiAgICAgICAgICAgIC8qIHVzZSBMUiBtYXNraW5nICovXG4gICAgICAgICAgICBwZV91c2UgPSBwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGNvcHkgZGF0YSBmb3IgTVAzIGZyYW1lIGFuYWx5emVyICovXG4gICAgICAgIGlmIChnZnAuYW5hbHlzaXMgJiYgZ2ZjLnBpbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoZ3IgPSAwOyBnciA8IGdmYy5tb2RlX2dyOyBncisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgICAgICBnZmMucGluZm8ubXNfcmF0aW9bZ3JdID0gZ2ZjLm1zX3JhdGlvW2dyXTtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLm1zX2VuZXJfcmF0aW9bZ3JdID0gbXNfZW5lcl9yYXRpb1tncl07XG4gICAgICAgICAgICAgICAgICAgIGdmYy5waW5mby5ibG9ja3R5cGVbZ3JdW2NoXSA9IGdmYy5sM19zaWRlLnR0W2dyXVtjaF0uYmxvY2tfdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLnBlW2dyXVtjaF0gPSBwZV91c2VbZ3JdW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgU3lzdGVtJDUuYXJyYXljb3B5KGdmYy5sM19zaWRlLnR0W2dyXVtjaF0ueHIsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZmMucGluZm8ueHJbZ3JdW2NoXSwgMCwgNTc2KTtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogaW4gcHN5bW9kZWwsIExSIGFuZCBNUyBkYXRhIHdhcyBzdG9yZWQgaW4gcGluZm8uIHN3aXRjaFxuICAgICAgICAgICAgICAgICAgICAgKiB0byBNUyBkYXRhOlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdmYy5tb2RlX2V4dCA9PSBNUEdfTURfTVNfTFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdmYy5waW5mby5lcnNbZ3JdW2NoXSA9IGdmYy5waW5mby5lcnNbZ3JdW2NoICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBTeXN0ZW0kNS5hcnJheWNvcHkoZ2ZjLnBpbmZvLmVuZXJneVtncl1bY2ggKyAyXSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZmMucGluZm8uZW5lcmd5W2dyXVtjaF0sIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLmVuZXJneVtncl1bY2hdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBTdGFnZSA0OiBxdWFudGl6YXRpb24gbG9vcCAqXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIGlmIChnZnAuVkJSID09IFZick1vZGUkNS52YnJfb2ZmIHx8IGdmcC5WQlIgPT0gVmJyTW9kZSQ1LnZicl9hYnIpIHtcblxuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgZjtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDE4OyBpKyspXG4gICAgICAgICAgICAgICAgZ2ZjLm5zUHN5LnBlZmlyYnVmW2ldID0gZ2ZjLm5zUHN5LnBlZmlyYnVmW2kgKyAxXTtcblxuICAgICAgICAgICAgZiA9IDAuMDtcbiAgICAgICAgICAgIGZvciAoZ3IgPSAwOyBnciA8IGdmYy5tb2RlX2dyOyBncisrKVxuICAgICAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspXG4gICAgICAgICAgICAgICAgICAgIGYgKz0gcGVfdXNlW2dyXVtjaF07XG4gICAgICAgICAgICBnZmMubnNQc3kucGVmaXJidWZbMThdID0gZjtcblxuICAgICAgICAgICAgZiA9IGdmYy5uc1BzeS5wZWZpcmJ1Zls5XTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA5OyBpKyspXG4gICAgICAgICAgICAgICAgZiArPSAoZ2ZjLm5zUHN5LnBlZmlyYnVmW2ldICsgZ2ZjLm5zUHN5LnBlZmlyYnVmWzE4IC0gaV0pXG4gICAgICAgICAgICAgICAgICAgICogRW5jb2RlciQyLmZpcmNvZWZbaV07XG5cbiAgICAgICAgICAgIGYgPSAoNjcwICogNSAqIGdmYy5tb2RlX2dyICogZ2ZjLmNoYW5uZWxzX291dCkgLyBmO1xuICAgICAgICAgICAgZm9yIChnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlX3VzZVtncl1bY2hdICo9IGY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdmYy5pdGVyYXRpb25fbG9vcC5pdGVyYXRpb25fbG9vcChnZnAsIHBlX3VzZSwgbXNfZW5lcl9yYXRpbywgbWFza2luZyk7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogU3RhZ2UgNTogYml0c3RyZWFtIGZvcm1hdHRpbmcgKlxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiB3cml0ZSB0aGUgZnJhbWUgdG8gdGhlIGJpdHN0cmVhbSAqL1xuICAgICAgICBicy5mb3JtYXRfYml0c3RyZWFtKGdmcCk7XG5cbiAgICAgICAgLyogY29weSBtcDMgYml0IGJ1ZmZlciBpbnRvIGFycmF5ICovXG4gICAgICAgIG1wM2NvdW50ID0gYnMuY29weV9idWZmZXIoZ2ZjLCBtcDNidWYsIG1wM2J1ZlBvcywgbXAzYnVmX3NpemUsIDEpO1xuXG4gICAgICAgIGlmIChnZnAuYldyaXRlVmJyVGFnKVxuICAgICAgICAgICAgdmJyLmFkZFZickZyYW1lKGdmcCk7XG5cbiAgICAgICAgaWYgKGdmcC5hbmFseXNpcyAmJiBnZmMucGluZm8gIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBGRlRPRkZTRVQ7IGorKylcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLnBjbWRhdGFbY2hdW2pdID0gZ2ZjLnBpbmZvLnBjbWRhdGFbY2hdW2pcbiAgICAgICAgICAgICAgICAgICAgKyBnZnAuZnJhbWVzaXplXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBGRlRPRkZTRVQ7IGogPCAxNjAwOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLnBjbWRhdGFbY2hdW2pdID0gaW5idWZbY2hdW2ogLSBGRlRPRkZTRVRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1cHZ0LnNldF9mcmFtZV9waW5mbyhnZnAsIG1hc2tpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlU3RhdHMoZ2ZjKTtcblxuICAgICAgICByZXR1cm4gbXAzY291bnQ7XG4gICAgfTtcbn1cblxuXG52YXIgRW5jb2Rlcl8xID0gRW5jb2RlciQyO1xuXG52YXIgVXRpbCQ0ID0gY29tbW9uLlV0aWw7XG52YXIgbmV3X2Zsb2F0JDQgPSBjb21tb24ubmV3X2Zsb2F0O1xuZnVuY3Rpb24gRkZUKCkge1xuXG4gICAgdmFyIHdpbmRvdyA9IG5ld19mbG9hdCQ0KEVuY29kZXJfMS5CTEtTSVpFKTtcbiAgICB2YXIgd2luZG93X3MgPSBuZXdfZmxvYXQkNChFbmNvZGVyXzEuQkxLU0laRV9zIC8gMik7XG5cbiAgICB2YXIgY29zdGFiID0gW1xuICAgICAgICA5LjIzODc5NTMyNTExMjg2N2UtMDEsIDMuODI2ODM0MzIzNjUwODk4ZS0wMSxcbiAgICAgICAgOS45NTE4NDcyNjY3MjE5NjllLTAxLCA5LjgwMTcxNDAzMjk1NjA2MGUtMDIsXG4gICAgICAgIDkuOTk2OTg4MTg2OTYyMDQyZS0wMSwgMi40NTQxMjI4NTIyOTEyMjllLTAyLFxuICAgICAgICA5Ljk5OTgxMTc1MjgyNjAxMWUtMDEsIDYuMTM1ODg0NjQ5MTU0NDc1ZS0wM1xuICAgIF07XG5cbiAgICBmdW5jdGlvbiBmaHQoZnosIGZ6UG9zLCBuKSB7XG4gICAgICAgIHZhciB0cmkgPSAwO1xuICAgICAgICB2YXIgazQ7XG4gICAgICAgIHZhciBmaTtcbiAgICAgICAgdmFyIGdpO1xuXG4gICAgICAgIG4gPDw9IDE7XG4gICAgICAgIC8qIHRvIGdldCBCTEtTSVpFLCBiZWNhdXNlIG9mIDNETm93ISBBU00gcm91dGluZSAqL1xuICAgICAgICB2YXIgZm4gPSBmelBvcyArIG47XG4gICAgICAgIGs0ID0gNDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIHMxLCBjMTtcbiAgICAgICAgICAgIHZhciBpLCBrMSwgazIsIGszLCBreDtcbiAgICAgICAgICAgIGt4ID0gazQgPj4gMTtcbiAgICAgICAgICAgIGsxID0gazQ7XG4gICAgICAgICAgICBrMiA9IGs0IDw8IDE7XG4gICAgICAgICAgICBrMyA9IGsyICsgazE7XG4gICAgICAgICAgICBrNCA9IGsyIDw8IDE7XG4gICAgICAgICAgICBmaSA9IGZ6UG9zO1xuICAgICAgICAgICAgZ2kgPSBmaSArIGt4O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBmMCwgZjEsIGYyLCBmMztcbiAgICAgICAgICAgICAgICBmMSA9IGZ6W2ZpICsgMF0gLSBmeltmaSArIGsxXTtcbiAgICAgICAgICAgICAgICBmMCA9IGZ6W2ZpICsgMF0gKyBmeltmaSArIGsxXTtcbiAgICAgICAgICAgICAgICBmMyA9IGZ6W2ZpICsgazJdIC0gZnpbZmkgKyBrM107XG4gICAgICAgICAgICAgICAgZjIgPSBmeltmaSArIGsyXSArIGZ6W2ZpICsgazNdO1xuICAgICAgICAgICAgICAgIGZ6W2ZpICsgazJdID0gZjAgLSBmMjtcbiAgICAgICAgICAgICAgICBmeltmaSArIDBdID0gZjAgKyBmMjtcbiAgICAgICAgICAgICAgICBmeltmaSArIGszXSA9IGYxIC0gZjM7XG4gICAgICAgICAgICAgICAgZnpbZmkgKyBrMV0gPSBmMSArIGYzO1xuICAgICAgICAgICAgICAgIGYxID0gZnpbZ2kgKyAwXSAtIGZ6W2dpICsgazFdO1xuICAgICAgICAgICAgICAgIGYwID0gZnpbZ2kgKyAwXSArIGZ6W2dpICsgazFdO1xuICAgICAgICAgICAgICAgIGYzID0gKFV0aWwkNC5TUVJUMiAqIGZ6W2dpICsgazNdKTtcbiAgICAgICAgICAgICAgICBmMiA9IChVdGlsJDQuU1FSVDIgKiBmeltnaSArIGsyXSk7XG4gICAgICAgICAgICAgICAgZnpbZ2kgKyBrMl0gPSBmMCAtIGYyO1xuICAgICAgICAgICAgICAgIGZ6W2dpICsgMF0gPSBmMCArIGYyO1xuICAgICAgICAgICAgICAgIGZ6W2dpICsgazNdID0gZjEgLSBmMztcbiAgICAgICAgICAgICAgICBmeltnaSArIGsxXSA9IGYxICsgZjM7XG4gICAgICAgICAgICAgICAgZ2kgKz0gazQ7XG4gICAgICAgICAgICAgICAgZmkgKz0gazQ7XG4gICAgICAgICAgICB9IHdoaWxlIChmaSA8IGZuKTtcbiAgICAgICAgICAgIGMxID0gY29zdGFiW3RyaSArIDBdO1xuICAgICAgICAgICAgczEgPSBjb3N0YWJbdHJpICsgMV07XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwga3g7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjMiwgczI7XG4gICAgICAgICAgICAgICAgYzIgPSAxIC0gKDIgKiBzMSkgKiBzMTtcbiAgICAgICAgICAgICAgICBzMiA9ICgyICogczEpICogYzE7XG4gICAgICAgICAgICAgICAgZmkgPSBmelBvcyArIGk7XG4gICAgICAgICAgICAgICAgZ2kgPSBmelBvcyArIGsxIC0gaTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhLCBiLCBnMCwgZjAsIGYxLCBnMSwgZjIsIGcyLCBmMywgZzM7XG4gICAgICAgICAgICAgICAgICAgIGIgPSBzMiAqIGZ6W2ZpICsgazFdIC0gYzIgKiBmeltnaSArIGsxXTtcbiAgICAgICAgICAgICAgICAgICAgYSA9IGMyICogZnpbZmkgKyBrMV0gKyBzMiAqIGZ6W2dpICsgazFdO1xuICAgICAgICAgICAgICAgICAgICBmMSA9IGZ6W2ZpICsgMF0gLSBhO1xuICAgICAgICAgICAgICAgICAgICBmMCA9IGZ6W2ZpICsgMF0gKyBhO1xuICAgICAgICAgICAgICAgICAgICBnMSA9IGZ6W2dpICsgMF0gLSBiO1xuICAgICAgICAgICAgICAgICAgICBnMCA9IGZ6W2dpICsgMF0gKyBiO1xuICAgICAgICAgICAgICAgICAgICBiID0gczIgKiBmeltmaSArIGszXSAtIGMyICogZnpbZ2kgKyBrM107XG4gICAgICAgICAgICAgICAgICAgIGEgPSBjMiAqIGZ6W2ZpICsgazNdICsgczIgKiBmeltnaSArIGszXTtcbiAgICAgICAgICAgICAgICAgICAgZjMgPSBmeltmaSArIGsyXSAtIGE7XG4gICAgICAgICAgICAgICAgICAgIGYyID0gZnpbZmkgKyBrMl0gKyBhO1xuICAgICAgICAgICAgICAgICAgICBnMyA9IGZ6W2dpICsgazJdIC0gYjtcbiAgICAgICAgICAgICAgICAgICAgZzIgPSBmeltnaSArIGsyXSArIGI7XG4gICAgICAgICAgICAgICAgICAgIGIgPSBzMSAqIGYyIC0gYzEgKiBnMztcbiAgICAgICAgICAgICAgICAgICAgYSA9IGMxICogZjIgKyBzMSAqIGczO1xuICAgICAgICAgICAgICAgICAgICBmeltmaSArIGsyXSA9IGYwIC0gYTtcbiAgICAgICAgICAgICAgICAgICAgZnpbZmkgKyAwXSA9IGYwICsgYTtcbiAgICAgICAgICAgICAgICAgICAgZnpbZ2kgKyBrM10gPSBnMSAtIGI7XG4gICAgICAgICAgICAgICAgICAgIGZ6W2dpICsgazFdID0gZzEgKyBiO1xuICAgICAgICAgICAgICAgICAgICBiID0gYzEgKiBnMiAtIHMxICogZjM7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBzMSAqIGcyICsgYzEgKiBmMztcbiAgICAgICAgICAgICAgICAgICAgZnpbZ2kgKyBrMl0gPSBnMCAtIGE7XG4gICAgICAgICAgICAgICAgICAgIGZ6W2dpICsgMF0gPSBnMCArIGE7XG4gICAgICAgICAgICAgICAgICAgIGZ6W2ZpICsgazNdID0gZjEgLSBiO1xuICAgICAgICAgICAgICAgICAgICBmeltmaSArIGsxXSA9IGYxICsgYjtcbiAgICAgICAgICAgICAgICAgICAgZ2kgKz0gazQ7XG4gICAgICAgICAgICAgICAgICAgIGZpICs9IGs0O1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGZpIDwgZm4pO1xuICAgICAgICAgICAgICAgIGMyID0gYzE7XG4gICAgICAgICAgICAgICAgYzEgPSBjMiAqIGNvc3RhYlt0cmkgKyAwXSAtIHMxICogY29zdGFiW3RyaSArIDFdO1xuICAgICAgICAgICAgICAgIHMxID0gYzIgKiBjb3N0YWJbdHJpICsgMV0gKyBzMSAqIGNvc3RhYlt0cmkgKyAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaSArPSAyO1xuICAgICAgICB9IHdoaWxlIChrNCA8IG4pO1xuICAgIH1cblxuICAgIHZhciBydl90YmwgPSBbMHgwMCwgMHg4MCwgMHg0MCxcbiAgICAgICAgMHhjMCwgMHgyMCwgMHhhMCwgMHg2MCwgMHhlMCwgMHgxMCxcbiAgICAgICAgMHg5MCwgMHg1MCwgMHhkMCwgMHgzMCwgMHhiMCwgMHg3MCxcbiAgICAgICAgMHhmMCwgMHgwOCwgMHg4OCwgMHg0OCwgMHhjOCwgMHgyOCxcbiAgICAgICAgMHhhOCwgMHg2OCwgMHhlOCwgMHgxOCwgMHg5OCwgMHg1OCxcbiAgICAgICAgMHhkOCwgMHgzOCwgMHhiOCwgMHg3OCwgMHhmOCwgMHgwNCxcbiAgICAgICAgMHg4NCwgMHg0NCwgMHhjNCwgMHgyNCwgMHhhNCwgMHg2NCxcbiAgICAgICAgMHhlNCwgMHgxNCwgMHg5NCwgMHg1NCwgMHhkNCwgMHgzNCxcbiAgICAgICAgMHhiNCwgMHg3NCwgMHhmNCwgMHgwYywgMHg4YywgMHg0YyxcbiAgICAgICAgMHhjYywgMHgyYywgMHhhYywgMHg2YywgMHhlYywgMHgxYyxcbiAgICAgICAgMHg5YywgMHg1YywgMHhkYywgMHgzYywgMHhiYywgMHg3YyxcbiAgICAgICAgMHhmYywgMHgwMiwgMHg4MiwgMHg0MiwgMHhjMiwgMHgyMixcbiAgICAgICAgMHhhMiwgMHg2MiwgMHhlMiwgMHgxMiwgMHg5MiwgMHg1MixcbiAgICAgICAgMHhkMiwgMHgzMiwgMHhiMiwgMHg3MiwgMHhmMiwgMHgwYSxcbiAgICAgICAgMHg4YSwgMHg0YSwgMHhjYSwgMHgyYSwgMHhhYSwgMHg2YSxcbiAgICAgICAgMHhlYSwgMHgxYSwgMHg5YSwgMHg1YSwgMHhkYSwgMHgzYSxcbiAgICAgICAgMHhiYSwgMHg3YSwgMHhmYSwgMHgwNiwgMHg4NiwgMHg0NixcbiAgICAgICAgMHhjNiwgMHgyNiwgMHhhNiwgMHg2NiwgMHhlNiwgMHgxNixcbiAgICAgICAgMHg5NiwgMHg1NiwgMHhkNiwgMHgzNiwgMHhiNiwgMHg3NixcbiAgICAgICAgMHhmNiwgMHgwZSwgMHg4ZSwgMHg0ZSwgMHhjZSwgMHgyZSxcbiAgICAgICAgMHhhZSwgMHg2ZSwgMHhlZSwgMHgxZSwgMHg5ZSwgMHg1ZSxcbiAgICAgICAgMHhkZSwgMHgzZSwgMHhiZSwgMHg3ZSwgMHhmZV07XG5cbiAgICB0aGlzLmZmdF9zaG9ydCA9IGZ1bmN0aW9uIChnZmMsIHhfcmVhbCwgY2huLCBidWZmZXIsIGJ1ZlBvcykge1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IDM7IGIrKykge1xuICAgICAgICAgICAgdmFyIHggPSBFbmNvZGVyXzEuQkxLU0laRV9zIC8gMjtcbiAgICAgICAgICAgIHZhciBrID0gMHhmZmZmICYgKCg1NzYgLyAzKSAqIChiICsgMSkpO1xuICAgICAgICAgICAgdmFyIGogPSBFbmNvZGVyXzEuQkxLU0laRV9zIC8gOCAtIDE7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIGYwLCBmMSwgZjIsIGYzLCB3O1xuICAgICAgICAgICAgICAgIHZhciBpID0gcnZfdGJsW2ogPDwgMl0gJiAweGZmO1xuXG4gICAgICAgICAgICAgICAgZjAgPSB3aW5kb3dfc1tpXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGkgKyBrXTtcbiAgICAgICAgICAgICAgICB3ID0gd2luZG93X3NbMHg3ZiAtIGldICogYnVmZmVyW2Nobl1bYnVmUG9zICsgaSArIGsgKyAweDgwXTtcbiAgICAgICAgICAgICAgICBmMSA9IGYwIC0gdztcbiAgICAgICAgICAgICAgICBmMCA9IGYwICsgdztcbiAgICAgICAgICAgICAgICBmMiA9IHdpbmRvd19zW2kgKyAweDQwXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGkgKyBrICsgMHg0MF07XG4gICAgICAgICAgICAgICAgdyA9IHdpbmRvd19zWzB4M2YgLSBpXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGkgKyBrICsgMHhjMF07XG4gICAgICAgICAgICAgICAgZjMgPSBmMiAtIHc7XG4gICAgICAgICAgICAgICAgZjIgPSBmMiArIHc7XG5cbiAgICAgICAgICAgICAgICB4IC09IDQ7XG4gICAgICAgICAgICAgICAgeF9yZWFsW2JdW3ggKyAwXSA9IGYwICsgZjI7XG4gICAgICAgICAgICAgICAgeF9yZWFsW2JdW3ggKyAyXSA9IGYwIC0gZjI7XG4gICAgICAgICAgICAgICAgeF9yZWFsW2JdW3ggKyAxXSA9IGYxICsgZjM7XG4gICAgICAgICAgICAgICAgeF9yZWFsW2JdW3ggKyAzXSA9IGYxIC0gZjM7XG5cbiAgICAgICAgICAgICAgICBmMCA9IHdpbmRvd19zW2kgKyAweDAxXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGkgKyBrICsgMHgwMV07XG4gICAgICAgICAgICAgICAgdyA9IHdpbmRvd19zWzB4N2UgLSBpXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGkgKyBrICsgMHg4MV07XG4gICAgICAgICAgICAgICAgZjEgPSBmMCAtIHc7XG4gICAgICAgICAgICAgICAgZjAgPSBmMCArIHc7XG4gICAgICAgICAgICAgICAgZjIgPSB3aW5kb3dfc1tpICsgMHg0MV0gKiBidWZmZXJbY2huXVtidWZQb3MgKyBpICsgayArIDB4NDFdO1xuICAgICAgICAgICAgICAgIHcgPSB3aW5kb3dfc1sweDNlIC0gaV0gKiBidWZmZXJbY2huXVtidWZQb3MgKyBpICsgayArIDB4YzFdO1xuICAgICAgICAgICAgICAgIGYzID0gZjIgLSB3O1xuICAgICAgICAgICAgICAgIGYyID0gZjIgKyB3O1xuXG4gICAgICAgICAgICAgICAgeF9yZWFsW2JdW3ggKyBFbmNvZGVyXzEuQkxLU0laRV9zIC8gMiArIDBdID0gZjAgKyBmMjtcbiAgICAgICAgICAgICAgICB4X3JlYWxbYl1beCArIEVuY29kZXJfMS5CTEtTSVpFX3MgLyAyICsgMl0gPSBmMCAtIGYyO1xuICAgICAgICAgICAgICAgIHhfcmVhbFtiXVt4ICsgRW5jb2Rlcl8xLkJMS1NJWkVfcyAvIDIgKyAxXSA9IGYxICsgZjM7XG4gICAgICAgICAgICAgICAgeF9yZWFsW2JdW3ggKyBFbmNvZGVyXzEuQkxLU0laRV9zIC8gMiArIDNdID0gZjEgLSBmMztcbiAgICAgICAgICAgIH0gd2hpbGUgKC0taiA+PSAwKTtcblxuICAgICAgICAgICAgZmh0KHhfcmVhbFtiXSwgeCwgRW5jb2Rlcl8xLkJMS1NJWkVfcyAvIDIpO1xuICAgICAgICAgICAgLyogQkxLU0laRV9zLzIgYmVjYXVzZSBvZiAzRE5vdyEgQVNNIHJvdXRpbmUgKi9cbiAgICAgICAgICAgIC8qIEJMS1NJWkUvMiBiZWNhdXNlIG9mIDNETm93ISBBU00gcm91dGluZSAqL1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZmZ0X2xvbmcgPSBmdW5jdGlvbiAoZ2ZjLCB5LCBjaG4sIGJ1ZmZlciwgYnVmUG9zKSB7XG4gICAgICAgIHZhciBqaiA9IEVuY29kZXJfMS5CTEtTSVpFIC8gOCAtIDE7XG4gICAgICAgIHZhciB4ID0gRW5jb2Rlcl8xLkJMS1NJWkUgLyAyO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBmMCwgZjEsIGYyLCBmMywgdztcbiAgICAgICAgICAgIHZhciBpID0gcnZfdGJsW2pqXSAmIDB4ZmY7XG4gICAgICAgICAgICBmMCA9IHdpbmRvd1tpXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGldO1xuICAgICAgICAgICAgdyA9IHdpbmRvd1tpICsgMHgyMDBdICogYnVmZmVyW2Nobl1bYnVmUG9zICsgaSArIDB4MjAwXTtcbiAgICAgICAgICAgIGYxID0gZjAgLSB3O1xuICAgICAgICAgICAgZjAgPSBmMCArIHc7XG4gICAgICAgICAgICBmMiA9IHdpbmRvd1tpICsgMHgxMDBdICogYnVmZmVyW2Nobl1bYnVmUG9zICsgaSArIDB4MTAwXTtcbiAgICAgICAgICAgIHcgPSB3aW5kb3dbaSArIDB4MzAwXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGkgKyAweDMwMF07XG4gICAgICAgICAgICBmMyA9IGYyIC0gdztcbiAgICAgICAgICAgIGYyID0gZjIgKyB3O1xuXG4gICAgICAgICAgICB4IC09IDQ7XG4gICAgICAgICAgICB5W3ggKyAwXSA9IGYwICsgZjI7XG4gICAgICAgICAgICB5W3ggKyAyXSA9IGYwIC0gZjI7XG4gICAgICAgICAgICB5W3ggKyAxXSA9IGYxICsgZjM7XG4gICAgICAgICAgICB5W3ggKyAzXSA9IGYxIC0gZjM7XG5cbiAgICAgICAgICAgIGYwID0gd2luZG93W2kgKyAweDAwMV0gKiBidWZmZXJbY2huXVtidWZQb3MgKyBpICsgMHgwMDFdO1xuICAgICAgICAgICAgdyA9IHdpbmRvd1tpICsgMHgyMDFdICogYnVmZmVyW2Nobl1bYnVmUG9zICsgaSArIDB4MjAxXTtcbiAgICAgICAgICAgIGYxID0gZjAgLSB3O1xuICAgICAgICAgICAgZjAgPSBmMCArIHc7XG4gICAgICAgICAgICBmMiA9IHdpbmRvd1tpICsgMHgxMDFdICogYnVmZmVyW2Nobl1bYnVmUG9zICsgaSArIDB4MTAxXTtcbiAgICAgICAgICAgIHcgPSB3aW5kb3dbaSArIDB4MzAxXSAqIGJ1ZmZlcltjaG5dW2J1ZlBvcyArIGkgKyAweDMwMV07XG4gICAgICAgICAgICBmMyA9IGYyIC0gdztcbiAgICAgICAgICAgIGYyID0gZjIgKyB3O1xuXG4gICAgICAgICAgICB5W3ggKyBFbmNvZGVyXzEuQkxLU0laRSAvIDIgKyAwXSA9IGYwICsgZjI7XG4gICAgICAgICAgICB5W3ggKyBFbmNvZGVyXzEuQkxLU0laRSAvIDIgKyAyXSA9IGYwIC0gZjI7XG4gICAgICAgICAgICB5W3ggKyBFbmNvZGVyXzEuQkxLU0laRSAvIDIgKyAxXSA9IGYxICsgZjM7XG4gICAgICAgICAgICB5W3ggKyBFbmNvZGVyXzEuQkxLU0laRSAvIDIgKyAzXSA9IGYxIC0gZjM7XG4gICAgICAgIH0gd2hpbGUgKC0tamogPj0gMCk7XG5cbiAgICAgICAgZmh0KHksIHgsIEVuY29kZXJfMS5CTEtTSVpFIC8gMik7XG4gICAgICAgIC8qIEJMS1NJWkUvMiBiZWNhdXNlIG9mIDNETm93ISBBU00gcm91dGluZSAqL1xuICAgIH07XG5cbiAgICB0aGlzLmluaXRfZmZ0ID0gZnVuY3Rpb24gKGdmYykge1xuICAgICAgICAvKiBUaGUgdHlwZSBvZiB3aW5kb3cgdXNlZCBoZXJlIHdpbGwgbWFrZSBubyByZWFsIGRpZmZlcmVuY2UsIGJ1dCAqL1xuICAgICAgICAvKlxuICAgICAgICAgKiBpbiB0aGUgaW50ZXJlc3Qgb2YgbWVyZ2luZyBuc3BzeXR1bmUgc3R1ZmYgLSBzd2l0Y2ggdG8gYmxhY2ttYW5cbiAgICAgICAgICogd2luZG93XG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEVuY29kZXJfMS5CTEtTSVpFOyBpKyspXG4gICAgICAgICAgICAvKiBibGFja21hbiB3aW5kb3cgKi9cbiAgICAgICAgICAgIHdpbmRvd1tpXSA9ICgwLjQyIC0gMC41ICogTWF0aC5jb3MoMiAqIE1hdGguUEkgKiAoaSArIC41KVxuICAgICAgICAgICAgICAgIC8gRW5jb2Rlcl8xLkJMS1NJWkUpICsgMC4wOCAqIE1hdGguY29zKDQgKiBNYXRoLlBJICogKGkgKyAuNSlcbiAgICAgICAgICAgICAgICAvIEVuY29kZXJfMS5CTEtTSVpFKSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBFbmNvZGVyXzEuQkxLU0laRV9zIC8gMjsgaSsrKVxuICAgICAgICAgICAgd2luZG93X3NbaV0gPSAoMC41ICogKDEuMCAtIE1hdGguY29zKDIuMCAqIE1hdGguUElcbiAgICAgICAgICAgICAgICAqIChpICsgMC41KSAvIEVuY29kZXJfMS5CTEtTSVpFX3MpKSk7XG5cbiAgICB9O1xuXG59XG5cbnZhciBGRlRfMSA9IEZGVDtcblxudmFyIFZick1vZGUkMyA9IGNvbW1vbi5WYnJNb2RlO1xudmFyIEZsb2F0JDMgPSBjb21tb24uRmxvYXQ7XG52YXIgU2hvcnRCbG9jayQzID0gY29tbW9uLlNob3J0QmxvY2s7XG52YXIgVXRpbCQzID0gY29tbW9uLlV0aWw7XG52YXIgQXJyYXlzJDMgPSBjb21tb24uQXJyYXlzO1xudmFyIG5ld19mbG9hdCQzID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfZmxvYXRfbiQzID0gY29tbW9uLm5ld19mbG9hdF9uO1xudmFyIG5ld19pbnQkMyA9IGNvbW1vbi5uZXdfaW50O1xudmFyIGFzc2VydCQzID0gY29tbW9uLmFzc2VydDtcblxuXG5cblxuZnVuY3Rpb24gUHN5TW9kZWwoKSB7XG5cbiAgICB2YXIgZmZ0ID0gbmV3IEZGVF8xKCk7XG5cbiAgICB2YXIgTE9HMTAgPSAyLjMwMjU4NTA5Mjk5NDA0NTY4NDAyO1xuXG4gICAgdmFyIHJwZWxldiA9IDI7XG4gICAgdmFyIHJwZWxldjIgPSAxNjtcbiAgICB2YXIgcnBlbGV2X3MgPSAyO1xuICAgIHZhciBycGVsZXYyX3MgPSAxNjtcblxuICAgIC8qIHNpemUgb2YgZWFjaCBwYXJ0aXRpb24gYmFuZCwgaW4gYmFya3M6ICovXG4gICAgdmFyIERFTEJBUksgPSAuMzQ7XG5cbiAgICAvKiB0dW5lZCBmb3Igb3V0cHV0IGxldmVsIChzZW5zaXRpdmUgdG8gZW5lcmd5IHNjYWxlKSAqL1xuICAgIHZhciBWT19TQ0FMRSA9ICgxLiAvICgxNDc1MiAqIDE0NzUyKSAvIChFbmNvZGVyXzEuQkxLU0laRSAvIDIpKTtcblxuICAgIHZhciB0ZW1wb3JhbG1hc2tfc3VzdGFpbl9zZWMgPSAwLjAxO1xuXG4gICAgdmFyIE5TX1BSRUVDSE9fQVRUMCA9IDAuODtcbiAgICB2YXIgTlNfUFJFRUNIT19BVFQxID0gMC42O1xuICAgIHZhciBOU19QUkVFQ0hPX0FUVDIgPSAwLjM7XG5cbiAgICB2YXIgTlNfTVNGSVggPSAzLjU7XG5cbiAgICB2YXIgTlNBVFRBQ0tUSFJFID0gNC40O1xuICAgIHZhciBOU0FUVEFDS1RIUkVfUyA9IDI1O1xuXG4gICAgdmFyIE5TRklSTEVOID0gMjE7XG5cbiAgICAvKiBzaXplIG9mIGVhY2ggcGFydGl0aW9uIGJhbmQsIGluIGJhcmtzOiAqL1xuICAgIHZhciBMTl9UT19MT0cxMCA9IDAuMjMwMjU4NTA5MztcblxuICAgIGZ1bmN0aW9uIE5PTl9MSU5FQVJfU0NBTEVfRU5FUkdZKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiAgICAgICBMM3BzeWNob19hbmFsLiAgQ29tcHV0ZSBwc3ljaG8gYWNvdXN0aWNzLlxuICAgICAqXG4gICAgICogICAgICAgRGF0YSByZXR1cm5lZCB0byB0aGUgY2FsbGluZyBwcm9ncmFtIG11c3QgYmUgZGVsYXllZCBieSBvbmVcbiAgICAgKiAgICAgICBncmFudWxlLlxuICAgICAqXG4gICAgICogICAgICAgVGhpcyBpcyBkb25lIGluIHR3byBwbGFjZXMuXG4gICAgICogICAgICAgSWYgd2UgZG8gbm90IG5lZWQgdG8ga25vdyB0aGUgYmxvY2t0eXBlLCB0aGUgY29weWluZ1xuICAgICAqICAgICAgIGNhbiBiZSBkb25lIGhlcmUgYXQgdGhlIHRvcCBvZiB0aGUgcHJvZ3JhbTogd2UgY29weSB0aGUgZGF0YSBmb3JcbiAgICAgKiAgICAgICB0aGUgbGFzdCBncmFudWxlIChjb21wdXRlZCBkdXJpbmcgdGhlIGxhc3QgY2FsbCkgYmVmb3JlIGl0IGlzXG4gICAgICogICAgICAgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IGRhdGEuICBJdCBsb29rcyBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiAgICAgICAwLiBzdGF0aWMgcHN5bW9kZWxfZGF0YVxuICAgICAqICAgICAgIDEuIGNhbGxpbmdfcHJvZ3JhbV9kYXRhID0gcHN5bW9kZWxfZGF0YVxuICAgICAqICAgICAgIDIuIGNvbXB1dGUgcHN5bW9kZWxfZGF0YVxuICAgICAqXG4gICAgICogICAgICAgRm9yIGRhdGEgd2hpY2ggbmVlZHMgdG8ga25vdyB0aGUgYmxvY2t0eXBlLCB0aGUgY29weWluZyBtdXN0IGJlXG4gICAgICogICAgICAgZG9uZSBhdCB0aGUgZW5kIG9mIHRoaXMgbG9vcCwgYW5kIHRoZSBvbGQgdmFsdWVzIG11c3QgYmUgc2F2ZWQ6XG4gICAgICpcbiAgICAgKiAgICAgICAwLiBzdGF0aWMgcHN5bW9kZWxfZGF0YV9vbGRcbiAgICAgKiAgICAgICAxLiBjb21wdXRlIHBzeW1vZGVsX2RhdGFcbiAgICAgKiAgICAgICAyLiBjb21wdXRlIHBvc3NpYmxlIGJsb2NrIHR5cGUgb2YgdGhpcyBncmFudWxlXG4gICAgICogICAgICAgMy4gY29tcHV0ZSBmaW5hbCBibG9jayB0eXBlIG9mIHByZXZpb3VzIGdyYW51bGUgYmFzZWQgb24gIzIuXG4gICAgICogICAgICAgNC4gY2FsbGluZ19wcm9ncmFtX2RhdGEgPSBwc3ltb2RlbF9kYXRhX29sZFxuICAgICAqICAgICAgIDUuIHBzeW1vZGVsX2RhdGFfb2xkID0gcHN5bW9kZWxfZGF0YVxuICAgICAqICAgICBwc3ljaG9fbG91ZG5lc3NfYXBwcm94XG4gICAgICogICAgICAgamQgLSAyMDAxIG1hciAxMlxuICAgICAqICAgIGluOiAgZW5lcmd5ICAgLSBCTEtTSVpFLzIgZWxlbWVudHMgb2YgZnJlcXVlbmN5IG1hZ25pdHVkZXMgXiAyXG4gICAgICogICAgICAgICBnZnAgICAgICAtIHVzZXMgb3V0X3NhbXBsZXJhdGUsIEFUSHR5cGUgKGFsc28gbmVlZGVkIGZvciBBVEhmb3JtdWxhKVxuICAgICAqICAgIHJldHVybnM6IGxvdWRuZXNzXjIgYXBwcm94aW1hdGlvbiwgYSBwb3NpdGl2ZSB2YWx1ZSByb3VnaGx5IHR1bmVkIGZvciBhIHZhbHVlXG4gICAgICogICAgICAgICAgICAgb2YgMS4wIGZvciBzaWduYWxzIG5lYXIgY2xpcHBpbmcuXG4gICAgICogICAgbm90ZXM6ICAgV2hlbiBjYWxpYnJhdGVkLCBmZWVkaW5nIHRoaXMgZnVuY3Rpb24gYmluYXJ5IHdoaXRlIG5vaXNlIGF0IHNhbXBsZVxuICAgICAqICAgICAgICAgICAgIHZhbHVlcyArMzI3Njcgb3IgLTMyNzY4IHNob3VsZCByZXR1cm4gdmFsdWVzIHRoYXQgYXBwcm9hY2ggMy5cbiAgICAgKiAgICAgICAgICAgICBBVEhmb3JtdWxhIGlzIHVzZWQgdG8gYXBwcm94aW1hdGUgYW4gZXF1YWwgbG91ZG5lc3MgY3VydmUuXG4gICAgICogICAgZnV0dXJlOiAgRGF0YSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2hhcGUgb2YgdGhlIGVxdWFsIGxvdWRuZXNzIGN1cnZlIHZhcmllc1xuICAgICAqICAgICAgICAgICAgIHdpdGggaW50ZW5zaXR5LiAgVGhpcyBmdW5jdGlvbiBtaWdodCBiZSBpbXByb3ZlZCBieSB1c2luZyBhbiBlcXVhbFxuICAgICAqICAgICAgICAgICAgIGxvdWRuZXNzIGN1cnZlIHNoYXBlZCBmb3IgdHlwaWNhbCBwbGF5YmFjayBsZXZlbHMgKGluc3RlYWQgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgQVRILCB0aGF0IGlzIHNoYXBlZCBmb3IgdGhlIHRocmVzaG9sZCkuICBBIGZsZXhpYmxlIHJlYWxpemF0aW9uIG1pZ2h0XG4gICAgICogICAgICAgICAgICAgc2ltcGx5IGJlbmQgdGhlIGV4aXN0aW5nIEFUSCBjdXJ2ZSB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIHNoYXBlLlxuICAgICAqICAgICAgICAgICAgIEhvd2V2ZXIsIHRoZSBwb3RlbnRpYWwgZ2FpbiBtYXkgbm90IGJlIGVub3VnaCB0byBqdXN0aWZ5IGFuIGVmZm9ydC5cbiAgICAgKiA8L1BSRT5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwc3ljaG9fbG91ZG5lc3NfYXBwcm94KGVuZXJneSwgZ2ZjKSB7XG4gICAgICAgIHZhciBsb3VkbmVzc19wb3dlciA9IDAuMDtcbiAgICAgICAgLyogYXBwbHkgd2VpZ2h0cyB0byBwb3dlciBpbiBmcmVxLiBiYW5kcyAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEVuY29kZXJfMS5CTEtTSVpFIC8gMjsgKytpKVxuICAgICAgICAgICAgbG91ZG5lc3NfcG93ZXIgKz0gZW5lcmd5W2ldICogZ2ZjLkFUSC5lcWxfd1tpXTtcbiAgICAgICAgbG91ZG5lc3NfcG93ZXIgKj0gVk9fU0NBTEU7XG5cbiAgICAgICAgcmV0dXJuIGxvdWRuZXNzX3Bvd2VyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVfZmZ0cyhnZnAsIGZmdGVuZXJneSwgZmZ0ZW5lcmd5X3MsIHdzYW1wX2wsIHdzYW1wX2xQb3MsIHdzYW1wX3MsIHdzYW1wX3NQb3MsIGdyX291dCwgY2huLCBidWZmZXIsIGJ1ZlBvcykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICBpZiAoY2huIDwgMikge1xuICAgICAgICAgICAgZmZ0LmZmdF9sb25nKGdmYywgd3NhbXBfbFt3c2FtcF9sUG9zXSwgY2huLCBidWZmZXIsIGJ1ZlBvcyk7XG4gICAgICAgICAgICBmZnQuZmZ0X3Nob3J0KGdmYywgd3NhbXBfc1t3c2FtcF9zUG9zXSwgY2huLCBidWZmZXIsIGJ1ZlBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogRkZUIGRhdGEgZm9yIG1pZCBhbmQgc2lkZSBjaGFubmVsIGlzIGRlcml2ZWQgZnJvbSBMICYgUiAqL1xuICAgICAgICBlbHNlIGlmIChjaG4gPT0gMikge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IEVuY29kZXJfMS5CTEtTSVpFIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHdzYW1wX2xbd3NhbXBfbFBvcyArIDBdW2pdO1xuICAgICAgICAgICAgICAgIHZhciByID0gd3NhbXBfbFt3c2FtcF9sUG9zICsgMV1bal07XG4gICAgICAgICAgICAgICAgd3NhbXBfbFt3c2FtcF9sUG9zICsgMF1bal0gPSAobCArIHIpICogVXRpbCQzLlNRUlQyICogMC41O1xuICAgICAgICAgICAgICAgIHdzYW1wX2xbd3NhbXBfbFBvcyArIDFdW2pdID0gKGwgLSByKSAqIFV0aWwkMy5TUVJUMiAqIDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAyOyBiID49IDA7IC0tYikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBFbmNvZGVyXzEuQkxLU0laRV9zIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSB3c2FtcF9zW3dzYW1wX3NQb3MgKyAwXVtiXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB3c2FtcF9zW3dzYW1wX3NQb3MgKyAxXVtiXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgd3NhbXBfc1t3c2FtcF9zUG9zICsgMF1bYl1bal0gPSAobCArIHIpICogVXRpbCQzLlNRUlQyICogMC41O1xuICAgICAgICAgICAgICAgICAgICB3c2FtcF9zW3dzYW1wX3NQb3MgKyAxXVtiXVtqXSA9IChsIC0gcikgKiBVdGlsJDMuU1FSVDIgKiAwLjU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBjb21wdXRlIGVuZXJnaWVzXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGZmdGVuZXJneVswXSA9IE5PTl9MSU5FQVJfU0NBTEVfRU5FUkdZKHdzYW1wX2xbd3NhbXBfbFBvcyArIDBdWzBdKTtcbiAgICAgICAgZmZ0ZW5lcmd5WzBdICo9IGZmdGVuZXJneVswXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gRW5jb2Rlcl8xLkJMS1NJWkUgLyAyIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgIHZhciByZSA9ICh3c2FtcF9sW3dzYW1wX2xQb3MgKyAwXSlbRW5jb2Rlcl8xLkJMS1NJWkUgLyAyIC0gal07XG4gICAgICAgICAgICB2YXIgaW0gPSAod3NhbXBfbFt3c2FtcF9sUG9zICsgMF0pW0VuY29kZXJfMS5CTEtTSVpFIC8gMiArIGpdO1xuICAgICAgICAgICAgZmZ0ZW5lcmd5W0VuY29kZXJfMS5CTEtTSVpFIC8gMiAtIGpdID0gTk9OX0xJTkVBUl9TQ0FMRV9FTkVSR1koKHJlXG4gICAgICAgICAgICAgICAgKiByZSArIGltICogaW0pICogMC41KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBiID0gMjsgYiA+PSAwOyAtLWIpIHtcbiAgICAgICAgICAgIGZmdGVuZXJneV9zW2JdWzBdID0gKHdzYW1wX3Nbd3NhbXBfc1BvcyArIDBdKVtiXVswXTtcbiAgICAgICAgICAgIGZmdGVuZXJneV9zW2JdWzBdICo9IGZmdGVuZXJneV9zW2JdWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IEVuY29kZXJfMS5CTEtTSVpFX3MgLyAyIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICB2YXIgcmUgPSAod3NhbXBfc1t3c2FtcF9zUG9zICsgMF0pW2JdW0VuY29kZXJfMS5CTEtTSVpFX3NcbiAgICAgICAgICAgICAgICAvIDIgLSBqXTtcbiAgICAgICAgICAgICAgICB2YXIgaW0gPSAod3NhbXBfc1t3c2FtcF9zUG9zICsgMF0pW2JdW0VuY29kZXJfMS5CTEtTSVpFX3NcbiAgICAgICAgICAgICAgICAvIDIgKyBqXTtcbiAgICAgICAgICAgICAgICBmZnRlbmVyZ3lfc1tiXVtFbmNvZGVyXzEuQkxLU0laRV9zIC8gMiAtIGpdID0gTk9OX0xJTkVBUl9TQ0FMRV9FTkVSR1koKHJlXG4gICAgICAgICAgICAgICAgICAgICogcmUgKyBpbSAqIGltKSAqIDAuNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogdG90YWwgZW5lcmd5ICovXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0b3RhbGVuZXJneSA9IDAuMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxMTsgaiA8IEVuY29kZXJfMS5IQkxLU0laRTsgaisrKVxuICAgICAgICAgICAgICAgIHRvdGFsZW5lcmd5ICs9IGZmdGVuZXJneVtqXTtcblxuICAgICAgICAgICAgZ2ZjLnRvdF9lbmVyW2Nobl0gPSB0b3RhbGVuZXJneTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZnAuYW5hbHlzaXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgRW5jb2Rlcl8xLkhCTEtTSVpFOyBqKyspIHtcbiAgICAgICAgICAgICAgICBnZmMucGluZm8uZW5lcmd5W2dyX291dF1bY2huXVtqXSA9IGdmYy5waW5mby5lbmVyZ3lfc2F2ZVtjaG5dW2pdO1xuICAgICAgICAgICAgICAgIGdmYy5waW5mby5lbmVyZ3lfc2F2ZVtjaG5dW2pdID0gZmZ0ZW5lcmd5W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2ZjLnBpbmZvLnBlW2dyX291dF1bY2huXSA9IGdmYy5wZVtjaG5dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBjb21wdXRlIGxvdWRuZXNzIGFwcHJveGltYXRpb24gKHVzZWQgZm9yIEFUSCBhdXRvLWxldmVsIGFkanVzdG1lbnQpXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGlmIChnZnAuYXRoYWFfbG91ZGFwcHJveCA9PSAyICYmIGNobiA8IDIpIHtcbiAgICAgICAgICAgIC8vIG5vIGxvdWRuZXNzIGZvciBtaWQvc2lkZSBjaFxuICAgICAgICAgICAgZ2ZjLmxvdWRuZXNzX3NxW2dyX291dF1bY2huXSA9IGdmYy5sb3VkbmVzc19zcV9zYXZlW2Nobl07XG4gICAgICAgICAgICBnZmMubG91ZG5lc3Nfc3Ffc2F2ZVtjaG5dID0gcHN5Y2hvX2xvdWRuZXNzX2FwcHJveChmZnRlbmVyZ3ksIGdmYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBtYXNrX2FkZCBvcHRpbWl6YXRpb24gKi9cbiAgICAvKiBpbml0IHRoZSBsaW1pdCB2YWx1ZXMgdXNlZCB0byBhdm9pZCBjb21wdXRpbmcgbG9nIGluIG1hc2tfYWRkIHdoZW4gaXQgaXMgbm90IG5lY2Vzc2FyeSAqL1xuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiAgRm9yIGV4YW1wbGUsIHdpdGggaSA9IDEwKmxvZzEwKG0yL20xKS8xMCoxNiAgICAgICAgICg9IGxvZzEwKG0yL20xKSoxNilcbiAgICAgKlxuICAgICAqIGFicyhpKT44IGlzIGVxdWl2YWxlbnQgKGFzIGkgaXMgYW4gaW50ZWdlcikgdG9cbiAgICAgKiBhYnMoaSk+PTlcbiAgICAgKiBpPj05IHx8IGk8PS05XG4gICAgICogZXF1aXZhbGVudCB0byAoYXMgaSBpcyB0aGUgYmlnZ2VzdCBpbnRlZ2VyIHNtYWxsZXIgdGhhbiBsb2cxMChtMi9tMSkqMTZcbiAgICAgKiBvciB0aGUgc21hbGxlc3QgaW50ZWdlciBiaWdnZXIgdGhhbiBsb2cxMChtMi9tMSkqMTYgZGVwZW5kaW5nIG9uIHRoZSBzaWduIG9mIGxvZzEwKG0yL20xKSoxNilcbiAgICAgKiBsb2cxMChtMi9tMSk+PTkvMTYgfHwgbG9nMTAobTIvbTEpPD0tOS8xNlxuICAgICAqIGV4cDEwIGlzIHN0cmljdGx5IGluY3JlYXNpbmcgdGh1cyB0aGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgKiBtMi9tMSA+PSAxMF4oOS8xNikgfHwgbTIvbTE8PTEwXigtOS8xNikgd2hpY2ggYXJlIGNvbXBhcmlzb25zIHRvIGNvbnN0YW50c1xuICAgICAqIDwvUFJFPlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogYXMgaW4gaWYoaT44KVxuICAgICAqL1xuICAgIHZhciBJMUxJTUlUID0gODtcbiAgICAvKipcbiAgICAgKiBhcyBpbiBpZihpPjI0KSAuIGNoYW5nZWQgMjNcbiAgICAgKi9cbiAgICB2YXIgSTJMSU1JVCA9IDIzO1xuICAgIC8qKlxuICAgICAqIGFzIGluIGlmKG08MTUpXG4gICAgICovXG4gICAgdmFyIE1MSU1JVCA9IDE1O1xuXG4gICAgdmFyIG1hX21heF9pMTtcbiAgICB2YXIgbWFfbWF4X2kyO1xuICAgIHZhciBtYV9tYXhfbTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIG1hc2tpbmcgdGFibGU6PEJSPlxuICAgICAqIEFjY29yZGluZyB0byB0b25hbGl0eSwgdmFsdWVzIGFyZSBnb2luZyBmcm9tIDBkQiAoVE1OKSB0byA5LjNkQiAoTk1UKS48QlI+XG4gICAgICogQWZ0ZXIgYWRkaXRpdmUgbWFza2luZyBjb21wdXRhdGlvbiwgOGRCIGFyZSBhZGRlZCwgc28gZmluYWwgdmFsdWVzIGFyZVxuICAgICAqIGdvaW5nIGZyb20gOGRCIHRvIDE3LjNkQlxuICAgICAqXG4gICAgICogcG93KDEwLCAtMC4wLi4tMC42KVxuICAgICAqL1xuICAgIHZhciB0YWIgPSBbMS4wLCAwLjc5NDMzLCAwLjYzMDk2LCAwLjYzMDk2LFxuICAgICAgICAwLjYzMDk2LCAwLjYzMDk2LCAwLjYzMDk2LCAwLjI1MTE5LCAwLjExNzQ5XTtcblxuICAgIGZ1bmN0aW9uIGluaXRfbWFza19hZGRfbWF4X3ZhbHVlcygpIHtcbiAgICAgICAgbWFfbWF4X2kxID0gTWF0aC5wb3coMTAsIChJMUxJTUlUICsgMSkgLyAxNi4wKTtcbiAgICAgICAgbWFfbWF4X2kyID0gTWF0aC5wb3coMTAsIChJMkxJTUlUICsgMSkgLyAxNi4wKTtcbiAgICAgICAgbWFfbWF4X20gPSBNYXRoLnBvdygxMCwgKE1MSU1JVCkgLyAxMC4wKTtcbiAgICB9XG5cbiAgICB2YXIgdGFibGUxID0gWzMuMzI0NiAqIDMuMzI0NixcbiAgICAgICAgMy4yMzgzNyAqIDMuMjM4MzcsIDMuMTU0MzcgKiAzLjE1NDM3LCAzLjAwNDEyICogMy4wMDQxMixcbiAgICAgICAgMi44NjEwMyAqIDIuODYxMDMsIDIuNjU0MDcgKiAyLjY1NDA3LCAyLjQ2MjA5ICogMi40NjIwOSxcbiAgICAgICAgMi4yODQgKiAyLjI4NCwgMi4xMTg3OSAqIDIuMTE4NzksIDEuOTY1NTIgKiAxLjk2NTUyLFxuICAgICAgICAxLjgyMzM1ICogMS44MjMzNSwgMS42OTE0NiAqIDEuNjkxNDYsIDEuNTY5MTEgKiAxLjU2OTExLFxuICAgICAgICAxLjQ2NjU4ICogMS40NjY1OCwgMS4zNzA3NCAqIDEuMzcwNzQsIDEuMzEwMzYgKiAxLjMxMDM2LFxuICAgICAgICAxLjI1MjY0ICogMS4yNTI2NCwgMS4yMDY0OCAqIDEuMjA2NDgsIDEuMTYyMDMgKiAxLjE2MjAzLFxuICAgICAgICAxLjEyNzY1ICogMS4xMjc2NSwgMS4wOTQyOCAqIDEuMDk0MjgsIDEuMDY1OSAqIDEuMDY1OSxcbiAgICAgICAgMS4wMzgyNiAqIDEuMDM4MjYsIDEuMDE4OTUgKiAxLjAxODk1LCAxXTtcblxuICAgIHZhciB0YWJsZTIgPSBbMS4zMzM1MiAqIDEuMzMzNTIsXG4gICAgICAgIDEuMzU4NzkgKiAxLjM1ODc5LCAxLjM4NDU0ICogMS4zODQ1NCwgMS4zOTQ5NyAqIDEuMzk0OTcsXG4gICAgICAgIDEuNDA1NDggKiAxLjQwNTQ4LCAxLjM1MzcgKiAxLjM1MzcsIDEuMzAzODIgKiAxLjMwMzgyLFxuICAgICAgICAxLjIyMzIxICogMS4yMjMyMSwgMS4xNDc1OCAqIDEuMTQ3NTgsIDFdO1xuXG4gICAgdmFyIHRhYmxlMyA9IFsyLjM1MzY0ICogMi4zNTM2NCxcbiAgICAgICAgMi4yOTI1OSAqIDIuMjkyNTksIDIuMjMzMTMgKiAyLjIzMzEzLCAyLjEyNjc1ICogMi4xMjY3NSxcbiAgICAgICAgMi4wMjU0NSAqIDIuMDI1NDUsIDEuODc4OTQgKiAxLjg3ODk0LCAxLjc0MzAzICogMS43NDMwMyxcbiAgICAgICAgMS42MTY5NSAqIDEuNjE2OTUsIDEuNDk5OTkgKiAxLjQ5OTk5LCAxLjM5MTQ4ICogMS4zOTE0OCxcbiAgICAgICAgMS4yOTA4MyAqIDEuMjkwODMsIDEuMTk3NDYgKiAxLjE5NzQ2LCAxLjExMDg0ICogMS4xMTA4NCxcbiAgICAgICAgMS4wMzgyNiAqIDEuMDM4MjZdO1xuXG4gICAgLyoqXG4gICAgICogYWRkaXRpb24gb2Ygc2ltdWx0YW5lb3VzIG1hc2tpbmcgTmFva2kgU2hpYmF0YSAyMDAwLzdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXNrX2FkZChtMSwgbTIsIGtrLCBiLCBnZmMsIHNob3J0YmxvY2spIHtcbiAgICAgICAgdmFyIHJhdGlvO1xuXG4gICAgICAgIGlmIChtMiA+IG0xKSB7XG4gICAgICAgICAgICBpZiAobTIgPCAobTEgKiBtYV9tYXhfaTIpKVxuICAgICAgICAgICAgICAgIHJhdGlvID0gbTIgLyBtMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gKG0xICsgbTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG0xID49IChtMiAqIG1hX21heF9pMikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIChtMSArIG0yKTtcbiAgICAgICAgICAgIHJhdGlvID0gbTEgLyBtMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFNob3VsZCBhbHdheXMgYmUgdHJ1ZSwganVzdCBjaGVja2luZyAqL1xuICAgICAgICBhc3NlcnQkMyhtMSA+PSAwKTtcbiAgICAgICAgYXNzZXJ0JDMobTIgPj0gMCk7XG5cbiAgICAgICAgbTEgKz0gbTI7XG4gICAgICAgIC8vaWYgKCgobG9uZykoYiArIDMpICYgMHhmZmZmZmZmZikgPD0gMyArIDMpIHtcbiAgICAgICAgaWYgKChiICsgMykgPD0gMyArIDMpIHtcbiAgICAgICAgICAgIC8qIGFwcHJveGltYXRlbHksIDEgYmFyayA9IDMgcGFydGl0aW9ucyAqL1xuICAgICAgICAgICAgLyogNjUlIG9mIHRoZSBjYXNlcyAqL1xuICAgICAgICAgICAgLyogb3JpZ2luYWxseSAnaWYoaSA+IDgpJyAqL1xuICAgICAgICAgICAgaWYgKHJhdGlvID49IG1hX21heF9pMSkge1xuICAgICAgICAgICAgICAgIC8qIDQzJSBvZiB0aGUgdG90YWwgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gbTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIDIyJSBvZiB0aGUgdG90YWwgKi9cbiAgICAgICAgICAgIHZhciBpID0gMCB8IChVdGlsJDMuRkFTVF9MT0cxMF9YKHJhdGlvLCAxNi4wKSk7XG4gICAgICAgICAgICByZXR1cm4gbTEgKiB0YWJsZTJbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogPFBSRT5cbiAgICAgICAgICogbTwxNSBlcXUgbG9nMTAoKG0xK20yKS9nZmMuQVRILmNiW2tdKTwxLjVcbiAgICAgICAgICogZXF1IChtMSttMikvZ2ZjLkFUSC5jYltrXTwxMF4xLjVcbiAgICAgICAgICogZXF1IChtMSttMik8MTBeMS41ICogZ2ZjLkFUSC5jYltrXVxuICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpID0gMCB8IFV0aWwkMy5GQVNUX0xPRzEwX1gocmF0aW8sIDE2LjApO1xuICAgICAgICBpZiAoc2hvcnRibG9jayAhPSAwKSB7XG4gICAgICAgICAgICBtMiA9IGdmYy5BVEguY2Jfc1tra10gKiBnZmMuQVRILmFkanVzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG0yID0gZ2ZjLkFUSC5jYl9sW2trXSAqIGdmYy5BVEguYWRqdXN0O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCQzKG0yID49IDApO1xuICAgICAgICBpZiAobTEgPCBtYV9tYXhfbSAqIG0yKSB7XG4gICAgICAgICAgICAvKiAzJSBvZiB0aGUgdG90YWwgKi9cbiAgICAgICAgICAgIC8qIE9yaWdpbmFsbHkgaWYgKG0gPiAwKSB7ICovXG4gICAgICAgICAgICBpZiAobTEgPiBtMikge1xuICAgICAgICAgICAgICAgIHZhciBmLCByO1xuXG4gICAgICAgICAgICAgICAgZiA9IDEuMDtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSAxMylcbiAgICAgICAgICAgICAgICAgICAgZiA9IHRhYmxlM1tpXTtcblxuICAgICAgICAgICAgICAgIHIgPSBVdGlsJDMuRkFTVF9MT0cxMF9YKG0xIC8gbTIsIDEwLjAgLyAxNS4wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTEgKiAoKHRhYmxlMVtpXSAtIGYpICogciArIGYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA+IDEzKVxuICAgICAgICAgICAgICAgIHJldHVybiBtMTtcblxuICAgICAgICAgICAgcmV0dXJuIG0xICogdGFibGUzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogMTAlIG9mIHRvdGFsICovXG4gICAgICAgIHJldHVybiBtMSAqIHRhYmxlMVtpXTtcbiAgICB9XG5cbiAgICB2YXIgdGFibGUyXyA9IFsxLjMzMzUyICogMS4zMzM1MixcbiAgICAgICAgMS4zNTg3OSAqIDEuMzU4NzksIDEuMzg0NTQgKiAxLjM4NDU0LCAxLjM5NDk3ICogMS4zOTQ5NyxcbiAgICAgICAgMS40MDU0OCAqIDEuNDA1NDgsIDEuMzUzNyAqIDEuMzUzNywgMS4zMDM4MiAqIDEuMzAzODIsXG4gICAgICAgIDEuMjIzMjEgKiAxLjIyMzIxLCAxLjE0NzU4ICogMS4xNDc1OCwgMV07XG5cbiAgICAvKipcbiAgICAgKiBhZGRpdGlvbiBvZiBzaW11bHRhbmVvdXMgbWFza2luZyBOYW9raSBTaGliYXRhIDIwMDAvN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZicnBzeV9tYXNrX2FkZChtMSwgbTIsIGIpIHtcbiAgICAgICAgdmFyIHJhdGlvO1xuXG4gICAgICAgIGlmIChtMSA8IDApIHtcbiAgICAgICAgICAgIG0xID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobTIgPCAwKSB7XG4gICAgICAgICAgICBtMiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0xIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobTIgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtMiA+IG0xKSB7XG4gICAgICAgICAgICByYXRpbyA9IG0yIC8gbTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYXRpbyA9IG0xIC8gbTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC0yIDw9IGIgJiYgYiA8PSAyKSB7XG4gICAgICAgICAgICAvKiBhcHByb3hpbWF0ZWx5LCAxIGJhcmsgPSAzIHBhcnRpdGlvbnMgKi9cbiAgICAgICAgICAgIC8qIG9yaWdpbmFsbHkgJ2lmKGkgPiA4KScgKi9cbiAgICAgICAgICAgIGlmIChyYXRpbyA+PSBtYV9tYXhfaTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTEgKyBtMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwIHwgKFV0aWwkMy5GQVNUX0xPRzEwX1gocmF0aW8sIDE2LjApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG0xICsgbTIpICogdGFibGUyX1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmF0aW8gPCBtYV9tYXhfaTIpIHtcbiAgICAgICAgICAgIHJldHVybiBtMSArIG0yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtMSA8IG0yKSB7XG4gICAgICAgICAgICBtMSA9IG0yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIGludGVyY2hhbm5lbCBtYXNraW5nIGVmZmVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxjX2ludGVyY2hhbm5lbF9tYXNraW5nKGdmcCwgcmF0aW8pIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgaWYgKGdmYy5jaGFubmVsc19vdXQgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzYiA9IDA7IHNiIDwgRW5jb2Rlcl8xLlNCTUFYX2w7IHNiKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGdmYy50aG1bMF0ubFtzYl07XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBnZmMudGhtWzFdLmxbc2JdO1xuICAgICAgICAgICAgICAgIGdmYy50aG1bMF0ubFtzYl0gKz0gciAqIHJhdGlvO1xuICAgICAgICAgICAgICAgIGdmYy50aG1bMV0ubFtzYl0gKz0gbCAqIHJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgc2IgPSAwOyBzYiA8IEVuY29kZXJfMS5TQk1BWF9zOyBzYisrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2Jsb2NrID0gMDsgc2Jsb2NrIDwgMzsgc2Jsb2NrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBnZmMudGhtWzBdLnNbc2JdW3NibG9ja107XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZ2ZjLnRobVsxXS5zW3NiXVtzYmxvY2tdO1xuICAgICAgICAgICAgICAgICAgICBnZmMudGhtWzBdLnNbc2JdW3NibG9ja10gKz0gciAqIHJhdGlvO1xuICAgICAgICAgICAgICAgICAgICBnZmMudGhtWzFdLnNbc2JdW3NibG9ja10gKz0gbCAqIHJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbXB1dGUgTS9TIHRocmVzaG9sZHMgZnJvbSBKb2huc3RvbiAmIEZlcnJlaXJhIDE5OTIgSUNBU1NQIHBhcGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXNmaXgxKGdmYykge1xuICAgICAgICBmb3IgKHZhciBzYiA9IDA7IHNiIDwgRW5jb2Rlcl8xLlNCTUFYX2w7IHNiKyspIHtcbiAgICAgICAgICAgIC8qIHVzZSB0aGlzIGZpeCBpZiBMICYgUiBtYXNraW5nIGRpZmZlcnMgYnkgMmRiIG9yIGxlc3MgKi9cbiAgICAgICAgICAgIC8qIGlmIGRiID0gMTAqbG9nMTAoeDIveDEpIDwgMiAqL1xuICAgICAgICAgICAgLyogaWYgKHgyIDwgMS41OCp4MSkgeyAqL1xuICAgICAgICAgICAgaWYgKGdmYy50aG1bMF0ubFtzYl0gPiAxLjU4ICogZ2ZjLnRobVsxXS5sW3NiXVxuICAgICAgICAgICAgICAgIHx8IGdmYy50aG1bMV0ubFtzYl0gPiAxLjU4ICogZ2ZjLnRobVswXS5sW3NiXSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBtbGQgPSBnZmMubWxkX2xbc2JdICogZ2ZjLmVuWzNdLmxbc2JdO1xuICAgICAgICAgICAgdmFyIHJtaWQgPSBNYXRoLm1heChnZmMudGhtWzJdLmxbc2JdLFxuICAgICAgICAgICAgICAgIE1hdGgubWluKGdmYy50aG1bM10ubFtzYl0sIG1sZCkpO1xuXG4gICAgICAgICAgICBtbGQgPSBnZmMubWxkX2xbc2JdICogZ2ZjLmVuWzJdLmxbc2JdO1xuICAgICAgICAgICAgdmFyIHJzaWRlID0gTWF0aC5tYXgoZ2ZjLnRobVszXS5sW3NiXSxcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihnZmMudGhtWzJdLmxbc2JdLCBtbGQpKTtcbiAgICAgICAgICAgIGdmYy50aG1bMl0ubFtzYl0gPSBybWlkO1xuICAgICAgICAgICAgZ2ZjLnRobVszXS5sW3NiXSA9IHJzaWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgc2IgPSAwOyBzYiA8IEVuY29kZXJfMS5TQk1BWF9zOyBzYisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzYmxvY2sgPSAwOyBzYmxvY2sgPCAzOyBzYmxvY2srKykge1xuICAgICAgICAgICAgICAgIGlmIChnZmMudGhtWzBdLnNbc2JdW3NibG9ja10gPiAxLjU4ICogZ2ZjLnRobVsxXS5zW3NiXVtzYmxvY2tdXG4gICAgICAgICAgICAgICAgICAgIHx8IGdmYy50aG1bMV0uc1tzYl1bc2Jsb2NrXSA+IDEuNTggKiBnZmMudGhtWzBdLnNbc2JdW3NibG9ja10pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHZhciBtbGQgPSBnZmMubWxkX3Nbc2JdICogZ2ZjLmVuWzNdLnNbc2JdW3NibG9ja107XG4gICAgICAgICAgICAgICAgdmFyIHJtaWQgPSBNYXRoLm1heChnZmMudGhtWzJdLnNbc2JdW3NibG9ja10sXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGdmYy50aG1bM10uc1tzYl1bc2Jsb2NrXSwgbWxkKSk7XG5cbiAgICAgICAgICAgICAgICBtbGQgPSBnZmMubWxkX3Nbc2JdICogZ2ZjLmVuWzJdLnNbc2JdW3NibG9ja107XG4gICAgICAgICAgICAgICAgdmFyIHJzaWRlID0gTWF0aC5tYXgoZ2ZjLnRobVszXS5zW3NiXVtzYmxvY2tdLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihnZmMudGhtWzJdLnNbc2JdW3NibG9ja10sIG1sZCkpO1xuXG4gICAgICAgICAgICAgICAgZ2ZjLnRobVsyXS5zW3NiXVtzYmxvY2tdID0gcm1pZDtcbiAgICAgICAgICAgICAgICBnZmMudGhtWzNdLnNbc2JdW3NibG9ja10gPSByc2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdCBNL1MgbWFza2luZ3MgaWYgdXNlciBzZXQgXCJtc2ZpeFwiXG4gICAgICpcbiAgICAgKiBOYW9raSBTaGliYXRhIDIwMDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuc19tc2ZpeChnZmMsIG1zZml4LCBhdGhhZGp1c3QpIHtcbiAgICAgICAgdmFyIG1zZml4MiA9IG1zZml4O1xuICAgICAgICB2YXIgYXRobG93ZXIgPSBNYXRoLnBvdygxMCwgYXRoYWRqdXN0KTtcblxuICAgICAgICBtc2ZpeCAqPSAyLjA7XG4gICAgICAgIG1zZml4MiAqPSAyLjA7XG4gICAgICAgIGZvciAodmFyIHNiID0gMDsgc2IgPCBFbmNvZGVyXzEuU0JNQVhfbDsgc2IrKykge1xuICAgICAgICAgICAgdmFyIHRobUxSLCB0aG1NLCB0aG1TLCBhdGg7XG4gICAgICAgICAgICBhdGggPSAoZ2ZjLkFUSC5jYl9sW2dmYy5ibV9sW3NiXV0pICogYXRobG93ZXI7XG4gICAgICAgICAgICB0aG1MUiA9IE1hdGgubWluKE1hdGgubWF4KGdmYy50aG1bMF0ubFtzYl0sIGF0aCksXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoZ2ZjLnRobVsxXS5sW3NiXSwgYXRoKSk7XG4gICAgICAgICAgICB0aG1NID0gTWF0aC5tYXgoZ2ZjLnRobVsyXS5sW3NiXSwgYXRoKTtcbiAgICAgICAgICAgIHRobVMgPSBNYXRoLm1heChnZmMudGhtWzNdLmxbc2JdLCBhdGgpO1xuICAgICAgICAgICAgaWYgKHRobUxSICogbXNmaXggPCB0aG1NICsgdGhtUykge1xuICAgICAgICAgICAgICAgIHZhciBmID0gdGhtTFIgKiBtc2ZpeDIgLyAodGhtTSArIHRobVMpO1xuICAgICAgICAgICAgICAgIHRobU0gKj0gZjtcbiAgICAgICAgICAgICAgICB0aG1TICo9IGY7XG4gICAgICAgICAgICAgICAgYXNzZXJ0JDModGhtTSArIHRobVMgPiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdmYy50aG1bMl0ubFtzYl0gPSBNYXRoLm1pbih0aG1NLCBnZmMudGhtWzJdLmxbc2JdKTtcbiAgICAgICAgICAgIGdmYy50aG1bM10ubFtzYl0gPSBNYXRoLm1pbih0aG1TLCBnZmMudGhtWzNdLmxbc2JdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0aGxvd2VyICo9ICggRW5jb2Rlcl8xLkJMS1NJWkVfcyAvIEVuY29kZXJfMS5CTEtTSVpFKTtcbiAgICAgICAgZm9yICh2YXIgc2IgPSAwOyBzYiA8IEVuY29kZXJfMS5TQk1BWF9zOyBzYisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzYmxvY2sgPSAwOyBzYmxvY2sgPCAzOyBzYmxvY2srKykge1xuICAgICAgICAgICAgICAgIHZhciB0aG1MUiwgdGhtTSwgdGhtUywgYXRoO1xuICAgICAgICAgICAgICAgIGF0aCA9IChnZmMuQVRILmNiX3NbZ2ZjLmJtX3Nbc2JdXSkgKiBhdGhsb3dlcjtcbiAgICAgICAgICAgICAgICB0aG1MUiA9IE1hdGgubWluKE1hdGgubWF4KGdmYy50aG1bMF0uc1tzYl1bc2Jsb2NrXSwgYXRoKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZ2ZjLnRobVsxXS5zW3NiXVtzYmxvY2tdLCBhdGgpKTtcbiAgICAgICAgICAgICAgICB0aG1NID0gTWF0aC5tYXgoZ2ZjLnRobVsyXS5zW3NiXVtzYmxvY2tdLCBhdGgpO1xuICAgICAgICAgICAgICAgIHRobVMgPSBNYXRoLm1heChnZmMudGhtWzNdLnNbc2JdW3NibG9ja10sIGF0aCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhtTFIgKiBtc2ZpeCA8IHRobU0gKyB0aG1TKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gdGhtTFIgKiBtc2ZpeCAvICh0aG1NICsgdGhtUyk7XG4gICAgICAgICAgICAgICAgICAgIHRobU0gKj0gZjtcbiAgICAgICAgICAgICAgICAgICAgdGhtUyAqPSBmO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQkMyh0aG1NICsgdGhtUyA+IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZmMudGhtWzJdLnNbc2JdW3NibG9ja10gPSBNYXRoLm1pbihnZmMudGhtWzJdLnNbc2JdW3NibG9ja10sXG4gICAgICAgICAgICAgICAgICAgIHRobU0pO1xuICAgICAgICAgICAgICAgIGdmYy50aG1bM10uc1tzYl1bc2Jsb2NrXSA9IE1hdGgubWluKGdmYy50aG1bM10uc1tzYl1bc2Jsb2NrXSxcbiAgICAgICAgICAgICAgICAgICAgdGhtUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzaG9ydCBibG9jayB0aHJlc2hvbGQgY2FsY3VsYXRpb24gKHBhcnQgMilcbiAgICAgKlxuICAgICAqIHBhcnRpdGlvbiBiYW5kIGJvX3Nbc2ZiXSBpcyBhdCB0aGUgdHJhbnNpdGlvbiBmcm9tIHNjYWxlZmFjdG9yIGJhbmQgc2ZiXG4gICAgICogdG8gdGhlIG5leHQgb25lIHNmYisxOyBlbm4gYW5kIHRobW0gaGF2ZSB0byBiZSBzcGxpdCBiZXR3ZWVuIHRoZW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0X3BhcnRpdGlvbjJzY2FsZWZhY19zKGdmYywgZWIsIHRociwgY2huLCBzYmxvY2spIHtcbiAgICAgICAgdmFyIHNiLCBiO1xuICAgICAgICB2YXIgZW5uID0gMC4wO1xuICAgICAgICB2YXIgdGhtbSA9IDAuMDtcbiAgICAgICAgZm9yIChzYiA9IGIgPSAwOyBzYiA8IEVuY29kZXJfMS5TQk1BWF9zOyArK2IsICsrc2IpIHtcbiAgICAgICAgICAgIHZhciBib19zX3NiID0gZ2ZjLmJvX3Nbc2JdO1xuICAgICAgICAgICAgdmFyIG5wYXJ0X3MgPSBnZmMubnBhcnRfcztcbiAgICAgICAgICAgIHZhciBiX2xpbSA9IGJvX3Nfc2IgPCBucGFydF9zID8gYm9fc19zYiA6IG5wYXJ0X3M7XG4gICAgICAgICAgICB3aGlsZSAoYiA8IGJfbGltKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0JDMoZWJbYl0gPj0gMCk7XG4gICAgICAgICAgICAgICAgLy8gaWZmIGZhaWxlZCwgaXQgbWF5IGluZGljYXRlIHNvbWUgaW5kZXggZXJyb3IgZWxzZXdoZXJlXG4gICAgICAgICAgICAgICAgYXNzZXJ0JDModGhyW2JdID49IDApO1xuICAgICAgICAgICAgICAgIGVubiArPSBlYltiXTtcbiAgICAgICAgICAgICAgICB0aG1tICs9IHRocltiXTtcbiAgICAgICAgICAgICAgICBiKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZmMuZW5bY2huXS5zW3NiXVtzYmxvY2tdID0gZW5uO1xuICAgICAgICAgICAgZ2ZjLnRobVtjaG5dLnNbc2JdW3NibG9ja10gPSB0aG1tO1xuXG4gICAgICAgICAgICBpZiAoYiA+PSBucGFydF9zKSB7XG4gICAgICAgICAgICAgICAgKytzYjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydCQzKGViW2JdID49IDApO1xuICAgICAgICAgICAgLy8gaWZmIGZhaWxlZCwgaXQgbWF5IGluZGljYXRlIHNvbWUgaW5kZXggZXJyb3IgZWxzZXdoZXJlXG4gICAgICAgICAgICBhc3NlcnQkMyh0aHJbYl0gPj0gMCk7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLyogYXQgdHJhbnNpdGlvbiBzZmIgLiBzZmIrMSAqL1xuICAgICAgICAgICAgICAgIHZhciB3X2N1cnIgPSBnZmMuUFNZLmJvX3Nfd2VpZ2h0W3NiXTtcbiAgICAgICAgICAgICAgICB2YXIgd19uZXh0ID0gMS4wIC0gd19jdXJyO1xuICAgICAgICAgICAgICAgIGVubiA9IHdfY3VyciAqIGViW2JdO1xuICAgICAgICAgICAgICAgIHRobW0gPSB3X2N1cnIgKiB0aHJbYl07XG4gICAgICAgICAgICAgICAgZ2ZjLmVuW2Nobl0uc1tzYl1bc2Jsb2NrXSArPSBlbm47XG4gICAgICAgICAgICAgICAgZ2ZjLnRobVtjaG5dLnNbc2JdW3NibG9ja10gKz0gdGhtbTtcbiAgICAgICAgICAgICAgICBlbm4gPSB3X25leHQgKiBlYltiXTtcbiAgICAgICAgICAgICAgICB0aG1tID0gd19uZXh0ICogdGhyW2JdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIHplcm8gaW5pdGlhbGl6ZSB0aGUgcmVzdCAqL1xuICAgICAgICBmb3IgKDsgc2IgPCBFbmNvZGVyXzEuU0JNQVhfczsgKytzYikge1xuICAgICAgICAgICAgZ2ZjLmVuW2Nobl0uc1tzYl1bc2Jsb2NrXSA9IDA7XG4gICAgICAgICAgICBnZmMudGhtW2Nobl0uc1tzYl1bc2Jsb2NrXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsb25nYmxvY2sgdGhyZXNob2xkIGNhbGN1bGF0aW9uIChwYXJ0IDIpXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydF9wYXJ0aXRpb24yc2NhbGVmYWNfbChnZmMsIGViLCB0aHIsIGNobikge1xuICAgICAgICB2YXIgc2IsIGI7XG4gICAgICAgIHZhciBlbm4gPSAwLjA7XG4gICAgICAgIHZhciB0aG1tID0gMC4wO1xuICAgICAgICBmb3IgKHNiID0gYiA9IDA7IHNiIDwgRW5jb2Rlcl8xLlNCTUFYX2w7ICsrYiwgKytzYikge1xuICAgICAgICAgICAgdmFyIGJvX2xfc2IgPSBnZmMuYm9fbFtzYl07XG4gICAgICAgICAgICB2YXIgbnBhcnRfbCA9IGdmYy5ucGFydF9sO1xuICAgICAgICAgICAgdmFyIGJfbGltID0gYm9fbF9zYiA8IG5wYXJ0X2wgPyBib19sX3NiIDogbnBhcnRfbDtcbiAgICAgICAgICAgIHdoaWxlIChiIDwgYl9saW0pIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQkMyhlYltiXSA+PSAwKTtcbiAgICAgICAgICAgICAgICAvLyBpZmYgZmFpbGVkLCBpdCBtYXkgaW5kaWNhdGUgc29tZSBpbmRleCBlcnJvciBlbHNld2hlcmVcbiAgICAgICAgICAgICAgICBhc3NlcnQkMyh0aHJbYl0gPj0gMCk7XG4gICAgICAgICAgICAgICAgZW5uICs9IGViW2JdO1xuICAgICAgICAgICAgICAgIHRobW0gKz0gdGhyW2JdO1xuICAgICAgICAgICAgICAgIGIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdmYy5lbltjaG5dLmxbc2JdID0gZW5uO1xuICAgICAgICAgICAgZ2ZjLnRobVtjaG5dLmxbc2JdID0gdGhtbTtcblxuICAgICAgICAgICAgaWYgKGIgPj0gbnBhcnRfbCkge1xuICAgICAgICAgICAgICAgICsrc2I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQkMyhlYltiXSA+PSAwKTtcbiAgICAgICAgICAgIGFzc2VydCQzKHRocltiXSA+PSAwKTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvKiBhdCB0cmFuc2l0aW9uIHNmYiAuIHNmYisxICovXG4gICAgICAgICAgICAgICAgdmFyIHdfY3VyciA9IGdmYy5QU1kuYm9fbF93ZWlnaHRbc2JdO1xuICAgICAgICAgICAgICAgIHZhciB3X25leHQgPSAxLjAgLSB3X2N1cnI7XG4gICAgICAgICAgICAgICAgZW5uID0gd19jdXJyICogZWJbYl07XG4gICAgICAgICAgICAgICAgdGhtbSA9IHdfY3VyciAqIHRocltiXTtcbiAgICAgICAgICAgICAgICBnZmMuZW5bY2huXS5sW3NiXSArPSBlbm47XG4gICAgICAgICAgICAgICAgZ2ZjLnRobVtjaG5dLmxbc2JdICs9IHRobW07XG4gICAgICAgICAgICAgICAgZW5uID0gd19uZXh0ICogZWJbYl07XG4gICAgICAgICAgICAgICAgdGhtbSA9IHdfbmV4dCAqIHRocltiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiB6ZXJvIGluaXRpYWxpemUgdGhlIHJlc3QgKi9cbiAgICAgICAgZm9yICg7IHNiIDwgRW5jb2Rlcl8xLlNCTUFYX2w7ICsrc2IpIHtcbiAgICAgICAgICAgIGdmYy5lbltjaG5dLmxbc2JdID0gMDtcbiAgICAgICAgICAgIGdmYy50aG1bY2huXS5sW3NiXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlX21hc2tpbmdfcyhnZnAsIGZmdGVuZXJneV9zLCBlYiwgdGhyLCBjaG4sIHNibG9jaykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgaiwgYjtcblxuICAgICAgICBmb3IgKGIgPSBqID0gMDsgYiA8IGdmYy5ucGFydF9zOyArK2IpIHtcbiAgICAgICAgICAgIHZhciBlYmIgPSAwLCBtID0gMDtcbiAgICAgICAgICAgIHZhciBuID0gZ2ZjLm51bWxpbmVzX3NbYl07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSwgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZmZ0ZW5lcmd5X3Nbc2Jsb2NrXVtqXTtcbiAgICAgICAgICAgICAgICBlYmIgKz0gZWw7XG4gICAgICAgICAgICAgICAgaWYgKG0gPCBlbClcbiAgICAgICAgICAgICAgICAgICAgbSA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWJbYl0gPSBlYmI7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0JDMoYiA9PSBnZmMubnBhcnRfcyk7XG4gICAgICAgIGFzc2VydCQzKGogPT0gMTI5KTtcbiAgICAgICAgZm9yIChqID0gYiA9IDA7IGIgPCBnZmMubnBhcnRfczsgYisrKSB7XG4gICAgICAgICAgICB2YXIga2sgPSBnZmMuczNpbmRfc1tiXVswXTtcbiAgICAgICAgICAgIHZhciBlY2IgPSBnZmMuczNfc3NbaisrXSAqIGViW2trXTtcbiAgICAgICAgICAgICsra2s7XG4gICAgICAgICAgICB3aGlsZSAoa2sgPD0gZ2ZjLnMzaW5kX3NbYl1bMV0pIHtcbiAgICAgICAgICAgICAgICBlY2IgKz0gZ2ZjLnMzX3NzW2pdICogZWJba2tdO1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgICAgICArK2trO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB7IC8qIGxpbWl0IGNhbGN1bGF0ZWQgdGhyZXNob2xkIGJ5IHByZXZpb3VzIGdyYW51bGUgKi9cbiAgICAgICAgICAgICAgICB2YXIgeCA9IHJwZWxldl9zICogZ2ZjLm5iX3MxW2Nobl1bYl07XG4gICAgICAgICAgICAgICAgdGhyW2JdID0gTWF0aC5taW4oZWNiLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZmMuYmxvY2t0eXBlX29sZFtjaG4gJiAxXSA9PSBFbmNvZGVyXzEuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIC8qIGxpbWl0IGNhbGN1bGF0ZWQgdGhyZXNob2xkIGJ5IGV2ZW4gb2xkZXIgZ3JhbnVsZSAqL1xuICAgICAgICAgICAgICAgIHZhciB4ID0gcnBlbGV2Ml9zICogZ2ZjLm5iX3MyW2Nobl1bYl07XG4gICAgICAgICAgICAgICAgdmFyIHkgPSB0aHJbYl07XG4gICAgICAgICAgICAgICAgdGhyW2JdID0gTWF0aC5taW4oeCwgeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdmYy5uYl9zMltjaG5dW2JdID0gZ2ZjLm5iX3MxW2Nobl1bYl07XG4gICAgICAgICAgICBnZmMubmJfczFbY2huXVtiXSA9IGVjYjtcbiAgICAgICAgICAgIGFzc2VydCQzKHRocltiXSA+PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgYiA8PSBFbmNvZGVyXzEuQ0JBTkRTOyArK2IpIHtcbiAgICAgICAgICAgIGViW2JdID0gMDtcbiAgICAgICAgICAgIHRocltiXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBibG9ja190eXBlX3NldChnZnAsIHVzZWxvbmdibG9jaywgYmxvY2t0eXBlX2QsIGJsb2NrdHlwZSkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXG4gICAgICAgIGlmIChnZnAuc2hvcnRfYmxvY2tzID09IFNob3J0QmxvY2skMy5zaG9ydF9ibG9ja19jb3VwbGVkXG4gICAgICAgICAgICAgICAgLyogZm9yY2UgYm90aCBjaGFubmVscyB0byB1c2UgdGhlIHNhbWUgYmxvY2sgdHlwZSAqL1xuICAgICAgICAgICAgICAgIC8qIHRoaXMgaXMgbmVjZXNzYXJ5IGlmIHRoZSBmcmFtZSBpcyB0byBiZSBlbmNvZGVkIGluIG1zX3N0ZXJlby4gKi9cbiAgICAgICAgICAgICAgICAvKiBCdXQgZXZlbiB3aXRob3V0IG1zX3N0ZXJlbywgRmhHIGRvZXMgdGhpcyAqL1xuICAgICAgICAgICAgJiYgISh1c2Vsb25nYmxvY2tbMF0gIT0gMCAmJiB1c2Vsb25nYmxvY2tbMV0gIT0gMCkpXG4gICAgICAgICAgICB1c2Vsb25nYmxvY2tbMF0gPSB1c2Vsb25nYmxvY2tbMV0gPSAwO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHVwZGF0ZSB0aGUgYmxvY2t0eXBlIG9mIHRoZSBwcmV2aW91cyBncmFudWxlLCBzaW5jZSBpdCBkZXBlbmRzIG9uXG4gICAgICAgICAqIHdoYXQgaGFwcGVuZCBpbiB0aGlzIGdyYW51bGVcbiAgICAgICAgICovXG4gICAgICAgIGZvciAodmFyIGNobiA9IDA7IGNobiA8IGdmYy5jaGFubmVsc19vdXQ7IGNobisrKSB7XG4gICAgICAgICAgICBibG9ja3R5cGVbY2huXSA9IEVuY29kZXJfMS5OT1JNX1RZUEU7XG4gICAgICAgICAgICAvKiBkaXNhYmxlIHNob3J0IGJsb2NrcyAqL1xuICAgICAgICAgICAgaWYgKGdmcC5zaG9ydF9ibG9ja3MgPT0gU2hvcnRCbG9jayQzLnNob3J0X2Jsb2NrX2Rpc3BlbnNlZClcbiAgICAgICAgICAgICAgICB1c2Vsb25nYmxvY2tbY2huXSA9IDE7XG4gICAgICAgICAgICBpZiAoZ2ZwLnNob3J0X2Jsb2NrcyA9PSBTaG9ydEJsb2NrJDMuc2hvcnRfYmxvY2tfZm9yY2VkKVxuICAgICAgICAgICAgICAgIHVzZWxvbmdibG9ja1tjaG5dID0gMDtcblxuICAgICAgICAgICAgaWYgKHVzZWxvbmdibG9ja1tjaG5dICE9IDApIHtcbiAgICAgICAgICAgICAgICAvKiBubyBhdHRhY2sgOiB1c2UgbG9uZyBibG9ja3MgKi9cbiAgICAgICAgICAgICAgICBhc3NlcnQkMyhnZmMuYmxvY2t0eXBlX29sZFtjaG5dICE9IEVuY29kZXJfMS5TVEFSVF9UWVBFKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLmJsb2NrdHlwZV9vbGRbY2huXSA9PSBFbmNvZGVyXzEuU0hPUlRfVFlQRSlcbiAgICAgICAgICAgICAgICAgICAgYmxvY2t0eXBlW2Nobl0gPSBFbmNvZGVyXzEuU1RPUF9UWVBFO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBhdHRhY2sgOiB1c2Ugc2hvcnQgYmxvY2tzICovXG4gICAgICAgICAgICAgICAgYmxvY2t0eXBlW2Nobl0gPSBFbmNvZGVyXzEuU0hPUlRfVFlQRTtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLmJsb2NrdHlwZV9vbGRbY2huXSA9PSBFbmNvZGVyXzEuTk9STV9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgIGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gPSBFbmNvZGVyXzEuU1RBUlRfVFlQRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gPT0gRW5jb2Rlcl8xLlNUT1BfVFlQRSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLmJsb2NrdHlwZV9vbGRbY2huXSA9IEVuY29kZXJfMS5TSE9SVF9UWVBFO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBibG9ja3R5cGVfZFtjaG5dID0gZ2ZjLmJsb2NrdHlwZV9vbGRbY2huXTtcbiAgICAgICAgICAgIC8vIHZhbHVlIHJldHVybmVkIHRvIGNhbGxpbmcgcHJvZ3JhbVxuICAgICAgICAgICAgZ2ZjLmJsb2NrdHlwZV9vbGRbY2huXSA9IGJsb2NrdHlwZVtjaG5dO1xuICAgICAgICAgICAgLy8gc2F2ZSBmb3IgbmV4dCBjYWxsIHRvIGwzcHN5X2FuYWxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIE5TX0lOVEVSUCh4LCB5LCByKSB7XG4gICAgICAgIC8qIHdhcyBwb3coKHgpLChyKSkqcG93KCh5KSwxLShyKSkgKi9cbiAgICAgICAgaWYgKHIgPj0gMS4wKSB7XG4gICAgICAgICAgICAvKiA5OS43JSBvZiB0aGUgdGltZSAqL1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIgPD0gMC4wKVxuICAgICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgIGlmICh5ID4gMC4wKSB7XG4gICAgICAgICAgICAvKiByZXN0IG9mIHRoZSB0aW1lICovXG4gICAgICAgICAgICByZXR1cm4gKE1hdGgucG93KHggLyB5LCByKSAqIHkpO1xuICAgICAgICB9XG4gICAgICAgIC8qIG5ldmVyIGhhcHBlbnMgKi9cbiAgICAgICAgcmV0dXJuIDAuMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGVzZSB2YWx1ZXMgYXJlIHR1bmVkIG9ubHkgZm9yIDQ0LjFrSHouLi5cbiAgICAgKi9cbiAgICB2YXIgcmVnY29lZl9zID0gWzExLjgsIDEzLjYsIDE3LjIsIDMyLCA0Ni41LFxuICAgICAgICA1MS4zLCA1Ny41LCA2Ny4xLCA3MS41LCA4NC42LCA5Ny42LCAxMzAsXG4gICAgICAgIC8qIDI1NS44ICovXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIHBlY2FsY19zKG1yLCBtYXNraW5nX2xvd2VyKSB7XG4gICAgICAgIHZhciBwZV9zID0gMTIzNi4yOCAvIDQ7XG4gICAgICAgIGZvciAodmFyIHNiID0gMDsgc2IgPCBFbmNvZGVyXzEuU0JNQVhfcyAtIDE7IHNiKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNibG9jayA9IDA7IHNibG9jayA8IDM7IHNibG9jaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRobSA9IG1yLnRobS5zW3NiXVtzYmxvY2tdO1xuICAgICAgICAgICAgICAgIGFzc2VydCQzKHNiIDwgcmVnY29lZl9zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRobSA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHRobSAqIG1hc2tpbmdfbG93ZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbiA9IG1yLmVuLnNbc2JdW3NibG9ja107XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbiA+IHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbiA+IHggKiAxZTEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVfcyArPSByZWdjb2VmX3Nbc2JdICogKDEwLjAgKiBMT0cxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCQzKHggPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZV9zICs9IHJlZ2NvZWZfc1tzYl0gKiBVdGlsJDMuRkFTVF9MT0cxMChlbiAvIHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBlX3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhlc2UgdmFsdWVzIGFyZSB0dW5lZCBvbmx5IGZvciA0NC4xa0h6Li4uXG4gICAgICovXG4gICAgdmFyIHJlZ2NvZWZfbCA9IFs2LjgsIDUuOCwgNS44LCA2LjQsIDYuNSwgOS45LFxuICAgICAgICAxMi4xLCAxNC40LCAxNSwgMTguOSwgMjEuNiwgMjYuOSwgMzQuMiwgNDAuMiwgNDYuOCwgNTYuNSxcbiAgICAgICAgNjAuNywgNzMuOSwgODUuNywgOTMuNCwgMTI2LjEsXG4gICAgICAgIC8qIDI0MS4zICovXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIHBlY2FsY19sKG1yLCBtYXNraW5nX2xvd2VyKSB7XG4gICAgICAgIHZhciBwZV9sID0gMTEyNC4yMyAvIDQ7XG4gICAgICAgIGZvciAodmFyIHNiID0gMDsgc2IgPCBFbmNvZGVyXzEuU0JNQVhfbCAtIDE7IHNiKyspIHtcbiAgICAgICAgICAgIHZhciB0aG0gPSBtci50aG0ubFtzYl07XG4gICAgICAgICAgICBhc3NlcnQkMyhzYiA8IHJlZ2NvZWZfbC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHRobSA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gdGhtICogbWFza2luZ19sb3dlcjtcbiAgICAgICAgICAgICAgICB2YXIgZW4gPSBtci5lbi5sW3NiXTtcbiAgICAgICAgICAgICAgICBpZiAoZW4gPiB4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbiA+IHggKiAxZTEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZV9sICs9IHJlZ2NvZWZfbFtzYl0gKiAoMTAuMCAqIExPRzEwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCQzKHggPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlX2wgKz0gcmVnY29lZl9sW3NiXSAqIFV0aWwkMy5GQVNUX0xPRzEwKGVuIC8geCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlX2w7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY19lbmVyZ3koZ2ZjLCBmZnRlbmVyZ3ksIGViLCBtYXgsIGF2Zykge1xuICAgICAgICB2YXIgYiwgajtcblxuICAgICAgICBmb3IgKGIgPSBqID0gMDsgYiA8IGdmYy5ucGFydF9sOyArK2IpIHtcbiAgICAgICAgICAgIHZhciBlYmIgPSAwLCBtID0gMDtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGdmYy5udW1saW5lc19sW2JdOyArK2ksICsraikge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGZmdGVuZXJneVtqXTtcbiAgICAgICAgICAgICAgICBhc3NlcnQkMyhlbCA+PSAwKTtcbiAgICAgICAgICAgICAgICBlYmIgKz0gZWw7XG4gICAgICAgICAgICAgICAgaWYgKG0gPCBlbClcbiAgICAgICAgICAgICAgICAgICAgbSA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWJbYl0gPSBlYmI7XG4gICAgICAgICAgICBtYXhbYl0gPSBtO1xuICAgICAgICAgICAgYXZnW2JdID0gZWJiICogZ2ZjLnJudW1saW5lc19sW2JdO1xuICAgICAgICAgICAgYXNzZXJ0JDMoZ2ZjLnJudW1saW5lc19sW2JdID49IDApO1xuICAgICAgICAgICAgYXNzZXJ0JDMoZWJiID49IDApO1xuICAgICAgICAgICAgYXNzZXJ0JDMoZWJbYl0gPj0gMCk7XG4gICAgICAgICAgICBhc3NlcnQkMyhtYXhbYl0gPj0gMCk7XG4gICAgICAgICAgICBhc3NlcnQkMyhhdmdbYl0gPj0gMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjX21hc2tfaW5kZXhfbChnZmMsIG1heCwgYXZnLCBtYXNrX2lkeCkge1xuICAgICAgICB2YXIgbGFzdF90YWJfZW50cnkgPSB0YWIubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGIgPSAwO1xuICAgICAgICB2YXIgYSA9IGF2Z1tiXSArIGF2Z1tiICsgMV07XG4gICAgICAgIGFzc2VydCQzKGEgPj0gMCk7XG4gICAgICAgIGlmIChhID4gMC4wKSB7XG4gICAgICAgICAgICB2YXIgbSA9IG1heFtiXTtcbiAgICAgICAgICAgIGlmIChtIDwgbWF4W2IgKyAxXSlcbiAgICAgICAgICAgICAgICBtID0gbWF4W2IgKyAxXTtcbiAgICAgICAgICAgIGFzc2VydCQzKChnZmMubnVtbGluZXNfbFtiXSArIGdmYy5udW1saW5lc19sW2IgKyAxXSAtIDEpID4gMCk7XG4gICAgICAgICAgICBhID0gMjAuMCAqIChtICogMi4wIC0gYSlcbiAgICAgICAgICAgICAgICAvIChhICogKGdmYy5udW1saW5lc19sW2JdICsgZ2ZjLm51bWxpbmVzX2xbYiArIDFdIC0gMSkpO1xuICAgICAgICAgICAgdmFyIGsgPSAwIHwgYTtcbiAgICAgICAgICAgIGlmIChrID4gbGFzdF90YWJfZW50cnkpXG4gICAgICAgICAgICAgICAgayA9IGxhc3RfdGFiX2VudHJ5O1xuICAgICAgICAgICAgbWFza19pZHhbYl0gPSBrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFza19pZHhbYl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChiID0gMTsgYiA8IGdmYy5ucGFydF9sIC0gMTsgYisrKSB7XG4gICAgICAgICAgICBhID0gYXZnW2IgLSAxXSArIGF2Z1tiXSArIGF2Z1tiICsgMV07XG4gICAgICAgICAgICBhc3NlcnQkMyhhID49IDApO1xuICAgICAgICAgICAgaWYgKGEgPiAwLjApIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IG1heFtiIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKG0gPCBtYXhbYl0pXG4gICAgICAgICAgICAgICAgICAgIG0gPSBtYXhbYl07XG4gICAgICAgICAgICAgICAgaWYgKG0gPCBtYXhbYiArIDFdKVxuICAgICAgICAgICAgICAgICAgICBtID0gbWF4W2IgKyAxXTtcbiAgICAgICAgICAgICAgICBhc3NlcnQkMygoZ2ZjLm51bWxpbmVzX2xbYiAtIDFdICsgZ2ZjLm51bWxpbmVzX2xbYl0gKyBnZmMubnVtbGluZXNfbFtiICsgMV0gLSAxKSA+IDApO1xuICAgICAgICAgICAgICAgIGEgPSAyMC4wXG4gICAgICAgICAgICAgICAgICAgICogKG0gKiAzLjAgLSBhKVxuICAgICAgICAgICAgICAgICAgICAvIChhICogKGdmYy5udW1saW5lc19sW2IgLSAxXSArIGdmYy5udW1saW5lc19sW2JdXG4gICAgICAgICAgICAgICAgICAgICsgZ2ZjLm51bWxpbmVzX2xbYiArIDFdIC0gMSkpO1xuICAgICAgICAgICAgICAgIHZhciBrID0gMCB8IGE7XG4gICAgICAgICAgICAgICAgaWYgKGsgPiBsYXN0X3RhYl9lbnRyeSlcbiAgICAgICAgICAgICAgICAgICAgayA9IGxhc3RfdGFiX2VudHJ5O1xuICAgICAgICAgICAgICAgIG1hc2tfaWR4W2JdID0gaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFza19pZHhbYl0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydCQzKGIgPiAwKTtcbiAgICAgICAgYXNzZXJ0JDMoYiA9PSBnZmMubnBhcnRfbCAtIDEpO1xuXG4gICAgICAgIGEgPSBhdmdbYiAtIDFdICsgYXZnW2JdO1xuICAgICAgICBhc3NlcnQkMyhhID49IDApO1xuICAgICAgICBpZiAoYSA+IDAuMCkge1xuICAgICAgICAgICAgdmFyIG0gPSBtYXhbYiAtIDFdO1xuICAgICAgICAgICAgaWYgKG0gPCBtYXhbYl0pXG4gICAgICAgICAgICAgICAgbSA9IG1heFtiXTtcbiAgICAgICAgICAgIGFzc2VydCQzKChnZmMubnVtbGluZXNfbFtiIC0gMV0gKyBnZmMubnVtbGluZXNfbFtiXSAtIDEpID4gMCk7XG4gICAgICAgICAgICBhID0gMjAuMCAqIChtICogMi4wIC0gYSlcbiAgICAgICAgICAgICAgICAvIChhICogKGdmYy5udW1saW5lc19sW2IgLSAxXSArIGdmYy5udW1saW5lc19sW2JdIC0gMSkpO1xuICAgICAgICAgICAgdmFyIGsgPSAwIHwgYTtcbiAgICAgICAgICAgIGlmIChrID4gbGFzdF90YWJfZW50cnkpXG4gICAgICAgICAgICAgICAgayA9IGxhc3RfdGFiX2VudHJ5O1xuICAgICAgICAgICAgbWFza19pZHhbYl0gPSBrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFza19pZHhbYl0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCQzKGIgPT0gKGdmYy5ucGFydF9sIC0gMSkpO1xuICAgIH1cblxuICAgIHZhciBmaXJjb2VmID0gW1xuICAgICAgICAtOC42NTE2M2UtMTggKiAyLCAtMC4wMDg1MTU4NiAqIDIsIC02Ljc0NzY0ZS0xOCAqIDIsIDAuMDIwOTAzNiAqIDIsXG4gICAgICAgIC0zLjM2NjM5ZS0xNyAqIDIsIC0wLjA0MzgxNjIgKiAyLCAtMS41NDE3NWUtMTcgKiAyLCAwLjA5MzE3MzggKiAyLFxuICAgICAgICAtNS41MjIxMmUtMTcgKiAyLCAtMC4zMTM4MTkgKiAyXG4gICAgXTtcblxuICAgIHRoaXMuTDNwc3ljaG9fYW5hbF9ucyA9IGZ1bmN0aW9uIChnZnAsIGJ1ZmZlciwgYnVmUG9zLCBncl9vdXQsIG1hc2tpbmdfcmF0aW8sIG1hc2tpbmdfTVNfcmF0aW8sIHBlcmNlcF9lbnRyb3B5LCBwZXJjZXBfTVNfZW50cm9weSwgZW5lcmd5LCBibG9ja3R5cGVfZCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiB0byBnZXQgYSBnb29kIGNhY2hlIHBlcmZvcm1hbmNlLCBvbmUgaGFzIHRvIHRoaW5rIGFib3V0IHRoZSBzZXF1ZW5jZSxcbiAgICAgICAgICogaW4gd2hpY2ggdGhlIHZhcmlhYmxlcyBhcmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgLyogZmZ0IGFuZCBlbmVyZ3kgY2FsY3VsYXRpb24gKi9cbiAgICAgICAgdmFyIHdzYW1wX0wgPSBuZXdfZmxvYXRfbiQzKFsyLCBFbmNvZGVyXzEuQkxLU0laRV0pO1xuICAgICAgICB2YXIgd3NhbXBfUyA9IG5ld19mbG9hdF9uJDMoWzIsIDMsIEVuY29kZXJfMS5CTEtTSVpFX3NdKTtcblxuICAgICAgICAvKiBjb252b2x1dGlvbiAqL1xuICAgICAgICB2YXIgZWJfbCA9IG5ld19mbG9hdCQzKEVuY29kZXJfMS5DQkFORFMgKyAxKTtcbiAgICAgICAgdmFyIGViX3MgPSBuZXdfZmxvYXQkMyhFbmNvZGVyXzEuQ0JBTkRTICsgMSk7XG4gICAgICAgIHZhciB0aHIgPSBuZXdfZmxvYXQkMyhFbmNvZGVyXzEuQ0JBTkRTICsgMik7XG5cbiAgICAgICAgLyogYmxvY2sgdHlwZSAqL1xuICAgICAgICB2YXIgYmxvY2t0eXBlID0gbmV3X2ludCQzKDIpLCB1c2Vsb25nYmxvY2sgPSBuZXdfaW50JDMoMik7XG5cbiAgICAgICAgLyogdXN1YWwgdmFyaWFibGVzIGxpa2UgbG9vcCBpbmRpY2VzLCBldGMuLiAqL1xuICAgICAgICB2YXIgbnVtY2huLCBjaG47XG4gICAgICAgIHZhciBiLCBpLCBqLCBrO1xuICAgICAgICB2YXIgc2IsIHNibG9jaztcblxuICAgICAgICAvKiB2YXJpYWJsZXMgdXNlZCBmb3IgLS1uc3BzeXR1bmUgKi9cbiAgICAgICAgdmFyIG5zX2hwZnNtcGwgPSBuZXdfZmxvYXRfbiQzKFsyLCA1NzZdKTtcbiAgICAgICAgdmFyIHBjZmFjdDtcbiAgICAgICAgdmFyIG1hc2tfaWR4X2wgPSBuZXdfaW50JDMoRW5jb2Rlcl8xLkNCQU5EUyArIDIpLCBtYXNrX2lkeF9zID0gbmV3X2ludCQzKEVuY29kZXJfMS5DQkFORFMgKyAyKTtcblxuICAgICAgICBBcnJheXMkMy5maWxsKG1hc2tfaWR4X3MsIDApO1xuXG4gICAgICAgIG51bWNobiA9IGdmYy5jaGFubmVsc19vdXQ7XG4gICAgICAgIC8qIGNobj0yIGFuZCAzID0gTWlkIGFuZCBTaWRlIGNoYW5uZWxzICovXG4gICAgICAgIGlmIChnZnAubW9kZSA9PSBNUEVHTW9kZS5KT0lOVF9TVEVSRU8pXG4gICAgICAgICAgICBudW1jaG4gPSA0O1xuXG4gICAgICAgIGlmIChnZnAuVkJSID09IFZick1vZGUkMy52YnJfb2ZmKVxuICAgICAgICAgICAgcGNmYWN0ID0gZ2ZjLlJlc3ZNYXggPT0gMCA/IDAgOiAoIGdmYy5SZXN2U2l6ZSlcbiAgICAgICAgICAgIC8gZ2ZjLlJlc3ZNYXggKiAwLjU7XG4gICAgICAgIGVsc2UgaWYgKGdmcC5WQlIgPT0gVmJyTW9kZSQzLnZicl9yaCB8fCBnZnAuVkJSID09IFZick1vZGUkMy52YnJfbXRyaFxuICAgICAgICAgICAgfHwgZ2ZwLlZCUiA9PSBWYnJNb2RlJDMudmJyX210KSB7XG4gICAgICAgICAgICBwY2ZhY3QgPSAwLjY7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcGNmYWN0ID0gMS4wO1xuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIEFwcGx5IEhQRiBvZiBmcy80IHRvIHRoZSBpbnB1dCBzaWduYWwuIFRoaXMgaXMgdXNlZCBmb3IgYXR0YWNrXG4gICAgICAgICAqIGRldGVjdGlvbiAvIGhhbmRsaW5nLlxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyogRG9uJ3QgY29weSB0aGUgaW5wdXQgYnVmZmVyIGludG8gYSB0ZW1wb3JhcnkgYnVmZmVyICovXG4gICAgICAgIC8qIHVucm9sbCB0aGUgbG9vcCAyIHRpbWVzICovXG4gICAgICAgIGZvciAoY2huID0gMDsgY2huIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2huKyspIHtcbiAgICAgICAgICAgIC8qIGFwcGx5IGhpZ2ggcGFzcyBmaWx0ZXIgb2YgZnMvNCAqL1xuICAgICAgICAgICAgdmFyIGZpcmJ1ZiA9IGJ1ZmZlcltjaG5dO1xuICAgICAgICAgICAgdmFyIGZpcmJ1ZlBvcyA9IGJ1ZlBvcyArIDU3NiAtIDM1MCAtIE5TRklSTEVOICsgMTkyO1xuICAgICAgICAgICAgYXNzZXJ0JDMoZmlyY29lZi5sZW5ndGggPT0gKChOU0ZJUkxFTiAtIDEpIC8gMikpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDU3NjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bTEsIHN1bTI7XG4gICAgICAgICAgICAgICAgc3VtMSA9IGZpcmJ1ZltmaXJidWZQb3MgKyBpICsgMTBdO1xuICAgICAgICAgICAgICAgIHN1bTIgPSAwLjA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8ICgoTlNGSVJMRU4gLSAxKSAvIDIpIC0gMTsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bTEgKz0gZmlyY29lZltqXVxuICAgICAgICAgICAgICAgICAgICAgICAgKiAoZmlyYnVmW2ZpcmJ1ZlBvcyArIGkgKyBqXSArIGZpcmJ1ZltmaXJidWZQb3MgKyBpXG4gICAgICAgICAgICAgICAgICAgICAgICArIE5TRklSTEVOIC0gal0pO1xuICAgICAgICAgICAgICAgICAgICBzdW0yICs9IGZpcmNvZWZbaiArIDFdXG4gICAgICAgICAgICAgICAgICAgICAgICAqIChmaXJidWZbZmlyYnVmUG9zICsgaSArIGogKyAxXSArIGZpcmJ1ZltmaXJidWZQb3NcbiAgICAgICAgICAgICAgICAgICAgICAgICsgaSArIE5TRklSTEVOIC0gaiAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnNfaHBmc21wbFtjaG5dW2ldID0gc3VtMSArIHN1bTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXNraW5nX3JhdGlvW2dyX291dF1bY2huXS5lbi5hc3NpZ24oZ2ZjLmVuW2Nobl0pO1xuICAgICAgICAgICAgbWFza2luZ19yYXRpb1tncl9vdXRdW2Nobl0udGhtLmFzc2lnbihnZmMudGhtW2Nobl0pO1xuICAgICAgICAgICAgaWYgKG51bWNobiA+IDIpIHtcbiAgICAgICAgICAgICAgICAvKiBNUyBtYXNraW5ncyAqL1xuICAgICAgICAgICAgICAgIC8qIHBlcmNlcF9NU19lbnRyb3B5IFtjaG4tMl0gPSBnZmMgLiBwZSBbY2huXTsgKi9cbiAgICAgICAgICAgICAgICBtYXNraW5nX01TX3JhdGlvW2dyX291dF1bY2huXS5lbi5hc3NpZ24oZ2ZjLmVuW2NobiArIDJdKTtcbiAgICAgICAgICAgICAgICBtYXNraW5nX01TX3JhdGlvW2dyX291dF1bY2huXS50aG0uYXNzaWduKGdmYy50aG1bY2huICsgMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjaG4gPSAwOyBjaG4gPCBudW1jaG47IGNobisrKSB7XG4gICAgICAgICAgICB2YXIgd3NhbXBfbDtcbiAgICAgICAgICAgIHZhciB3c2FtcF9zO1xuICAgICAgICAgICAgdmFyIGVuX3N1YnNob3J0ID0gbmV3X2Zsb2F0JDMoMTIpO1xuICAgICAgICAgICAgdmFyIGVuX3Nob3J0ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgdmFyIGF0dGFja19pbnRlbnNpdHkgPSBuZXdfZmxvYXQkMygxMik7XG4gICAgICAgICAgICB2YXIgbnNfdXNlbG9uZ2Jsb2NrID0gMTtcbiAgICAgICAgICAgIHZhciBhdHRhY2tUaHJlc2hvbGQ7XG4gICAgICAgICAgICB2YXIgbWF4ID0gbmV3X2Zsb2F0JDMoRW5jb2Rlcl8xLkNCQU5EUyksIGF2ZyA9IG5ld19mbG9hdCQzKEVuY29kZXJfMS5DQkFORFMpO1xuICAgICAgICAgICAgdmFyIG5zX2F0dGFja3MgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgICAgICB2YXIgZmZ0ZW5lcmd5ID0gbmV3X2Zsb2F0JDMoRW5jb2Rlcl8xLkhCTEtTSVpFKTtcbiAgICAgICAgICAgIHZhciBmZnRlbmVyZ3lfcyA9IG5ld19mbG9hdF9uJDMoWzMsIEVuY29kZXJfMS5IQkxLU0laRV9zXSk7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiByaCAyMDA0MDMwMTogdGhlIGZvbGxvd2luZyBsb29wcyBkbyBhY2Nlc3Mgb25lIG9mZiB0aGUgbGltaXRzIHNvXG4gICAgICAgICAgICAgKiBJIGluY3JlYXNlIHRoZSBhcnJheSBkaW1lbnNpb25zIGJ5IG9uZSBhbmQgaW5pdGlhbGl6ZSB0aGVcbiAgICAgICAgICAgICAqIGFjY2Vzc2VkIHZhbHVlcyB0byB6ZXJvXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFzc2VydCQzKGdmYy5ucGFydF9zIDw9IEVuY29kZXJfMS5DQkFORFMpO1xuICAgICAgICAgICAgYXNzZXJ0JDMoZ2ZjLm5wYXJ0X2wgPD0gRW5jb2Rlcl8xLkNCQU5EUyk7XG5cbiAgICAgICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICAgICAqIGRldGVybWluZSB0aGUgYmxvY2sgdHlwZSAod2luZG93IHR5cGUpXG4gICAgICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAgICAgLyogY2FsY3VsYXRlIGVuZXJnaWVzIG9mIGVhY2ggc3ViLXNob3J0YmxvY2tzICovXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZW5fc3Vic2hvcnRbaV0gPSBnZmMubnNQc3kubGFzdF9lbl9zdWJzaG9ydFtjaG5dW2kgKyA2XTtcbiAgICAgICAgICAgICAgICBhc3NlcnQkMyhnZmMubnNQc3kubGFzdF9lbl9zdWJzaG9ydFtjaG5dW2kgKyA0XSA+IDApO1xuICAgICAgICAgICAgICAgIGF0dGFja19pbnRlbnNpdHlbaV0gPSBlbl9zdWJzaG9ydFtpXVxuICAgICAgICAgICAgICAgICAgICAvIGdmYy5uc1BzeS5sYXN0X2VuX3N1YnNob3J0W2Nobl1baSArIDRdO1xuICAgICAgICAgICAgICAgIGVuX3Nob3J0WzBdICs9IGVuX3N1YnNob3J0W2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2huID09IDIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNTc2OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwsIHI7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBuc19ocGZzbXBsWzBdW2ldO1xuICAgICAgICAgICAgICAgICAgICByID0gbnNfaHBmc21wbFsxXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgbnNfaHBmc21wbFswXVtpXSA9IGwgKyByO1xuICAgICAgICAgICAgICAgICAgICBuc19ocGZzbXBsWzFdW2ldID0gbCAtIHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwZiA9IG5zX2hwZnNtcGxbY2huICYgMV07XG4gICAgICAgICAgICAgICAgdmFyIHBmUG9zID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZmUgPSBwZlBvcyArIDU3NiAvIDk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gMS47XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwZlBvcyA8IHBmZTsgcGZQb3MrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwIDwgTWF0aC5hYnMocGZbcGZQb3NdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gTWF0aC5hYnMocGZbcGZQb3NdKTtcblxuICAgICAgICAgICAgICAgICAgICBnZmMubnNQc3kubGFzdF9lbl9zdWJzaG9ydFtjaG5dW2ldID0gZW5fc3Vic2hvcnRbaSArIDNdID0gcDtcbiAgICAgICAgICAgICAgICAgICAgZW5fc2hvcnRbMSArIGkgLyAzXSArPSBwO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA+IGVuX3N1YnNob3J0W2kgKyAzIC0gMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCQzKGVuX3N1YnNob3J0W2kgKyAzIC0gMl0gPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwIC8gZW5fc3Vic2hvcnRbaSArIDMgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbl9zdWJzaG9ydFtpICsgMyAtIDJdID4gcCAqIDEwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCQzKHAgPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBlbl9zdWJzaG9ydFtpICsgMyAtIDJdIC8gKHAgKiAxMC4wKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBhdHRhY2tfaW50ZW5zaXR5W2kgKyAzXSA9IHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2ZwLmFuYWx5c2lzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBhdHRhY2tfaW50ZW5zaXR5WzBdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCAxMjsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA8IGF0dGFja19pbnRlbnNpdHlbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYXR0YWNrX2ludGVuc2l0eVtpXTtcbiAgICAgICAgICAgICAgICBnZmMucGluZm8uZXJzW2dyX291dF1bY2huXSA9IGdmYy5waW5mby5lcnNfc2F2ZVtjaG5dO1xuICAgICAgICAgICAgICAgIGdmYy5waW5mby5lcnNfc2F2ZVtjaG5dID0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogY29tcGFyZSBlbmVyZ2llcyBiZXR3ZWVuIHN1Yi1zaG9ydGJsb2NrcyAqL1xuICAgICAgICAgICAgYXR0YWNrVGhyZXNob2xkID0gKGNobiA9PSAzKSA/IGdmYy5uc1BzeS5hdHRhY2t0aHJlX3NcbiAgICAgICAgICAgICAgICA6IGdmYy5uc1BzeS5hdHRhY2t0aHJlO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKDAgPT0gbnNfYXR0YWNrc1tpIC8gM11cbiAgICAgICAgICAgICAgICAgICAgJiYgYXR0YWNrX2ludGVuc2l0eVtpXSA+IGF0dGFja1RocmVzaG9sZClcbiAgICAgICAgICAgICAgICAgICAgbnNfYXR0YWNrc1tpIC8gM10gPSAoaSAlIDMpICsgMTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHNob3VsZCBoYXZlIGVuZXJneSBjaGFuZ2UgYmV0d2VlbiBzaG9ydCBibG9ja3MsIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAgICAgICAgKiBwZXJpb2RpYyBzaWduYWxzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmF0aW87XG4gICAgICAgICAgICAgICAgaWYgKGVuX3Nob3J0W2kgLSAxXSA+IGVuX3Nob3J0W2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCQzKGVuX3Nob3J0W2ldID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIHJhdGlvID0gZW5fc2hvcnRbaSAtIDFdIC8gZW5fc2hvcnRbaV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0JDMoZW5fc2hvcnRbaSAtIDFdID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIHJhdGlvID0gZW5fc2hvcnRbaV0gLyBlbl9zaG9ydFtpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyYXRpbyA8IDEuNykge1xuICAgICAgICAgICAgICAgICAgICBuc19hdHRhY2tzW2ldID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5zX2F0dGFja3NbMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5zX2F0dGFja3NbMF0gIT0gMCAmJiBnZmMubnNQc3kubGFzdEF0dGFja3NbY2huXSAhPSAwKVxuICAgICAgICAgICAgICAgIG5zX2F0dGFja3NbMF0gPSAwO1xuXG4gICAgICAgICAgICBpZiAoZ2ZjLm5zUHN5Lmxhc3RBdHRhY2tzW2Nobl0gPT0gM1xuICAgICAgICAgICAgICAgIHx8IChuc19hdHRhY2tzWzBdICsgbnNfYXR0YWNrc1sxXSArIG5zX2F0dGFja3NbMl0gKyBuc19hdHRhY2tzWzNdKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgbnNfdXNlbG9uZ2Jsb2NrID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChuc19hdHRhY2tzWzFdICE9IDAgJiYgbnNfYXR0YWNrc1swXSAhPSAwKVxuICAgICAgICAgICAgICAgICAgICBuc19hdHRhY2tzWzFdID0gMDtcbiAgICAgICAgICAgICAgICBpZiAobnNfYXR0YWNrc1syXSAhPSAwICYmIG5zX2F0dGFja3NbMV0gIT0gMClcbiAgICAgICAgICAgICAgICAgICAgbnNfYXR0YWNrc1syXSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKG5zX2F0dGFja3NbM10gIT0gMCAmJiBuc19hdHRhY2tzWzJdICE9IDApXG4gICAgICAgICAgICAgICAgICAgIG5zX2F0dGFja3NbM10gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2huIDwgMikge1xuICAgICAgICAgICAgICAgIHVzZWxvbmdibG9ja1tjaG5dID0gbnNfdXNlbG9uZ2Jsb2NrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobnNfdXNlbG9uZ2Jsb2NrID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlbG9uZ2Jsb2NrWzBdID0gdXNlbG9uZ2Jsb2NrWzFdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiB0aGVyZSBpcyBhIG9uZSBncmFudWxlIGRlbGF5LiBDb3B5IG1hc2tpbmdzIGNvbXB1dGVkIGxhc3QgY2FsbFxuICAgICAgICAgICAgICogaW50byBtYXNraW5nX3JhdGlvIHRvIHJldHVybiB0byBjYWxsaW5nIHByb2dyYW0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVuZXJneVtjaG5dID0gZ2ZjLnRvdF9lbmVyW2Nobl07XG5cbiAgICAgICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICAgICAqIGNvbXB1dGUgRkZUc1xuICAgICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgICAgIHdzYW1wX3MgPSB3c2FtcF9TO1xuICAgICAgICAgICAgd3NhbXBfbCA9IHdzYW1wX0w7XG4gICAgICAgICAgICBjb21wdXRlX2ZmdHMoZ2ZwLCBmZnRlbmVyZ3ksIGZmdGVuZXJneV9zLCB3c2FtcF9sLCAoY2huICYgMSksXG4gICAgICAgICAgICAgICAgd3NhbXBfcywgKGNobiAmIDEpLCBncl9vdXQsIGNobiwgYnVmZmVyLCBidWZQb3MpO1xuXG4gICAgICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIGVuZXJneSBhbmQgdGhlIHRvbmFsaXR5IG9mIGVhY2ggcGFydGl0aW9uLlxuICAgICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgICAgIGNhbGNfZW5lcmd5KGdmYywgZmZ0ZW5lcmd5LCBlYl9sLCBtYXgsIGF2Zyk7XG4gICAgICAgICAgICBjYWxjX21hc2tfaW5kZXhfbChnZmMsIG1heCwgYXZnLCBtYXNrX2lkeF9sKTtcbiAgICAgICAgICAgIC8qIGNvbXB1dGUgbWFza2luZyB0aHJlc2hvbGRzIGZvciBzaG9ydCBibG9ja3MgKi9cbiAgICAgICAgICAgIGZvciAoc2Jsb2NrID0gMDsgc2Jsb2NrIDwgMzsgc2Jsb2NrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5uLCB0aG1tO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVfbWFza2luZ19zKGdmcCwgZmZ0ZW5lcmd5X3MsIGViX3MsIHRociwgY2huLCBzYmxvY2spO1xuICAgICAgICAgICAgICAgIGNvbnZlcnRfcGFydGl0aW9uMnNjYWxlZmFjX3MoZ2ZjLCBlYl9zLCB0aHIsIGNobiwgc2Jsb2NrKTtcbiAgICAgICAgICAgICAgICAvKioqKiBzaG9ydCBibG9jayBwcmUtZWNobyBjb250cm9sICoqKiovXG4gICAgICAgICAgICAgICAgZm9yIChzYiA9IDA7IHNiIDwgRW5jb2Rlcl8xLlNCTUFYX3M7IHNiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhtbSA9IGdmYy50aG1bY2huXS5zW3NiXVtzYmxvY2tdO1xuXG4gICAgICAgICAgICAgICAgICAgIHRobW0gKj0gTlNfUFJFRUNIT19BVFQwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnNfYXR0YWNrc1tzYmxvY2tdID49IDIgfHwgbnNfYXR0YWNrc1tzYmxvY2sgKyAxXSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gKHNibG9jayAhPSAwKSA/IHNibG9jayAtIDEgOiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBOU19JTlRFUlAoZ2ZjLnRobVtjaG5dLnNbc2JdW2lkeF0sIHRobW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTlNfUFJFRUNIT19BVFQxICogcGNmYWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRobW0gPSBNYXRoLm1pbih0aG1tLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuc19hdHRhY2tzW3NibG9ja10gPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IChzYmxvY2sgIT0gMCkgPyBzYmxvY2sgLSAxIDogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gTlNfSU5URVJQKGdmYy50aG1bY2huXS5zW3NiXVtpZHhdLCB0aG1tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5TX1BSRUVDSE9fQVRUMiAqIHBjZmFjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aG1tID0gTWF0aC5taW4odGhtbSwgcCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHNibG9jayAhPSAwICYmIG5zX2F0dGFja3Nbc2Jsb2NrIC0gMV0gPT0gMylcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChzYmxvY2sgPT0gMCAmJiBnZmMubnNQc3kubGFzdEF0dGFja3NbY2huXSA9PSAzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IChzYmxvY2sgIT0gMikgPyBzYmxvY2sgKyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gTlNfSU5URVJQKGdmYy50aG1bY2huXS5zW3NiXVtpZHhdLCB0aG1tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5TX1BSRUVDSE9fQVRUMiAqIHBjZmFjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aG1tID0gTWF0aC5taW4odGhtbSwgcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKiBwdWxzZSBsaWtlIHNpZ25hbCBkZXRlY3Rpb24gZm9yIGZhdGJveS53YXYgYW5kIHNvIG9uICovXG4gICAgICAgICAgICAgICAgICAgIGVubiA9IGVuX3N1YnNob3J0W3NibG9jayAqIDMgKyAzXVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBlbl9zdWJzaG9ydFtzYmxvY2sgKiAzICsgNF1cbiAgICAgICAgICAgICAgICAgICAgICAgICsgZW5fc3Vic2hvcnRbc2Jsb2NrICogMyArIDVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5fc3Vic2hvcnRbc2Jsb2NrICogMyArIDVdICogNiA8IGVubikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhtbSAqPSAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5fc3Vic2hvcnRbc2Jsb2NrICogMyArIDRdICogNiA8IGVubilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aG1tICo9IDAuNTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGdmYy50aG1bY2huXS5zW3NiXVtzYmxvY2tdID0gdGhtbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZmMubnNQc3kubGFzdEF0dGFja3NbY2huXSA9IG5zX2F0dGFja3NbMl07XG5cbiAgICAgICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICAgICAqIGNvbnZvbHZlIHRoZSBwYXJ0aXRpb25lZCBlbmVyZ3kgYW5kIHVucHJlZGljdGFiaWxpdHkgd2l0aCB0aGVcbiAgICAgICAgICAgICAqIHNwcmVhZGluZyBmdW5jdGlvbiwgczNfbFtiXVtrXVxuICAgICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9yIChiID0gMDsgYiA8IGdmYy5ucGFydF9sOyBiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogY29udm9sdmUgdGhlIHBhcnRpdGlvbmVkIGVuZXJneSB3aXRoIHRoZSBzcHJlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICogZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBrayA9IGdmYy5zM2luZFtiXVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGViMiA9IGViX2xba2tdICogdGFiW21hc2tfaWR4X2xba2tdXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVjYiA9IGdmYy5zM19sbFtrKytdICogZWIyO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKytrayA8PSBnZmMuczNpbmRbYl1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGViMiA9IGViX2xba2tdICogdGFiW21hc2tfaWR4X2xba2tdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVjYiA9IG1hc2tfYWRkKGVjYiwgZ2ZjLnMzX2xsW2srK10gKiBlYjIsIGtrLCBrayAtIGIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2ZjLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlY2IgKj0gMC4xNTg0ODkzMTkyNDYxMTE7XG4gICAgICAgICAgICAgICAgICAgIC8qIHBvdygxMCwtMC44KSAqL1xuXG4gICAgICAgICAgICAgICAgICAgIC8qKioqIGxvbmcgYmxvY2sgcHJlLWVjaG8gY29udHJvbCAqKioqL1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogPFBSRT5cbiAgICAgICAgICAgICAgICAgICAgICogZG9udCB1c2UgbG9uZyBibG9jayBwcmUtZWNobyBjb250cm9sIGlmIHByZXZpb3VzIGdyYW51bGUgd2FzXG4gICAgICAgICAgICAgICAgICAgICAqIGEgc2hvcnQgYmxvY2suICBUaGlzIGlzIHRvIGF2b2lkIHRoZSBzaXR1YXRpb246XG4gICAgICAgICAgICAgICAgICAgICAqIGZyYW1lMDogIHF1aWV0ICh2ZXJ5IGxvdyBtYXNraW5nKVxuICAgICAgICAgICAgICAgICAgICAgKiBmcmFtZTE6ICBzdXJnZSAgKHRyaWdnZXJzIHNob3J0IGJsb2NrcylcbiAgICAgICAgICAgICAgICAgICAgICogZnJhbWUyOiAgcmVndWxhciBmcmFtZS4gIGxvb2tzIGxpa2UgcHJlLWVjaG8gd2hlbiBjb21wYXJlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBmcmFtZTAsIGJ1dCBhbGwgcHJlLWVjaG8gd2FzIGluIGZyYW1lMS5cbiAgICAgICAgICAgICAgICAgICAgICogPC9QUkU+XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBjaG49MCwxIEwgYW5kIFIgY2hhbm5lbHNcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogY2huPTIsMyBTIGFuZCBNIGNoYW5uZWxzLlxuICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2ZjLmJsb2NrdHlwZV9vbGRbY2huICYgMV0gPT0gRW5jb2Rlcl8xLlNIT1JUX1RZUEUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJbYl0gPSBlY2I7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocltiXSA9IE5TX0lOVEVSUChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihlY2IsIE1hdGgubWluKHJwZWxldlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdmYy5uYl8xW2Nobl1bYl0sIHJwZWxldjJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZmMubmJfMltjaG5dW2JdKSksIGVjYiwgcGNmYWN0KTtcblxuICAgICAgICAgICAgICAgICAgICBnZmMubmJfMltjaG5dW2JdID0gZ2ZjLm5iXzFbY2huXVtiXTtcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLm5iXzFbY2huXVtiXSA9IGVjYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgYiA8PSBFbmNvZGVyXzEuQ0JBTkRTOyArK2IpIHtcbiAgICAgICAgICAgICAgICBlYl9sW2JdID0gMDtcbiAgICAgICAgICAgICAgICB0aHJbYl0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogY29tcHV0ZSBtYXNraW5nIHRocmVzaG9sZHMgZm9yIGxvbmcgYmxvY2tzICovXG4gICAgICAgICAgICBjb252ZXJ0X3BhcnRpdGlvbjJzY2FsZWZhY19sKGdmYywgZWJfbCwgdGhyLCBjaG4pO1xuICAgICAgICB9XG4gICAgICAgIC8qIGVuZCBsb29wIG92ZXIgY2huICovXG5cbiAgICAgICAgaWYgKGdmcC5tb2RlID09IE1QRUdNb2RlLlNURVJFTyB8fCBnZnAubW9kZSA9PSBNUEVHTW9kZS5KT0lOVF9TVEVSRU8pIHtcbiAgICAgICAgICAgIGlmIChnZnAuaW50ZXJDaFJhdGlvID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgY2FsY19pbnRlcmNoYW5uZWxfbWFza2luZyhnZnAsIGdmcC5pbnRlckNoUmF0aW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdmcC5tb2RlID09IE1QRUdNb2RlLkpPSU5UX1NURVJFTykge1xuICAgICAgICAgICAgdmFyIG1zZml4O1xuICAgICAgICAgICAgbXNmaXgxKGdmYyk7XG4gICAgICAgICAgICBtc2ZpeCA9IGdmcC5tc2ZpeDtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhtc2ZpeCkgPiAwLjApXG4gICAgICAgICAgICAgICAgbnNfbXNmaXgoZ2ZjLCBtc2ZpeCwgZ2ZwLkFUSGxvd2VyICogZ2ZjLkFUSC5hZGp1c3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBkZXRlcm1pbmUgZmluYWwgYmxvY2sgdHlwZVxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBibG9ja190eXBlX3NldChnZnAsIHVzZWxvbmdibG9jaywgYmxvY2t0eXBlX2QsIGJsb2NrdHlwZSk7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBvZiBQRSB0byByZXR1cm4gLi4uIG5vIGRlbGF5IGFuZCBhZHZhbmNlXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGZvciAoY2huID0gMDsgY2huIDwgbnVtY2huOyBjaG4rKykge1xuICAgICAgICAgICAgdmFyIHBwZTtcbiAgICAgICAgICAgIHZhciBwcGVQb3MgPSAwO1xuICAgICAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgICAgICB2YXIgbXI7XG5cbiAgICAgICAgICAgIGlmIChjaG4gPiAxKSB7XG4gICAgICAgICAgICAgICAgcHBlID0gcGVyY2VwX01TX2VudHJvcHk7XG4gICAgICAgICAgICAgICAgcHBlUG9zID0gLTI7XG4gICAgICAgICAgICAgICAgdHlwZSA9IEVuY29kZXJfMS5OT1JNX1RZUEU7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrdHlwZV9kWzBdID09IEVuY29kZXJfMS5TSE9SVF9UWVBFXG4gICAgICAgICAgICAgICAgICAgIHx8IGJsb2NrdHlwZV9kWzFdID09IEVuY29kZXJfMS5TSE9SVF9UWVBFKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gRW5jb2Rlcl8xLlNIT1JUX1RZUEU7XG4gICAgICAgICAgICAgICAgbXIgPSBtYXNraW5nX01TX3JhdGlvW2dyX291dF1bY2huIC0gMl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBwZSA9IHBlcmNlcF9lbnRyb3B5O1xuICAgICAgICAgICAgICAgIHBwZVBvcyA9IDA7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGJsb2NrdHlwZV9kW2Nobl07XG4gICAgICAgICAgICAgICAgbXIgPSBtYXNraW5nX3JhdGlvW2dyX291dF1bY2huXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gRW5jb2Rlcl8xLlNIT1JUX1RZUEUpXG4gICAgICAgICAgICAgICAgcHBlW3BwZVBvcyArIGNobl0gPSBwZWNhbGNfcyhtciwgZ2ZjLm1hc2tpbmdfbG93ZXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBwZVtwcGVQb3MgKyBjaG5dID0gcGVjYWxjX2wobXIsIGdmYy5tYXNraW5nX2xvd2VyKTtcblxuICAgICAgICAgICAgaWYgKGdmcC5hbmFseXNpcylcbiAgICAgICAgICAgICAgICBnZmMucGluZm8ucGVbZ3Jfb3V0XVtjaG5dID0gcHBlW3BwZVBvcyArIGNobl07XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdmJycHN5X2NvbXB1dGVfZmZ0X2woZ2ZwLCBidWZmZXIsIGJ1ZlBvcywgY2huLCBncl9vdXQsIGZmdGVuZXJneSwgd3NhbXBfbCwgd3NhbXBfbFBvcykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICBpZiAoY2huIDwgMikge1xuICAgICAgICAgICAgZmZ0LmZmdF9sb25nKGdmYywgd3NhbXBfbFt3c2FtcF9sUG9zXSwgY2huLCBidWZmZXIsIGJ1ZlBvcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2huID09IDIpIHtcbiAgICAgICAgICAgIC8qIEZGVCBkYXRhIGZvciBtaWQgYW5kIHNpZGUgY2hhbm5lbCBpcyBkZXJpdmVkIGZyb20gTCAmIFIgKi9cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBFbmNvZGVyXzEuQkxLU0laRSAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSB3c2FtcF9sW3dzYW1wX2xQb3MgKyAwXVtqXTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHdzYW1wX2xbd3NhbXBfbFBvcyArIDFdW2pdO1xuICAgICAgICAgICAgICAgIHdzYW1wX2xbd3NhbXBfbFBvcyArIDBdW2pdID0gKGwgKyByKSAqIFV0aWwkMy5TUVJUMiAqIDAuNTtcbiAgICAgICAgICAgICAgICB3c2FtcF9sW3dzYW1wX2xQb3MgKyAxXVtqXSA9IChsIC0gcikgKiBVdGlsJDMuU1FSVDIgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIGNvbXB1dGUgZW5lcmdpZXNcbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgZmZ0ZW5lcmd5WzBdID0gTk9OX0xJTkVBUl9TQ0FMRV9FTkVSR1kod3NhbXBfbFt3c2FtcF9sUG9zICsgMF1bMF0pO1xuICAgICAgICBmZnRlbmVyZ3lbMF0gKj0gZmZ0ZW5lcmd5WzBdO1xuXG4gICAgICAgIGZvciAodmFyIGogPSBFbmNvZGVyXzEuQkxLU0laRSAvIDIgLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgdmFyIHJlID0gd3NhbXBfbFt3c2FtcF9sUG9zICsgMF1bRW5jb2Rlcl8xLkJMS1NJWkUgLyAyIC0gal07XG4gICAgICAgICAgICB2YXIgaW0gPSB3c2FtcF9sW3dzYW1wX2xQb3MgKyAwXVtFbmNvZGVyXzEuQkxLU0laRSAvIDIgKyBqXTtcbiAgICAgICAgICAgIGZmdGVuZXJneVtFbmNvZGVyXzEuQkxLU0laRSAvIDIgLSBqXSA9IE5PTl9MSU5FQVJfU0NBTEVfRU5FUkdZKChyZVxuICAgICAgICAgICAgICAgICogcmUgKyBpbSAqIGltKSAqIDAuNSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogdG90YWwgZW5lcmd5ICovXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0b3RhbGVuZXJneSA9IDAuMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxMTsgaiA8IEVuY29kZXJfMS5IQkxLU0laRTsgaisrKVxuICAgICAgICAgICAgICAgIHRvdGFsZW5lcmd5ICs9IGZmdGVuZXJneVtqXTtcblxuICAgICAgICAgICAgZ2ZjLnRvdF9lbmVyW2Nobl0gPSB0b3RhbGVuZXJneTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZnAuYW5hbHlzaXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgRW5jb2Rlcl8xLkhCTEtTSVpFOyBqKyspIHtcbiAgICAgICAgICAgICAgICBnZmMucGluZm8uZW5lcmd5W2dyX291dF1bY2huXVtqXSA9IGdmYy5waW5mby5lbmVyZ3lfc2F2ZVtjaG5dW2pdO1xuICAgICAgICAgICAgICAgIGdmYy5waW5mby5lbmVyZ3lfc2F2ZVtjaG5dW2pdID0gZmZ0ZW5lcmd5W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2ZjLnBpbmZvLnBlW2dyX291dF1bY2huXSA9IGdmYy5wZVtjaG5dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmJycHN5X2NvbXB1dGVfZmZ0X3MoZ2ZwLCBidWZmZXIsIGJ1ZlBvcywgY2huLCBzYmxvY2ssIGZmdGVuZXJneV9zLCB3c2FtcF9zLCB3c2FtcF9zUG9zKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgaWYgKHNibG9jayA9PSAwICYmIGNobiA8IDIpIHtcbiAgICAgICAgICAgIGZmdC5mZnRfc2hvcnQoZ2ZjLCB3c2FtcF9zW3dzYW1wX3NQb3NdLCBjaG4sIGJ1ZmZlciwgYnVmUG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2huID09IDIpIHtcbiAgICAgICAgICAgIC8qIEZGVCBkYXRhIGZvciBtaWQgYW5kIHNpZGUgY2hhbm5lbCBpcyBkZXJpdmVkIGZyb20gTCAmIFIgKi9cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBFbmNvZGVyXzEuQkxLU0laRV9zIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHdzYW1wX3Nbd3NhbXBfc1BvcyArIDBdW3NibG9ja11bal07XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB3c2FtcF9zW3dzYW1wX3NQb3MgKyAxXVtzYmxvY2tdW2pdO1xuICAgICAgICAgICAgICAgIHdzYW1wX3Nbd3NhbXBfc1BvcyArIDBdW3NibG9ja11bal0gPSAobCArIHIpICogVXRpbCQzLlNRUlQyICogMC41O1xuICAgICAgICAgICAgICAgIHdzYW1wX3Nbd3NhbXBfc1BvcyArIDFdW3NibG9ja11bal0gPSAobCAtIHIpICogVXRpbCQzLlNRUlQyICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBjb21wdXRlIGVuZXJnaWVzXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGZmdGVuZXJneV9zW3NibG9ja11bMF0gPSB3c2FtcF9zW3dzYW1wX3NQb3MgKyAwXVtzYmxvY2tdWzBdO1xuICAgICAgICBmZnRlbmVyZ3lfc1tzYmxvY2tdWzBdICo9IGZmdGVuZXJneV9zW3NibG9ja11bMF07XG4gICAgICAgIGZvciAodmFyIGogPSBFbmNvZGVyXzEuQkxLU0laRV9zIC8gMiAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICB2YXIgcmUgPSB3c2FtcF9zW3dzYW1wX3NQb3MgKyAwXVtzYmxvY2tdW0VuY29kZXJfMS5CTEtTSVpFX3MgLyAyIC0gal07XG4gICAgICAgICAgICB2YXIgaW0gPSB3c2FtcF9zW3dzYW1wX3NQb3MgKyAwXVtzYmxvY2tdW0VuY29kZXJfMS5CTEtTSVpFX3MgLyAyICsgal07XG4gICAgICAgICAgICBmZnRlbmVyZ3lfc1tzYmxvY2tdW0VuY29kZXJfMS5CTEtTSVpFX3MgLyAyIC0gal0gPSBOT05fTElORUFSX1NDQUxFX0VORVJHWSgocmVcbiAgICAgICAgICAgICAgICAqIHJlICsgaW0gKiBpbSkgKiAwLjUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSBsb3VkbmVzcyBhcHByb3hpbWF0aW9uICh1c2VkIGZvciBBVEggYXV0by1sZXZlbCBhZGp1c3RtZW50KVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZicnBzeV9jb21wdXRlX2xvdWRuZXNzX2FwcHJveGltYXRpb25fbChnZnAsIGdyX291dCwgY2huLCBmZnRlbmVyZ3kpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgaWYgKGdmcC5hdGhhYV9sb3VkYXBwcm94ID09IDIgJiYgY2huIDwgMikge1xuICAgICAgICAgICAgLy8gbm8gbG91ZG5lc3MgZm9yIG1pZC9zaWRlIGNoXG4gICAgICAgICAgICBnZmMubG91ZG5lc3Nfc3FbZ3Jfb3V0XVtjaG5dID0gZ2ZjLmxvdWRuZXNzX3NxX3NhdmVbY2huXTtcbiAgICAgICAgICAgIGdmYy5sb3VkbmVzc19zcV9zYXZlW2Nobl0gPSBwc3ljaG9fbG91ZG5lc3NfYXBwcm94KGZmdGVuZXJneSwgZ2ZjKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaXJjb2VmXyA9IFstOC42NTE2M2UtMTggKiAyLFxuICAgICAgICAtMC4wMDg1MTU4NiAqIDIsIC02Ljc0NzY0ZS0xOCAqIDIsIDAuMDIwOTAzNiAqIDIsXG4gICAgICAgIC0zLjM2NjM5ZS0xNyAqIDIsIC0wLjA0MzgxNjIgKiAyLCAtMS41NDE3NWUtMTcgKiAyLFxuICAgICAgICAwLjA5MzE3MzggKiAyLCAtNS41MjIxMmUtMTcgKiAyLCAtMC4zMTM4MTkgKiAyXTtcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IEhQRiBvZiBmcy80IHRvIHRoZSBpbnB1dCBzaWduYWwuIFRoaXMgaXMgdXNlZCBmb3IgYXR0YWNrIGRldGVjdGlvblxuICAgICAqIC8gaGFuZGxpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmJycHN5X2F0dGFja19kZXRlY3Rpb24oZ2ZwLCBidWZmZXIsIGJ1ZlBvcywgZ3Jfb3V0LCBtYXNraW5nX3JhdGlvLCBtYXNraW5nX01TX3JhdGlvLCBlbmVyZ3ksIHN1Yl9zaG9ydF9mYWN0b3IsIG5zX2F0dGFja3MsIHVzZWxvbmdibG9jaykge1xuICAgICAgICB2YXIgbnNfaHBmc21wbCA9IG5ld19mbG9hdF9uJDMoWzIsIDU3Nl0pO1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgbl9jaG5fb3V0ID0gZ2ZjLmNoYW5uZWxzX291dDtcbiAgICAgICAgLyogY2huPTIgYW5kIDMgPSBNaWQgYW5kIFNpZGUgY2hhbm5lbHMgKi9cbiAgICAgICAgdmFyIG5fY2huX3BzeSA9IChnZnAubW9kZSA9PSBNUEVHTW9kZS5KT0lOVF9TVEVSRU8pID8gNCA6IG5fY2huX291dDtcbiAgICAgICAgLyogRG9uJ3QgY29weSB0aGUgaW5wdXQgYnVmZmVyIGludG8gYSB0ZW1wb3JhcnkgYnVmZmVyICovXG4gICAgICAgIC8qIHVucm9sbCB0aGUgbG9vcCAyIHRpbWVzICovXG4gICAgICAgIGZvciAodmFyIGNobiA9IDA7IGNobiA8IG5fY2huX291dDsgY2huKyspIHtcbiAgICAgICAgICAgIC8qIGFwcGx5IGhpZ2ggcGFzcyBmaWx0ZXIgb2YgZnMvNCAqL1xuICAgICAgICAgICAgZmlyYnVmID0gYnVmZmVyW2Nobl07XG4gICAgICAgICAgICB2YXIgZmlyYnVmUG9zID0gYnVmUG9zICsgNTc2IC0gMzUwIC0gTlNGSVJMRU4gKyAxOTI7XG4gICAgICAgICAgICBhc3NlcnQkMyhmaXJjb2VmXy5sZW5ndGggPT0gKChOU0ZJUkxFTiAtIDEpIC8gMikpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1NzY7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdW0xLCBzdW0yO1xuICAgICAgICAgICAgICAgIHN1bTEgPSBmaXJidWZbZmlyYnVmUG9zICsgaSArIDEwXTtcbiAgICAgICAgICAgICAgICBzdW0yID0gMC4wO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgKChOU0ZJUkxFTiAtIDEpIC8gMikgLSAxOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtMSArPSBmaXJjb2VmX1tqXVxuICAgICAgICAgICAgICAgICAgICAgICAgKiAoZmlyYnVmW2ZpcmJ1ZlBvcyArIGkgKyBqXSArIGZpcmJ1ZltmaXJidWZQb3MgKyBpXG4gICAgICAgICAgICAgICAgICAgICAgICArIE5TRklSTEVOIC0gal0pO1xuICAgICAgICAgICAgICAgICAgICBzdW0yICs9IGZpcmNvZWZfW2ogKyAxXVxuICAgICAgICAgICAgICAgICAgICAgICAgKiAoZmlyYnVmW2ZpcmJ1ZlBvcyArIGkgKyBqICsgMV0gKyBmaXJidWZbZmlyYnVmUG9zXG4gICAgICAgICAgICAgICAgICAgICAgICArIGkgKyBOU0ZJUkxFTiAtIGogLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5zX2hwZnNtcGxbY2huXVtpXSA9IHN1bTEgKyBzdW0yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFza2luZ19yYXRpb1tncl9vdXRdW2Nobl0uZW4uYXNzaWduKGdmYy5lbltjaG5dKTtcbiAgICAgICAgICAgIG1hc2tpbmdfcmF0aW9bZ3Jfb3V0XVtjaG5dLnRobS5hc3NpZ24oZ2ZjLnRobVtjaG5dKTtcbiAgICAgICAgICAgIGlmIChuX2Nobl9wc3kgPiAyKSB7XG4gICAgICAgICAgICAgICAgLyogTVMgbWFza2luZ3MgKi9cbiAgICAgICAgICAgICAgICAvKiBwZXJjZXBfTVNfZW50cm9weSBbY2huLTJdID0gZ2ZjIC4gcGUgW2Nobl07ICovXG4gICAgICAgICAgICAgICAgbWFza2luZ19NU19yYXRpb1tncl9vdXRdW2Nobl0uZW4uYXNzaWduKGdmYy5lbltjaG4gKyAyXSk7XG4gICAgICAgICAgICAgICAgbWFza2luZ19NU19yYXRpb1tncl9vdXRdW2Nobl0udGhtLmFzc2lnbihnZmMudGhtW2NobiArIDJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBjaG4gPSAwOyBjaG4gPCBuX2Nobl9wc3k7IGNobisrKSB7XG4gICAgICAgICAgICB2YXIgYXR0YWNrX2ludGVuc2l0eSA9IG5ld19mbG9hdCQzKDEyKTtcbiAgICAgICAgICAgIHZhciBlbl9zdWJzaG9ydCA9IG5ld19mbG9hdCQzKDEyKTtcbiAgICAgICAgICAgIHZhciBlbl9zaG9ydCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgIHZhciBwZiA9IG5zX2hwZnNtcGxbY2huICYgMV07XG4gICAgICAgICAgICB2YXIgcGZQb3MgPSAwO1xuICAgICAgICAgICAgdmFyIGF0dGFja1RocmVzaG9sZCA9IChjaG4gPT0gMykgPyBnZmMubnNQc3kuYXR0YWNrdGhyZV9zXG4gICAgICAgICAgICAgICAgOiBnZmMubnNQc3kuYXR0YWNrdGhyZTtcbiAgICAgICAgICAgIHZhciBuc191c2Vsb25nYmxvY2sgPSAxO1xuXG4gICAgICAgICAgICBpZiAoY2huID09IDIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDU3NjsgaiA+IDA7ICsraSwgLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsID0gbnNfaHBmc21wbFswXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBuc19ocGZzbXBsWzFdW2ldO1xuICAgICAgICAgICAgICAgICAgICBuc19ocGZzbXBsWzBdW2ldID0gbCArIHI7XG4gICAgICAgICAgICAgICAgICAgIG5zX2hwZnNtcGxbMV1baV0gPSBsIC0gcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICAgKiBkZXRlcm1pbmUgdGhlIGJsb2NrIHR5cGUgKHdpbmRvdyB0eXBlKVxuICAgICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgICAgIC8qIGNhbGN1bGF0ZSBlbmVyZ2llcyBvZiBlYWNoIHN1Yi1zaG9ydGJsb2NrcyAqL1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbl9zdWJzaG9ydFtpXSA9IGdmYy5uc1BzeS5sYXN0X2VuX3N1YnNob3J0W2Nobl1baSArIDZdO1xuICAgICAgICAgICAgICAgIGFzc2VydCQzKGdmYy5uc1BzeS5sYXN0X2VuX3N1YnNob3J0W2Nobl1baSArIDRdID4gMCk7XG4gICAgICAgICAgICAgICAgYXR0YWNrX2ludGVuc2l0eVtpXSA9IGVuX3N1YnNob3J0W2ldXG4gICAgICAgICAgICAgICAgICAgIC8gZ2ZjLm5zUHN5Lmxhc3RfZW5fc3Vic2hvcnRbY2huXVtpICsgNF07XG4gICAgICAgICAgICAgICAgZW5fc2hvcnRbMF0gKz0gZW5fc3Vic2hvcnRbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBmZSA9IHBmUG9zICsgNTc2IC8gOTtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IDEuO1xuICAgICAgICAgICAgICAgIGZvciAoOyBwZlBvcyA8IHBmZTsgcGZQb3MrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPCBNYXRoLmFicyhwZltwZlBvc10pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IE1hdGguYWJzKHBmW3BmUG9zXSk7XG5cbiAgICAgICAgICAgICAgICBnZmMubnNQc3kubGFzdF9lbl9zdWJzaG9ydFtjaG5dW2ldID0gZW5fc3Vic2hvcnRbaSArIDNdID0gcDtcbiAgICAgICAgICAgICAgICBlbl9zaG9ydFsxICsgaSAvIDNdICs9IHA7XG4gICAgICAgICAgICAgICAgaWYgKHAgPiBlbl9zdWJzaG9ydFtpICsgMyAtIDJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCQzKGVuX3N1YnNob3J0W2kgKyAzIC0gMl0gPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAgLyBlbl9zdWJzaG9ydFtpICsgMyAtIDJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5fc3Vic2hvcnRbaSArIDMgLSAyXSA+IHAgKiAxMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCQzKHAgPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGVuX3N1YnNob3J0W2kgKyAzIC0gMl0gLyAocCAqIDEwLjApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSAwLjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0dGFja19pbnRlbnNpdHlbaSArIDNdID0gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIHB1bHNlIGxpa2Ugc2lnbmFsIGRldGVjdGlvbiBmb3IgZmF0Ym95LndhdiBhbmQgc28gb24gKi9cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVubiA9IGVuX3N1YnNob3J0W2kgKiAzICsgM11cbiAgICAgICAgICAgICAgICAgICAgKyBlbl9zdWJzaG9ydFtpICogMyArIDRdICsgZW5fc3Vic2hvcnRbaSAqIDMgKyA1XTtcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gMS47XG4gICAgICAgICAgICAgICAgaWYgKGVuX3N1YnNob3J0W2kgKiAzICsgNV0gKiA2IDwgZW5uKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhY3RvciAqPSAwLjU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbl9zdWJzaG9ydFtpICogMyArIDRdICogNiA8IGVubikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yICo9IDAuNTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJfc2hvcnRfZmFjdG9yW2Nobl1baV0gPSBmYWN0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnZnAuYW5hbHlzaXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGF0dGFja19pbnRlbnNpdHlbMF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4IDwgYXR0YWNrX2ludGVuc2l0eVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGF0dGFja19pbnRlbnNpdHlbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLmVyc1tncl9vdXRdW2Nobl0gPSBnZmMucGluZm8uZXJzX3NhdmVbY2huXTtcbiAgICAgICAgICAgICAgICBnZmMucGluZm8uZXJzX3NhdmVbY2huXSA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIGNvbXBhcmUgZW5lcmdpZXMgYmV0d2VlbiBzdWItc2hvcnRibG9ja3MgKi9cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgwID09IG5zX2F0dGFja3NbY2huXVtpIC8gM11cbiAgICAgICAgICAgICAgICAgICAgJiYgYXR0YWNrX2ludGVuc2l0eVtpXSA+IGF0dGFja1RocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBuc19hdHRhY2tzW2Nobl1baSAvIDNdID0gKGkgJSAzKSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogc2hvdWxkIGhhdmUgZW5lcmd5IGNoYW5nZSBiZXR3ZWVuIHNob3J0IGJsb2NrcywgaW4gb3JkZXIgdG8gYXZvaWRcbiAgICAgICAgICAgICAqIHBlcmlvZGljIHNpZ25hbHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyogR29vZCBzYW1wbGVzIHRvIHNob3cgdGhlIGVmZmVjdCBhcmUgVHJ1bXBldCB0ZXN0IHNvbmdzICovXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogR0I6IHR1bmVkICgxKSB0byBhdm9pZCB0b28gbWFueSBzaG9ydCBibG9ja3MgZm9yIHRlc3Qgc2FtcGxlXG4gICAgICAgICAgICAgKiBUUlVNUEVUXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBSSDogdHVuZWQgKDIpIHRvIGxldCBlbm91Z2ggc2hvcnQgYmxvY2tzIHRocm91Z2ggZm9yIHRlc3Qgc2FtcGxlXG4gICAgICAgICAgICAgKiBGU09MIGFuZCBTTkFQU1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB1ID0gZW5fc2hvcnRbaSAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciB2ID0gZW5fc2hvcnRbaV07XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBNYXRoLm1heCh1LCB2KTtcbiAgICAgICAgICAgICAgICBpZiAobSA8IDQwMDAwKSB7IC8qICgyKSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA8IDEuNyAqIHYgJiYgdiA8IDEuNyAqIHUpIHsgLyogKDEpICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxICYmIG5zX2F0dGFja3NbY2huXVswXSA8PSBuc19hdHRhY2tzW2Nobl1baV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuc19hdHRhY2tzW2Nobl1bMF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbnNfYXR0YWNrc1tjaG5dW2ldID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5zX2F0dGFja3NbY2huXVswXSA8PSBnZmMubnNQc3kubGFzdEF0dGFja3NbY2huXSkge1xuICAgICAgICAgICAgICAgIG5zX2F0dGFja3NbY2huXVswXSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnZmMubnNQc3kubGFzdEF0dGFja3NbY2huXSA9PSAzXG4gICAgICAgICAgICAgICAgfHwgKG5zX2F0dGFja3NbY2huXVswXSArIG5zX2F0dGFja3NbY2huXVsxXVxuICAgICAgICAgICAgICAgICsgbnNfYXR0YWNrc1tjaG5dWzJdICsgbnNfYXR0YWNrc1tjaG5dWzNdKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgbnNfdXNlbG9uZ2Jsb2NrID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChuc19hdHRhY2tzW2Nobl1bMV0gIT0gMCAmJiBuc19hdHRhY2tzW2Nobl1bMF0gIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBuc19hdHRhY2tzW2Nobl1bMV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobnNfYXR0YWNrc1tjaG5dWzJdICE9IDAgJiYgbnNfYXR0YWNrc1tjaG5dWzFdICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbnNfYXR0YWNrc1tjaG5dWzJdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5zX2F0dGFja3NbY2huXVszXSAhPSAwICYmIG5zX2F0dGFja3NbY2huXVsyXSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5zX2F0dGFja3NbY2huXVszXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNobiA8IDIpIHtcbiAgICAgICAgICAgICAgICB1c2Vsb25nYmxvY2tbY2huXSA9IG5zX3VzZWxvbmdibG9jaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5zX3VzZWxvbmdibG9jayA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZWxvbmdibG9ja1swXSA9IHVzZWxvbmdibG9ja1sxXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogdGhlcmUgaXMgYSBvbmUgZ3JhbnVsZSBkZWxheS4gQ29weSBtYXNraW5ncyBjb21wdXRlZCBsYXN0IGNhbGxcbiAgICAgICAgICAgICAqIGludG8gbWFza2luZ19yYXRpbyB0byByZXR1cm4gdG8gY2FsbGluZyBwcm9ncmFtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbmVyZ3lbY2huXSA9IGdmYy50b3RfZW5lcltjaG5dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmJycHN5X3NraXBfbWFza2luZ19zKGdmYywgY2huLCBzYmxvY2spIHtcbiAgICAgICAgaWYgKHNibG9jayA9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGdmYy5ucGFydF9zOyBiKyspIHtcbiAgICAgICAgICAgICAgICBnZmMubmJfczJbY2huXVtiXSA9IGdmYy5uYl9zMVtjaG5dW2JdO1xuICAgICAgICAgICAgICAgIGdmYy5uYl9zMVtjaG5dW2JdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZicnBzeV9za2lwX21hc2tpbmdfbChnZmMsIGNobikge1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGdmYy5ucGFydF9sOyBiKyspIHtcbiAgICAgICAgICAgIGdmYy5uYl8yW2Nobl1bYl0gPSBnZmMubmJfMVtjaG5dW2JdO1xuICAgICAgICAgICAgZ2ZjLm5iXzFbY2huXVtiXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwc3l2YnJfY2FsY19tYXNrX2luZGV4X3MoZ2ZjLCBtYXgsIGF2ZywgbWFza19pZHgpIHtcbiAgICAgICAgdmFyIGxhc3RfdGFiX2VudHJ5ID0gdGFiLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBiID0gMDtcbiAgICAgICAgdmFyIGEgPSBhdmdbYl0gKyBhdmdbYiArIDFdO1xuICAgICAgICBhc3NlcnQkMyhhID49IDApO1xuICAgICAgICBpZiAoYSA+IDAuMCkge1xuICAgICAgICAgICAgdmFyIG0gPSBtYXhbYl07XG4gICAgICAgICAgICBpZiAobSA8IG1heFtiICsgMV0pXG4gICAgICAgICAgICAgICAgbSA9IG1heFtiICsgMV07XG4gICAgICAgICAgICBhc3NlcnQkMygoZ2ZjLm51bWxpbmVzX3NbYl0gKyBnZmMubnVtbGluZXNfc1tiICsgMV0gLSAxKSA+IDApO1xuICAgICAgICAgICAgYSA9IDIwLjAgKiAobSAqIDIuMCAtIGEpXG4gICAgICAgICAgICAgICAgLyAoYSAqIChnZmMubnVtbGluZXNfc1tiXSArIGdmYy5udW1saW5lc19zW2IgKyAxXSAtIDEpKTtcbiAgICAgICAgICAgIHZhciBrID0gMCB8IGE7XG4gICAgICAgICAgICBpZiAoayA+IGxhc3RfdGFiX2VudHJ5KVxuICAgICAgICAgICAgICAgIGsgPSBsYXN0X3RhYl9lbnRyeTtcbiAgICAgICAgICAgIG1hc2tfaWR4W2JdID0gaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hc2tfaWR4W2JdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoYiA9IDE7IGIgPCBnZmMubnBhcnRfcyAtIDE7IGIrKykge1xuICAgICAgICAgICAgYSA9IGF2Z1tiIC0gMV0gKyBhdmdbYl0gKyBhdmdbYiArIDFdO1xuICAgICAgICAgICAgYXNzZXJ0JDMoYiArIDEgPCBnZmMubnBhcnRfcyk7XG4gICAgICAgICAgICBhc3NlcnQkMyhhID49IDApO1xuICAgICAgICAgICAgaWYgKGEgPiAwLjApIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IG1heFtiIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKG0gPCBtYXhbYl0pXG4gICAgICAgICAgICAgICAgICAgIG0gPSBtYXhbYl07XG4gICAgICAgICAgICAgICAgaWYgKG0gPCBtYXhbYiArIDFdKVxuICAgICAgICAgICAgICAgICAgICBtID0gbWF4W2IgKyAxXTtcbiAgICAgICAgICAgICAgICBhc3NlcnQkMygoZ2ZjLm51bWxpbmVzX3NbYiAtIDFdICsgZ2ZjLm51bWxpbmVzX3NbYl0gKyBnZmMubnVtbGluZXNfc1tiICsgMV0gLSAxKSA+IDApO1xuICAgICAgICAgICAgICAgIGEgPSAyMC4wXG4gICAgICAgICAgICAgICAgICAgICogKG0gKiAzLjAgLSBhKVxuICAgICAgICAgICAgICAgICAgICAvIChhICogKGdmYy5udW1saW5lc19zW2IgLSAxXSArIGdmYy5udW1saW5lc19zW2JdXG4gICAgICAgICAgICAgICAgICAgICsgZ2ZjLm51bWxpbmVzX3NbYiArIDFdIC0gMSkpO1xuICAgICAgICAgICAgICAgIHZhciBrID0gMCB8IGE7XG4gICAgICAgICAgICAgICAgaWYgKGsgPiBsYXN0X3RhYl9lbnRyeSlcbiAgICAgICAgICAgICAgICAgICAgayA9IGxhc3RfdGFiX2VudHJ5O1xuICAgICAgICAgICAgICAgIG1hc2tfaWR4W2JdID0gaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFza19pZHhbYl0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydCQzKGIgPiAwKTtcbiAgICAgICAgYXNzZXJ0JDMoYiA9PSBnZmMubnBhcnRfcyAtIDEpO1xuXG4gICAgICAgIGEgPSBhdmdbYiAtIDFdICsgYXZnW2JdO1xuICAgICAgICBhc3NlcnQkMyhhID49IDApO1xuICAgICAgICBpZiAoYSA+IDAuMCkge1xuICAgICAgICAgICAgdmFyIG0gPSBtYXhbYiAtIDFdO1xuICAgICAgICAgICAgaWYgKG0gPCBtYXhbYl0pXG4gICAgICAgICAgICAgICAgbSA9IG1heFtiXTtcbiAgICAgICAgICAgIGFzc2VydCQzKChnZmMubnVtbGluZXNfc1tiIC0gMV0gKyBnZmMubnVtbGluZXNfc1tiXSAtIDEpID4gMCk7XG4gICAgICAgICAgICBhID0gMjAuMCAqIChtICogMi4wIC0gYSlcbiAgICAgICAgICAgICAgICAvIChhICogKGdmYy5udW1saW5lc19zW2IgLSAxXSArIGdmYy5udW1saW5lc19zW2JdIC0gMSkpO1xuICAgICAgICAgICAgdmFyIGsgPSAwIHwgYTtcbiAgICAgICAgICAgIGlmIChrID4gbGFzdF90YWJfZW50cnkpXG4gICAgICAgICAgICAgICAgayA9IGxhc3RfdGFiX2VudHJ5O1xuICAgICAgICAgICAgbWFza19pZHhbYl0gPSBrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFza19pZHhbYl0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCQzKGIgPT0gKGdmYy5ucGFydF9zIC0gMSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZicnBzeV9jb21wdXRlX21hc2tpbmdfcyhnZnAsIGZmdGVuZXJneV9zLCBlYiwgdGhyLCBjaG4sIHNibG9jaykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgbWF4ID0gbmV3IGZsb2F0W0VuY29kZXJfMS5DQkFORFNdLCBhdmcgPSBuZXdfZmxvYXQkMyhFbmNvZGVyXzEuQ0JBTkRTKTtcbiAgICAgICAgdmFyIGksIGosIGI7XG4gICAgICAgIHZhciBtYXNrX2lkeF9zID0gbmV3IGludFtFbmNvZGVyXzEuQ0JBTkRTXTtcblxuICAgICAgICBmb3IgKGIgPSBqID0gMDsgYiA8IGdmYy5ucGFydF9zOyArK2IpIHtcbiAgICAgICAgICAgIHZhciBlYmIgPSAwLCBtID0gMDtcbiAgICAgICAgICAgIHZhciBuID0gZ2ZjLm51bWxpbmVzX3NbYl07XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpLCArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBmZnRlbmVyZ3lfc1tzYmxvY2tdW2pdO1xuICAgICAgICAgICAgICAgIGViYiArPSBlbDtcbiAgICAgICAgICAgICAgICBpZiAobSA8IGVsKVxuICAgICAgICAgICAgICAgICAgICBtID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlYltiXSA9IGViYjtcbiAgICAgICAgICAgIGFzc2VydCQzKGViYiA+PSAwKTtcbiAgICAgICAgICAgIG1heFtiXSA9IG07XG4gICAgICAgICAgICBhc3NlcnQkMyhuID4gMCk7XG4gICAgICAgICAgICBhdmdbYl0gPSBlYmIgLyBuO1xuICAgICAgICAgICAgYXNzZXJ0JDMoYXZnW2JdID49IDApO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCQzKGIgPT0gZ2ZjLm5wYXJ0X3MpO1xuICAgICAgICBhc3NlcnQkMyhqID09IDEyOSk7XG4gICAgICAgIGZvciAoOyBiIDwgRW5jb2Rlcl8xLkNCQU5EUzsgKytiKSB7XG4gICAgICAgICAgICBtYXhbYl0gPSAwO1xuICAgICAgICAgICAgYXZnW2JdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwc3l2YnJfY2FsY19tYXNrX2luZGV4X3MoZ2ZjLCBtYXgsIGF2ZywgbWFza19pZHhfcyk7XG4gICAgICAgIGZvciAoaiA9IGIgPSAwOyBiIDwgZ2ZjLm5wYXJ0X3M7IGIrKykge1xuICAgICAgICAgICAgdmFyIGtrID0gZ2ZjLnMzaW5kX3NbYl1bMF07XG4gICAgICAgICAgICB2YXIgbGFzdCA9IGdmYy5zM2luZF9zW2JdWzFdO1xuICAgICAgICAgICAgdmFyIGRkLCBkZF9uO1xuICAgICAgICAgICAgdmFyIHgsIGVjYiwgYXZnX21hc2s7XG4gICAgICAgICAgICBkZCA9IG1hc2tfaWR4X3Nba2tdO1xuICAgICAgICAgICAgZGRfbiA9IDE7XG4gICAgICAgICAgICBlY2IgPSBnZmMuczNfc3Nbal0gKiBlYltra10gKiB0YWJbbWFza19pZHhfc1tra11dO1xuICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgKytraztcbiAgICAgICAgICAgIHdoaWxlIChrayA8PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgZGQgKz0gbWFza19pZHhfc1tra107XG4gICAgICAgICAgICAgICAgZGRfbiArPSAxO1xuICAgICAgICAgICAgICAgIHggPSBnZmMuczNfc3Nbal0gKiBlYltra10gKiB0YWJbbWFza19pZHhfc1tra11dO1xuICAgICAgICAgICAgICAgIGVjYiA9IHZicnBzeV9tYXNrX2FkZChlY2IsIHgsIGtrIC0gYik7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICAgICsra2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZCA9ICgxICsgMiAqIGRkKSAvICgyICogZGRfbik7XG4gICAgICAgICAgICBhdmdfbWFzayA9IHRhYltkZF0gKiAwLjU7XG4gICAgICAgICAgICBlY2IgKj0gYXZnX21hc2s7XG4gICAgICAgICAgICB0aHJbYl0gPSBlY2I7XG4gICAgICAgICAgICBnZmMubmJfczJbY2huXVtiXSA9IGdmYy5uYl9zMVtjaG5dW2JdO1xuICAgICAgICAgICAgZ2ZjLm5iX3MxW2Nobl1bYl0gPSBlY2I7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBpZiBUSFIgZXhjZWVkcyBFQiwgdGhlIHF1YW50aXphdGlvbiByb3V0aW5lcyB3aWxsIHRha2UgdGhlXG4gICAgICAgICAgICAgICAgICogZGlmZmVyZW5jZSBmcm9tIG90aGVyIGJhbmRzLiBpbiBjYXNlIG9mIHN0cm9uZyB0b25hbCBzYW1wbGVzXG4gICAgICAgICAgICAgICAgICogKHRvbmFsdGVzdC53YXYpIHRoaXMgbGVhZHMgdG8gaGVhdnkgZGlzdG9ydGlvbnMuIHRoYXQncyB3aHlcbiAgICAgICAgICAgICAgICAgKiB3ZSBsaW1pdCBUSFIgaGVyZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB4ID0gbWF4W2JdO1xuICAgICAgICAgICAgICAgIHggKj0gZ2ZjLm1pbnZhbF9zW2JdO1xuICAgICAgICAgICAgICAgIHggKj0gYXZnX21hc2s7XG4gICAgICAgICAgICAgICAgaWYgKHRocltiXSA+IHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyW2JdID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2ZjLm1hc2tpbmdfbG93ZXIgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyW2JdICo9IGdmYy5tYXNraW5nX2xvd2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRocltiXSA+IGViW2JdKSB7XG4gICAgICAgICAgICAgICAgdGhyW2JdID0gZWJbYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2ZjLm1hc2tpbmdfbG93ZXIgPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhyW2JdICo9IGdmYy5tYXNraW5nX2xvd2VyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3NlcnQkMyh0aHJbYl0gPj0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGIgPCBFbmNvZGVyXzEuQ0JBTkRTOyArK2IpIHtcbiAgICAgICAgICAgIGViW2JdID0gMDtcbiAgICAgICAgICAgIHRocltiXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YnJwc3lfY29tcHV0ZV9tYXNraW5nX2woZ2ZjLCBmZnRlbmVyZ3ksIGViX2wsIHRociwgY2huKSB7XG4gICAgICAgIHZhciBtYXggPSBuZXdfZmxvYXQkMyhFbmNvZGVyXzEuQ0JBTkRTKSwgYXZnID0gbmV3X2Zsb2F0JDMoRW5jb2Rlcl8xLkNCQU5EUyk7XG4gICAgICAgIHZhciBtYXNrX2lkeF9sID0gbmV3X2ludCQzKEVuY29kZXJfMS5DQkFORFMgKyAyKTtcbiAgICAgICAgdmFyIGI7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIGVuZXJneSBhbmQgdGhlIHRvbmFsaXR5IG9mIGVhY2ggcGFydGl0aW9uLlxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBjYWxjX2VuZXJneShnZmMsIGZmdGVuZXJneSwgZWJfbCwgbWF4LCBhdmcpO1xuICAgICAgICBjYWxjX21hc2tfaW5kZXhfbChnZmMsIG1heCwgYXZnLCBtYXNrX2lkeF9sKTtcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIGNvbnZvbHZlIHRoZSBwYXJ0aXRpb25lZCBlbmVyZ3kgYW5kIHVucHJlZGljdGFiaWxpdHkgd2l0aCB0aGVcbiAgICAgICAgICogc3ByZWFkaW5nIGZ1bmN0aW9uLCBzM19sW2JdW2tdXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICBmb3IgKGIgPSAwOyBiIDwgZ2ZjLm5wYXJ0X2w7IGIrKykge1xuICAgICAgICAgICAgdmFyIHgsIGVjYiwgYXZnX21hc2ssIHQ7XG4gICAgICAgICAgICAvKiBjb252b2x2ZSB0aGUgcGFydGl0aW9uZWQgZW5lcmd5IHdpdGggdGhlIHNwcmVhZGluZyBmdW5jdGlvbiAqL1xuICAgICAgICAgICAgdmFyIGtrID0gZ2ZjLnMzaW5kW2JdWzBdO1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBnZmMuczNpbmRbYl1bMV07XG4gICAgICAgICAgICB2YXIgZGQgPSAwLCBkZF9uID0gMDtcbiAgICAgICAgICAgIGRkID0gbWFza19pZHhfbFtra107XG4gICAgICAgICAgICBkZF9uICs9IDE7XG4gICAgICAgICAgICBlY2IgPSBnZmMuczNfbGxba10gKiBlYl9sW2trXSAqIHRhYlttYXNrX2lkeF9sW2trXV07XG4gICAgICAgICAgICArK2s7XG4gICAgICAgICAgICArK2trO1xuICAgICAgICAgICAgd2hpbGUgKGtrIDw9IGxhc3QpIHtcbiAgICAgICAgICAgICAgICBkZCArPSBtYXNrX2lkeF9sW2trXTtcbiAgICAgICAgICAgICAgICBkZF9uICs9IDE7XG4gICAgICAgICAgICAgICAgeCA9IGdmYy5zM19sbFtrXSAqIGViX2xba2tdICogdGFiW21hc2tfaWR4X2xba2tdXTtcbiAgICAgICAgICAgICAgICB0ID0gdmJycHN5X21hc2tfYWRkKGVjYiwgeCwga2sgLSBiKTtcbiAgICAgICAgICAgICAgICBlY2IgPSB0O1xuICAgICAgICAgICAgICAgICsraztcbiAgICAgICAgICAgICAgICArK2trO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGQgPSAoMSArIDIgKiBkZCkgLyAoMiAqIGRkX24pO1xuICAgICAgICAgICAgYXZnX21hc2sgPSB0YWJbZGRdICogMC41O1xuICAgICAgICAgICAgZWNiICo9IGF2Z19tYXNrO1xuXG4gICAgICAgICAgICAvKioqKiBsb25nIGJsb2NrIHByZS1lY2hvIGNvbnRyb2wgKioqKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogPFBSRT5cbiAgICAgICAgICAgICAqIGRvbnQgdXNlIGxvbmcgYmxvY2sgcHJlLWVjaG8gY29udHJvbCBpZiBwcmV2aW91cyBncmFudWxlIHdhc1xuICAgICAgICAgICAgICogYSBzaG9ydCBibG9jay4gIFRoaXMgaXMgdG8gYXZvaWQgdGhlIHNpdHVhdGlvbjpcbiAgICAgICAgICAgICAqIGZyYW1lMDogIHF1aWV0ICh2ZXJ5IGxvdyBtYXNraW5nKVxuICAgICAgICAgICAgICogZnJhbWUxOiAgc3VyZ2UgICh0cmlnZ2VycyBzaG9ydCBibG9ja3MpXG4gICAgICAgICAgICAgKiBmcmFtZTI6ICByZWd1bGFyIGZyYW1lLiAgbG9va3MgbGlrZSBwcmUtZWNobyB3aGVuIGNvbXBhcmVkIHRvXG4gICAgICAgICAgICAgKiAgICAgICAgICBmcmFtZTAsIGJ1dCBhbGwgcHJlLWVjaG8gd2FzIGluIGZyYW1lMS5cbiAgICAgICAgICAgICAqIDwvUFJFPlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogY2huPTAsMSBMIGFuZCBSIGNoYW5uZWxzIGNobj0yLDMgUyBhbmQgTSBjaGFubmVscy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGdmYy5ibG9ja3R5cGVfb2xkW2NobiAmIDB4MDFdID09IEVuY29kZXJfMS5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVjYl9saW1pdCA9IHJwZWxldiAqIGdmYy5uYl8xW2Nobl1bYl07XG4gICAgICAgICAgICAgICAgaWYgKGVjYl9saW1pdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyW2JdID0gTWF0aC5taW4oZWNiLCBlY2JfbGltaXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiA8UFJFPlxuICAgICAgICAgICAgICAgICAgICAgKiBSb2JlcnQgMDcxMjA5OlxuICAgICAgICAgICAgICAgICAgICAgKiBCZWNhdXNlIHdlIGRvbid0IGNhbGN1bGF0ZSBsb25nIGJsb2NrIHBzeSB3aGVuIHdlIGtub3cgYSBncmFudWxlXG4gICAgICAgICAgICAgICAgICAgICAqIHNob3VsZCBiZSBvZiBzaG9ydCBibG9ja3MsIHdlIGRvbid0IGhhdmUgYW55IGNsdWUgaG93IHRoZSBncmFudWxlXG4gICAgICAgICAgICAgICAgICAgICAqIGJlZm9yZSB3b3VsZCBoYXZlIGxvb2tlZCBsaWtlIGFzIGEgbG9uZyBibG9jay4gU28gd2UgaGF2ZSB0byBndWVzc1xuICAgICAgICAgICAgICAgICAgICAgKiBhIGxpdHRsZSBiaXQgZm9yIHRoaXMgRU5EX1RZUEUgYmxvY2suXG4gICAgICAgICAgICAgICAgICAgICAqIE1vc3Qgb2YgdGhlIHRpbWUgd2UgZ2V0IGF3YXkgd2l0aCB0aGlzIHNsb3BweW5lc3MuIChmaW5nZXJzIGNyb3NzZWQgOilcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIHNwZWVkIGluY3JlYXNlIGlzIHdvcnRoIGl0LlxuICAgICAgICAgICAgICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRocltiXSA9IE1hdGgubWluKGVjYiwgZWJfbFtiXSAqIE5TX1BSRUVDSE9fQVRUMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZWNiX2xpbWl0XzIgPSBycGVsZXYyICogZ2ZjLm5iXzJbY2huXVtiXTtcbiAgICAgICAgICAgICAgICB2YXIgZWNiX2xpbWl0XzEgPSBycGVsZXYgKiBnZmMubmJfMVtjaG5dW2JdO1xuICAgICAgICAgICAgICAgIHZhciBlY2JfbGltaXQ7XG4gICAgICAgICAgICAgICAgaWYgKGVjYl9saW1pdF8yIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZWNiX2xpbWl0XzIgPSBlY2I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlY2JfbGltaXRfMSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVjYl9saW1pdF8xID0gZWNiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLmJsb2NrdHlwZV9vbGRbY2huICYgMHgwMV0gPT0gRW5jb2Rlcl8xLk5PUk1fVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICBlY2JfbGltaXQgPSBNYXRoLm1pbihlY2JfbGltaXRfMSwgZWNiX2xpbWl0XzIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVjYl9saW1pdCA9IGVjYl9saW1pdF8xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJbYl0gPSBNYXRoLm1pbihlY2IsIGVjYl9saW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZmMubmJfMltjaG5dW2JdID0gZ2ZjLm5iXzFbY2huXVtiXTtcbiAgICAgICAgICAgIGdmYy5uYl8xW2Nobl1bYl0gPSBlY2I7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBpZiBUSFIgZXhjZWVkcyBFQiwgdGhlIHF1YW50aXphdGlvbiByb3V0aW5lcyB3aWxsIHRha2UgdGhlXG4gICAgICAgICAgICAgICAgICogZGlmZmVyZW5jZSBmcm9tIG90aGVyIGJhbmRzLiBpbiBjYXNlIG9mIHN0cm9uZyB0b25hbCBzYW1wbGVzXG4gICAgICAgICAgICAgICAgICogKHRvbmFsdGVzdC53YXYpIHRoaXMgbGVhZHMgdG8gaGVhdnkgZGlzdG9ydGlvbnMuIHRoYXQncyB3aHlcbiAgICAgICAgICAgICAgICAgKiB3ZSBsaW1pdCBUSFIgaGVyZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB4ID0gbWF4W2JdO1xuICAgICAgICAgICAgICAgIHggKj0gZ2ZjLm1pbnZhbF9sW2JdO1xuICAgICAgICAgICAgICAgIHggKj0gYXZnX21hc2s7XG4gICAgICAgICAgICAgICAgaWYgKHRocltiXSA+IHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyW2JdID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2ZjLm1hc2tpbmdfbG93ZXIgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyW2JdICo9IGdmYy5tYXNraW5nX2xvd2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRocltiXSA+IGViX2xbYl0pIHtcbiAgICAgICAgICAgICAgICB0aHJbYl0gPSBlYl9sW2JdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdmYy5tYXNraW5nX2xvd2VyIDwgMSkge1xuICAgICAgICAgICAgICAgIHRocltiXSAqPSBnZmMubWFza2luZ19sb3dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydCQzKHRocltiXSA+PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgYiA8IEVuY29kZXJfMS5DQkFORFM7ICsrYikge1xuICAgICAgICAgICAgZWJfbFtiXSA9IDA7XG4gICAgICAgICAgICB0aHJbYl0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmJycHN5X2NvbXB1dGVfYmxvY2tfdHlwZShnZnAsIHVzZWxvbmdibG9jaykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXG4gICAgICAgIGlmIChnZnAuc2hvcnRfYmxvY2tzID09IFNob3J0QmxvY2skMy5zaG9ydF9ibG9ja19jb3VwbGVkXG4gICAgICAgICAgICAgICAgLyogZm9yY2UgYm90aCBjaGFubmVscyB0byB1c2UgdGhlIHNhbWUgYmxvY2sgdHlwZSAqL1xuICAgICAgICAgICAgICAgIC8qIHRoaXMgaXMgbmVjZXNzYXJ5IGlmIHRoZSBmcmFtZSBpcyB0byBiZSBlbmNvZGVkIGluIG1zX3N0ZXJlby4gKi9cbiAgICAgICAgICAgICAgICAvKiBCdXQgZXZlbiB3aXRob3V0IG1zX3N0ZXJlbywgRmhHIGRvZXMgdGhpcyAqL1xuICAgICAgICAgICAgJiYgISh1c2Vsb25nYmxvY2tbMF0gIT0gMCAmJiB1c2Vsb25nYmxvY2tbMV0gIT0gMCkpXG4gICAgICAgICAgICB1c2Vsb25nYmxvY2tbMF0gPSB1c2Vsb25nYmxvY2tbMV0gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGNobiA9IDA7IGNobiA8IGdmYy5jaGFubmVsc19vdXQ7IGNobisrKSB7XG4gICAgICAgICAgICAvKiBkaXNhYmxlIHNob3J0IGJsb2NrcyAqL1xuICAgICAgICAgICAgaWYgKGdmcC5zaG9ydF9ibG9ja3MgPT0gU2hvcnRCbG9jayQzLnNob3J0X2Jsb2NrX2Rpc3BlbnNlZCkge1xuICAgICAgICAgICAgICAgIHVzZWxvbmdibG9ja1tjaG5dID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZnAuc2hvcnRfYmxvY2tzID09IFNob3J0QmxvY2skMy5zaG9ydF9ibG9ja19mb3JjZWQpIHtcbiAgICAgICAgICAgICAgICB1c2Vsb25nYmxvY2tbY2huXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YnJwc3lfYXBwbHlfYmxvY2tfdHlwZShnZnAsIHVzZWxvbmdibG9jaywgYmxvY2t0eXBlX2QpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblxuICAgICAgICAvKlxuICAgICAgICAgKiB1cGRhdGUgdGhlIGJsb2NrdHlwZSBvZiB0aGUgcHJldmlvdXMgZ3JhbnVsZSwgc2luY2UgaXQgZGVwZW5kcyBvblxuICAgICAgICAgKiB3aGF0IGhhcHBlbmQgaW4gdGhpcyBncmFudWxlXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKHZhciBjaG4gPSAwOyBjaG4gPCBnZmMuY2hhbm5lbHNfb3V0OyBjaG4rKykge1xuICAgICAgICAgICAgdmFyIGJsb2NrdHlwZSA9IEVuY29kZXJfMS5OT1JNX1RZUEU7XG4gICAgICAgICAgICAvKiBkaXNhYmxlIHNob3J0IGJsb2NrcyAqL1xuXG4gICAgICAgICAgICBpZiAodXNlbG9uZ2Jsb2NrW2Nobl0gIT0gMCkge1xuICAgICAgICAgICAgICAgIC8qIG5vIGF0dGFjayA6IHVzZSBsb25nIGJsb2NrcyAqL1xuICAgICAgICAgICAgICAgIGFzc2VydCQzKGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gIT0gRW5jb2Rlcl8xLlNUQVJUX1RZUEUpO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuYmxvY2t0eXBlX29sZFtjaG5dID09IEVuY29kZXJfMS5TSE9SVF9UWVBFKVxuICAgICAgICAgICAgICAgICAgICBibG9ja3R5cGUgPSBFbmNvZGVyXzEuU1RPUF9UWVBFO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBhdHRhY2sgOiB1c2Ugc2hvcnQgYmxvY2tzICovXG4gICAgICAgICAgICAgICAgYmxvY2t0eXBlID0gRW5jb2Rlcl8xLlNIT1JUX1RZUEU7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gPT0gRW5jb2Rlcl8xLk5PUk1fVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICBnZmMuYmxvY2t0eXBlX29sZFtjaG5dID0gRW5jb2Rlcl8xLlNUQVJUX1RZUEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZmMuYmxvY2t0eXBlX29sZFtjaG5dID09IEVuY29kZXJfMS5TVE9QX1RZUEUpXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gPSBFbmNvZGVyXzEuU0hPUlRfVFlQRTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmxvY2t0eXBlX2RbY2huXSA9IGdmYy5ibG9ja3R5cGVfb2xkW2Nobl07XG4gICAgICAgICAgICAvLyB2YWx1ZSByZXR1cm5lZCB0byBjYWxsaW5nIHByb2dyYW1cbiAgICAgICAgICAgIGdmYy5ibG9ja3R5cGVfb2xkW2Nobl0gPSBibG9ja3R5cGU7XG4gICAgICAgICAgICAvLyBzYXZlIGZvciBuZXh0IGNhbGwgdG8gbDNwc3lfYW5hbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSBNL1MgdGhyZXNob2xkcyBmcm9tIEpvaG5zdG9uICYgRmVycmVpcmEgMTk5MiBJQ0FTU1AgcGFwZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YnJwc3lfY29tcHV0ZV9NU190aHJlc2hvbGRzKGViLCB0aHIsIGNiX21sZCwgYXRoX2NiLCBhdGhhZGp1c3QsIG1zZml4LCBuKSB7XG4gICAgICAgIHZhciBtc2ZpeDIgPSBtc2ZpeCAqIDI7XG4gICAgICAgIHZhciBhdGhsb3dlciA9IG1zZml4ID4gMCA/IE1hdGgucG93KDEwLCBhdGhhZGp1c3QpIDogMTtcbiAgICAgICAgdmFyIHJzaWRlLCBybWlkO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IG47ICsrYikge1xuICAgICAgICAgICAgdmFyIGViTSA9IGViWzJdW2JdO1xuICAgICAgICAgICAgdmFyIGViUyA9IGViWzNdW2JdO1xuICAgICAgICAgICAgdmFyIHRobUwgPSB0aHJbMF1bYl07XG4gICAgICAgICAgICB2YXIgdGhtUiA9IHRoclsxXVtiXTtcbiAgICAgICAgICAgIHZhciB0aG1NID0gdGhyWzJdW2JdO1xuICAgICAgICAgICAgdmFyIHRobVMgPSB0aHJbM11bYl07XG5cbiAgICAgICAgICAgIC8qIHVzZSB0aGlzIGZpeCBpZiBMICYgUiBtYXNraW5nIGRpZmZlcnMgYnkgMmRiIG9yIGxlc3MgKi9cbiAgICAgICAgICAgIGlmICh0aG1MIDw9IDEuNTggKiB0aG1SICYmIHRobVIgPD0gMS41OCAqIHRobUwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWxkX20gPSBjYl9tbGRbYl0gKiBlYlM7XG4gICAgICAgICAgICAgICAgdmFyIG1sZF9zID0gY2JfbWxkW2JdICogZWJNO1xuICAgICAgICAgICAgICAgIHJtaWQgPSBNYXRoLm1heCh0aG1NLCBNYXRoLm1pbih0aG1TLCBtbGRfbSkpO1xuICAgICAgICAgICAgICAgIHJzaWRlID0gTWF0aC5tYXgodGhtUywgTWF0aC5taW4odGhtTSwgbWxkX3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm1pZCA9IHRobU07XG4gICAgICAgICAgICAgICAgcnNpZGUgPSB0aG1TO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1zZml4ID4gMCkge1xuICAgICAgICAgICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgICAgICAgICAgLyogQWRqdXN0IE0vUyBtYXNraW5ncyBpZiB1c2VyIHNldCBcIm1zZml4XCIgKi9cbiAgICAgICAgICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAgICAgICAgIC8qIE5hb2tpIFNoaWJhdGEgMjAwMCAqL1xuICAgICAgICAgICAgICAgIHZhciB0aG1MUiwgdGhtTVM7XG4gICAgICAgICAgICAgICAgdmFyIGF0aCA9IGF0aF9jYltiXSAqIGF0aGxvd2VyO1xuICAgICAgICAgICAgICAgIHRobUxSID0gTWF0aC5taW4oTWF0aC5tYXgodGhtTCwgYXRoKSwgTWF0aC5tYXgodGhtUiwgYXRoKSk7XG4gICAgICAgICAgICAgICAgdGhtTSA9IE1hdGgubWF4KHJtaWQsIGF0aCk7XG4gICAgICAgICAgICAgICAgdGhtUyA9IE1hdGgubWF4KHJzaWRlLCBhdGgpO1xuICAgICAgICAgICAgICAgIHRobU1TID0gdGhtTSArIHRobVM7XG4gICAgICAgICAgICAgICAgaWYgKHRobU1TID4gMCAmJiAodGhtTFIgKiBtc2ZpeDIpIDwgdGhtTVMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSB0aG1MUiAqIG1zZml4MiAvIHRobU1TO1xuICAgICAgICAgICAgICAgICAgICB0aG1NICo9IGY7XG4gICAgICAgICAgICAgICAgICAgIHRobVMgKj0gZjtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0JDModGhtTVMgPiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm1pZCA9IE1hdGgubWluKHRobU0sIHJtaWQpO1xuICAgICAgICAgICAgICAgIHJzaWRlID0gTWF0aC5taW4odGhtUywgcnNpZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJtaWQgPiBlYk0pIHtcbiAgICAgICAgICAgICAgICBybWlkID0gZWJNO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJzaWRlID4gZWJTKSB7XG4gICAgICAgICAgICAgICAgcnNpZGUgPSBlYlM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJbMl1bYl0gPSBybWlkO1xuICAgICAgICAgICAgdGhyWzNdW2JdID0gcnNpZGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLkwzcHN5Y2hvX2FuYWxfdmJyID0gZnVuY3Rpb24gKGdmcCwgYnVmZmVyLCBidWZQb3MsIGdyX291dCwgbWFza2luZ19yYXRpbywgbWFza2luZ19NU19yYXRpbywgcGVyY2VwX2VudHJvcHksIHBlcmNlcF9NU19lbnRyb3B5LCBlbmVyZ3ksIGJsb2NrdHlwZV9kKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgLyogZmZ0IGFuZCBlbmVyZ3kgY2FsY3VsYXRpb24gKi9cbiAgICAgICAgdmFyIHdzYW1wX2w7XG4gICAgICAgIHZhciB3c2FtcF9zO1xuICAgICAgICB2YXIgZmZ0ZW5lcmd5ID0gbmV3X2Zsb2F0JDMoRW5jb2Rlcl8xLkhCTEtTSVpFKTtcbiAgICAgICAgdmFyIGZmdGVuZXJneV9zID0gbmV3X2Zsb2F0X24kMyhbMywgRW5jb2Rlcl8xLkhCTEtTSVpFX3NdKTtcbiAgICAgICAgdmFyIHdzYW1wX0wgPSBuZXdfZmxvYXRfbiQzKFsyLCBFbmNvZGVyXzEuQkxLU0laRV0pO1xuICAgICAgICB2YXIgd3NhbXBfUyA9IG5ld19mbG9hdF9uJDMoWzIsIDMsIEVuY29kZXJfMS5CTEtTSVpFX3NdKTtcbiAgICAgICAgdmFyIGViID0gbmV3X2Zsb2F0X24kMyhbNCwgRW5jb2Rlcl8xLkNCQU5EU10pLCB0aHIgPSBuZXdfZmxvYXRfbiQzKFs0LCBFbmNvZGVyXzEuQ0JBTkRTXSk7XG4gICAgICAgIHZhciBzdWJfc2hvcnRfZmFjdG9yID0gbmV3X2Zsb2F0X24kMyhbNCwgM10pO1xuICAgICAgICB2YXIgcGNmYWN0ID0gMC42O1xuXG4gICAgICAgIC8qIGJsb2NrIHR5cGUgKi9cbiAgICAgICAgdmFyIG5zX2F0dGFja3MgPSBbWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIFswLCAwLCAwLCAwXV07XG4gICAgICAgIHZhciB1c2Vsb25nYmxvY2sgPSBuZXdfaW50JDMoMik7XG5cbiAgICAgICAgLyogdXN1YWwgdmFyaWFibGVzIGxpa2UgbG9vcCBpbmRpY2VzLCBldGMuLiAqL1xuXG4gICAgICAgIC8qIGNobj0yIGFuZCAzID0gTWlkIGFuZCBTaWRlIGNoYW5uZWxzICovXG4gICAgICAgIHZhciBuX2Nobl9wc3kgPSAoZ2ZwLm1vZGUgPT0gTVBFR01vZGUuSk9JTlRfU1RFUkVPKSA/IDRcbiAgICAgICAgICAgIDogZ2ZjLmNoYW5uZWxzX291dDtcblxuICAgICAgICB2YnJwc3lfYXR0YWNrX2RldGVjdGlvbihnZnAsIGJ1ZmZlciwgYnVmUG9zLCBncl9vdXQsIG1hc2tpbmdfcmF0aW8sXG4gICAgICAgICAgICBtYXNraW5nX01TX3JhdGlvLCBlbmVyZ3ksIHN1Yl9zaG9ydF9mYWN0b3IsIG5zX2F0dGFja3MsXG4gICAgICAgICAgICB1c2Vsb25nYmxvY2spO1xuXG4gICAgICAgIHZicnBzeV9jb21wdXRlX2Jsb2NrX3R5cGUoZ2ZwLCB1c2Vsb25nYmxvY2spO1xuXG4gICAgICAgIC8qIExPTkcgQkxPQ0sgQ0FTRSAqL1xuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBjaG4gPSAwOyBjaG4gPCBuX2Nobl9wc3k7IGNobisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoMDEgPSBjaG4gJiAweDAxO1xuICAgICAgICAgICAgICAgIHdzYW1wX2wgPSB3c2FtcF9MO1xuICAgICAgICAgICAgICAgIHZicnBzeV9jb21wdXRlX2ZmdF9sKGdmcCwgYnVmZmVyLCBidWZQb3MsIGNobiwgZ3Jfb3V0LFxuICAgICAgICAgICAgICAgICAgICBmZnRlbmVyZ3ksIHdzYW1wX2wsIGNoMDEpO1xuXG4gICAgICAgICAgICAgICAgdmJycHN5X2NvbXB1dGVfbG91ZG5lc3NfYXBwcm94aW1hdGlvbl9sKGdmcCwgZ3Jfb3V0LCBjaG4sXG4gICAgICAgICAgICAgICAgICAgIGZmdGVuZXJneSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodXNlbG9uZ2Jsb2NrW2NoMDFdICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmJycHN5X2NvbXB1dGVfbWFza2luZ19sKGdmYywgZmZ0ZW5lcmd5LCBlYltjaG5dLCB0aHJbY2huXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNobik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmJycHN5X3NraXBfbWFza2luZ19sKGdmYywgY2huKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHVzZWxvbmdibG9ja1swXSArIHVzZWxvbmdibG9ja1sxXSkgPT0gMikge1xuICAgICAgICAgICAgICAgIC8qIE0vUyBjaGFubmVsICovXG4gICAgICAgICAgICAgICAgaWYgKGdmcC5tb2RlID09IE1QRUdNb2RlLkpPSU5UX1NURVJFTykge1xuICAgICAgICAgICAgICAgICAgICB2YnJwc3lfY29tcHV0ZV9NU190aHJlc2hvbGRzKGViLCB0aHIsIGdmYy5tbGRfY2JfbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdmYy5BVEguY2JfbCwgZ2ZwLkFUSGxvd2VyICogZ2ZjLkFUSC5hZGp1c3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZnAubXNmaXgsIGdmYy5ucGFydF9sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBUT0RPOiBhcHBseSBhZGFwdGl2ZSBBVEggbWFza2luZyBoZXJlID8/ICovXG4gICAgICAgICAgICBmb3IgKHZhciBjaG4gPSAwOyBjaG4gPCBuX2Nobl9wc3k7IGNobisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoMDEgPSBjaG4gJiAweDAxO1xuICAgICAgICAgICAgICAgIGlmICh1c2Vsb25nYmxvY2tbY2gwMV0gIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0X3BhcnRpdGlvbjJzY2FsZWZhY19sKGdmYywgZWJbY2huXSwgdGhyW2Nobl0sIGNobik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogU0hPUlQgQkxPQ0tTIENBU0UgKi9cbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgc2Jsb2NrID0gMDsgc2Jsb2NrIDwgMzsgc2Jsb2NrKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjaG4gPSAwOyBjaG4gPCBuX2Nobl9wc3k7ICsrY2huKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaDAxID0gY2huICYgMHgwMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodXNlbG9uZ2Jsb2NrW2NoMDFdICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZicnBzeV9za2lwX21hc2tpbmdfcyhnZmMsIGNobiwgc2Jsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbXB1dGUgbWFza2luZyB0aHJlc2hvbGRzIGZvciBzaG9ydCBibG9ja3MgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHdzYW1wX3MgPSB3c2FtcF9TO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmJycHN5X2NvbXB1dGVfZmZ0X3MoZ2ZwLCBidWZmZXIsIGJ1ZlBvcywgY2huLCBzYmxvY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmZ0ZW5lcmd5X3MsIHdzYW1wX3MsIGNoMDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmJycHN5X2NvbXB1dGVfbWFza2luZ19zKGdmcCwgZmZ0ZW5lcmd5X3MsIGViW2Nobl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyW2Nobl0sIGNobiwgc2Jsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHVzZWxvbmdibG9ja1swXSArIHVzZWxvbmdibG9ja1sxXSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBNL1MgY2hhbm5lbCAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2ZwLm1vZGUgPT0gTVBFR01vZGUuSk9JTlRfU1RFUkVPKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YnJwc3lfY29tcHV0ZV9NU190aHJlc2hvbGRzKGViLCB0aHIsIGdmYy5tbGRfY2JfcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZmMuQVRILmNiX3MsIGdmcC5BVEhsb3dlciAqIGdmYy5BVEguYWRqdXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdmcC5tc2ZpeCwgZ2ZjLm5wYXJ0X3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIEwvUiBjaGFubmVsICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIFRPRE86IGFwcGx5IGFkYXB0aXZlIEFUSCBtYXNraW5nIGhlcmUgPz8gKi9cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjaG4gPSAwOyBjaG4gPCBuX2Nobl9wc3k7ICsrY2huKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaDAxID0gY2huICYgMHgwMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT0gdXNlbG9uZ2Jsb2NrW2NoMDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0X3BhcnRpdGlvbjJzY2FsZWZhY19zKGdmYywgZWJbY2huXSwgdGhyW2Nobl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2huLCBzYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKioqKiBzaG9ydCBibG9jayBwcmUtZWNobyBjb250cm9sICoqKiovXG4gICAgICAgICAgICBmb3IgKHZhciBjaG4gPSAwOyBjaG4gPCBuX2Nobl9wc3k7IGNobisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoMDEgPSBjaG4gJiAweDAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKHVzZWxvbmdibG9ja1tjaDAxXSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzYiA9IDA7IHNiIDwgRW5jb2Rlcl8xLlNCTUFYX3M7IHNiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld190aG1tID0gbmV3X2Zsb2F0JDMoMyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHNibG9jayA9IDA7IHNibG9jayA8IDM7IHNibG9jaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhtbSA9IGdmYy50aG1bY2huXS5zW3NiXVtzYmxvY2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhtbSAqPSBOU19QUkVFQ0hPX0FUVDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuc19hdHRhY2tzW2Nobl1bc2Jsb2NrXSA+PSAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgbnNfYXR0YWNrc1tjaG5dW3NibG9jayArIDFdID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gKHNibG9jayAhPSAwKSA/IHNibG9jayAtIDEgOiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gTlNfSU5URVJQKGdmYy50aG1bY2huXS5zW3NiXVtpZHhdLCB0aG1tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOU19QUkVFQ0hPX0FUVDEgKiBwY2ZhY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRobW0gPSBNYXRoLm1pbih0aG1tLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnNfYXR0YWNrc1tjaG5dW3NibG9ja10gPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAoc2Jsb2NrICE9IDApID8gc2Jsb2NrIC0gMSA6IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBOU19JTlRFUlAoZ2ZjLnRobVtjaG5dLnNbc2JdW2lkeF0sIHRobW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5TX1BSRUVDSE9fQVRUMiAqIHBjZmFjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhtbSA9IE1hdGgubWluKHRobW0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoc2Jsb2NrICE9IDAgJiYgbnNfYXR0YWNrc1tjaG5dW3NibG9jayAtIDFdID09IDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHNibG9jayA9PSAwICYmIGdmYy5uc1BzeS5sYXN0QXR0YWNrc1tjaG5dID09IDMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IChzYmxvY2sgIT0gMikgPyBzYmxvY2sgKyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IE5TX0lOVEVSUChnZmMudGhtW2Nobl0uc1tzYl1baWR4XSwgdGhtbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTlNfUFJFRUNIT19BVFQyICogcGNmYWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aG1tID0gTWF0aC5taW4odGhtbSwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIHB1bHNlIGxpa2Ugc2lnbmFsIGRldGVjdGlvbiBmb3IgZmF0Ym95LndhdiBhbmQgc28gb24gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRobW0gKj0gc3ViX3Nob3J0X2ZhY3RvcltjaG5dW3NibG9ja107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld190aG1tW3NibG9ja10gPSB0aG1tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHNibG9jayA9IDA7IHNibG9jayA8IDM7IHNibG9jaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZmMudGhtW2Nobl0uc1tzYl1bc2Jsb2NrXSA9IG5ld190aG1tW3NibG9ja107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgY2huID0gMDsgY2huIDwgbl9jaG5fcHN5OyBjaG4rKykge1xuICAgICAgICAgICAgZ2ZjLm5zUHN5Lmxhc3RBdHRhY2tzW2Nobl0gPSBuc19hdHRhY2tzW2Nobl1bMl07XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIGRldGVybWluZSBmaW5hbCBibG9jayB0eXBlXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIHZicnBzeV9hcHBseV9ibG9ja190eXBlKGdmcCwgdXNlbG9uZ2Jsb2NrLCBibG9ja3R5cGVfZCk7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBvZiBQRSB0byByZXR1cm4gLi4uIG5vIGRlbGF5IGFuZCBhZHZhbmNlXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGZvciAodmFyIGNobiA9IDA7IGNobiA8IG5fY2huX3BzeTsgY2huKyspIHtcbiAgICAgICAgICAgIHZhciBwcGU7XG4gICAgICAgICAgICB2YXIgcHBlUG9zO1xuICAgICAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgICAgICB2YXIgbXI7XG5cbiAgICAgICAgICAgIGlmIChjaG4gPiAxKSB7XG4gICAgICAgICAgICAgICAgcHBlID0gcGVyY2VwX01TX2VudHJvcHk7XG4gICAgICAgICAgICAgICAgcHBlUG9zID0gLTI7XG4gICAgICAgICAgICAgICAgdHlwZSA9IEVuY29kZXJfMS5OT1JNX1RZUEU7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrdHlwZV9kWzBdID09IEVuY29kZXJfMS5TSE9SVF9UWVBFXG4gICAgICAgICAgICAgICAgICAgIHx8IGJsb2NrdHlwZV9kWzFdID09IEVuY29kZXJfMS5TSE9SVF9UWVBFKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gRW5jb2Rlcl8xLlNIT1JUX1RZUEU7XG4gICAgICAgICAgICAgICAgbXIgPSBtYXNraW5nX01TX3JhdGlvW2dyX291dF1bY2huIC0gMl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBwZSA9IHBlcmNlcF9lbnRyb3B5O1xuICAgICAgICAgICAgICAgIHBwZVBvcyA9IDA7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGJsb2NrdHlwZV9kW2Nobl07XG4gICAgICAgICAgICAgICAgbXIgPSBtYXNraW5nX3JhdGlvW2dyX291dF1bY2huXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gRW5jb2Rlcl8xLlNIT1JUX1RZUEUpIHtcbiAgICAgICAgICAgICAgICBwcGVbcHBlUG9zICsgY2huXSA9IHBlY2FsY19zKG1yLCBnZmMubWFza2luZ19sb3dlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBwZVtwcGVQb3MgKyBjaG5dID0gcGVjYWxjX2wobXIsIGdmYy5tYXNraW5nX2xvd2VyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdmcC5hbmFseXNpcykge1xuICAgICAgICAgICAgICAgIGdmYy5waW5mby5wZVtncl9vdXRdW2Nobl0gPSBwcGVbcHBlUG9zICsgY2huXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gczNfZnVuY194KGJhcmssIGhmX3Nsb3BlKSB7XG4gICAgICAgIHZhciB0ZW1weCA9IGJhcmssIHRlbXB5O1xuXG4gICAgICAgIGlmICh0ZW1weCA+PSAwKSB7XG4gICAgICAgICAgICB0ZW1weSA9IC10ZW1weCAqIDI3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcHkgPSB0ZW1weCAqIGhmX3Nsb3BlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZW1weSA8PSAtNzIuMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGguZXhwKHRlbXB5ICogTE5fVE9fTE9HMTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1fczNfZnVuY194KGhmX3Nsb3BlKSB7XG4gICAgICAgIHZhciBsaW1fYSA9IDAsIGxpbV9iID0gMDtcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHggPSAwLCBsLCBoO1xuICAgICAgICAgICAgZm9yICh4ID0gMDsgczNfZnVuY194KHgsIGhmX3Nsb3BlKSA+IDFlLTIwOyB4IC09IDEpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgbCA9IHg7XG4gICAgICAgICAgICBoID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChNYXRoLmFicyhoIC0gbCkgPiAxZS0xMikge1xuICAgICAgICAgICAgICAgIHggPSAoaCArIGwpIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoczNfZnVuY194KHgsIGhmX3Nsb3BlKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaCA9IHg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbCA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGltX2EgPSBsO1xuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB4ID0gMCwgbCwgaDtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHMzX2Z1bmNfeCh4LCBoZl9zbG9wZSkgPiAxZS0yMDsgeCArPSAxKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGwgPSAwO1xuICAgICAgICAgICAgaCA9IHg7XG4gICAgICAgICAgICB3aGlsZSAoTWF0aC5hYnMoaCAtIGwpID4gMWUtMTIpIHtcbiAgICAgICAgICAgICAgICB4ID0gKGggKyBsKSAvIDI7XG4gICAgICAgICAgICAgICAgaWYgKHMzX2Z1bmNfeCh4LCBoZl9zbG9wZSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGwgPSB4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGggPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbV9iID0gaDtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIHZhciBtID0gMTAwMDtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBtOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGxpbV9hICsgaSAqIChsaW1fYiAtIGxpbV9hKSAvIG07XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBzM19mdW5jX3goeCwgaGZfc2xvcGUpO1xuICAgICAgICAgICAgICAgIHN1bSArPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBub3JtID0gKG0gKyAxKSAvIChzdW0gKiAobGltX2IgLSBsaW1fYSkpO1xuICAgICAgICAgICAgICAgIC8qIHByaW50ZiggXCJub3JtID0gJWxmXFxuXCIsbm9ybSk7ICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgIFRoZSBzcHJlYWRpbmcgZnVuY3Rpb24uICBWYWx1ZXMgcmV0dXJuZWQgaW4gdW5pdHMgb2YgZW5lcmd5XG4gICAgICovXG4gICAgZnVuY3Rpb24gczNfZnVuYyhiYXJrKSB7XG4gICAgICAgIHZhciB0ZW1weCwgeCwgdGVtcHksIHRlbXA7XG4gICAgICAgIHRlbXB4ID0gYmFyaztcbiAgICAgICAgaWYgKHRlbXB4ID49IDApXG4gICAgICAgICAgICB0ZW1weCAqPSAzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ZW1weCAqPSAxLjU7XG5cbiAgICAgICAgaWYgKHRlbXB4ID49IDAuNSAmJiB0ZW1weCA8PSAyLjUpIHtcbiAgICAgICAgICAgIHRlbXAgPSB0ZW1weCAtIDAuNTtcbiAgICAgICAgICAgIHggPSA4LjAgKiAodGVtcCAqIHRlbXAgLSAyLjAgKiB0ZW1wKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB4ID0gMC4wO1xuICAgICAgICB0ZW1weCArPSAwLjQ3NDtcbiAgICAgICAgdGVtcHkgPSAxNS44MTEzODkgKyA3LjUgKiB0ZW1weCAtIDE3LjVcbiAgICAgICAgICAgICogTWF0aC5zcXJ0KDEuMCArIHRlbXB4ICogdGVtcHgpO1xuXG4gICAgICAgIGlmICh0ZW1weSA8PSAtNjAuMClcbiAgICAgICAgICAgIHJldHVybiAwLjA7XG5cbiAgICAgICAgdGVtcHggPSBNYXRoLmV4cCgoeCArIHRlbXB5KSAqIExOX1RPX0xPRzEwKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogPFBSRT5cbiAgICAgICAgICogTm9ybWFsaXphdGlvbi4gIFRoZSBzcHJlYWRpbmcgZnVuY3Rpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWQgc28gdGhhdDpcbiAgICAgICAgICogK2luZlxuICAgICAgICAgKiAvXG4gICAgICAgICAqIHwgIHMzIFsgYmFyayBdICBkKGJhcmspICAgPSAgMVxuICAgICAgICAgKiAvXG4gICAgICAgICAqIC1pbmZcbiAgICAgICAgICogPC9QUkU+XG4gICAgICAgICAqL1xuICAgICAgICB0ZW1weCAvPSAuNjYwOTE5MztcbiAgICAgICAgcmV0dXJuIHRlbXB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNlZSBmb3IgZXhhbXBsZSBcIlp3aWNrZXI6IFBzeWNob2FrdXN0aWssIDE5ODI7IElTQk4gMy01NDAtMTE0MDEtN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyZXEyYmFyayhmcmVxKSB7XG4gICAgICAgIC8qIGlucHV0OiBmcmVxIGluIGh6IG91dHB1dDogYmFya3MgKi9cbiAgICAgICAgaWYgKGZyZXEgPCAwKVxuICAgICAgICAgICAgZnJlcSA9IDA7XG4gICAgICAgIGZyZXEgPSBmcmVxICogMC4wMDE7XG4gICAgICAgIHJldHVybiAxMy4wICogTWF0aC5hdGFuKC43NiAqIGZyZXEpICsgMy41XG4gICAgICAgICAgICAqIE1hdGguYXRhbihmcmVxICogZnJlcSAvICg3LjUgKiA3LjUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0X251bWxpbmUobnVtbGluZXMsIGJvLCBibSwgYnZhbCwgYnZhbF93aWR0aCwgbWxkLCBib193LCBzZnJlcSwgYmxrc2l6ZSwgc2NhbGVwb3MsIGRlbHRhZnJlcSwgc2JtYXgpIHtcbiAgICAgICAgdmFyIGJfZnJxID0gbmV3X2Zsb2F0JDMoRW5jb2Rlcl8xLkNCQU5EUyArIDEpO1xuICAgICAgICB2YXIgc2FtcGxlX2ZyZXFfZnJhYyA9IHNmcmVxIC8gKHNibWF4ID4gMTUgPyAyICogNTc2IDogMiAqIDE5Mik7XG4gICAgICAgIHZhciBwYXJ0aXRpb24gPSBuZXdfaW50JDMoRW5jb2Rlcl8xLkhCTEtTSVpFKTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHNmcmVxIC89IGJsa3NpemU7XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgdmFyIG5pID0gMDtcbiAgICAgICAgLyogY29tcHV0ZSBudW1saW5lcywgdGhlIG51bWJlciBvZiBzcGVjdHJhbCBsaW5lcyBpbiBlYWNoIHBhcnRpdGlvbiBiYW5kICovXG4gICAgICAgIC8qIGVhY2ggcGFydGl0aW9uIGJhbmQgc2hvdWxkIGJlIGFib3V0IERFTEJBUksgd2lkZS4gKi9cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IEVuY29kZXJfMS5DQkFORFM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJhcmsxO1xuICAgICAgICAgICAgdmFyIGoyO1xuICAgICAgICAgICAgYmFyazEgPSBmcmVxMmJhcmsoc2ZyZXEgKiBqKTtcblxuICAgICAgICAgICAgYl9mcnFbaV0gPSBzZnJlcSAqIGo7XG5cbiAgICAgICAgICAgIGZvciAoajIgPSBqOyBmcmVxMmJhcmsoc2ZyZXEgKiBqMikgLSBiYXJrMSA8IERFTEJBUktcbiAgICAgICAgICAgICYmIGoyIDw9IGJsa3NpemUgLyAyOyBqMisrKVxuICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgbnVtbGluZXNbaV0gPSBqMiAtIGo7XG4gICAgICAgICAgICBuaSA9IGkgKyAxO1xuXG4gICAgICAgICAgICB3aGlsZSAoaiA8IGoyKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0JDMoaiA8IEVuY29kZXJfMS5IQkxLU0laRSk7XG4gICAgICAgICAgICAgICAgcGFydGl0aW9uW2orK10gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPiBibGtzaXplIC8gMikge1xuICAgICAgICAgICAgICAgIGogPSBibGtzaXplIC8gMjtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0JDMoaSA8IEVuY29kZXJfMS5DQkFORFMpO1xuICAgICAgICBiX2ZycVtpXSA9IHNmcmVxICogajtcblxuICAgICAgICBmb3IgKHZhciBzZmIgPSAwOyBzZmIgPCBzYm1heDsgc2ZiKyspIHtcbiAgICAgICAgICAgIHZhciBpMSwgaTIsIHN0YXJ0LCBlbmQ7XG4gICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgc3RhcnQgPSBzY2FsZXBvc1tzZmJdO1xuICAgICAgICAgICAgZW5kID0gc2NhbGVwb3Nbc2ZiICsgMV07XG5cbiAgICAgICAgICAgIGkxID0gMCB8IE1hdGguZmxvb3IoLjUgKyBkZWx0YWZyZXEgKiAoc3RhcnQgLSAuNSkpO1xuICAgICAgICAgICAgaWYgKGkxIDwgMClcbiAgICAgICAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgICBpMiA9IDAgfCBNYXRoLmZsb29yKC41ICsgZGVsdGFmcmVxICogKGVuZCAtIC41KSk7XG5cbiAgICAgICAgICAgIGlmIChpMiA+IGJsa3NpemUgLyAyKVxuICAgICAgICAgICAgICAgIGkyID0gYmxrc2l6ZSAvIDI7XG5cbiAgICAgICAgICAgIGJtW3NmYl0gPSAocGFydGl0aW9uW2kxXSArIHBhcnRpdGlvbltpMl0pIC8gMjtcbiAgICAgICAgICAgIGJvW3NmYl0gPSBwYXJ0aXRpb25baTJdO1xuICAgICAgICAgICAgdmFyIGZfdG1wID0gc2FtcGxlX2ZyZXFfZnJhYyAqIGVuZDtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBjYWxjdWxhdGUgaG93IG11Y2ggb2YgdGhpcyBiYW5kIGJlbG9uZ3MgdG8gY3VycmVudCBzY2FsZWZhY3RvclxuICAgICAgICAgICAgICogYmFuZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBib193W3NmYl0gPSAoZl90bXAgLSBiX2ZycVtib1tzZmJdXSlcbiAgICAgICAgICAgICAgICAvIChiX2ZycVtib1tzZmJdICsgMV0gLSBiX2ZycVtib1tzZmJdXSk7XG4gICAgICAgICAgICBpZiAoYm9fd1tzZmJdIDwgMCkge1xuICAgICAgICAgICAgICAgIGJvX3dbc2ZiXSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChib193W3NmYl0gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvX3dbc2ZiXSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogc2V0dXAgc3RlcmVvIGRlbWFza2luZyB0aHJlc2hvbGRzICovXG4gICAgICAgICAgICAvKiBmb3JtdWxhIHJldmVyc2UgZW5naW5lcnJlZCBmcm9tIHBsb3QgaW4gcGFwZXIgKi9cbiAgICAgICAgICAgIGFyZyA9IGZyZXEyYmFyayhzZnJlcSAqIHNjYWxlcG9zW3NmYl0gKiBkZWx0YWZyZXEpO1xuICAgICAgICAgICAgYXJnID0gKCBNYXRoLm1pbihhcmcsIDE1LjUpIC8gMTUuNSk7XG5cbiAgICAgICAgICAgIG1sZFtzZmJdID0gTWF0aC5wb3coMTAuMCxcbiAgICAgICAgICAgICAgICAxLjI1ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogYXJnKSkgLSAyLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogY29tcHV0ZSBiYXJrIHZhbHVlcyBvZiBlYWNoIGNyaXRpY2FsIGJhbmQgKi9cbiAgICAgICAgaiA9IDA7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbmk7IGsrKykge1xuICAgICAgICAgICAgdmFyIHcgPSBudW1saW5lc1trXTtcbiAgICAgICAgICAgIHZhciBiYXJrMSwgYmFyazI7XG5cbiAgICAgICAgICAgIGJhcmsxID0gZnJlcTJiYXJrKHNmcmVxICogKGopKTtcbiAgICAgICAgICAgIGJhcmsyID0gZnJlcTJiYXJrKHNmcmVxICogKGogKyB3IC0gMSkpO1xuICAgICAgICAgICAgYnZhbFtrXSA9IC41ICogKGJhcmsxICsgYmFyazIpO1xuXG4gICAgICAgICAgICBiYXJrMSA9IGZyZXEyYmFyayhzZnJlcSAqIChqIC0gLjUpKTtcbiAgICAgICAgICAgIGJhcmsyID0gZnJlcTJiYXJrKHNmcmVxICogKGogKyB3IC0gLjUpKTtcbiAgICAgICAgICAgIGJ2YWxfd2lkdGhba10gPSBiYXJrMiAtIGJhcmsxO1xuICAgICAgICAgICAgaiArPSB3O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRfczNfdmFsdWVzKHMzaW5kLCBucGFydCwgYnZhbCwgYnZhbF93aWR0aCwgbm9ybSwgdXNlX29sZF9zMykge1xuICAgICAgICB2YXIgczMgPSBuZXdfZmxvYXRfbiQzKFtFbmNvZGVyXzEuQ0JBTkRTLCBFbmNvZGVyXzEuQ0JBTkRTXSk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBzMyBhcnJheSBpcyBub3QgbGluZWFyIGluIHRoZSBiYXJrIHNjYWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBidmFsW3hdIHNob3VsZCBiZSB1c2VkIHRvIGdldCB0aGUgYmFyayB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBqO1xuICAgICAgICB2YXIgbnVtYmVyT2ZOb25lWmVybyA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxQUkU+XG4gICAgICAgICAqIHNbaV1bal0sIHRoZSB2YWx1ZSBvZiB0aGUgc3ByZWFkaW5nIGZ1bmN0aW9uLFxuICAgICAgICAgKiBjZW50ZXJlZCBhdCBiYW5kIGogKG1hc2tlciksIGZvciBiYW5kIGkgKG1hc2tlZSlcbiAgICAgICAgICpcbiAgICAgICAgICogaS5lLjogc3VtIG92ZXIgaiB0byBzcHJlYWQgaW50byBzaWduYWwgYmFya3ZhbD1pXG4gICAgICAgICAqIE5PVEU6IGkgYW5kIGogYXJlIHVzZWQgb3Bwb3NpdGUgYXMgaW4gdGhlIElTTyBkb2NzXG4gICAgICAgICAqIDwvUFJFPlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHVzZV9vbGRfczMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnBhcnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBucGFydDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gczNfZnVuYyhidmFsW2ldIC0gYnZhbFtqXSkgKiBidmFsX3dpZHRoW2pdO1xuICAgICAgICAgICAgICAgICAgICBzM1tpXVtqXSA9IHYgKiBub3JtW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBucGFydDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhmX3Nsb3BlID0gMTUgKyBNYXRoLm1pbigyMSAvIGJ2YWxbal0sIDEyKTtcbiAgICAgICAgICAgICAgICB2YXIgczNfeF9ub3JtID0gbm9ybV9zM19mdW5jX3goaGZfc2xvcGUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnBhcnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHMzX3hfbm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgKiBzM19mdW5jX3goYnZhbFtpXSAtIGJ2YWxbal0sIGhmX3Nsb3BlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKiBidmFsX3dpZHRoW2pdO1xuICAgICAgICAgICAgICAgICAgICBzM1tpXVtqXSA9IHYgKiBub3JtW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5wYXJ0OyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBucGFydDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMzW2ldW2pdID4gMC4wKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMzaW5kW2ldWzBdID0gajtcblxuICAgICAgICAgICAgZm9yIChqID0gbnBhcnQgLSAxOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMzW2ldW2pdID4gMC4wKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMzaW5kW2ldWzFdID0gajtcbiAgICAgICAgICAgIG51bWJlck9mTm9uZVplcm8gKz0gKHMzaW5kW2ldWzFdIC0gczNpbmRbaV1bMF0gKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwID0gbmV3X2Zsb2F0JDMobnVtYmVyT2ZOb25lWmVybyk7XG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBucGFydDsgaSsrKVxuICAgICAgICAgICAgZm9yIChqID0gczNpbmRbaV1bMF07IGogPD0gczNpbmRbaV1bMV07IGorKylcbiAgICAgICAgICAgICAgICBwW2srK10gPSBzM1tpXVtqXTtcblxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGVyZW9fZGVtYXNrKGYpIHtcbiAgICAgICAgLyogc2V0dXAgc3RlcmVvIGRlbWFza2luZyB0aHJlc2hvbGRzICovXG4gICAgICAgIC8qIGZvcm11bGEgcmV2ZXJzZSBlbmdpbmVycmVkIGZyb20gcGxvdCBpbiBwYXBlciAqL1xuICAgICAgICB2YXIgYXJnID0gZnJlcTJiYXJrKGYpO1xuICAgICAgICBhcmcgPSAoTWF0aC5taW4oYXJnLCAxNS41KSAvIDE1LjUpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnBvdygxMC4wLFxuICAgICAgICAgICAgMS4yNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGFyZykpIC0gMi41KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOT1RFOiB0aGUgYml0cmF0ZSByZWR1Y3Rpb24gZnJvbSB0aGUgaW50ZXItY2hhbm5lbCBtYXNraW5nIGVmZmVjdCBpcyBsb3dcbiAgICAgKiBjb21wYXJlZCB0byB0aGUgY2hhbmNlIG9mIGdldHRpbmcgYW5ueW9pbmcgYXJ0ZWZhY3RzLiBMM3BzeWNob19hbmFsX3ZiclxuICAgICAqIGRvZXMgbm90IHVzZSB0aGlzIGZlYXR1cmUuIChSb2JlcnQgMDcxMjE2KVxuICAgICAqL1xuICAgIHRoaXMucHN5bW9kZWxfaW5pdCA9IGZ1bmN0aW9uIChnZnApIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB1c2VPbGRTMyA9IHRydWU7XG4gICAgICAgIHZhciBidmxfYSA9IDEzLCBidmxfYiA9IDI0O1xuICAgICAgICB2YXIgc25yX2xfYSA9IDAsIHNucl9sX2IgPSAwO1xuICAgICAgICB2YXIgc25yX3NfYSA9IC04LjI1LCBzbnJfc19iID0gLTQuNTtcbiAgICAgICAgdmFyIGJ2YWwgPSBuZXdfZmxvYXQkMyhFbmNvZGVyXzEuQ0JBTkRTKTtcbiAgICAgICAgdmFyIGJ2YWxfd2lkdGggPSBuZXdfZmxvYXQkMyhFbmNvZGVyXzEuQ0JBTkRTKTtcbiAgICAgICAgdmFyIG5vcm0gPSBuZXdfZmxvYXQkMyhFbmNvZGVyXzEuQ0JBTkRTKTtcbiAgICAgICAgdmFyIHNmcmVxID0gZ2ZwLm91dF9zYW1wbGVyYXRlO1xuXG4gICAgICAgIHN3aXRjaCAoZ2ZwLmV4cGVyaW1lbnRhbFopIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlT2xkUzMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHVzZU9sZFMzID0gKGdmcC5WQlIgPT0gVmJyTW9kZSQzLnZicl9tdHJoIHx8IGdmcC5WQlIgPT0gVmJyTW9kZSQzLnZicl9tdCkgPyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICA6IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdXNlT2xkUzMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBidmxfYSA9IDg7XG4gICAgICAgICAgICAgICAgc25yX2xfYSA9IC0xLjc1O1xuICAgICAgICAgICAgICAgIHNucl9sX2IgPSAtMC4wMTI1O1xuICAgICAgICAgICAgICAgIHNucl9zX2EgPSAtOC4yNTtcbiAgICAgICAgICAgICAgICBzbnJfc19iID0gLTIuMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZ2ZjLm1zX2VuZXJfcmF0aW9fb2xkID0gLjI1O1xuICAgICAgICBnZmMuYmxvY2t0eXBlX29sZFswXSA9IGdmYy5ibG9ja3R5cGVfb2xkWzFdID0gRW5jb2Rlcl8xLk5PUk1fVFlQRTtcbiAgICAgICAgLy8gdGhlIHZiciBoZWFkZXIgaXMgbG9uZyBibG9ja3NcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IEVuY29kZXJfMS5DQkFORFM7ICsraikge1xuICAgICAgICAgICAgICAgIGdmYy5uYl8xW2ldW2pdID0gMWUyMDtcbiAgICAgICAgICAgICAgICBnZmMubmJfMltpXVtqXSA9IDFlMjA7XG4gICAgICAgICAgICAgICAgZ2ZjLm5iX3MxW2ldW2pdID0gZ2ZjLm5iX3MyW2ldW2pdID0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgc2IgPSAwOyBzYiA8IEVuY29kZXJfMS5TQk1BWF9sOyBzYisrKSB7XG4gICAgICAgICAgICAgICAgZ2ZjLmVuW2ldLmxbc2JdID0gMWUyMDtcbiAgICAgICAgICAgICAgICBnZmMudGhtW2ldLmxbc2JdID0gMWUyMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgKytqKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2IgPSAwOyBzYiA8IEVuY29kZXJfMS5TQk1BWF9zOyBzYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdmYy5lbltpXS5zW3NiXVtqXSA9IDFlMjA7XG4gICAgICAgICAgICAgICAgICAgIGdmYy50aG1baV0uc1tzYl1bal0gPSAxZTIwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZmMubnNQc3kubGFzdEF0dGFja3NbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA5OyBqKyspXG4gICAgICAgICAgICAgICAgZ2ZjLm5zUHN5Lmxhc3RfZW5fc3Vic2hvcnRbaV1bal0gPSAxMC47XG4gICAgICAgIH1cblxuICAgICAgICAvKiBpbml0LiBmb3IgbG91ZG5lc3MgYXBwcm94LiAtamQgMjAwMSBtYXIgMjcgKi9cbiAgICAgICAgZ2ZjLmxvdWRuZXNzX3NxX3NhdmVbMF0gPSBnZmMubG91ZG5lc3Nfc3Ffc2F2ZVsxXSA9IDAuMDtcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgKiBub3cgY29tcHV0ZSB0aGUgcHN5Y2hvYWNvdXN0aWMgbW9kZWwgc3BlY2lmaWMgY29uc3RhbnRzXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qIGNvbXB1dGUgbnVtbGluZXMsIGJvLCBibSwgYnZhbCwgYnZhbF93aWR0aCwgbWxkICovXG5cbiAgICAgICAgZ2ZjLm5wYXJ0X2wgPSBpbml0X251bWxpbmUoZ2ZjLm51bWxpbmVzX2wsIGdmYy5ib19sLCBnZmMuYm1fbCwgYnZhbCxcbiAgICAgICAgICAgIGJ2YWxfd2lkdGgsIGdmYy5tbGRfbCwgZ2ZjLlBTWS5ib19sX3dlaWdodCwgc2ZyZXEsXG4gICAgICAgICAgICBFbmNvZGVyXzEuQkxLU0laRSwgZ2ZjLnNjYWxlZmFjX2JhbmQubCwgRW5jb2Rlcl8xLkJMS1NJWkVcbiAgICAgICAgICAgIC8gKDIuMCAqIDU3NiksIEVuY29kZXJfMS5TQk1BWF9sKTtcbiAgICAgICAgYXNzZXJ0JDMoZ2ZjLm5wYXJ0X2wgPCBFbmNvZGVyXzEuQ0JBTkRTKTtcbiAgICAgICAgLyogY29tcHV0ZSB0aGUgc3ByZWFkaW5nIGZ1bmN0aW9uICovXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZmMubnBhcnRfbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc25yID0gc25yX2xfYTtcbiAgICAgICAgICAgIGlmIChidmFsW2ldID49IGJ2bF9hKSB7XG4gICAgICAgICAgICAgICAgc25yID0gc25yX2xfYiAqIChidmFsW2ldIC0gYnZsX2EpIC8gKGJ2bF9iIC0gYnZsX2EpICsgc25yX2xfYVxuICAgICAgICAgICAgICAgICAgICAqIChidmxfYiAtIGJ2YWxbaV0pIC8gKGJ2bF9iIC0gYnZsX2EpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybVtpXSA9IE1hdGgucG93KDEwLjAsIHNuciAvIDEwLjApO1xuICAgICAgICAgICAgaWYgKGdmYy5udW1saW5lc19sW2ldID4gMCkge1xuICAgICAgICAgICAgICAgIGdmYy5ybnVtbGluZXNfbFtpXSA9IDEuMCAvIGdmYy5udW1saW5lc19sW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZmMucm51bWxpbmVzX2xbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdmYy5zM19sbCA9IGluaXRfczNfdmFsdWVzKGdmYy5zM2luZCwgZ2ZjLm5wYXJ0X2wsIGJ2YWwsIGJ2YWxfd2lkdGgsXG4gICAgICAgICAgICBub3JtLCB1c2VPbGRTMyk7XG5cbiAgICAgICAgLyogY29tcHV0ZSBsb25nIGJsb2NrIHNwZWNpZmljIHZhbHVlcywgQVRIIGFuZCBNSU5WQUwgKi9cbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2ZjLm5wYXJ0X2w7IGkrKykge1xuICAgICAgICAgICAgdmFyIHg7XG5cbiAgICAgICAgICAgIC8qIEFUSCAqL1xuICAgICAgICAgICAgeCA9IEZsb2F0JDMuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBnZmMubnVtbGluZXNfbFtpXTsgaysrLCBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJlcSA9IHNmcmVxICogaiAvICgxMDAwLjAgKiBFbmNvZGVyXzEuQkxLU0laRSk7XG4gICAgICAgICAgICAgICAgdmFyIGxldmVsO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogQVRIIGJlbG93IDEwMCBIeiBjb25zdGFudCwgbm90IGZ1cnRoZXIgY2xpbWJpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsZXZlbCA9IHRoaXMuQVRIZm9ybXVsYShmcmVxICogMTAwMCwgZ2ZwKSAtIDIwO1xuICAgICAgICAgICAgICAgIC8vIHNjYWxlIHRvIEZGVCB1bml0czsgcmV0dXJuZWQgdmFsdWUgaXMgaW4gZEJcbiAgICAgICAgICAgICAgICBsZXZlbCA9IE1hdGgucG93KDEwLiwgMC4xICogbGV2ZWwpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgZnJvbSBkQiAuIGVuZXJneVxuICAgICAgICAgICAgICAgIGxldmVsICo9IGdmYy5udW1saW5lc19sW2ldO1xuICAgICAgICAgICAgICAgIGlmICh4ID4gbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgIHggPSBsZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdmYy5BVEguY2JfbFtpXSA9IHg7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBNSU5WQUwuIEZvciBsb3cgZnJlcSwgdGhlIHN0cmVuZ3RoIG9mIHRoZSBtYXNraW5nIGlzIGxpbWl0ZWQgYnlcbiAgICAgICAgICAgICAqIG1pbnZhbCB0aGlzIGlzIGFuIElTTyBNUEVHMSB0aGluZywgZG9udCBrbm93IGlmIGl0IGlzIHJlYWxseVxuICAgICAgICAgICAgICogbmVlZGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBGSVhNRTogaXQgZG9lcyB3b3JrIHRvIHJlZHVjZSBsb3ctZnJlcSBwcm9ibGVtcyBpbiBTNTMtV2luZC1TYXhcbiAgICAgICAgICAgICAqIGFuZCBsZWFkLXZvaWNlIHNhbXBsZXMsIGJ1dCBpbnRyb2R1Y2VzIHNvbWUgMyBrYnBzIGJpdCBibG9hdCB0b28uXG4gICAgICAgICAgICAgKiBUT0RPOiBGdXJ0aGVyIHJlZmluZW1lbnQgb2YgdGhlIHNoYXBlIG9mIHRoaXMgaGFjay5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgeCA9IC0yMCArIGJ2YWxbaV0gKiAyMCAvIDEwO1xuICAgICAgICAgICAgaWYgKHggPiA2KSB7XG4gICAgICAgICAgICAgICAgeCA9IDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4IDwgLTE1KSB7XG4gICAgICAgICAgICAgICAgeCA9IC0xNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggLT0gOC47XG4gICAgICAgICAgICBnZmMubWludmFsX2xbaV0gPSAoTWF0aC5wb3coMTAuMCwgeCAvIDEwLikgKiBnZmMubnVtbGluZXNfbFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIGRvIHRoZSBzYW1lIHRoaW5ncyBmb3Igc2hvcnQgYmxvY2tzXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGdmYy5ucGFydF9zID0gaW5pdF9udW1saW5lKGdmYy5udW1saW5lc19zLCBnZmMuYm9fcywgZ2ZjLmJtX3MsIGJ2YWwsXG4gICAgICAgICAgICBidmFsX3dpZHRoLCBnZmMubWxkX3MsIGdmYy5QU1kuYm9fc193ZWlnaHQsIHNmcmVxLFxuICAgICAgICAgICAgRW5jb2Rlcl8xLkJMS1NJWkVfcywgZ2ZjLnNjYWxlZmFjX2JhbmQucywgRW5jb2Rlcl8xLkJMS1NJWkVfc1xuICAgICAgICAgICAgLyAoMi4wICogMTkyKSwgRW5jb2Rlcl8xLlNCTUFYX3MpO1xuICAgICAgICBhc3NlcnQkMyhnZmMubnBhcnRfcyA8IEVuY29kZXJfMS5DQkFORFMpO1xuXG4gICAgICAgIC8qIFNOUiBmb3JtdWxhLiBzaG9ydCBibG9jayBpcyBub3JtYWxpemVkIGJ5IFNOUi4gaXMgaXQgc3RpbGwgcmlnaHQgPyAqL1xuICAgICAgICBqID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdmYy5ucGFydF9zOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHNuciA9IHNucl9zX2E7XG4gICAgICAgICAgICBpZiAoYnZhbFtpXSA+PSBidmxfYSkge1xuICAgICAgICAgICAgICAgIHNuciA9IHNucl9zX2IgKiAoYnZhbFtpXSAtIGJ2bF9hKSAvIChidmxfYiAtIGJ2bF9hKSArIHNucl9zX2FcbiAgICAgICAgICAgICAgICAgICAgKiAoYnZsX2IgLSBidmFsW2ldKSAvIChidmxfYiAtIGJ2bF9hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1baV0gPSBNYXRoLnBvdygxMC4wLCBzbnIgLyAxMC4wKTtcblxuICAgICAgICAgICAgLyogQVRIICovXG4gICAgICAgICAgICB4ID0gRmxvYXQkMy5NQVhfVkFMVUU7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdmYy5udW1saW5lc19zW2ldOyBrKyssIGorKykge1xuICAgICAgICAgICAgICAgIHZhciBmcmVxID0gc2ZyZXEgKiBqIC8gKDEwMDAuMCAqIEVuY29kZXJfMS5CTEtTSVpFX3MpO1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbDtcbiAgICAgICAgICAgICAgICAvKiBmcmVxID0gTWluKC4xLGZyZXEpOyAqL1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogQVRIIGJlbG93IDEwMCBIeiBjb25zdGFudCwgbm90XG4gICAgICAgICAgICAgICAgICogZnVydGhlciBjbGltYmluZ1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGxldmVsID0gdGhpcy5BVEhmb3JtdWxhKGZyZXEgKiAxMDAwLCBnZnApIC0gMjA7XG4gICAgICAgICAgICAgICAgLy8gc2NhbGUgdG8gRkZUIHVuaXRzOyByZXR1cm5lZCB2YWx1ZSBpcyBpbiBkQlxuICAgICAgICAgICAgICAgIGxldmVsID0gTWF0aC5wb3coMTAuLCAwLjEgKiBsZXZlbCk7XG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBmcm9tIGRCIC4gZW5lcmd5XG4gICAgICAgICAgICAgICAgbGV2ZWwgKj0gZ2ZjLm51bWxpbmVzX3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKHggPiBsZXZlbClcbiAgICAgICAgICAgICAgICAgICAgeCA9IGxldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2ZjLkFUSC5jYl9zW2ldID0geDtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIE1JTlZBTC4gRm9yIGxvdyBmcmVxLCB0aGUgc3RyZW5ndGggb2YgdGhlIG1hc2tpbmcgaXMgbGltaXRlZCBieVxuICAgICAgICAgICAgICogbWludmFsIHRoaXMgaXMgYW4gSVNPIE1QRUcxIHRoaW5nLCBkb250IGtub3cgaWYgaXQgaXMgcmVhbGx5XG4gICAgICAgICAgICAgKiBuZWVkZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgeCA9ICgtNy4wICsgYnZhbFtpXSAqIDcuMCAvIDEyLjApO1xuICAgICAgICAgICAgaWYgKGJ2YWxbaV0gPiAxMikge1xuICAgICAgICAgICAgICAgIHggKj0gMSArIE1hdGgubG9nKDEgKyB4KSAqIDMuMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidmFsW2ldIDwgMTIpIHtcbiAgICAgICAgICAgICAgICB4ICo9IDEgKyBNYXRoLmxvZygxIC0geCkgKiAyLjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA8IC0xNSkge1xuICAgICAgICAgICAgICAgIHggPSAtMTU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4IC09IDg7XG4gICAgICAgICAgICBnZmMubWludmFsX3NbaV0gPSBNYXRoLnBvdygxMC4wLCB4IC8gMTApXG4gICAgICAgICAgICAgICAgKiBnZmMubnVtbGluZXNfc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdmYy5zM19zcyA9IGluaXRfczNfdmFsdWVzKGdmYy5zM2luZF9zLCBnZmMubnBhcnRfcywgYnZhbCwgYnZhbF93aWR0aCxcbiAgICAgICAgICAgIG5vcm0sIHVzZU9sZFMzKTtcblxuICAgICAgICBpbml0X21hc2tfYWRkX21heF92YWx1ZXMoKTtcbiAgICAgICAgZmZ0LmluaXRfZmZ0KGdmYyk7XG5cbiAgICAgICAgLyogc2V0dXAgdGVtcG9yYWwgbWFza2luZyAqL1xuICAgICAgICBnZmMuZGVjYXkgPSBNYXRoLmV4cCgtMS4wICogTE9HMTBcbiAgICAgICAgICAgIC8gKHRlbXBvcmFsbWFza19zdXN0YWluX3NlYyAqIHNmcmVxIC8gMTkyLjApKTtcblxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbXNmaXg7XG4gICAgICAgICAgICBtc2ZpeCA9IE5TX01TRklYO1xuICAgICAgICAgICAgaWYgKChnZnAuZXhwX25zcHN5dHVuZSAmIDIpICE9IDApXG4gICAgICAgICAgICAgICAgbXNmaXggPSAxLjA7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZ2ZwLm1zZml4KSA+IDAuMClcbiAgICAgICAgICAgICAgICBtc2ZpeCA9IGdmcC5tc2ZpeDtcbiAgICAgICAgICAgIGdmcC5tc2ZpeCA9IG1zZml4O1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogc3ByZWFkIG9ubHkgZnJvbSBucGFydF9sIGJhbmRzLiBOb3JtYWxseSwgd2UgdXNlIHRoZSBzcHJlYWRpbmdcbiAgICAgICAgICAgICAqIGZ1bmN0aW9uIHRvIGNvbnZvbHZlIGZyb20gbnBhcnRfbCBkb3duIHRvIG5wYXJ0X2wgYmFuZHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBnZmMubnBhcnRfbDsgYisrKVxuICAgICAgICAgICAgICAgIGlmIChnZmMuczNpbmRbYl1bMV0gPiBnZmMubnBhcnRfbCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIGdmYy5zM2luZFtiXVsxXSA9IGdmYy5ucGFydF9sIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHByZXBhcmUgZm9yIEFUSCBhdXRvIGFkanVzdG1lbnQ6IHdlIHdhbnQgdG8gZGVjcmVhc2UgdGhlIEFUSCBieSAxMiBkQlxuICAgICAgICAgKiBwZXIgc2Vjb25kXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZnJhbWVfZHVyYXRpb24gPSAoNTc2LiAqIGdmYy5tb2RlX2dyIC8gc2ZyZXEpO1xuICAgICAgICBnZmMuQVRILmRlY2F5ID0gTWF0aC5wb3coMTAuLCAtMTIuIC8gMTAuICogZnJhbWVfZHVyYXRpb24pO1xuICAgICAgICBnZmMuQVRILmFkanVzdCA9IDAuMDE7XG4gICAgICAgIC8qIG1pbmltdW0sIGZvciBsZWFkaW5nIGxvdyBsb3VkbmVzcyAqL1xuICAgICAgICBnZmMuQVRILmFkanVzdExpbWl0ID0gMS4wO1xuICAgICAgICAvKiBvbiBsZWFkLCBhbGxvdyBhZGp1c3QgdXAgdG8gbWF4aW11bSAqL1xuXG4gICAgICAgIGFzc2VydCQzKGdmYy5ib19sW0VuY29kZXJfMS5TQk1BWF9sIC0gMV0gPD0gZ2ZjLm5wYXJ0X2wpO1xuICAgICAgICBhc3NlcnQkMyhnZmMuYm9fc1tFbmNvZGVyXzEuU0JNQVhfcyAtIDFdIDw9IGdmYy5ucGFydF9zKTtcblxuICAgICAgICBpZiAoZ2ZwLkFUSHR5cGUgIT0gLTEpIHtcbiAgICAgICAgICAgIC8qIGNvbXB1dGUgZXF1YWwgbG91ZG5lc3Mgd2VpZ2h0cyAoZXFsX3cpICovXG4gICAgICAgICAgICB2YXIgZnJlcTtcbiAgICAgICAgICAgIHZhciBmcmVxX2luYyA9IGdmcC5vdXRfc2FtcGxlcmF0ZVxuICAgICAgICAgICAgICAgIC8gKEVuY29kZXJfMS5CTEtTSVpFKTtcbiAgICAgICAgICAgIHZhciBlcWxfYmFsYW5jZSA9IDAuMDtcbiAgICAgICAgICAgIGZyZXEgPSAwLjA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgRW5jb2Rlcl8xLkJMS1NJWkUgLyAyOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvKiBjb252ZXJ0IEFUSCBkQiB0byByZWxhdGl2ZSBwb3dlciAobm90IGRCKSAqL1xuICAgICAgICAgICAgICAgIC8qIHRvIGRldGVybWluZSBlcWxfdyAqL1xuICAgICAgICAgICAgICAgIGZyZXEgKz0gZnJlcV9pbmM7XG4gICAgICAgICAgICAgICAgZ2ZjLkFUSC5lcWxfd1tpXSA9IDEuIC8gTWF0aC5wb3coMTAsIHRoaXMuQVRIZm9ybXVsYShmcmVxLCBnZnApIC8gMTApO1xuICAgICAgICAgICAgICAgIGVxbF9iYWxhbmNlICs9IGdmYy5BVEguZXFsX3dbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcWxfYmFsYW5jZSA9IDEuMCAvIGVxbF9iYWxhbmNlO1xuICAgICAgICAgICAgZm9yIChpID0gRW5jb2Rlcl8xLkJMS1NJWkUgLyAyOyAtLWkgPj0gMDspIHsgLyogc2NhbGUgd2VpZ2h0cyAqL1xuICAgICAgICAgICAgICAgIGdmYy5BVEguZXFsX3dbaV0gKj0gZXFsX2JhbGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IGogPSAwOyBiIDwgZ2ZjLm5wYXJ0X3M7ICsrYikge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZmMubnVtbGluZXNfc1tiXTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQkMyhqID09IDEyOSk7XG4gICAgICAgICAgICBmb3IgKHZhciBiID0gaiA9IDA7IGIgPCBnZmMubnBhcnRfbDsgKytiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGdmYy5udW1saW5lc19sW2JdOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydCQzKGogPT0gNTEzKTtcbiAgICAgICAgfVxuICAgICAgICBqID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdmYy5ucGFydF9sOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmcmVxID0gc2ZyZXEgKiAoaiArIGdmYy5udW1saW5lc19sW2ldIC8gMikgLyAoMS4wICogRW5jb2Rlcl8xLkJMS1NJWkUpO1xuICAgICAgICAgICAgZ2ZjLm1sZF9jYl9sW2ldID0gc3RlcmVvX2RlbWFzayhmcmVxKTtcbiAgICAgICAgICAgIGogKz0gZ2ZjLm51bWxpbmVzX2xbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBFbmNvZGVyXzEuQ0JBTkRTOyArK2kpIHtcbiAgICAgICAgICAgIGdmYy5tbGRfY2JfbFtpXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaiA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZmMubnBhcnRfczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZnJlcSA9IHNmcmVxICogKGogKyBnZmMubnVtbGluZXNfc1tpXSAvIDIpIC8gKDEuMCAqIEVuY29kZXJfMS5CTEtTSVpFX3MpO1xuICAgICAgICAgICAgZ2ZjLm1sZF9jYl9zW2ldID0gc3RlcmVvX2RlbWFzayhmcmVxKTtcbiAgICAgICAgICAgIGogKz0gZ2ZjLm51bWxpbmVzX3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBFbmNvZGVyXzEuQ0JBTkRTOyArK2kpIHtcbiAgICAgICAgICAgIGdmYy5tbGRfY2Jfc1tpXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRob3NlIEFUSCBmb3JtdWxhcyBhcmUgcmV0dXJuaW5nIHRoZWlyIG1pbmltdW0gdmFsdWUgZm9yIGlucHV0ID0gLTFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBVEhmb3JtdWxhX0dCKGYsIHZhbHVlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8UFJFPlxuICAgICAgICAgKiAgZnJvbSBQYWludGVyICYgU3Bhbmlhc1xuICAgICAgICAgKiAgICAgICAgICAgbW9kaWZpZWQgYnkgR2FicmllbCBCb3V2aWduZSB0byBiZXR0ZXIgZml0IHRoZSByZWFsaXR5XG4gICAgICAgICAqICAgICAgICAgICBhdGggPSAgICAzLjY0MCAqIHBvdyhmLC0wLjgpXG4gICAgICAgICAqICAgICAgICAgICAtIDYuODAwICogZXhwKC0wLjYqcG93KGYtMy40LDIuMCkpXG4gICAgICAgICAqICAgICAgICAgICArIDYuMDAwICogZXhwKC0wLjE1KnBvdyhmLTguNywyLjApKVxuICAgICAgICAgKiAgICAgICAgICAgKyAwLjYqIDAuMDAxICogcG93KGYsNC4wKTtcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICAgIEluIHRoZSBwYXN0IExBTUUgd2FzIHVzaW5nIHRoZSBQYWludGVyICZTcGFuaWFzIGZvcm11bGEuXG4gICAgICAgICAqICAgICAgICAgICBCdXQgd2UgaGFkIHNvbWUgcmVjdXJyZW50IHByb2JsZW1zIHdpdGggSEYgY29udGVudC5cbiAgICAgICAgICogICAgICAgICAgIFdlIG1lYXN1cmVkIHJlYWwgQVRIIHZhbHVlcywgYW5kIGZvdW5kIHRoZSBvbGRlciBmb3JtdWxhXG4gICAgICAgICAqICAgICAgICAgICB0byBiZSBpbmFjY3VyYXRlIGluIHRoZSBoaWdoZXIgcGFydC4gU28gd2UgbWFkZSB0aGlzIG5ld1xuICAgICAgICAgKiAgICAgICAgICAgZm9ybXVsYSBhbmQgdGhpcyBzb2x2ZWQgbW9zdCBvZiBIRiBwcm9ibGVtYXRpYyB0ZXN0IGNhc2VzLlxuICAgICAgICAgKiAgICAgICAgICAgVGhlIHRyYWRlb2ZmIGlzIHRoYXQgaW4gVkJSIG1vZGUgaXQgaW5jcmVhc2VzIGEgbG90IHRoZVxuICAgICAgICAgKiAgICAgICAgICAgYml0cmF0ZS5cbiAgICAgICAgICogPC9QUkU+XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoaXMgY3VydmUgY2FuIGJlIGFkanVzdGVkIGFjY29yZGluZyB0byB0aGUgVkJSIHNjYWxlOiBpdCBhZGp1c3RzXG4gICAgICAgICAqIGZyb20gc29tZXRoaW5nIGNsb3NlIHRvIFBhaW50ZXIgJiBTcGFuaWFzIG9uIFY5IHVwIHRvIEJvdXZpZ25lJ3NcbiAgICAgICAgICogZm9ybXVsYSBmb3IgVjAuIFRoaXMgd2F5IHRoZSBWQlIgYml0cmF0ZSBpcyBtb3JlIGJhbGFuY2VkIGFjY29yZGluZ1xuICAgICAgICAgKiB0byB0aGUgLVYgdmFsdWUuXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgSGFjayBhbGxvd3MgdG8gYXNrIGZvciB0aGUgbG93ZXN0IHZhbHVlXG4gICAgICAgIGlmIChmIDwgLS4zKVxuICAgICAgICAgICAgZiA9IDM0MTA7XG5cbiAgICAgICAgLy8gY29udmVydCB0byBraHpcbiAgICAgICAgZiAvPSAxMDAwO1xuICAgICAgICBmID0gTWF0aC5tYXgoMC4xLCBmKTtcbiAgICAgICAgdmFyIGF0aCA9IDMuNjQwICogTWF0aC5wb3coZiwgLTAuOCkgLSA2LjgwMFxuICAgICAgICAgICAgKiBNYXRoLmV4cCgtMC42ICogTWF0aC5wb3coZiAtIDMuNCwgMi4wKSkgKyA2LjAwMFxuICAgICAgICAgICAgKiBNYXRoLmV4cCgtMC4xNSAqIE1hdGgucG93KGYgLSA4LjcsIDIuMCkpXG4gICAgICAgICAgICArICgwLjYgKyAwLjA0ICogdmFsdWUpICogMC4wMDEgKiBNYXRoLnBvdyhmLCA0LjApO1xuICAgICAgICByZXR1cm4gYXRoO1xuICAgIH1cblxuICAgIHRoaXMuQVRIZm9ybXVsYSA9IGZ1bmN0aW9uIChmLCBnZnApIHtcbiAgICAgICAgdmFyIGF0aDtcbiAgICAgICAgc3dpdGNoIChnZnAuQVRIdHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGF0aCA9IEFUSGZvcm11bGFfR0IoZiwgOSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgLy8gb3ZlciBzZW5zaXRpdmUsIHNob3VsZCBwcm9iYWJseSBiZSByZW1vdmVkXG4gICAgICAgICAgICAgICAgYXRoID0gQVRIZm9ybXVsYV9HQihmLCAtMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgYXRoID0gQVRIZm9ybXVsYV9HQihmLCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAvLyBtb2RpZmljYXRpb24gb2YgR0IgZm9ybXVsYSBieSBSb2VsXG4gICAgICAgICAgICAgICAgYXRoID0gQVRIZm9ybXVsYV9HQihmLCAxKSArIDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgYXRoID0gQVRIZm9ybXVsYV9HQihmLCBnZnAuQVRIY3VydmUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhdGggPSBBVEhmb3JtdWxhX0dCKGYsIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdGg7XG4gICAgfTtcblxufVxuXG52YXIgUHN5TW9kZWxfMSA9IFBzeU1vZGVsO1xuXG4vL3BhY2thZ2UgbXAzO1xuXG4vKiBNUEVHIG1vZGVzICovXG5mdW5jdGlvbiBNUEVHTW9kZSQxKG9yZGluYWwpIHtcbiAgICB2YXIgX29yZGluYWwgPSBvcmRpbmFsO1xuICAgIHRoaXMub3JkaW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9vcmRpbmFsO1xuICAgIH07XG59XG5cbk1QRUdNb2RlJDEuU1RFUkVPID0gbmV3IE1QRUdNb2RlJDEoMCk7XG5NUEVHTW9kZSQxLkpPSU5UX1NURVJFTyA9IG5ldyBNUEVHTW9kZSQxKDEpO1xuTVBFR01vZGUkMS5EVUFMX0NIQU5ORUwgPSBuZXcgTVBFR01vZGUkMSgyKTtcbk1QRUdNb2RlJDEuTU9OTyA9IG5ldyBNUEVHTW9kZSQxKDMpO1xuTVBFR01vZGUkMS5OT1RfU0VUID0gbmV3IE1QRUdNb2RlJDEoNCk7XG5cbnZhciBNUEVHTW9kZV8xID0gTVBFR01vZGUkMTtcblxuZnVuY3Rpb24gTGFtZUdsb2JhbEZsYWdzKCkge1xuXG4gICAgdGhpcy5jbGFzc19pZCA9IDA7XG5cbiAgICAvKiBpbnB1dCBkZXNjcmlwdGlvbiAqL1xuXG4gICAgLyoqXG4gICAgICogbnVtYmVyIG9mIHNhbXBsZXMuIGRlZmF1bHQ9LTFcbiAgICAgKi9cbiAgICB0aGlzLm51bV9zYW1wbGVzID0gMDtcbiAgICAvKipcbiAgICAgKiBpbnB1dCBudW1iZXIgb2YgY2hhbm5lbHMuIGRlZmF1bHQ9MlxuICAgICAqL1xuICAgIHRoaXMubnVtX2NoYW5uZWxzID0gMDtcbiAgICAvKipcbiAgICAgKiBpbnB1dF9zYW1wX3JhdGUgaW4gSHouIGRlZmF1bHQ9NDQuMSBrSHpcbiAgICAgKi9cbiAgICB0aGlzLmluX3NhbXBsZXJhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIG91dHB1dF9zYW1wX3JhdGUuIGRlZmF1bHQ6IExBTUUgcGlja3MgYmVzdCB2YWx1ZSBhdCBsZWFzdCBub3QgdXNlZCBmb3JcbiAgICAgKiBNUDMgZGVjb2Rpbmc6IFJlbWVtYmVyIDQ0LjEga0h6IE1QM3MgYW5kIEFDOTdcbiAgICAgKi9cbiAgICB0aGlzLm91dF9zYW1wbGVyYXRlID0gMDtcbiAgICAvKipcbiAgICAgKiBzY2FsZSBpbnB1dCBieSB0aGlzIGFtb3VudCBiZWZvcmUgZW5jb2RpbmcgYXQgbGVhc3Qgbm90IHVzZWQgZm9yIE1QM1xuICAgICAqIGRlY29kaW5nXG4gICAgICovXG4gICAgdGhpcy5zY2FsZSA9IDAuO1xuICAgIC8qKlxuICAgICAqIHNjYWxlIGlucHV0IG9mIGNoYW5uZWwgMCAobGVmdCkgYnkgdGhpcyBhbW91bnQgYmVmb3JlIGVuY29kaW5nXG4gICAgICovXG4gICAgdGhpcy5zY2FsZV9sZWZ0ID0gMC47XG4gICAgLyoqXG4gICAgICogc2NhbGUgaW5wdXQgb2YgY2hhbm5lbCAxIChyaWdodCkgYnkgdGhpcyBhbW91bnQgYmVmb3JlIGVuY29kaW5nXG4gICAgICovXG4gICAgdGhpcy5zY2FsZV9yaWdodCA9IDAuO1xuXG4gICAgLyogZ2VuZXJhbCBjb250cm9sIHBhcmFtcyAqL1xuICAgIC8qKlxuICAgICAqIGNvbGxlY3QgZGF0YSBmb3IgYSBNUDMgZnJhbWUgYW5hbHl6ZXI/XG4gICAgICovXG4gICAgdGhpcy5hbmFseXNpcyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGFkZCBYaW5nIFZCUiB0YWc/XG4gICAgICovXG4gICAgdGhpcy5iV3JpdGVWYnJUYWcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIHVzZSBsYW1lL21wZ2xpYiB0byBjb252ZXJ0IG1wMyB0byB3YXZcbiAgICAgKi9cbiAgICB0aGlzLmRlY29kZV9vbmx5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogcXVhbGl0eSBzZXR0aW5nIDA9YmVzdCwgOT13b3JzdCBkZWZhdWx0PTVcbiAgICAgKi9cbiAgICB0aGlzLnF1YWxpdHkgPSAwO1xuICAgIC8qKlxuICAgICAqIHNlZSBlbnVtIGRlZmF1bHQgPSBMQU1FIHBpY2tzIGJlc3QgdmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLm1vZGUgPSBNUEVHTW9kZV8xLlNURVJFTztcbiAgICAvKipcbiAgICAgKiBmb3JjZSBNL1MgbW9kZS4gcmVxdWlyZXMgbW9kZT0xXG4gICAgICovXG4gICAgdGhpcy5mb3JjZV9tcyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIHVzZSBmcmVlIGZvcm1hdD8gZGVmYXVsdD0wXG4gICAgICovXG4gICAgdGhpcy5mcmVlX2Zvcm1hdCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGZpbmQgdGhlIFJHIHZhbHVlPyBkZWZhdWx0PTBcbiAgICAgKi9cbiAgICB0aGlzLmZpbmRSZXBsYXlHYWluID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogZGVjb2RlIG9uIHRoZSBmbHk/IGRlZmF1bHQ9MFxuICAgICAqL1xuICAgIHRoaXMuZGVjb2RlX29uX3RoZV9mbHkgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiAxIChkZWZhdWx0KSB3cml0ZXMgSUQzIHRhZ3MsIDAgbm90XG4gICAgICovXG4gICAgdGhpcy53cml0ZV9pZDN0YWdfYXV0b21hdGljID0gZmFsc2U7XG5cbiAgICAvKlxuICAgICAqIHNldCBlaXRoZXIgYnJhdGU+MCBvciBjb21wcmVzc2lvbl9yYXRpbz4wLCBMQU1FIHdpbGwgY29tcHV0ZSB0aGUgdmFsdWUgb2ZcbiAgICAgKiB0aGUgdmFyaWFibGUgbm90IHNldC4gRGVmYXVsdCBpcyBjb21wcmVzc2lvbl9yYXRpbyA9IDExLjAyNVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGJpdHJhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJyYXRlID0gMDtcbiAgICAvKipcbiAgICAgKiBzaXplb2Yod2F2IGZpbGUpL3NpemVvZihtcDMgZmlsZSlcbiAgICAgKi9cbiAgICB0aGlzLmNvbXByZXNzaW9uX3JhdGlvID0gMC47XG5cbiAgICAvKiBmcmFtZSBwYXJhbXMgKi9cbiAgICAvKipcbiAgICAgKiBtYXJrIGFzIGNvcHlyaWdodC4gZGVmYXVsdD0wXG4gICAgICovXG4gICAgdGhpcy5jb3B5cmlnaHQgPSAwO1xuICAgIC8qKlxuICAgICAqIG1hcmsgYXMgb3JpZ2luYWwuIGRlZmF1bHQ9MVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luYWwgPSAwO1xuICAgIC8qKlxuICAgICAqIHRoZSBNUDMgJ3ByaXZhdGUgZXh0ZW5zaW9uJyBiaXQuIE1lYW5pbmdsZXNzXG4gICAgICovXG4gICAgdGhpcy5leHRlbnNpb24gPSAwO1xuICAgIC8qKlxuICAgICAqIElucHV0IFBDTSBpcyBlbXBoYXNlZCBQQ00gKGZvciBpbnN0YW5jZSBmcm9tIG9uZSBvZiB0aGUgcmFyZWx5IGVtcGhhc2VkXG4gICAgICogQ0RzKSwgaXQgaXMgU1RST05HTFkgbm90IHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzLCBiZWNhdXNlIHBzeWNobyBkb2VzIG5vdFxuICAgICAqIHRha2UgaXQgaW50byBhY2NvdW50LCBhbmQgbGFzdCBidXQgbm90IGxlYXN0IG1hbnkgZGVjb2RlcnMgZG9uJ3QgY2FyZVxuICAgICAqIGFib3V0IHRoZXNlIGJpdHNcbiAgICAgKi9cbiAgICB0aGlzLmVtcGhhc2lzID0gMDtcbiAgICAvKipcbiAgICAgKiB1c2UgMiBieXRlcyBwZXIgZnJhbWUgZm9yIGEgQ1JDIGNoZWNrc3VtLiBkZWZhdWx0PTBcbiAgICAgKi9cbiAgICB0aGlzLmVycm9yX3Byb3RlY3Rpb24gPSAwO1xuICAgIC8qKlxuICAgICAqIGVuZm9yY2UgSVNPIHNwZWMgYXMgbXVjaCBhcyBwb3NzaWJsZVxuICAgICAqL1xuICAgIHRoaXMuc3RyaWN0X0lTTyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogdXNlIGJpdCByZXNlcnZvaXI/XG4gICAgICovXG4gICAgdGhpcy5kaXNhYmxlX3Jlc2Vydm9pciA9IGZhbHNlO1xuXG4gICAgLyogcXVhbnRpemF0aW9uL25vaXNlIHNoYXBpbmcgKi9cbiAgICB0aGlzLnF1YW50X2NvbXAgPSAwO1xuICAgIHRoaXMucXVhbnRfY29tcF9zaG9ydCA9IDA7XG4gICAgdGhpcy5leHBlcmltZW50YWxZID0gZmFsc2U7XG4gICAgdGhpcy5leHBlcmltZW50YWxaID0gMDtcbiAgICB0aGlzLmV4cF9uc3BzeXR1bmUgPSAwO1xuXG4gICAgdGhpcy5wcmVzZXQgPSAwO1xuXG4gICAgLyogVkJSIGNvbnRyb2wgKi9cbiAgICB0aGlzLlZCUiA9IG51bGw7XG4gICAgLyoqXG4gICAgICogUmFuZ2UgWzAsLi4uLDFbXG4gICAgICovXG4gICAgdGhpcy5WQlJfcV9mcmFjID0gMC47XG4gICAgLyoqXG4gICAgICogUmFuZ2UgWzAsLi4uLDldXG4gICAgICovXG4gICAgdGhpcy5WQlJfcSA9IDA7XG4gICAgdGhpcy5WQlJfbWVhbl9iaXRyYXRlX2ticHMgPSAwO1xuICAgIHRoaXMuVkJSX21pbl9iaXRyYXRlX2ticHMgPSAwO1xuICAgIHRoaXMuVkJSX21heF9iaXRyYXRlX2ticHMgPSAwO1xuICAgIC8qKlxuICAgICAqIHN0cmljdGx5IGVuZm9yY2UgVkJSX21pbl9iaXRyYXRlIG5vcm1hbHksIGl0IHdpbGwgYmUgdmlvbGF0ZWQgZm9yIGFuYWxvZ1xuICAgICAqIHNpbGVuY2VcbiAgICAgKi9cbiAgICB0aGlzLlZCUl9oYXJkX21pbiA9IDA7XG5cbiAgICAvKiByZXNhbXBsaW5nIGFuZCBmaWx0ZXJpbmcgKi9cblxuICAgIC8qKlxuICAgICAqIGZyZXEgaW4gSHouIDA9bGFtZSBjaG9zZXMuIC0xPW5vIGZpbHRlclxuICAgICAqL1xuICAgIHRoaXMubG93cGFzc2ZyZXEgPSAwO1xuICAgIC8qKlxuICAgICAqIGZyZXEgaW4gSHouIDA9bGFtZSBjaG9zZXMuIC0xPW5vIGZpbHRlclxuICAgICAqL1xuICAgIHRoaXMuaGlnaHBhc3NmcmVxID0gMDtcbiAgICAvKipcbiAgICAgKiBmcmVxIHdpZHRoIG9mIGZpbHRlciwgaW4gSHogKGRlZmF1bHQ9MTUlKVxuICAgICAqL1xuICAgIHRoaXMubG93cGFzc3dpZHRoID0gMDtcbiAgICAvKipcbiAgICAgKiBmcmVxIHdpZHRoIG9mIGZpbHRlciwgaW4gSHogKGRlZmF1bHQ9MTUlKVxuICAgICAqL1xuICAgIHRoaXMuaGlnaHBhc3N3aWR0aCA9IDA7XG5cbiAgICAvKlxuICAgICAqIHBzeWNobyBhY291c3RpY3MgYW5kIG90aGVyIGFyZ3VtZW50cyB3aGljaCB5b3Ugc2hvdWxkIG5vdCBjaGFuZ2UgdW5sZXNzXG4gICAgICogeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nXG4gICAgICovXG5cbiAgICB0aGlzLm1hc2tpbmdhZGp1c3QgPSAwLjtcbiAgICB0aGlzLm1hc2tpbmdhZGp1c3Rfc2hvcnQgPSAwLjtcbiAgICAvKipcbiAgICAgKiBvbmx5IHVzZSBBVEhcbiAgICAgKi9cbiAgICB0aGlzLkFUSG9ubHkgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBvbmx5IHVzZSBBVEggZm9yIHNob3J0IGJsb2Nrc1xuICAgICAqL1xuICAgIHRoaXMuQVRIc2hvcnQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBkaXNhYmxlIEFUSFxuICAgICAqL1xuICAgIHRoaXMubm9BVEggPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBzZWxlY3QgQVRIIGZvcm11bGFcbiAgICAgKi9cbiAgICB0aGlzLkFUSHR5cGUgPSAwO1xuICAgIC8qKlxuICAgICAqIGNoYW5nZSBBVEggZm9ybXVsYSA0IHNoYXBlXG4gICAgICovXG4gICAgdGhpcy5BVEhjdXJ2ZSA9IDAuO1xuICAgIC8qKlxuICAgICAqIGxvd2VyIEFUSCBieSB0aGlzIG1hbnkgZGJcbiAgICAgKi9cbiAgICB0aGlzLkFUSGxvd2VyID0gMC47XG4gICAgLyoqXG4gICAgICogc2VsZWN0IEFUSCBhdXRvLWFkanVzdCBzY2hlbWVcbiAgICAgKi9cbiAgICB0aGlzLmF0aGFhX3R5cGUgPSAwO1xuICAgIC8qKlxuICAgICAqIHNlbGVjdCBBVEggYXV0by1hZGp1c3QgbG91ZG5lc3MgY2FsY1xuICAgICAqL1xuICAgIHRoaXMuYXRoYWFfbG91ZGFwcHJveCA9IDA7XG4gICAgLyoqXG4gICAgICogZEIsIHR1bmUgYWN0aXZlIHJlZ2lvbiBvZiBhdXRvLWxldmVsXG4gICAgICovXG4gICAgdGhpcy5hdGhhYV9zZW5zaXRpdml0eSA9IDAuO1xuICAgIHRoaXMuc2hvcnRfYmxvY2tzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiB1c2UgdGVtcG9yYWwgbWFza2luZyBlZmZlY3RcbiAgICAgKi9cbiAgICB0aGlzLnVzZVRlbXBvcmFsID0gZmFsc2U7XG4gICAgdGhpcy5pbnRlckNoUmF0aW8gPSAwLjtcbiAgICAvKipcbiAgICAgKiBOYW9raSdzIGFkanVzdG1lbnQgb2YgTWlkL1NpZGUgbWFza2luZ3NcbiAgICAgKi9cbiAgICB0aGlzLm1zZml4ID0gMC47XG5cbiAgICAvKipcbiAgICAgKiAwIG9mZiwgMSBvblxuICAgICAqL1xuICAgIHRoaXMudHVuZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIHVzZWQgdG8gcGFzcyB2YWx1ZXMgZm9yIGRlYnVnZ2luZyBhbmQgc3R1ZmZcbiAgICAgKi9cbiAgICB0aGlzLnR1bmVfdmFsdWVfYSA9IDAuO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKiBpbnRlcm5hbCB2YXJpYWJsZXMsIGRvIG5vdCBzZXQuLi4gKi9cbiAgICAvKiBwcm92aWRlZCBiZWNhdXNlIHRoZXkgbWF5IGJlIG9mIHVzZSB0byBjYWxsaW5nIGFwcGxpY2F0aW9uICovXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIDA9TVBFRy0yLzIuNSAxPU1QRUctMVxuICAgICAqL1xuICAgIHRoaXMudmVyc2lvbiA9IDA7XG4gICAgdGhpcy5lbmNvZGVyX2RlbGF5ID0gMDtcbiAgICAvKipcbiAgICAgKiBudW1iZXIgb2Ygc2FtcGxlcyBvZiBwYWRkaW5nIGFwcGVuZGVkIHRvIGlucHV0XG4gICAgICovXG4gICAgdGhpcy5lbmNvZGVyX3BhZGRpbmcgPSAwO1xuICAgIHRoaXMuZnJhbWVzaXplID0gMDtcbiAgICAvKipcbiAgICAgKiBudW1iZXIgb2YgZnJhbWVzIGVuY29kZWRcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lTnVtID0gMDtcbiAgICAvKipcbiAgICAgKiBpcyB0aGlzIHN0cnVjdCBvd25lZCBieSBjYWxsaW5nIHByb2dyYW0gb3IgbGFtZT9cbiAgICAgKi9cbiAgICB0aGlzLmxhbWVfYWxsb2NhdGVkX2dmcCA9IDA7XG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qIG1vcmUgaW50ZXJuYWwgdmFyaWFibGVzIGFyZSBzdG9yZWQgaW4gdGhpcyBzdHJ1Y3R1cmU6ICovXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIHRoaXMuaW50ZXJuYWxfZmxhZ3MgPSBudWxsO1xufVxuXG52YXIgTGFtZUdsb2JhbEZsYWdzXzEgPSBMYW1lR2xvYmFsRmxhZ3M7XG5cbnZhciBMM1NpZGUkMSA9IHt9O1xuXG5cblx0LyoqXG5cdCAqIG1heCBzY2FsZWZhY3RvciBiYW5kLCBtYXgoU0JNQVhfbCwgU0JNQVhfcyozLCAoU0JNQVhfcy0zKSozKzgpXG5cdCAqL1xuTDNTaWRlJDEuU0ZCTUFYID0gKEVuY29kZXJfMS5TQk1BWF9zICogMyk7XG5cbnZhciBMM1NpZGVfMSA9IEwzU2lkZSQxO1xuXG52YXIgbmV3X2Zsb2F0JDEwID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfaW50JDEwID0gY29tbW9uLm5ld19pbnQ7XG5mdW5jdGlvbiBHckluZm8oKSB7XG4gICAgLy9mbG9hdCB4cltdID0gbmV3IGZsb2F0WzU3Nl07XG4gICAgdGhpcy54ciA9IG5ld19mbG9hdCQxMCg1NzYpO1xuICAgIC8vaW50IGwzX2VuY1tdID0gbmV3IGludFs1NzZdO1xuICAgIHRoaXMubDNfZW5jID0gbmV3X2ludCQxMCg1NzYpO1xuICAgIC8vaW50IHNjYWxlZmFjW10gPSBuZXcgaW50W0wzU2lkZS5TRkJNQVhdO1xuICAgIHRoaXMuc2NhbGVmYWMgPSBuZXdfaW50JDEwKEwzU2lkZV8xLlNGQk1BWCk7XG4gICAgdGhpcy54cnBvd19tYXggPSAwLjtcblxuICAgIHRoaXMucGFydDJfM19sZW5ndGggPSAwO1xuICAgIHRoaXMuYmlnX3ZhbHVlcyA9IDA7XG4gICAgdGhpcy5jb3VudDEgPSAwO1xuICAgIHRoaXMuZ2xvYmFsX2dhaW4gPSAwO1xuICAgIHRoaXMuc2NhbGVmYWNfY29tcHJlc3MgPSAwO1xuICAgIHRoaXMuYmxvY2tfdHlwZSA9IDA7XG4gICAgdGhpcy5taXhlZF9ibG9ja19mbGFnID0gMDtcbiAgICB0aGlzLnRhYmxlX3NlbGVjdCA9IG5ld19pbnQkMTAoMyk7XG4gICAgdGhpcy5zdWJibG9ja19nYWluID0gbmV3X2ludCQxMCgzICsgMSk7XG4gICAgdGhpcy5yZWdpb24wX2NvdW50ID0gMDtcbiAgICB0aGlzLnJlZ2lvbjFfY291bnQgPSAwO1xuICAgIHRoaXMucHJlZmxhZyA9IDA7XG4gICAgdGhpcy5zY2FsZWZhY19zY2FsZSA9IDA7XG4gICAgdGhpcy5jb3VudDF0YWJsZV9zZWxlY3QgPSAwO1xuXG4gICAgdGhpcy5wYXJ0Ml9sZW5ndGggPSAwO1xuICAgIHRoaXMuc2ZiX2xtYXggPSAwO1xuICAgIHRoaXMuc2ZiX3NtaW4gPSAwO1xuICAgIHRoaXMucHN5X2xtYXggPSAwO1xuICAgIHRoaXMuc2ZibWF4ID0gMDtcbiAgICB0aGlzLnBzeW1heCA9IDA7XG4gICAgdGhpcy5zZmJkaXZpZGUgPSAwO1xuICAgIHRoaXMud2lkdGggPSBuZXdfaW50JDEwKEwzU2lkZV8xLlNGQk1BWCk7XG4gICAgdGhpcy53aW5kb3cgPSBuZXdfaW50JDEwKEwzU2lkZV8xLlNGQk1BWCk7XG4gICAgdGhpcy5jb3VudDFiaXRzID0gMDtcbiAgICAvKipcbiAgICAgKiBhZGRlZCBmb3IgTFNGXG4gICAgICovXG4gICAgdGhpcy5zZmJfcGFydGl0aW9uX3RhYmxlID0gbnVsbDtcbiAgICB0aGlzLnNsZW4gPSBuZXdfaW50JDEwKDQpO1xuXG4gICAgdGhpcy5tYXhfbm9uemVyb19jb2VmZiA9IDA7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gY2xvbmVfaW50KGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShhcnJheSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lX2Zsb2F0KGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGFycmF5KTtcbiAgICB9XG4gICAgdGhpcy5hc3NpZ24gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgc2VsZi54ciA9IGNsb25lX2Zsb2F0KG90aGVyLnhyKTsgLy8uc2xpY2UoMCk7IC8vY2xvbmUoKTtcbiAgICAgICAgc2VsZi5sM19lbmMgPSBjbG9uZV9pbnQob3RoZXIubDNfZW5jKTsgLy8uc2xpY2UoMCk7IC8vY2xvbmUoKTtcbiAgICAgICAgc2VsZi5zY2FsZWZhYyA9IGNsb25lX2ludChvdGhlci5zY2FsZWZhYyk7Ly8uc2xpY2UoMCk7IC8vY2xvbmUoKTtcbiAgICAgICAgc2VsZi54cnBvd19tYXggPSBvdGhlci54cnBvd19tYXg7XG5cbiAgICAgICAgc2VsZi5wYXJ0Ml8zX2xlbmd0aCA9IG90aGVyLnBhcnQyXzNfbGVuZ3RoO1xuICAgICAgICBzZWxmLmJpZ192YWx1ZXMgPSBvdGhlci5iaWdfdmFsdWVzO1xuICAgICAgICBzZWxmLmNvdW50MSA9IG90aGVyLmNvdW50MTtcbiAgICAgICAgc2VsZi5nbG9iYWxfZ2FpbiA9IG90aGVyLmdsb2JhbF9nYWluO1xuICAgICAgICBzZWxmLnNjYWxlZmFjX2NvbXByZXNzID0gb3RoZXIuc2NhbGVmYWNfY29tcHJlc3M7XG4gICAgICAgIHNlbGYuYmxvY2tfdHlwZSA9IG90aGVyLmJsb2NrX3R5cGU7XG4gICAgICAgIHNlbGYubWl4ZWRfYmxvY2tfZmxhZyA9IG90aGVyLm1peGVkX2Jsb2NrX2ZsYWc7XG4gICAgICAgIHNlbGYudGFibGVfc2VsZWN0ID0gY2xvbmVfaW50KG90aGVyLnRhYmxlX3NlbGVjdCk7Ly8uc2xpY2UoMCk7IC8vY2xvbmUoKTtcbiAgICAgICAgc2VsZi5zdWJibG9ja19nYWluID0gY2xvbmVfaW50KG90aGVyLnN1YmJsb2NrX2dhaW4pOyAvLy5zbGljZSgwKTsgLy8uY2xvbmUoKTtcbiAgICAgICAgc2VsZi5yZWdpb24wX2NvdW50ID0gb3RoZXIucmVnaW9uMF9jb3VudDtcbiAgICAgICAgc2VsZi5yZWdpb24xX2NvdW50ID0gb3RoZXIucmVnaW9uMV9jb3VudDtcbiAgICAgICAgc2VsZi5wcmVmbGFnID0gb3RoZXIucHJlZmxhZztcbiAgICAgICAgc2VsZi5zY2FsZWZhY19zY2FsZSA9IG90aGVyLnNjYWxlZmFjX3NjYWxlO1xuICAgICAgICBzZWxmLmNvdW50MXRhYmxlX3NlbGVjdCA9IG90aGVyLmNvdW50MXRhYmxlX3NlbGVjdDtcblxuICAgICAgICBzZWxmLnBhcnQyX2xlbmd0aCA9IG90aGVyLnBhcnQyX2xlbmd0aDtcbiAgICAgICAgc2VsZi5zZmJfbG1heCA9IG90aGVyLnNmYl9sbWF4O1xuICAgICAgICBzZWxmLnNmYl9zbWluID0gb3RoZXIuc2ZiX3NtaW47XG4gICAgICAgIHNlbGYucHN5X2xtYXggPSBvdGhlci5wc3lfbG1heDtcbiAgICAgICAgc2VsZi5zZmJtYXggPSBvdGhlci5zZmJtYXg7XG4gICAgICAgIHNlbGYucHN5bWF4ID0gb3RoZXIucHN5bWF4O1xuICAgICAgICBzZWxmLnNmYmRpdmlkZSA9IG90aGVyLnNmYmRpdmlkZTtcbiAgICAgICAgc2VsZi53aWR0aCA9IGNsb25lX2ludChvdGhlci53aWR0aCk7IC8vLnNsaWNlKDApOyAvLy5jbG9uZSgpO1xuICAgICAgICBzZWxmLndpbmRvdyA9IGNsb25lX2ludChvdGhlci53aW5kb3cpOyAvLy5zbGljZSgwKTsgLy8uY2xvbmUoKTtcbiAgICAgICAgc2VsZi5jb3VudDFiaXRzID0gb3RoZXIuY291bnQxYml0cztcblxuICAgICAgICBzZWxmLnNmYl9wYXJ0aXRpb25fdGFibGUgPSBvdGhlci5zZmJfcGFydGl0aW9uX3RhYmxlLnNsaWNlKDApOyAvLy5jbG9uZSgpO1xuICAgICAgICBzZWxmLnNsZW4gPSBjbG9uZV9pbnQob3RoZXIuc2xlbik7IC8vLnNsaWNlKDApOyAvLy5jbG9uZSgpO1xuICAgICAgICBzZWxmLm1heF9ub256ZXJvX2NvZWZmID0gb3RoZXIubWF4X25vbnplcm9fY29lZmY7XG4gICAgfTtcbn1cblxudmFyIEdySW5mb18xID0gR3JJbmZvO1xuXG52YXIgbmV3X2ludCQ5ID0gY29tbW9uLm5ld19pbnQ7XG5mdW5jdGlvbiBJSUlTaWRlSW5mbygpIHtcbiAgICB0aGlzLnR0ID0gW1tudWxsLCBudWxsXSwgW251bGwsIG51bGxdXTtcbiAgICB0aGlzLm1haW5fZGF0YV9iZWdpbiA9IDA7XG4gICAgdGhpcy5wcml2YXRlX2JpdHMgPSAwO1xuICAgIHRoaXMucmVzdkRyYWluX3ByZSA9IDA7XG4gICAgdGhpcy5yZXN2RHJhaW5fcG9zdCA9IDA7XG4gICAgdGhpcy5zY2ZzaSA9IFtuZXdfaW50JDkoNCksIG5ld19pbnQkOSg0KV07XG5cbiAgICBmb3IgKHZhciBnciA9IDA7IGdyIDwgMjsgZ3IrKykge1xuICAgICAgICBmb3IgKHZhciBjaCA9IDA7IGNoIDwgMjsgY2grKykge1xuICAgICAgICAgICAgdGhpcy50dFtncl1bY2hdID0gbmV3IEdySW5mb18xKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBJSUlTaWRlSW5mb18xID0gSUlJU2lkZUluZm87XG5cbi8vcGFja2FnZSBtcDM7XG5cbi8qKlxuICogTGF5ZXIgSUlJIHNpZGUgaW5mb3JtYXRpb24uXG4gKlxuICogQGF1dGhvciBLZW5cbiAqXG4gKi9cblxuXG52YXIgU3lzdGVtJDExID0gY29tbW9uLlN5c3RlbTtcbnZhciBuZXdfaW50JDExID0gY29tbW9uLm5ld19pbnQ7XG5mdW5jdGlvbiBTY2FsZUZhYyhhcnJMLCBhcnJTLCBhcnIyMSwgYXJyMTIpIHtcblxuICAgIHRoaXMubCA9IG5ld19pbnQkMTEoMSArIEVuY29kZXJfMS5TQk1BWF9sKTtcbiAgICB0aGlzLnMgPSBuZXdfaW50JDExKDEgKyBFbmNvZGVyXzEuU0JNQVhfcyk7XG4gICAgdGhpcy5wc2ZiMjEgPSBuZXdfaW50JDExKDEgKyBFbmNvZGVyXzEuUFNGQjIxKTtcbiAgICB0aGlzLnBzZmIxMiA9IG5ld19pbnQkMTEoMSArIEVuY29kZXJfMS5QU0ZCMTIpO1xuICAgIHZhciBsID0gdGhpcy5sO1xuICAgIHZhciBzID0gdGhpcy5zO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gNCkge1xuICAgICAgICAvL3B1YmxpYyBTY2FsZUZhYyhmaW5hbCBpbnRbXSBhcnJMLCBmaW5hbCBpbnRbXSBhcnJTLCBmaW5hbCBpbnRbXSBhcnIyMSxcbiAgICAgICAgLy8gICAgZmluYWwgaW50W10gYXJyMTIpIHtcbiAgICAgICAgdGhpcy5hcnJMID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB0aGlzLmFyclMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHRoaXMuYXJyMjEgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIHRoaXMuYXJyMTIgPSBhcmd1bWVudHNbM107XG5cbiAgICAgICAgU3lzdGVtJDExLmFycmF5Y29weSh0aGlzLmFyckwsIDAsIGwsIDAsIE1hdGgubWluKHRoaXMuYXJyTC5sZW5ndGgsIHRoaXMubC5sZW5ndGgpKTtcbiAgICAgICAgU3lzdGVtJDExLmFycmF5Y29weSh0aGlzLmFyclMsIDAsIHMsIDAsIE1hdGgubWluKHRoaXMuYXJyUy5sZW5ndGgsIHRoaXMucy5sZW5ndGgpKTtcbiAgICAgICAgU3lzdGVtJDExLmFycmF5Y29weSh0aGlzLmFycjIxLCAwLCB0aGlzLnBzZmIyMSwgMCwgTWF0aC5taW4odGhpcy5hcnIyMS5sZW5ndGgsIHRoaXMucHNmYjIxLmxlbmd0aCkpO1xuICAgICAgICBTeXN0ZW0kMTEuYXJyYXljb3B5KHRoaXMuYXJyMTIsIDAsIHRoaXMucHNmYjEyLCAwLCBNYXRoLm1pbih0aGlzLmFycjEyLmxlbmd0aCwgdGhpcy5wc2ZiMTIubGVuZ3RoKSk7XG4gICAgfVxufVxuXG52YXIgU2NhbGVGYWNfMSA9IFNjYWxlRmFjO1xuXG52YXIgbmV3X2Zsb2F0JDEyID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfZmxvYXRfbiQxMiA9IGNvbW1vbi5uZXdfZmxvYXRfbjtcbnZhciBuZXdfaW50JDEyID0gY29tbW9uLm5ld19pbnQ7XG4vL3BhY2thZ2UgbXAzO1xuXG4vKipcbiAqIFZhcmlhYmxlcyB1c2VkIGZvciAtLW5zcHN5dHVuZVxuICpcbiAqIEBhdXRob3IgS2VuXG4gKlxuICovXG5mdW5jdGlvbiBOc1BzeSgpIHtcbiAgICB0aGlzLmxhc3RfZW5fc3Vic2hvcnQgPSBuZXdfZmxvYXRfbiQxMihbNCwgOV0pO1xuICAgIHRoaXMubGFzdEF0dGFja3MgPSBuZXdfaW50JDEyKDQpO1xuICAgIHRoaXMucGVmaXJidWYgPSBuZXdfZmxvYXQkMTIoMTkpO1xuICAgIHRoaXMubG9uZ2ZhY3QgPSBuZXdfZmxvYXQkMTIoRW5jb2Rlcl8xLlNCTUFYX2wpO1xuICAgIHRoaXMuc2hvcnRmYWN0ID0gbmV3X2Zsb2F0JDEyKEVuY29kZXJfMS5TQk1BWF9zKTtcblxuICAgIC8qKlxuICAgICAqIHNob3J0IGJsb2NrIHR1bmluZ1xuICAgICAqL1xuICAgIHRoaXMuYXR0YWNrdGhyZSA9IDAuO1xuICAgIHRoaXMuYXR0YWNrdGhyZV9zID0gMC47XG59XG5cbnZhciBOc1BzeV8xID0gTnNQc3k7XG5cbi8vcGFja2FnZSBtcDM7XG5cbmZ1bmN0aW9uIFZCUlNlZWtJbmZvKCkge1xuICAgIC8qKlxuICAgICAqIFdoYXQgd2UgaGF2ZSBzZWVuIHNvIGZhci5cbiAgICAgKi9cbiAgICB0aGlzLnN1bSA9IDA7XG4gICAgLyoqXG4gICAgICogSG93IG1hbnkgZnJhbWVzIHdlIGhhdmUgc2VlbiBpbiB0aGlzIGNodW5rLlxuICAgICAqL1xuICAgIHRoaXMuc2VlbiA9IDA7XG4gICAgLyoqXG4gICAgICogSG93IG1hbnkgZnJhbWVzIHdlIHdhbnQgdG8gY29sbGVjdCBpbnRvIG9uZSBjaHVuay5cbiAgICAgKi9cbiAgICB0aGlzLndhbnQgPSAwO1xuICAgIC8qKlxuICAgICAqIEFjdHVhbCBwb3NpdGlvbiBpbiBvdXIgYmFnLlxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBTaXplIG9mIG91ciBiYWcuXG4gICAgICovXG4gICAgdGhpcy5zaXplID0gMDtcbiAgICAvKipcbiAgICAgKiBQb2ludGVyIHRvIG91ciBiYWcuXG4gICAgICovXG4gICAgdGhpcy5iYWcgPSBudWxsO1xuICAgIHRoaXMublZick51bUZyYW1lcyA9IDA7XG4gICAgdGhpcy5uQnl0ZXNXcml0dGVuID0gMDtcbiAgICAvKiBWQlIgdGFnIGRhdGEgKi9cbiAgICB0aGlzLlRvdGFsRnJhbWVTaXplID0gMDtcbn1cblxudmFyIFZCUlNlZWtJbmZvXzEgPSBWQlJTZWVrSW5mbztcblxudmFyIG5ld19ieXRlJDggPSBjb21tb24ubmV3X2J5dGU7XG52YXIgbmV3X2RvdWJsZSQ4ID0gY29tbW9uLm5ld19kb3VibGU7XG52YXIgbmV3X2Zsb2F0JDggPSBjb21tb24ubmV3X2Zsb2F0O1xudmFyIG5ld19mbG9hdF9uJDggPSBjb21tb24ubmV3X2Zsb2F0X247XG52YXIgbmV3X2ludCQ4ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgbmV3X2ludF9uJDggPSBjb21tb24ubmV3X2ludF9uO1xuTGFtZUludGVybmFsRmxhZ3MkMS5NRlNJWkUgPSAoMyAqIDExNTIgKyBFbmNvZGVyXzEuRU5DREVMQVkgLSBFbmNvZGVyXzEuTURDVERFTEFZKTtcbkxhbWVJbnRlcm5hbEZsYWdzJDEuTUFYX0hFQURFUl9CVUYgPSAyNTY7XG5MYW1lSW50ZXJuYWxGbGFncyQxLk1BWF9CSVRTX1BFUl9DSEFOTkVMID0gNDA5NTtcbkxhbWVJbnRlcm5hbEZsYWdzJDEuTUFYX0JJVFNfUEVSX0dSQU5VTEUgPSA3NjgwO1xuTGFtZUludGVybmFsRmxhZ3MkMS5CUEMgPSAzMjA7XG5cbmZ1bmN0aW9uIExhbWVJbnRlcm5hbEZsYWdzJDEoKSB7XG4gICAgdmFyIE1BWF9IRUFERVJfTEVOID0gNDA7XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIGludGVybmFsIHZhcmlhYmxlcyBOT1Qgc2V0IGJ5IGNhbGxpbmcgcHJvZ3JhbSwgYW5kIHNob3VsZCBub3QgYmUgKlxuICAgICAqIG1vZGlmaWVkIGJ5IHRoZSBjYWxsaW5nIHByb2dyYW0gKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIFNvbWUgcmVtYXJrcyB0byB0aGUgQ2xhc3NfSUQgZmllbGQ6IFRoZSBDbGFzcyBJRCBpcyBhbiBJZGVudGlmaWVyIGZvciBhXG4gICAgICogcG9pbnRlciB0byB0aGlzIHN0cnVjdC4gSXQgaXMgdmVyeSB1bmxpa2VseSB0aGF0IGEgcG9pbnRlciB0b1xuICAgICAqIGxhbWVfZ2xvYmFsX2ZsYWdzIGhhcyB0aGUgc2FtZSAzMiBiaXRzIGluIGl0J3Mgc3RydWN0dXJlIChsYXJnZSBhbmQgb3RoZXJcbiAgICAgKiBzcGVjaWFsIHByb3BlcnRpZXMsIGZvciBpbnN0YW5jZSBwcmltZSkuXG4gICAgICpcbiAgICAgKiBUbyB0ZXN0IHRoYXQgdGhlIHN0cnVjdHVyZSBpcyByaWdodCBhbmQgaW5pdGlhbGl6ZWQsIHVzZTogaWYgKCBnZmMgLlxuICAgICAqIENsYXNzX0lEID09IExBTUVfSUQgKSAuLi4gT3RoZXIgcmVtYXJrOiBJZiB5b3Ugc2V0IGEgZmxhZyB0byAwIGZvciB1bmluaXRcbiAgICAgKiBkYXRhIGFuZCAxIGZvciBpbml0IGRhdGEsIHRoZSByaWdodCB0ZXN0IHNob3VsZCBiZSBcImlmIChmbGFnID09IDEpXCIgYW5kXG4gICAgICogTk9UIFwiaWYgKGZsYWcpXCIuIFVuaW50ZW5kZWQgbW9kaWZpY2F0aW9uIG9mIHRoaXMgZWxlbWVudCB3aWxsIGJlXG4gICAgICogb3RoZXJ3aXNlIG1pc2ludGVycHJldGVkIGFzIGFuIGluaXQuXG4gICAgICovXG4gICAgdGhpcy5DbGFzc19JRCA9IDA7XG5cbiAgICB0aGlzLmxhbWVfZW5jb2RlX2ZyYW1lX2luaXQgPSAwO1xuICAgIHRoaXMuaXRlcmF0aW9uX2luaXRfaW5pdCA9IDA7XG4gICAgdGhpcy5maWxsX2J1ZmZlcl9yZXNhbXBsZV9pbml0ID0gMDtcblxuICAgIC8vcHVibGljIGZsb2F0IG1mYnVmW11bXSA9IG5ldyBmbG9hdFsyXVtNRlNJWkVdO1xuICAgIHRoaXMubWZidWYgPSBuZXdfZmxvYXRfbiQ4KFsyLCBMYW1lSW50ZXJuYWxGbGFncyQxLk1GU0laRV0pO1xuXG4gICAgLyoqXG4gICAgICogZ3JhbnVsZXMgcGVyIGZyYW1lXG4gICAgICovXG4gICAgdGhpcy5tb2RlX2dyID0gMDtcbiAgICAvKipcbiAgICAgKiBudW1iZXIgb2YgY2hhbm5lbHMgaW4gdGhlIGlucHV0IGRhdGEgc3RyZWFtIChQQ00gb3IgZGVjb2RlZCBQQ00pXG4gICAgICovXG4gICAgdGhpcy5jaGFubmVsc19pbiA9IDA7XG4gICAgLyoqXG4gICAgICogbnVtYmVyIG9mIGNoYW5uZWxzIGluIHRoZSBvdXRwdXQgZGF0YSBzdHJlYW0gKG5vdCB1c2VkIGZvciBkZWNvZGluZylcbiAgICAgKi9cbiAgICB0aGlzLmNoYW5uZWxzX291dCA9IDA7XG4gICAgLyoqXG4gICAgICogaW5wdXRfc2FtcF9yYXRlL291dHB1dF9zYW1wX3JhdGVcbiAgICAgKi9cbiAgICAgICAgLy9wdWJsaWMgZG91YmxlIHJlc2FtcGxlX3JhdGlvO1xuICAgIHRoaXMucmVzYW1wbGVfcmF0aW8gPSAwLjtcblxuICAgIHRoaXMubWZfc2FtcGxlc190b19lbmNvZGUgPSAwO1xuICAgIHRoaXMubWZfc2l6ZSA9IDA7XG4gICAgLyoqXG4gICAgICogbWluIGJpdHJhdGUgaW5kZXhcbiAgICAgKi9cbiAgICB0aGlzLlZCUl9taW5fYml0cmF0ZSA9IDA7XG4gICAgLyoqXG4gICAgICogbWF4IGJpdHJhdGUgaW5kZXhcbiAgICAgKi9cbiAgICB0aGlzLlZCUl9tYXhfYml0cmF0ZSA9IDA7XG4gICAgdGhpcy5iaXRyYXRlX2luZGV4ID0gMDtcbiAgICB0aGlzLnNhbXBsZXJhdGVfaW5kZXggPSAwO1xuICAgIHRoaXMubW9kZV9leHQgPSAwO1xuXG4gICAgLyogbG93cGFzcyBhbmQgaGlnaHBhc3MgZmlsdGVyIGNvbnRyb2wgKi9cbiAgICAvKipcbiAgICAgKiBub3JtYWxpemVkIGZyZXF1ZW5jeSBib3VuZHMgb2YgcGFzc2JhbmRcbiAgICAgKi9cbiAgICB0aGlzLmxvd3Bhc3MxID0gMC47XG4gICAgdGhpcy5sb3dwYXNzMiA9IDAuO1xuICAgIC8qKlxuICAgICAqIG5vcm1hbGl6ZWQgZnJlcXVlbmN5IGJvdW5kcyBvZiBwYXNzYmFuZFxuICAgICAqL1xuICAgIHRoaXMuaGlnaHBhc3MxID0gMC47XG4gICAgdGhpcy5oaWdocGFzczIgPSAwLjtcblxuICAgIC8qKlxuICAgICAqIDAgPSBub25lIDEgPSBJU08gQUFDIG1vZGVsIDIgPSBhbGxvdyBzY2FsZWZhY19zZWxlY3Q9MVxuICAgICAqL1xuICAgIHRoaXMubm9pc2Vfc2hhcGluZyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiAwID0gSVNPIG1vZGVsOiBhbXBsaWZ5IGFsbCBkaXN0b3J0ZWQgYmFuZHM8QlI+XG4gICAgICogMSA9IGFtcGxpZnkgd2l0aGluIDUwJSBvZiBtYXggKG9uIGRiIHNjYWxlKTxCUj5cbiAgICAgKiAyID0gYW1wbGlmeSBvbmx5IG1vc3QgZGlzdG9ydGVkIGJhbmQ8QlI+XG4gICAgICogMyA9IG1ldGhvZCAxIGFuZCByZWZpbmUgd2l0aCBtZXRob2QgMjxCUj5cbiAgICAgKi9cbiAgICB0aGlzLm5vaXNlX3NoYXBpbmdfYW1wID0gMDtcbiAgICAvKipcbiAgICAgKiAwID0gbm8gc3Vic3RlcDxCUj5cbiAgICAgKiAxID0gdXNlIHN1YnN0ZXAgc2hhcGluZyBhdCBsYXN0IHN0ZXAoVkJSIG9ubHkpPEJSPlxuICAgICAqIChub3QgaW1wbGVtZW50ZWQgeWV0KTxCUj5cbiAgICAgKiAyID0gdXNlIHN1YnN0ZXAgaW5zaWRlIGxvb3A8QlI+XG4gICAgICogMyA9IHVzZSBzdWJzdGVwIGluc2lkZSBsb29wIGFuZCBsYXN0IHN0ZXA8QlI+XG4gICAgICovXG4gICAgdGhpcy5zdWJzdGVwX3NoYXBpbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogMSA9IGdwc3ljaG8uIDAgPSBub25lXG4gICAgICovXG4gICAgdGhpcy5wc3ltb2RlbCA9IDA7XG4gICAgLyoqXG4gICAgICogMCA9IHN0b3AgYXQgb3Zlcj0wLCBhbGwgc2NhbGVmYWNzIGFtcGxpZmllZCBvcjxCUj5cbiAgICAgKiBhIHNjYWxlZmFjIGhhcyByZWFjaGVkIG1heCB2YWx1ZTxCUj5cbiAgICAgKiAxID0gc3RvcCB3aGVuIGFsbCBzY2FsZWZhY3MgYW1wbGlmaWVkIG9yIGEgc2NhbGVmYWMgaGFzIHJlYWNoZWQgbWF4IHZhbHVlPEJSPlxuICAgICAqIDIgPSBzdG9wIHdoZW4gYWxsIHNjYWxlZmFjcyBhbXBsaWZpZWRcbiAgICAgKi9cbiAgICB0aGlzLm5vaXNlX3NoYXBpbmdfc3RvcCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiAwID0gbm8sIDEgPSB5ZXNcbiAgICAgKi9cbiAgICB0aGlzLnN1YmJsb2NrX2dhaW4gPSAwO1xuICAgIC8qKlxuICAgICAqIDAgPSBuby4gMT1vdXRzaWRlIGxvb3AgMj1pbnNpZGUgbG9vcChzbG93KVxuICAgICAqL1xuICAgIHRoaXMudXNlX2Jlc3RfaHVmZm1hbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiAwID0gc3RvcCBlYXJseSBhZnRlciAwIGRpc3RvcnRpb24gZm91bmQuIDEgPSBmdWxsIHNlYXJjaFxuICAgICAqL1xuICAgIHRoaXMuZnVsbF9vdXRlcl9sb29wID0gMDtcblxuICAgIC8vcHVibGljIElJSVNpZGVJbmZvIGwzX3NpZGUgPSBuZXcgSUlJU2lkZUluZm8oKTtcbiAgICB0aGlzLmwzX3NpZGUgPSBuZXcgSUlJU2lkZUluZm9fMSgpO1xuICAgIHRoaXMubXNfcmF0aW8gPSBuZXdfZmxvYXQkOCgyKTtcblxuICAgIC8qIHVzZWQgZm9yIHBhZGRpbmcgKi9cbiAgICAvKipcbiAgICAgKiBwYWRkaW5nIGZvciB0aGUgY3VycmVudCBmcmFtZT9cbiAgICAgKi9cbiAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICAgIHRoaXMuZnJhY19TcEYgPSAwO1xuICAgIHRoaXMuc2xvdF9sYWcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogb3B0aW9uYWwgSUQzIHRhZ3NcbiAgICAgKi9cbiAgICAgICAgLy9wdWJsaWMgSUQzVGFnU3BlYyB0YWdfc3BlYztcbiAgICB0aGlzLnRhZ19zcGVjID0gbnVsbDtcbiAgICB0aGlzLm5NdXNpY0NSQyA9IDA7XG5cbiAgICAvKiB2YXJpYWJsZXMgdXNlZCBieSBRdWFudGl6ZSAqL1xuICAgIC8vcHVibGljIGludCBPbGRWYWx1ZVtdID0gbmV3IGludFsyXTtcbiAgICB0aGlzLk9sZFZhbHVlID0gbmV3X2ludCQ4KDIpO1xuICAgIC8vcHVibGljIGludCBDdXJyZW50U3RlcFtdID0gbmV3IGludFsyXTtcbiAgICB0aGlzLkN1cnJlbnRTdGVwID0gbmV3X2ludCQ4KDIpO1xuXG4gICAgdGhpcy5tYXNraW5nX2xvd2VyID0gMC47XG4gICAgLy9wdWJsaWMgaW50IGJ2X3NjZltdID0gbmV3IGludFs1NzZdO1xuICAgIHRoaXMuYnZfc2NmID0gbmV3X2ludCQ4KDU3Nik7XG4gICAgLy9wdWJsaWMgaW50IHBzZXVkb2hhbGZbXSA9IG5ldyBpbnRbTDNTaWRlLlNGQk1BWF07XG4gICAgdGhpcy5wc2V1ZG9oYWxmID0gbmV3X2ludCQ4KEwzU2lkZV8xLlNGQk1BWCk7XG5cbiAgICAvKipcbiAgICAgKiB3aWxsIGJlIHNldCBpbiBsYW1lX2luaXRfcGFyYW1zXG4gICAgICovXG4gICAgdGhpcy5zZmIyMV9leHRyYSA9IGZhbHNlO1xuXG4gICAgLyogQlBDID0gbWF4aW11bSBudW1iZXIgb2YgZmlsdGVyIGNvbnZvbHV0aW9uIHdpbmRvd3MgdG8gcHJlY29tcHV0ZSAqL1xuICAgIC8vcHVibGljIGZsb2F0W11bXSBpbmJ1Zl9vbGQgPSBuZXcgZmxvYXRbMl1bXTtcbiAgICB0aGlzLmluYnVmX29sZCA9IG5ldyBBcnJheSgyKTtcbiAgICAvL3B1YmxpYyBmbG9hdFtdW10gYmxhY2tmaWx0ID0gbmV3IGZsb2F0WzIgKiBCUEMgKyAxXVtdO1xuICAgIHRoaXMuYmxhY2tmaWx0ID0gbmV3IEFycmF5KDIgKiBMYW1lSW50ZXJuYWxGbGFncyQxLkJQQyArIDEpO1xuICAgIC8vcHVibGljIGRvdWJsZSBpdGltZVtdID0gbmV3IGRvdWJsZVsyXTtcbiAgICB0aGlzLml0aW1lID0gbmV3X2RvdWJsZSQ4KDIpO1xuICAgIHRoaXMuc2lkZWluZm9fbGVuID0gMDtcblxuICAgIC8qIHZhcmlhYmxlcyBmb3IgbmV3bWRjdC5jICovXG4gICAgLy9wdWJsaWMgZmxvYXQgc2Jfc2FtcGxlW11bXVtdW10gPSBuZXcgZmxvYXRbMl1bMl1bMThdW0VuY29kZXIuU0JMSU1JVF07XG4gICAgdGhpcy5zYl9zYW1wbGUgPSBuZXdfZmxvYXRfbiQ4KFsyLCAyLCAxOCwgRW5jb2Rlcl8xLlNCTElNSVRdKTtcbiAgICB0aGlzLmFtcF9maWx0ZXIgPSBuZXdfZmxvYXQkOCgzMik7XG5cbiAgICAvKiB2YXJpYWJsZXMgZm9yIEJpdFN0cmVhbSAqL1xuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiBtcGVnMTogYnVmZmVyPTUxMSBieXRlcyAgc21hbGxlc3QgZnJhbWU6IDk2LTM4KHNpZGVpbmZvKT01OFxuICAgICAqIG1heCBudW1iZXIgb2YgZnJhbWVzIGluIHJlc2Vydm9pcjogIDhcbiAgICAgKiBtcGVnMjogYnVmZmVyPTI1NSBieXRlcy4gIHNtYWxsZXN0IGZyYW1lOiAyNC0yM2J5dGVzPTFcbiAgICAgKiB3aXRoIFZCUiwgaWYgeW91IGFyZSBlbmNvZGluZyBhbGwgc2lsZW5jZSwgaXQgaXMgcG9zc2libGUgdG9cbiAgICAgKiBoYXZlIDhrYnMvMjRraHogZnJhbWVzIHdpdGggMWJ5dGUgb2YgZGF0YSBlYWNoLCB3aGljaCBtZWFucyB3ZSBuZWVkXG4gICAgICogdG8gYnVmZmVyIHVwIHRvIDI1NSBoZWFkZXJzIVxuICAgICAqIDwvUFJFPlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGFsc28sIG1heF9oZWFkZXJfYnVmIGhhcyB0byBiZSBhIHBvd2VyIG9mIHR3b1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIG1heCBzaXplIG9mIGhlYWRlciBpcyAzOFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gSGVhZGVyKCkge1xuICAgICAgICB0aGlzLndyaXRlX3RpbWluZyA9IDA7XG4gICAgICAgIHRoaXMucHRyID0gMDtcbiAgICAgICAgLy9wdWJsaWMgYnl0ZSBidWZbXSA9IG5ldyBieXRlW01BWF9IRUFERVJfTEVOXTtcbiAgICAgICAgdGhpcy5idWYgPSBuZXdfYnl0ZSQ4KE1BWF9IRUFERVJfTEVOKTtcbiAgICB9XG5cbiAgICB0aGlzLmhlYWRlciA9IG5ldyBBcnJheShMYW1lSW50ZXJuYWxGbGFncyQxLk1BWF9IRUFERVJfQlVGKTtcblxuICAgIHRoaXMuaF9wdHIgPSAwO1xuICAgIHRoaXMud19wdHIgPSAwO1xuICAgIHRoaXMuYW5jaWxsYXJ5X2ZsYWcgPSAwO1xuXG4gICAgLyogdmFyaWFibGVzIGZvciBSZXNlcnZvaXIgKi9cbiAgICAvKipcbiAgICAgKiBpbiBiaXRzXG4gICAgICovXG4gICAgdGhpcy5SZXN2U2l6ZSA9IDA7XG4gICAgLyoqXG4gICAgICogaW4gYml0c1xuICAgICAqL1xuICAgIHRoaXMuUmVzdk1heCA9IDA7XG5cbiAgICAvL3B1YmxpYyBTY2FsZUZhYyBzY2FsZWZhY19iYW5kID0gbmV3IFNjYWxlRmFjKCk7XG4gICAgdGhpcy5zY2FsZWZhY19iYW5kID0gbmV3IFNjYWxlRmFjXzEoKTtcblxuICAgIC8qIGRhYSBmcm9tIFBzeU1vZGVsICovXG4gICAgLyogVGhlIHN0YXRpYyB2YXJpYWJsZXMgXCJyXCIsIFwicGhpX3NhdlwiLCBcIm5ld1wiLCBcIm9sZFwiIGFuZCBcIm9sZGVzdFwiIGhhdmUgKi9cbiAgICAvKiB0byBiZSByZW1lbWJlcmVkIGZvciB0aGUgdW5wcmVkaWN0YWJpbGl0eSBtZWFzdXJlLiBGb3IgXCJyXCIgYW5kICovXG4gICAgLyogXCJwaGlfc2F2XCIsIHRoZSBmaXJzdCBpbmRleCBmcm9tIHRoZSBsZWZ0IGlzIHRoZSBjaGFubmVsIHNlbGVjdCBhbmQgKi9cbiAgICAvKiB0aGUgc2Vjb25kIGluZGV4IGlzIHRoZSBcImFnZVwiIG9mIHRoZSBkYXRhLiAqL1xuICAgIHRoaXMubWludmFsX2wgPSBuZXdfZmxvYXQkOChFbmNvZGVyXzEuQ0JBTkRTKTtcbiAgICB0aGlzLm1pbnZhbF9zID0gbmV3X2Zsb2F0JDgoRW5jb2Rlcl8xLkNCQU5EUyk7XG4gICAgdGhpcy5uYl8xID0gbmV3X2Zsb2F0X24kOChbNCwgRW5jb2Rlcl8xLkNCQU5EU10pO1xuICAgIHRoaXMubmJfMiA9IG5ld19mbG9hdF9uJDgoWzQsIEVuY29kZXJfMS5DQkFORFNdKTtcbiAgICB0aGlzLm5iX3MxID0gbmV3X2Zsb2F0X24kOChbNCwgRW5jb2Rlcl8xLkNCQU5EU10pO1xuICAgIHRoaXMubmJfczIgPSBuZXdfZmxvYXRfbiQ4KFs0LCBFbmNvZGVyXzEuQ0JBTkRTXSk7XG4gICAgdGhpcy5zM19zcyA9IG51bGw7XG4gICAgdGhpcy5zM19sbCA9IG51bGw7XG4gICAgdGhpcy5kZWNheSA9IDAuO1xuXG4gICAgLy9wdWJsaWMgSUlJX3BzeV94bWluW10gdGhtID0gbmV3IElJSV9wc3lfeG1pbls0XTtcbiAgICAvL3B1YmxpYyBJSUlfcHN5X3htaW5bXSBlbiA9IG5ldyBJSUlfcHN5X3htaW5bNF07XG4gICAgdGhpcy50aG0gPSBuZXcgQXJyYXkoNCk7XG4gICAgdGhpcy5lbiA9IG5ldyBBcnJheSg0KTtcblxuICAgIC8qKlxuICAgICAqIGZmdCBhbmQgZW5lcmd5IGNhbGN1bGF0aW9uXG4gICAgICovXG4gICAgdGhpcy50b3RfZW5lciA9IG5ld19mbG9hdCQ4KDQpO1xuXG4gICAgLyogbG91ZG5lc3MgY2FsY3VsYXRpb24gKGZvciBhZGFwdGl2ZSB0aHJlc2hvbGQgb2YgaGVhcmluZykgKi9cbiAgICAvKipcbiAgICAgKiBsb3VkbmVzc14yIGFwcHJveC4gcGVyIGdyYW51bGUgYW5kIGNoYW5uZWxcbiAgICAgKi9cbiAgICB0aGlzLmxvdWRuZXNzX3NxID0gbmV3X2Zsb2F0X24kOChbMiwgMl0pO1xuICAgIC8qKlxuICAgICAqIGFjY291bnQgZm9yIGdyYW51bGUgZGVsYXkgb2YgTDNwc3ljaG9fYW5hbFxuICAgICAqL1xuICAgIHRoaXMubG91ZG5lc3Nfc3Ffc2F2ZSA9IG5ld19mbG9hdCQ4KDIpO1xuXG4gICAgLyoqXG4gICAgICogU2NhbGUgRmFjdG9yIEJhbmRzXG4gICAgICovXG4gICAgdGhpcy5tbGRfbCA9IG5ld19mbG9hdCQ4KEVuY29kZXJfMS5TQk1BWF9sKTtcbiAgICB0aGlzLm1sZF9zID0gbmV3X2Zsb2F0JDgoRW5jb2Rlcl8xLlNCTUFYX3MpO1xuICAgIHRoaXMuYm1fbCA9IG5ld19pbnQkOChFbmNvZGVyXzEuU0JNQVhfbCk7XG4gICAgdGhpcy5ib19sID0gbmV3X2ludCQ4KEVuY29kZXJfMS5TQk1BWF9sKTtcbiAgICB0aGlzLmJtX3MgPSBuZXdfaW50JDgoRW5jb2Rlcl8xLlNCTUFYX3MpO1xuICAgIHRoaXMuYm9fcyA9IG5ld19pbnQkOChFbmNvZGVyXzEuU0JNQVhfcyk7XG4gICAgdGhpcy5ucGFydF9sID0gMDtcbiAgICB0aGlzLm5wYXJ0X3MgPSAwO1xuXG4gICAgdGhpcy5zM2luZCA9IG5ld19pbnRfbiQ4KFtFbmNvZGVyXzEuQ0JBTkRTLCAyXSk7XG4gICAgdGhpcy5zM2luZF9zID0gbmV3X2ludF9uJDgoW0VuY29kZXJfMS5DQkFORFMsIDJdKTtcblxuICAgIHRoaXMubnVtbGluZXNfcyA9IG5ld19pbnQkOChFbmNvZGVyXzEuQ0JBTkRTKTtcbiAgICB0aGlzLm51bWxpbmVzX2wgPSBuZXdfaW50JDgoRW5jb2Rlcl8xLkNCQU5EUyk7XG4gICAgdGhpcy5ybnVtbGluZXNfbCA9IG5ld19mbG9hdCQ4KEVuY29kZXJfMS5DQkFORFMpO1xuICAgIHRoaXMubWxkX2NiX2wgPSBuZXdfZmxvYXQkOChFbmNvZGVyXzEuQ0JBTkRTKTtcbiAgICB0aGlzLm1sZF9jYl9zID0gbmV3X2Zsb2F0JDgoRW5jb2Rlcl8xLkNCQU5EUyk7XG4gICAgdGhpcy5udW1saW5lc19zX251bTEgPSAwO1xuICAgIHRoaXMubnVtbGluZXNfbF9udW0xID0gMDtcblxuICAgIC8qIHJhdGlvcyAqL1xuICAgIHRoaXMucGUgPSBuZXdfZmxvYXQkOCg0KTtcbiAgICB0aGlzLm1zX3JhdGlvX3Nfb2xkID0gMC47XG4gICAgdGhpcy5tc19yYXRpb19sX29sZCA9IDAuO1xuICAgIHRoaXMubXNfZW5lcl9yYXRpb19vbGQgPSAwLjtcblxuICAgIC8qKlxuICAgICAqIGJsb2NrIHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLmJsb2NrdHlwZV9vbGQgPSBuZXdfaW50JDgoMik7XG5cbiAgICAvKipcbiAgICAgKiB2YXJpYWJsZXMgdXNlZCBmb3IgLS1uc3BzeXR1bmVcbiAgICAgKi9cbiAgICB0aGlzLm5zUHN5ID0gbmV3IE5zUHN5XzEoKTtcblxuICAgIC8qKlxuICAgICAqIHVzZWQgZm9yIFhpbmcgVkJSIGhlYWRlclxuICAgICAqL1xuICAgIHRoaXMuVkJSX3NlZWtfdGFibGUgPSBuZXcgVkJSU2Vla0luZm9fMSgpO1xuXG4gICAgLyoqXG4gICAgICogYWxsIEFUSCByZWxhdGVkIHN0dWZmXG4gICAgICovXG4gICAgICAgIC8vcHVibGljIEFUSCBBVEg7XG4gICAgdGhpcy5BVEggPSBudWxsO1xuXG4gICAgdGhpcy5QU1kgPSBudWxsO1xuXG4gICAgdGhpcy5ub2dhcF90b3RhbCA9IDA7XG4gICAgdGhpcy5ub2dhcF9jdXJyZW50ID0gMDtcblxuICAgIC8qIFJlcGxheUdhaW4gKi9cbiAgICB0aGlzLmRlY29kZV9vbl90aGVfZmx5ID0gdHJ1ZTtcbiAgICB0aGlzLmZpbmRSZXBsYXlHYWluID0gdHJ1ZTtcbiAgICB0aGlzLmZpbmRQZWFrU2FtcGxlID0gdHJ1ZTtcbiAgICB0aGlzLlBlYWtTYW1wbGUgPSAwLjtcbiAgICB0aGlzLlJhZGlvR2FpbiA9IDA7XG4gICAgdGhpcy5BdWRpb3BoaWxlR2FpbiA9IDA7XG4gICAgLy9wdWJsaWMgUmVwbGF5R2FpbiByZ2RhdGE7XG4gICAgdGhpcy5yZ2RhdGEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogZ2FpbiBjaGFuZ2UgcmVxdWlyZWQgZm9yIHByZXZlbnRpbmcgY2xpcHBpbmdcbiAgICAgKi9cbiAgICB0aGlzLm5vY2xpcEdhaW5DaGFuZ2UgPSAwO1xuICAgIC8qKlxuICAgICAqIHVzZXItc3BlY2lmaWVkIHNjYWxlIGZhY3RvciByZXF1aXJlZCBmb3IgcHJldmVudGluZyBjbGlwcGluZ1xuICAgICAqL1xuICAgIHRoaXMubm9jbGlwU2NhbGUgPSAwLjtcblxuICAgIC8qIHNpbXBsZSBzdGF0aXN0aWNzICovXG4gICAgdGhpcy5iaXRyYXRlX3N0ZXJlb01vZGVfSGlzdCA9IG5ld19pbnRfbiQ4KFsxNiwgNCArIDFdKTtcbiAgICAvKipcbiAgICAgKiBub3JtL3N0YXJ0L3Nob3J0L3N0b3AvbWl4ZWQoc2hvcnQpL3N1bVxuICAgICAqL1xuICAgIHRoaXMuYml0cmF0ZV9ibG9ja1R5cGVfSGlzdCA9IG5ld19pbnRfbiQ4KFsxNiwgNCArIDEgKyAxXSk7XG5cbiAgICAvL3B1YmxpYyBQbG90dGluZ0RhdGEgcGluZm87XG4gICAgLy9wdWJsaWMgTVBHTGliLm1wc3RyX3RhZyBoaXA7XG4gICAgdGhpcy5waW5mbyA9IG51bGw7XG4gICAgdGhpcy5oaXAgPSBudWxsO1xuXG4gICAgdGhpcy5pbl9idWZmZXJfbnNhbXBsZXMgPSAwO1xuICAgIC8vcHVibGljIGZsb2F0W10gaW5fYnVmZmVyXzA7XG4gICAgLy9wdWJsaWMgZmxvYXRbXSBpbl9idWZmZXJfMTtcbiAgICB0aGlzLmluX2J1ZmZlcl8wID0gbnVsbDtcbiAgICB0aGlzLmluX2J1ZmZlcl8xID0gbnVsbDtcblxuICAgIC8vcHVibGljIElJdGVyYXRpb25Mb29wIGl0ZXJhdGlvbl9sb29wO1xuICAgIHRoaXMuaXRlcmF0aW9uX2xvb3AgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZW5baV0gPSBuZXcgSUlJX3BzeV94bWluXzEoKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRobS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnRobVtpXSA9IG5ldyBJSUlfcHN5X3htaW5fMSgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyW2ldID0gbmV3IEhlYWRlcigpO1xuICAgIH1cblxufVxuXG52YXIgTGFtZUludGVybmFsRmxhZ3NfMSA9IExhbWVJbnRlcm5hbEZsYWdzJDE7XG5cbnZhciBuZXdfZmxvYXQkMTMgPSBjb21tb24ubmV3X2Zsb2F0O1xuLyoqXG4gKiBBVEggcmVsYXRlZCBzdHVmZiwgaWYgc29tZXRoaW5nIG5ldyBBVEggcmVsYXRlZCBoYXMgdG8gYmUgYWRkZWQsIHBsZWFzZSBwbHVnXG4gKiBpdCBoZXJlIGludG8gdGhlIEFUSC5cbiAqL1xuZnVuY3Rpb24gQVRIKCkge1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCBmb3IgdGhlIGF1dG8gYWRqdXN0bWVudC5cbiAgICAgKi9cbiAgICB0aGlzLnVzZUFkanVzdCA9IDA7XG4gICAgLyoqXG4gICAgICogZmFjdG9yIGZvciB0dW5pbmcgdGhlIChzYW1wbGUgcG93ZXIpIHBvaW50IGJlbG93IHdoaWNoIGFkYXB0aXZlIHRocmVzaG9sZFxuICAgICAqIG9mIGhlYXJpbmcgYWRqdXN0bWVudCBvY2N1cnNcbiAgICAgKi9cbiAgICB0aGlzLmFhU2Vuc2l0aXZpdHlQID0gMC47XG4gICAgLyoqXG4gICAgICogTG93ZXJpbmcgYmFzZWQgb24gcGVhayB2b2x1bWUsIDEgPSBubyBsb3dlcmluZy5cbiAgICAgKi9cbiAgICB0aGlzLmFkanVzdCA9IDAuO1xuICAgIC8qKlxuICAgICAqIExpbWl0IGZvciBkeW5hbWljIEFUSCBhZGp1c3QuXG4gICAgICovXG4gICAgdGhpcy5hZGp1c3RMaW1pdCA9IDAuO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZWQgdG8gbG93ZXIgeCBkQiBlYWNoIHNlY29uZC5cbiAgICAgKi9cbiAgICB0aGlzLmRlY2F5ID0gMC47XG4gICAgLyoqXG4gICAgICogTG93ZXN0IEFUSCB2YWx1ZS5cbiAgICAgKi9cbiAgICB0aGlzLmZsb29yID0gMC47XG4gICAgLyoqXG4gICAgICogQVRIIGZvciBzZmJzIGluIGxvbmcgYmxvY2tzLlxuICAgICAqL1xuICAgIHRoaXMubCA9IG5ld19mbG9hdCQxMyhFbmNvZGVyXzEuU0JNQVhfbCk7XG4gICAgLyoqXG4gICAgICogQVRIIGZvciBzZmJzIGluIHNob3J0IGJsb2Nrcy5cbiAgICAgKi9cbiAgICB0aGlzLnMgPSBuZXdfZmxvYXQkMTMoRW5jb2Rlcl8xLlNCTUFYX3MpO1xuICAgIC8qKlxuICAgICAqIEFUSCBmb3IgcGFydGl0aW9uZWQgc2ZiMjEgaW4gbG9uZyBibG9ja3MuXG4gICAgICovXG4gICAgdGhpcy5wc2ZiMjEgPSBuZXdfZmxvYXQkMTMoRW5jb2Rlcl8xLlBTRkIyMSk7XG4gICAgLyoqXG4gICAgICogQVRIIGZvciBwYXJ0aXRpb25lZCBzZmIxMiBpbiBzaG9ydCBibG9ja3MuXG4gICAgICovXG4gICAgdGhpcy5wc2ZiMTIgPSBuZXdfZmxvYXQkMTMoRW5jb2Rlcl8xLlBTRkIxMik7XG4gICAgLyoqXG4gICAgICogQVRIIGZvciBsb25nIGJsb2NrIGNvbnZvbHV0aW9uIGJhbmRzLlxuICAgICAqL1xuICAgIHRoaXMuY2JfbCA9IG5ld19mbG9hdCQxMyhFbmNvZGVyXzEuQ0JBTkRTKTtcbiAgICAvKipcbiAgICAgKiBBVEggZm9yIHNob3J0IGJsb2NrIGNvbnZvbHV0aW9uIGJhbmRzLlxuICAgICAqL1xuICAgIHRoaXMuY2JfcyA9IG5ld19mbG9hdCQxMyhFbmNvZGVyXzEuQ0JBTkRTKTtcbiAgICAvKipcbiAgICAgKiBFcXVhbCBsb3VkbmVzcyB3ZWlnaHRzIChiYXNlZCBvbiBBVEgpLlxuICAgICAqL1xuICAgIHRoaXMuZXFsX3cgPSBuZXdfZmxvYXQkMTMoRW5jb2Rlcl8xLkJMS1NJWkUgLyAyKTtcbn1cblxudmFyIEFUSF8xID0gQVRIO1xuXG4vKlxuICogIFJlcGxheUdhaW5BbmFseXNpcyAtIGFuYWx5emVzIGlucHV0IHNhbXBsZXMgYW5kIGdpdmUgdGhlIHJlY29tbWVuZGVkIGRCIGNoYW5nZVxuICogIENvcHlyaWdodCAoQykgMjAwMSBEYXZpZCBSb2JpbnNvbiBhbmQgR2xlbiBTYXd5ZXJcbiAqICBJbXByb3ZlbWVudHMgYW5kIG9wdGltaXphdGlvbnMgYWRkZWQgYnkgRnJhbmsgS2xlbW0sIGFuZCBieSBNYXJjZWwgTXVsbGVyIFxuICpcbiAqICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gKiAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlclxuICogIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqICBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gKiAgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAqICBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UsIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAgMDIxMTEtMTMwNyAgVVNBXG4gKlxuICogIGNvbmNlcHQgYW5kIGZpbHRlciB2YWx1ZXMgYnkgRGF2aWQgUm9iaW5zb24gKERhdmlkQFJvYmluc29uLm9yZylcbiAqICAgIC0tIGJsYW1lIGhpbSBpZiB5b3UgdGhpbmsgdGhlIGlkZWEgaXMgZmxhd2VkXG4gKiAgb3JpZ2luYWwgY29kaW5nIGJ5IEdsZW4gU2F3eWVyIChtcDNnYWluQGhvdG1haWwuY29tKVxuICogICAgLS0gYmxhbWUgaGltIGlmIHlvdSB0aGluayB0aGlzIHJ1bnMgdG9vIHNsb3dseSwgb3IgdGhlIGNvZGluZyBpcyBvdGhlcndpc2UgZmxhd2VkXG4gKlxuICogIGxvdHMgb2YgY29kZSBpbXByb3ZlbWVudHMgYnkgRnJhbmsgS2xlbW0gKCBodHRwOi8vd3d3LnVuaS1qZW5hLmRlL35wZmsvbXBwLyApXG4gKiAgICAtLSBjcmVkaXQgaGltIGZvciBhbGwgdGhlIF9nb29kXyBwcm9ncmFtbWluZyA7KVxuICpcbiAqXG4gKiAgRm9yIGFuIGV4cGxhbmF0aW9uIG9mIHRoZSBjb25jZXB0cyBhbmQgdGhlIGJhc2ljIGFsZ29yaXRobXMgaW52b2x2ZWQsIGdvIHRvOlxuICogICAgaHR0cDovL3d3dy5yZXBsYXlnYWluLm9yZy9cbiAqL1xuXG4vKlxuICogIEhlcmUncyB0aGUgZGVhbC4gQ2FsbFxuICpcbiAqICAgIEluaXRHYWluQW5hbHlzaXMgKCBsb25nIHNhbXBsZWZyZXEgKTtcbiAqXG4gKiAgdG8gaW5pdGlhbGl6ZSBldmVyeXRoaW5nLiBDYWxsXG4gKlxuICogICAgQW5hbHl6ZVNhbXBsZXMgKCB2YXIgRmxvYXRfdCogIGxlZnRfc2FtcGxlcyxcbiAqICAgICAgICAgICAgICAgICAgICAgdmFyIEZsb2F0X3QqICByaWdodF9zYW1wbGVzLFxuICogICAgICAgICAgICAgICAgICAgICBzaXplX3QgICAgICAgICAgbnVtX3NhbXBsZXMsXG4gKiAgICAgICAgICAgICAgICAgICAgIGludCAgICAgICAgICAgICBudW1fY2hhbm5lbHMgKTtcbiAqXG4gKiAgYXMgbWFueSB0aW1lcyBhcyB5b3Ugd2FudCwgd2l0aCBhcyBtYW55IG9yIGFzIGZldyBzYW1wbGVzIGFzIHlvdSB3YW50LlxuICogIElmIG1vbm8sIHBhc3MgdGhlIHNhbXBsZSBidWZmZXIgaW4gdGhyb3VnaCBsZWZ0X3NhbXBsZXMsIGxlYXZlXG4gKiAgcmlnaHRfc2FtcGxlcyBOVUxMLCBhbmQgbWFrZSBzdXJlIG51bV9jaGFubmVscyA9IDEuXG4gKlxuICogICAgR2V0VGl0bGVHYWluKClcbiAqXG4gKiAgd2lsbCByZXR1cm4gdGhlIHJlY29tbWVuZGVkIGRCIGxldmVsIGNoYW5nZSBmb3IgYWxsIHNhbXBsZXMgYW5hbHl6ZWRcbiAqICBTSU5DRSBUSEUgTEFTVCBUSU1FIHlvdSBjYWxsZWQgR2V0VGl0bGVHYWluKCkgT1IgSW5pdEdhaW5BbmFseXNpcygpLlxuICpcbiAqICAgIEdldEFsYnVtR2FpbigpXG4gKlxuICogIHdpbGwgcmV0dXJuIHRoZSByZWNvbW1lbmRlZCBkQiBsZXZlbCBjaGFuZ2UgZm9yIGFsbCBzYW1wbGVzIGFuYWx5emVkXG4gKiAgc2luY2UgSW5pdEdhaW5BbmFseXNpcygpIHdhcyBjYWxsZWQgYW5kIGZpbmFsaXplZCB3aXRoIEdldFRpdGxlR2FpbigpLlxuICpcbiAqICBQc2V1ZG8tY29kZSB0byBwcm9jZXNzIGFuIGFsYnVtOlxuICpcbiAqICAgIEZsb2F0X3QgICAgICAgbF9zYW1wbGVzIFs0MDk2XTtcbiAqICAgIEZsb2F0X3QgICAgICAgcl9zYW1wbGVzIFs0MDk2XTtcbiAqICAgIHNpemVfdCAgICAgICAgbnVtX3NhbXBsZXM7XG4gKiAgICB1bnNpZ25lZCBpbnQgIG51bV9zb25ncztcbiAqICAgIHVuc2lnbmVkIGludCAgaTtcbiAqXG4gKiAgICBJbml0R2FpbkFuYWx5c2lzICggNDQxMDAgKTtcbiAqICAgIGZvciAoIGkgPSAxOyBpIDw9IG51bV9zb25nczsgaSsrICkge1xuICogICAgICAgIHdoaWxlICggKCBudW1fc2FtcGxlcyA9IGdldFNvbmdTYW1wbGVzICggc29uZ1tpXSwgbGVmdF9zYW1wbGVzLCByaWdodF9zYW1wbGVzICkgKSA+IDAgKVxuICogICAgICAgICAgICBBbmFseXplU2FtcGxlcyAoIGxlZnRfc2FtcGxlcywgcmlnaHRfc2FtcGxlcywgbnVtX3NhbXBsZXMsIDIgKTtcbiAqICAgICAgICBmcHJpbnRmIChcIlJlY29tbWVuZGVkIGRCIGNoYW5nZSBmb3Igc29uZyAlMmQ6ICUrNi4yIGRCXFxuXCIsIGksIEdldFRpdGxlR2FpbigpICk7XG4gKiAgICB9XG4gKiAgICBmcHJpbnRmIChcIlJlY29tbWVuZGVkIGRCIGNoYW5nZSBmb3Igd2hvbGUgYWxidW06ICUrNi4yIGRCXFxuXCIsIEdldEFsYnVtR2FpbigpICk7XG4gKi9cblxuLypcbiAqICBTbyBoZXJlJ3MgdGhlIG1haW4gc291cmNlIG9mIHBvdGVudGlhbCBjb2RlIGNvbmZ1c2lvbjpcbiAqXG4gKiAgVGhlIGZpbHRlcnMgYXBwbGllZCB0byB0aGUgaW5jb21pbmcgc2FtcGxlcyBhcmUgSUlSIGZpbHRlcnMsXG4gKiAgbWVhbmluZyB0aGV5IHJlbHkgb24gdXAgdG8gPGZpbHRlciBvcmRlcj4gbnVtYmVyIG9mIHByZXZpb3VzIHNhbXBsZXNcbiAqICBBTkQgdXAgdG8gPGZpbHRlciBvcmRlcj4gbnVtYmVyIG9mIHByZXZpb3VzIGZpbHRlcmVkIHNhbXBsZXMuXG4gKlxuICogIEkgc2V0IHVwIHRoZSBBbmFseXplU2FtcGxlcyByb3V0aW5lIHRvIG1pbmltaXplIG1lbW9yeSB1c2FnZSBhbmQgaW50ZXJmYWNlXG4gKiAgY29tcGxleGl0eS4gVGhlIHNwZWVkIGlzbid0IGNvbXByb21pc2VkIHRvbyBtdWNoIChJIGRvbid0IHRoaW5rKSwgYnV0IHRoZVxuICogIGludGVybmFsIGNvbXBsZXhpdHkgaXMgaGlnaGVyIHRoYW4gaXQgc2hvdWxkIGJlIGZvciBzdWNoIGEgcmVsYXRpdmVseVxuICogIHNpbXBsZSByb3V0aW5lLlxuICpcbiAqICBPcHRpbWl6YXRpb24vY2xhcml0eSBzdWdnZXN0aW9ucyBhcmUgd2VsY29tZS5cbiAqL1xuXG52YXIgU3lzdGVtJDE1ID0gY29tbW9uLlN5c3RlbTtcbnZhciBBcnJheXMkMTUgPSBjb21tb24uQXJyYXlzO1xuLyoqXG4gKiBUYWJsZSBlbnRyaWVzIHBlciBkQlxuICovXG5HYWluQW5hbHlzaXMkMS5TVEVQU19wZXJfZEIgPSAxMDAuO1xuLyoqXG4gKiBUYWJsZSBlbnRyaWVzIGZvciAwLi4uTUFYX2RCIChub3JtYWwgbWF4LiB2YWx1ZXMgYXJlIDcwLi4uODAgZEIpXG4gKi9cbkdhaW5BbmFseXNpcyQxLk1BWF9kQiA9IDEyMC47XG5HYWluQW5hbHlzaXMkMS5HQUlOX05PVF9FTk9VR0hfU0FNUExFUyA9IC0yNDYwMTtcbkdhaW5BbmFseXNpcyQxLkdBSU5fQU5BTFlTSVNfRVJST1IgPSAwO1xuR2FpbkFuYWx5c2lzJDEuR0FJTl9BTkFMWVNJU19PSyA9IDE7XG5HYWluQW5hbHlzaXMkMS5JTklUX0dBSU5fQU5BTFlTSVNfRVJST1IgPSAwO1xuR2FpbkFuYWx5c2lzJDEuSU5JVF9HQUlOX0FOQUxZU0lTX09LID0gMTtcblxuR2FpbkFuYWx5c2lzJDEuWVVMRV9PUkRFUiA9IDEwO1xuR2FpbkFuYWx5c2lzJDEuTUFYX09SREVSID0gR2FpbkFuYWx5c2lzJDEuWVVMRV9PUkRFUjtcblxuR2FpbkFuYWx5c2lzJDEuTUFYX1NBTVBfRlJFUSA9IDQ4MDAwO1xuR2FpbkFuYWx5c2lzJDEuUk1TX1dJTkRPV19USU1FX05VTUVSQVRPUiA9IDE7XG5HYWluQW5hbHlzaXMkMS5STVNfV0lORE9XX1RJTUVfREVOT01JTkFUT1IgPSAyMDtcbkdhaW5BbmFseXNpcyQxLk1BWF9TQU1QTEVTX1BFUl9XSU5ET1cgPSAoKEdhaW5BbmFseXNpcyQxLk1BWF9TQU1QX0ZSRVEgKiBHYWluQW5hbHlzaXMkMS5STVNfV0lORE9XX1RJTUVfTlVNRVJBVE9SKSAvIEdhaW5BbmFseXNpcyQxLlJNU19XSU5ET1dfVElNRV9ERU5PTUlOQVRPUiArIDEpO1xuXG5mdW5jdGlvbiBHYWluQW5hbHlzaXMkMSgpIHtcbiAgICAvKipcbiAgICAgKiBjYWxpYnJhdGlvbiB2YWx1ZSBmb3IgODlkQlxuICAgICAqL1xuICAgIHZhciBQSU5LX1JFRiA9IDY0LjgyO1xuXG4gICAgdmFyIFlVTEVfT1JERVIgPSBHYWluQW5hbHlzaXMkMS5ZVUxFX09SREVSO1xuICAgIC8qKlxuICAgICAqIHBlcmNlbnRpbGUgd2hpY2ggaXMgbG91ZGVyIHRoYW4gdGhlIHByb3Bvc2VkIGxldmVsXG4gICAgICovXG4gICAgdmFyIFJNU19QRVJDRU5USUxFID0gMC45NTtcbiAgICAvKipcbiAgICAgKiBtYXhpbXVtIGFsbG93ZWQgc2FtcGxlIGZyZXF1ZW5jeSBbSHpdXG4gICAgICovXG4gICAgdmFyIE1BWF9TQU1QX0ZSRVEgPSBHYWluQW5hbHlzaXMkMS5NQVhfU0FNUF9GUkVRO1xuICAgIHZhciBSTVNfV0lORE9XX1RJTUVfTlVNRVJBVE9SID0gR2FpbkFuYWx5c2lzJDEuUk1TX1dJTkRPV19USU1FX05VTUVSQVRPUjtcbiAgICAvKipcbiAgICAgKiBudW1lcmF0b3IgLyBkZW5vbWluYXRvciA9IHRpbWUgc2xpY2Ugc2l6ZSBbc11cbiAgICAgKi9cbiAgICB2YXIgUk1TX1dJTkRPV19USU1FX0RFTk9NSU5BVE9SID0gR2FpbkFuYWx5c2lzJDEuUk1TX1dJTkRPV19USU1FX0RFTk9NSU5BVE9SO1xuICAgIC8qKlxuICAgICAqIG1heC4gU2FtcGxlcyBwZXIgVGltZSBzbGljZVxuICAgICAqL1xuICAgIHZhciBNQVhfU0FNUExFU19QRVJfV0lORE9XID0gR2FpbkFuYWx5c2lzJDEuTUFYX1NBTVBMRVNfUEVSX1dJTkRPVztcblxuXG4gICAgdmFyIEFCWXVsZSA9IFtcbiAgICAgICAgWzAuMDM4NTc1OTk0MzUyMDAsIC0zLjg0NjY0NjE3MTE4MDY3LCAtMC4wMjE2MDM2NzE4NDE4NSxcbiAgICAgICAgICAgIDcuODE1MDE2NTMwMDU1MzgsIC0wLjAwMTIzMzk1MzE2ODUxLCAtMTEuMzQxNzAzNTUxMzIwNDIsXG4gICAgICAgICAgICAtMC4wMDAwOTI5MTY3Nzk1OSwgMTMuMDU1MDQyMTkzMjc1NDUsIC0wLjAxNjU1MjYwMzQxNjE5LFxuICAgICAgICAgICAgLTEyLjI4NzU5ODk1MTQ1Mjk0LCAwLjAyMTYxNTI2ODQzMjc0LCA5LjQ4MjkzODA2MzE5NzkwLFxuICAgICAgICAgICAgLTAuMDIwNzQwNDUyMTUyODUsIC01Ljg3MjU3ODYxNzc1OTk5LCAwLjAwNTk0Mjk4MDY1MTI1LFxuICAgICAgICAgICAgMi43NTQ2NTg2MTg3NDYxMywgMC4wMDMwNjQyODAyMzE5MSwgLTAuODY5ODQzNzY1OTM1NTEsXG4gICAgICAgICAgICAwLjAwMDEyMDI1MzIyMDI3LCAwLjEzOTE5MzE0NTY3NDMyLCAwLjAwMjg4NDYzNjgzOTE2XSxcbiAgICAgICAgWzAuMDU0MTg2NTY0MDY0MzAsIC0zLjQ3ODQ1OTQ4NTUwMDcxLCAtMC4wMjkxMTAwNzgwODk0OCxcbiAgICAgICAgICAgIDYuMzYzMTc3Nzc1NjYxNDgsIC0wLjAwODQ4NzA5Mzc5ODUxLCAtOC41NDc1MTUyNzQ3MTg3NCxcbiAgICAgICAgICAgIC0wLjAwODUxMTY1NjQ1NDY5LCA5LjQ3NjkzNjA3ODAxMjgwLCAtMC4wMDgzNDk5MDkwNDkzNixcbiAgICAgICAgICAgIC04LjgxNDk4NjgxMzcwMTU1LCAwLjAyMjQ1MjkzMjUzMzM5LCA2Ljg1NDAxNTQwOTM2OTk4LFxuICAgICAgICAgICAgLTAuMDI1OTYzMzg1MTI5MTUsIC00LjM5NDcwOTk2MDc5NTU5LCAwLjAxNjI0ODY0OTYyOTc1LFxuICAgICAgICAgICAgMi4xOTYxMTY4NDg5MDc3NCwgLTAuMDAyNDA4NzkwNTE1ODQsIC0wLjc1MTA0MzAyNDUxNDMyLFxuICAgICAgICAgICAgMC4wMDY3NDYxMzY4MjI0NywgMC4xMzE0OTMxNzk1ODgwOCwgLTAuMDAxODc3NjM3NzczNjJdLFxuICAgICAgICBbMC4xNTQ1NzI5OTY4MTkyNCwgLTIuMzc4OTg4MzQ5NzMwODQsIC0wLjA5MzMxMDQ5MDU2MzE1LFxuICAgICAgICAgICAgMi44NDg2ODE1MTE1NjMyNywgLTAuMDYyNDc4ODAxNTM2NTMsIC0yLjY0NTc3MTcwMjI5ODI1LFxuICAgICAgICAgICAgMC4wMjE2MzU0MTg4ODc5OCwgMi4yMzY5NzY1NzQ1MTcxMywgLTAuMDU1ODgzOTMzMjk4NTYsXG4gICAgICAgICAgICAtMS42NzE0ODE1MzM2NzYwMiwgMC4wNDc4MTQ3NjY3NDkyMSwgMS4wMDU5NTk1NDgwODU0NyxcbiAgICAgICAgICAgIDAuMDAyMjIzMTI1OTc3NDMsIC0wLjQ1OTUzNDU4MDU0OTgzLCAwLjAzMTc0MDkyNTQwMDQ5LFxuICAgICAgICAgICAgMC4xNjM3ODE2NDg1ODU5NiwgLTAuMDEzOTA1ODk0MjE4OTgsIC0wLjA1MDMyMDc3NzE3MTMxLFxuICAgICAgICAgICAgMC4wMDY1MTQyMDY2NzgzMSwgMC4wMjM0Nzg5NzQwNzAyMCwgLTAuMDA4ODEzNjI3MzM4MzldLFxuICAgICAgICBbMC4zMDI5NjkwNzMxOTMyNywgLTEuNjEyNzMxNjUxMzcyNDcsIC0wLjIyNjEzOTg4NjgyMTIzLFxuICAgICAgICAgICAgMS4wNzk3NzQ5MjI1OTk3MCwgLTAuMDg1ODczMjM3MzA3NzIsIC0wLjI1NjU2MjU3NzU0MDcwLFxuICAgICAgICAgICAgMC4wMzI4MjkzMDE3MjY2NCwgLTAuMTYyNzY3MTkxMjA0NDAsIC0wLjAwOTE1NzAyOTMzNDM0LFxuICAgICAgICAgICAgLTAuMjI2Mzg4OTM3NzM5MDYsIC0wLjAyMzY0MTQxMjAyNTIyLCAwLjM5MTIwODAwNzg4Mjg0LFxuICAgICAgICAgICAgLTAuMDA1ODQ0NTYwMzk5MTMsIC0wLjIyMTM4MTM4OTU0OTI1LCAwLjA2Mjc2MTAxMzIxNzQ5LFxuICAgICAgICAgICAgMC4wNDUwMDIzNTM4NzM1MiwgLTAuMDAwMDA4MjgwODY3NDgsIDAuMDIwMDU4NTE4MDY1MDEsXG4gICAgICAgICAgICAwLjAwMjA1ODYxODg1NTY0LCAwLjAwMzAyNDM5MDk1NzQxLCAtMC4wMjk1MDEzNDk4MzI4N10sXG4gICAgICAgIFswLjMzNjQyMzA0ODU2MTMyLCAtMS40OTg1ODk3OTM2Nzc5OSwgLTAuMjU1NzIyNDE0MjU1NzAsXG4gICAgICAgICAgICAwLjg3MzUwMjcxNDE4MTg4LCAtMC4xMTgyODU3MDE3NzU1NSwgMC4xMjIwNTAyMjMwODA4NCxcbiAgICAgICAgICAgIDAuMTE5MjExNDg2NzUyMDMsIC0wLjgwNzc0OTQ0NjcxNDM4LCAtMC4wNzgzNDQ4OTYwOTQ3OSxcbiAgICAgICAgICAgIDAuNDc4NTQ3OTQ1NjIzMjYsIC0wLjAwNDY5OTc3OTE0MzgwLCAtMC4xMjQ1MzQ1ODE0MDAxOSxcbiAgICAgICAgICAgIC0wLjAwNTg5NTAwMjI0NDQwLCAtMC4wNDA2NzUxMDE5NzAxNCwgMC4wNTcyNDIyODE0MDM1MSxcbiAgICAgICAgICAgIDAuMDgzMzM3NTUyODQxMDcsIDAuMDA4MzIwNDM5ODA3NzMsIC0wLjA0MjM3MzQ4MDI1NzQ2LFxuICAgICAgICAgICAgLTAuMDE2MzUzODEzODQ1NDAsIDAuMDI5NzcyMDczMTk5MjUsIC0wLjAxNzYwMTc2NTY4MTUwXSxcbiAgICAgICAgWzAuNDQ5MTUyNTY2MDg0NTAsIC0wLjYyODIwNjE5MjMzNjcxLCAtMC4xNDM1MTc1NzQ2NDU0NyxcbiAgICAgICAgICAgIDAuMjk2NjE3ODM3MDYzNjYsIC0wLjIyNzg0Mzk0NDI5NzQ5LCAtMC4zNzI1NjM3Mjk0MjQwMCxcbiAgICAgICAgICAgIC0wLjAxNDE5MTQwMTAwNTUxLCAwLjAwMjEzNzY3ODU3MTI0LCAwLjA0MDc4MjYyNzk3MTM5LFxuICAgICAgICAgICAgLTAuNDIwMjk4MjAxNzA5MTgsIC0wLjEyMzk4MTYzMzgxNzQ4LCAwLjIyMTk5NjUwNTY0ODI0LFxuICAgICAgICAgICAgMC4wNDA5NzU2NTEzNTY0OCwgMC4wMDYxMzQyNDM1MDY4MiwgMC4xMDQ3ODUwMzYwMDI1MSxcbiAgICAgICAgICAgIDAuMDY3NDc2MjA3NDQ2ODMsIC0wLjAxODYzODg3ODEwOTI3LCAwLjA1Nzg0ODIwMzc1ODAxLFxuICAgICAgICAgICAgLTAuMDMxOTM0Mjg0Mzg5MTUsIDAuMDMyMjI3NTQwNzIxNzMsIDAuMDA1NDE5MDc3NDg3MDddLFxuICAgICAgICBbMC41NjYxOTQ3MDc1NzY0MSwgLTEuMDQ4MDAzMzUxMjYzNDksIC0wLjc1NDY0NDU2OTM5MzAyLFxuICAgICAgICAgICAgMC4yOTE1NjMxMTk3MTI0OSwgMC4xNjI0MjEzNzc0MjIzMCwgLTAuMjY4MDYwMDEwNDI5NDcsXG4gICAgICAgICAgICAwLjE2NzQ0MjQzNDkzNjcyLCAwLjAwODE5OTk5NjQ1ODU4LCAtMC4xODkwMTYwNDE5OTYwOSxcbiAgICAgICAgICAgIDAuNDUwNTQ3MzQ1MDUwMDgsIDAuMzA5MzE3ODI4NDE4MzAsIC0wLjMzMDMyNDAzMzE0MDA2LFxuICAgICAgICAgICAgLTAuMjc1NjI5NjE5ODYyMjQsIDAuMDY3MzkzNjgzMzMxMTAsIDAuMDA2NDczMTA2NzcyNDYsXG4gICAgICAgICAgICAtMC4wNDc4NDI1NDIyOTAzMywgMC4wODY0NzUwMzc4MDM1MSwgMC4wMTYzOTkwNzgzNjE4OSxcbiAgICAgICAgICAgIC0wLjAzNzg4OTg0NTU0ODQwLCAwLjAxODA3MzY0MzIzNTczLCAtMC4wMDU4ODIxNTQ0MzQyMV0sXG4gICAgICAgIFswLjU4MTAwNDk0OTYwNTUzLCAtMC41MTAzNTMyNzA5NTE4NCwgLTAuNTMxNzQ5MDkwNTg1NzgsXG4gICAgICAgICAgICAtMC4zMTg2MzU2MzMyNTI0NSwgLTAuMTQyODk3OTkwMzQyNTMsIC0wLjIwMjU2NDEzNDg0NDc3LFxuICAgICAgICAgICAgMC4xNzUyMDcwNDgzNTUyMiwgMC4xNDcyODE1NDEzNDMzMCwgMC4wMjM3Nzk0NTIxNzYxNSxcbiAgICAgICAgICAgIDAuMzg5NTI2Mzk5Nzg5OTksIDAuMTU1NTg0NDkxMzU1NzMsIC0wLjIzMzEzMjcxODgwODY4LFxuICAgICAgICAgICAgLTAuMjUzNDQ3OTAwNTkzNTMsIC0wLjA1MjQ2MDE5MDI0NDYzLCAwLjAxNjI4NDYyNDA2MzMzLFxuICAgICAgICAgICAgLTAuMDI1MDU5NjE3MjQwNTMsIDAuMDY5MjA0Njc3NjM5NTksIDAuMDI0NDIzNTczMTYwOTksXG4gICAgICAgICAgICAtMC4wMzcyMTYxMTM5NTgwMSwgMC4wMTgxODgwMTExMTUwMywgLTAuMDA3NDk2MTg3OTcxNzJdLFxuICAgICAgICBbMC41MzY0ODc4OTI1NTEwNSwgLTAuMjUwNDk4NzE5NTYwMjAsIC0wLjQyMTYzMDM0MzUwNjk2LFxuICAgICAgICAgICAgLTAuNDMxOTM5NDIzMTExMTQsIC0wLjAwMjc1OTUzNjExOTI5LCAtMC4wMzQyNDY4MTAxNzY3NSxcbiAgICAgICAgICAgIDAuMDQyNjc4NDIyMTk0MTUsIC0wLjA0Njc4MzI4Nzg0MjQyLCAtMC4xMDIxNDg2NDE3OTY3NixcbiAgICAgICAgICAgIDAuMjY0MDgzMDAyMDA5NTUsIDAuMTQ1OTA3NzIyODkzODgsIDAuMTUxMTMxMzA1MzMyMTYsXG4gICAgICAgICAgICAtMC4wMjQ1OTg2NDg1OTM0NSwgLTAuMTc1NTY0OTMzNjY0NDksIC0wLjExMjAyMzE1MTk1Mzg4LFxuICAgICAgICAgICAgLTAuMTg4MjMwMDkyNjIxMTUsIC0wLjA0MDYwMDM0MTI3MDAwLCAwLjA1NDc3NzIwNDI4Njc0LFxuICAgICAgICAgICAgMC4wNDc4ODY2NTU0ODE4MCwgMC4wNDcwNDQwOTY4ODEyMCwgLTAuMDIyMTc5MzY4MDExMzRdXTtcblxuICAgIHZhciBBQkJ1dHRlciA9IFtcbiAgICAgICAgWzAuOTg2MjExOTI0NjI3MDgsIC0xLjk3MjIzMzcyOTE5NTI3LCAtMS45NzI0MjM4NDkyNTQxNixcbiAgICAgICAgICAgIDAuOTcyNjEzOTY5MzEzMDYsIDAuOTg2MjExOTI0NjI3MDhdLFxuICAgICAgICBbMC45ODUwMDE3NTc4NzI0MiwgLTEuOTY5Nzc4NTU1ODI2MTgsIC0xLjk3MDAwMzUxNTc0NDg0LFxuICAgICAgICAgICAgMC45NzAyMjg0NzU2NjM1MCwgMC45ODUwMDE3NTc4NzI0Ml0sXG4gICAgICAgIFswLjk3OTM4OTMyNzM1MjE0LCAtMS45NTgzNTM4MDk3NTM5OCwgLTEuOTU4Nzc4NjU0NzA0MjgsXG4gICAgICAgICAgICAwLjk1OTIwMzQ5OTY1NDU5LCAwLjk3OTM4OTMyNzM1MjE0XSxcbiAgICAgICAgWzAuOTc1MzE4NDMyMDQ5MjgsIC0xLjk1MDAyNzU5MTQ5ODc4LCAtMS45NTA2MzY4NjQwOTg1NyxcbiAgICAgICAgICAgIDAuOTUxMjQ2MTM2Njk4MzUsIDAuOTc1MzE4NDMyMDQ5MjhdLFxuICAgICAgICBbMC45NzMxNjUyMzQ5ODE2MSwgLTEuOTQ1NjEwMjM1NjY1MjcsIC0xLjk0NjMzMDQ2OTk2MzIzLFxuICAgICAgICAgICAgMC45NDcwNTA3MDQyNjExOCwgMC45NzMxNjUyMzQ5ODE2MV0sXG4gICAgICAgIFswLjk2NDU0NTE1NTUyODI2LCAtMS45Mjc4MzI4Njk3NzAzNiwgLTEuOTI5MDkwMzExMDU2NTIsXG4gICAgICAgICAgICAwLjkzMDM0Nzc1MjM0MjY4LCAwLjk2NDU0NTE1NTUyODI2XSxcbiAgICAgICAgWzAuOTYwMDkxNDI5NTA1NDEsIC0xLjkxODU4OTUzMDMzNzg0LCAtMS45MjAxODI4NTkwMTA4MixcbiAgICAgICAgICAgIDAuOTIxNzc2MTg3NjgzODEsIDAuOTYwMDkxNDI5NTA1NDFdLFxuICAgICAgICBbMC45NTg1NjkxNjU5OTYwMSwgLTEuOTE1NDIxMDgwNzQ3ODAsIC0xLjkxNzEzODMzMTk5MjAzLFxuICAgICAgICAgICAgMC45MTg4NTU1ODMyMzYyNSwgMC45NTg1NjkxNjU5OTYwMV0sXG4gICAgICAgIFswLjk0NTk3Njg1NjAwMjc5LCAtMS44ODkwMzMwNzkzOTQ1MiwgLTEuODkxOTUzNzEyMDA1NTgsXG4gICAgICAgICAgICAwLjg5NDg3NDM0NDYxNjY0LCAwLjk0NTk3Njg1NjAwMjc5XV07XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2FsbGluZyB0aGlzIHByb2NlZHVyZSwgbWFrZSBzdXJlIHRoYXQgaXBbLW9yZGVyXSBhbmQgb3BbLW9yZGVyXVxuICAgICAqIHBvaW50IHRvIHJlYWwgZGF0YVxuICAgICAqL1xuICAgIC8vcHJpdmF0ZSB2b2lkIGZpbHRlcll1bGUoZmluYWwgZmxvYXRbXSBpbnB1dCwgaW50IGlucHV0UG9zLCBmbG9hdFtdIG91dHB1dCxcbiAgICAvL2ludCBvdXRwdXRQb3MsIGludCBuU2FtcGxlcywgZmluYWwgZmxvYXRbXSBrZXJuZWwpIHtcbiAgICBmdW5jdGlvbiBmaWx0ZXJZdWxlKGlucHV0LCBpbnB1dFBvcywgb3V0cHV0LCBvdXRwdXRQb3MsIG5TYW1wbGVzLCBrZXJuZWwpIHtcblxuICAgICAgICB3aGlsZSAoKG5TYW1wbGVzLS0pICE9IDApIHtcbiAgICAgICAgICAgIC8qIDFlLTEwIGlzIGEgaGFjayB0byBhdm9pZCBzbG93ZG93biBiZWNhdXNlIG9mIGRlbm9ybWFscyAqL1xuICAgICAgICAgICAgb3V0cHV0W291dHB1dFBvc10gPSAxZS0xMCArIGlucHV0W2lucHV0UG9zICsgMF0gKiBrZXJuZWxbMF1cbiAgICAgICAgICAgICAgICAtIG91dHB1dFtvdXRwdXRQb3MgLSAxXSAqIGtlcm5lbFsxXSArIGlucHV0W2lucHV0UG9zIC0gMV1cbiAgICAgICAgICAgICAgICAqIGtlcm5lbFsyXSAtIG91dHB1dFtvdXRwdXRQb3MgLSAyXSAqIGtlcm5lbFszXVxuICAgICAgICAgICAgICAgICsgaW5wdXRbaW5wdXRQb3MgLSAyXSAqIGtlcm5lbFs0XSAtIG91dHB1dFtvdXRwdXRQb3MgLSAzXVxuICAgICAgICAgICAgICAgICoga2VybmVsWzVdICsgaW5wdXRbaW5wdXRQb3MgLSAzXSAqIGtlcm5lbFs2XVxuICAgICAgICAgICAgICAgIC0gb3V0cHV0W291dHB1dFBvcyAtIDRdICoga2VybmVsWzddICsgaW5wdXRbaW5wdXRQb3MgLSA0XVxuICAgICAgICAgICAgICAgICoga2VybmVsWzhdIC0gb3V0cHV0W291dHB1dFBvcyAtIDVdICoga2VybmVsWzldXG4gICAgICAgICAgICAgICAgKyBpbnB1dFtpbnB1dFBvcyAtIDVdICoga2VybmVsWzEwXSAtIG91dHB1dFtvdXRwdXRQb3MgLSA2XVxuICAgICAgICAgICAgICAgICoga2VybmVsWzExXSArIGlucHV0W2lucHV0UG9zIC0gNl0gKiBrZXJuZWxbMTJdXG4gICAgICAgICAgICAgICAgLSBvdXRwdXRbb3V0cHV0UG9zIC0gN10gKiBrZXJuZWxbMTNdICsgaW5wdXRbaW5wdXRQb3MgLSA3XVxuICAgICAgICAgICAgICAgICoga2VybmVsWzE0XSAtIG91dHB1dFtvdXRwdXRQb3MgLSA4XSAqIGtlcm5lbFsxNV1cbiAgICAgICAgICAgICAgICArIGlucHV0W2lucHV0UG9zIC0gOF0gKiBrZXJuZWxbMTZdIC0gb3V0cHV0W291dHB1dFBvcyAtIDldXG4gICAgICAgICAgICAgICAgKiBrZXJuZWxbMTddICsgaW5wdXRbaW5wdXRQb3MgLSA5XSAqIGtlcm5lbFsxOF1cbiAgICAgICAgICAgICAgICAtIG91dHB1dFtvdXRwdXRQb3MgLSAxMF0gKiBrZXJuZWxbMTldXG4gICAgICAgICAgICAgICAgKyBpbnB1dFtpbnB1dFBvcyAtIDEwXSAqIGtlcm5lbFsyMF07XG4gICAgICAgICAgICArK291dHB1dFBvcztcbiAgICAgICAgICAgICsraW5wdXRQb3M7XG4gICAgICAgIH1cbiAgICB9XG5cbi8vcHJpdmF0ZSB2b2lkIGZpbHRlckJ1dHRlcihmaW5hbCBmbG9hdFtdIGlucHV0LCBpbnQgaW5wdXRQb3MsXG4vLyAgICBmbG9hdFtdIG91dHB1dCwgaW50IG91dHB1dFBvcywgaW50IG5TYW1wbGVzLCBmaW5hbCBmbG9hdFtdIGtlcm5lbCkge1xuICAgIGZ1bmN0aW9uIGZpbHRlckJ1dHRlcihpbnB1dCwgaW5wdXRQb3MsIG91dHB1dCwgb3V0cHV0UG9zLCBuU2FtcGxlcywga2VybmVsKSB7XG5cbiAgICAgICAgd2hpbGUgKChuU2FtcGxlcy0tKSAhPSAwKSB7XG4gICAgICAgICAgICBvdXRwdXRbb3V0cHV0UG9zXSA9IGlucHV0W2lucHV0UG9zICsgMF0gKiBrZXJuZWxbMF1cbiAgICAgICAgICAgICAgICAtIG91dHB1dFtvdXRwdXRQb3MgLSAxXSAqIGtlcm5lbFsxXSArIGlucHV0W2lucHV0UG9zIC0gMV1cbiAgICAgICAgICAgICAgICAqIGtlcm5lbFsyXSAtIG91dHB1dFtvdXRwdXRQb3MgLSAyXSAqIGtlcm5lbFszXVxuICAgICAgICAgICAgICAgICsgaW5wdXRbaW5wdXRQb3MgLSAyXSAqIGtlcm5lbFs0XTtcbiAgICAgICAgICAgICsrb3V0cHV0UG9zO1xuICAgICAgICAgICAgKytpbnB1dFBvcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gSU5JVF9HQUlOX0FOQUxZU0lTX09LIGlmIHN1Y2Nlc3NmdWwsIElOSVRfR0FJTl9BTkFMWVNJU19FUlJPUiBpZlxuICAgICAqICAgICAgICAgbm90XG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVzZXRTYW1wbGVGcmVxdWVuY3kocmdEYXRhLCBzYW1wbGVmcmVxKSB7XG4gICAgICAgIC8qIHplcm8gb3V0IGluaXRpYWwgdmFsdWVzICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTUFYX09SREVSOyBpKyspXG4gICAgICAgICAgICByZ0RhdGEubGlucHJlYnVmW2ldID0gcmdEYXRhLmxzdGVwYnVmW2ldID0gcmdEYXRhLmxvdXRidWZbaV0gPSByZ0RhdGEucmlucHJlYnVmW2ldID0gcmdEYXRhLnJzdGVwYnVmW2ldID0gcmdEYXRhLnJvdXRidWZbaV0gPSAwLjtcblxuICAgICAgICBzd2l0Y2ggKDAgfCAoc2FtcGxlZnJlcSkpIHtcbiAgICAgICAgICAgIGNhc2UgNDgwMDA6XG4gICAgICAgICAgICAgICAgcmdEYXRhLnJlcWluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDQxMDA6XG4gICAgICAgICAgICAgICAgcmdEYXRhLnJlcWluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzIwMDA6XG4gICAgICAgICAgICAgICAgcmdEYXRhLnJlcWluZGV4ID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjQwMDA6XG4gICAgICAgICAgICAgICAgcmdEYXRhLnJlcWluZGV4ID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjIwNTA6XG4gICAgICAgICAgICAgICAgcmdEYXRhLnJlcWluZGV4ID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTYwMDA6XG4gICAgICAgICAgICAgICAgcmdEYXRhLnJlcWluZGV4ID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTIwMDA6XG4gICAgICAgICAgICAgICAgcmdEYXRhLnJlcWluZGV4ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTEwMjU6XG4gICAgICAgICAgICAgICAgcmdEYXRhLnJlcWluZGV4ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODAwMDpcbiAgICAgICAgICAgICAgICByZ0RhdGEucmVxaW5kZXggPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5JVF9HQUlOX0FOQUxZU0lTX0VSUk9SO1xuICAgICAgICB9XG5cbiAgICAgICAgcmdEYXRhLnNhbXBsZVdpbmRvdyA9IDAgfCAoKHNhbXBsZWZyZXEgKiBSTVNfV0lORE9XX1RJTUVfTlVNRVJBVE9SXG4gICAgICAgICAgICArIFJNU19XSU5ET1dfVElNRV9ERU5PTUlOQVRPUiAtIDEpIC8gUk1TX1dJTkRPV19USU1FX0RFTk9NSU5BVE9SKTtcblxuICAgICAgICByZ0RhdGEubHN1bSA9IDAuO1xuICAgICAgICByZ0RhdGEucnN1bSA9IDAuO1xuICAgICAgICByZ0RhdGEudG90c2FtcCA9IDA7XG5cbiAgICAgICAgQXJyYXlzJDE1LmlsbChyZ0RhdGEuQSwgMCk7XG5cbiAgICAgICAgcmV0dXJuIElOSVRfR0FJTl9BTkFMWVNJU19PSztcbiAgICB9XG5cbiAgICB0aGlzLkluaXRHYWluQW5hbHlzaXMgPSBmdW5jdGlvbiAocmdEYXRhLCBzYW1wbGVmcmVxKSB7XG4gICAgICAgIGlmIChSZXNldFNhbXBsZUZyZXF1ZW5jeShyZ0RhdGEsIHNhbXBsZWZyZXEpICE9IElOSVRfR0FJTl9BTkFMWVNJU19PSykge1xuICAgICAgICAgICAgcmV0dXJuIElOSVRfR0FJTl9BTkFMWVNJU19FUlJPUjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJnRGF0YS5saW5wcmUgPSBNQVhfT1JERVI7XG4gICAgICAgIHJnRGF0YS5yaW5wcmUgPSBNQVhfT1JERVI7XG4gICAgICAgIHJnRGF0YS5sc3RlcCA9IE1BWF9PUkRFUjtcbiAgICAgICAgcmdEYXRhLnJzdGVwID0gTUFYX09SREVSO1xuICAgICAgICByZ0RhdGEubG91dCA9IE1BWF9PUkRFUjtcbiAgICAgICAgcmdEYXRhLnJvdXQgPSBNQVhfT1JERVI7XG5cbiAgICAgICAgQXJyYXlzJDE1LmZpbGwocmdEYXRhLkIsIDApO1xuXG4gICAgICAgIHJldHVybiBJTklUX0dBSU5fQU5BTFlTSVNfT0s7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNxdWFyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZzcXIoZCkge1xuICAgICAgICByZXR1cm4gZCAqIGQ7XG4gICAgfVxuXG4gICAgdGhpcy5BbmFseXplU2FtcGxlcyA9IGZ1bmN0aW9uIChyZ0RhdGEsIGxlZnRfc2FtcGxlcywgbGVmdF9zYW1wbGVzUG9zLCByaWdodF9zYW1wbGVzLCByaWdodF9zYW1wbGVzUG9zLCBudW1fc2FtcGxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bV9jaGFubmVscykge1xuICAgICAgICB2YXIgY3VybGVmdDtcbiAgICAgICAgdmFyIGN1cmxlZnRCYXNlO1xuICAgICAgICB2YXIgY3VycmlnaHQ7XG4gICAgICAgIHZhciBjdXJyaWdodEJhc2U7XG4gICAgICAgIHZhciBiYXRjaHNhbXBsZXM7XG4gICAgICAgIHZhciBjdXJzYW1wbGVzO1xuICAgICAgICB2YXIgY3Vyc2FtcGxlcG9zO1xuXG4gICAgICAgIGlmIChudW1fc2FtcGxlcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIEdBSU5fQU5BTFlTSVNfT0s7XG5cbiAgICAgICAgY3Vyc2FtcGxlcG9zID0gMDtcbiAgICAgICAgYmF0Y2hzYW1wbGVzID0gbnVtX3NhbXBsZXM7XG5cbiAgICAgICAgc3dpdGNoIChudW1fY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByaWdodF9zYW1wbGVzID0gbGVmdF9zYW1wbGVzO1xuICAgICAgICAgICAgICAgIHJpZ2h0X3NhbXBsZXNQb3MgPSBsZWZ0X3NhbXBsZXNQb3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBHQUlOX0FOQUxZU0lTX0VSUk9SO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bV9zYW1wbGVzIDwgTUFYX09SREVSKSB7XG4gICAgICAgICAgICBTeXN0ZW0kMTUuYXJyYXljb3B5KGxlZnRfc2FtcGxlcywgbGVmdF9zYW1wbGVzUG9zLCByZ0RhdGEubGlucHJlYnVmLFxuICAgICAgICAgICAgICAgIE1BWF9PUkRFUiwgbnVtX3NhbXBsZXMpO1xuICAgICAgICAgICAgU3lzdGVtJDE1LmFycmF5Y29weShyaWdodF9zYW1wbGVzLCByaWdodF9zYW1wbGVzUG9zLCByZ0RhdGEucmlucHJlYnVmLFxuICAgICAgICAgICAgICAgIE1BWF9PUkRFUiwgbnVtX3NhbXBsZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgU3lzdGVtJDE1LmFycmF5Y29weShsZWZ0X3NhbXBsZXMsIGxlZnRfc2FtcGxlc1BvcywgcmdEYXRhLmxpbnByZWJ1ZixcbiAgICAgICAgICAgICAgICBNQVhfT1JERVIsIE1BWF9PUkRFUik7XG4gICAgICAgICAgICBTeXN0ZW0kMTUuYXJyYXljb3B5KHJpZ2h0X3NhbXBsZXMsIHJpZ2h0X3NhbXBsZXNQb3MsIHJnRGF0YS5yaW5wcmVidWYsXG4gICAgICAgICAgICAgICAgTUFYX09SREVSLCBNQVhfT1JERVIpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGJhdGNoc2FtcGxlcyA+IDApIHtcbiAgICAgICAgICAgIGN1cnNhbXBsZXMgPSBiYXRjaHNhbXBsZXMgPiByZ0RhdGEuc2FtcGxlV2luZG93IC0gcmdEYXRhLnRvdHNhbXAgPyByZ0RhdGEuc2FtcGxlV2luZG93XG4gICAgICAgICAgICAtIHJnRGF0YS50b3RzYW1wXG4gICAgICAgICAgICAgICAgOiBiYXRjaHNhbXBsZXM7XG4gICAgICAgICAgICBpZiAoY3Vyc2FtcGxlcG9zIDwgTUFYX09SREVSKSB7XG4gICAgICAgICAgICAgICAgY3VybGVmdCA9IHJnRGF0YS5saW5wcmUgKyBjdXJzYW1wbGVwb3M7XG4gICAgICAgICAgICAgICAgY3VybGVmdEJhc2UgPSByZ0RhdGEubGlucHJlYnVmO1xuICAgICAgICAgICAgICAgIGN1cnJpZ2h0ID0gcmdEYXRhLnJpbnByZSArIGN1cnNhbXBsZXBvcztcbiAgICAgICAgICAgICAgICBjdXJyaWdodEJhc2UgPSByZ0RhdGEucmlucHJlYnVmO1xuICAgICAgICAgICAgICAgIGlmIChjdXJzYW1wbGVzID4gTUFYX09SREVSIC0gY3Vyc2FtcGxlcG9zKVxuICAgICAgICAgICAgICAgICAgICBjdXJzYW1wbGVzID0gTUFYX09SREVSIC0gY3Vyc2FtcGxlcG9zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJsZWZ0ID0gbGVmdF9zYW1wbGVzUG9zICsgY3Vyc2FtcGxlcG9zO1xuICAgICAgICAgICAgICAgIGN1cmxlZnRCYXNlID0gbGVmdF9zYW1wbGVzO1xuICAgICAgICAgICAgICAgIGN1cnJpZ2h0ID0gcmlnaHRfc2FtcGxlc1BvcyArIGN1cnNhbXBsZXBvcztcbiAgICAgICAgICAgICAgICBjdXJyaWdodEJhc2UgPSByaWdodF9zYW1wbGVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWx0ZXJZdWxlKGN1cmxlZnRCYXNlLCBjdXJsZWZ0LCByZ0RhdGEubHN0ZXBidWYsIHJnRGF0YS5sc3RlcFxuICAgICAgICAgICAgICAgICsgcmdEYXRhLnRvdHNhbXAsIGN1cnNhbXBsZXMsIEFCWXVsZVtyZ0RhdGEucmVxaW5kZXhdKTtcbiAgICAgICAgICAgIGZpbHRlcll1bGUoY3VycmlnaHRCYXNlLCBjdXJyaWdodCwgcmdEYXRhLnJzdGVwYnVmLCByZ0RhdGEucnN0ZXBcbiAgICAgICAgICAgICAgICArIHJnRGF0YS50b3RzYW1wLCBjdXJzYW1wbGVzLCBBQll1bGVbcmdEYXRhLnJlcWluZGV4XSk7XG5cbiAgICAgICAgICAgIGZpbHRlckJ1dHRlcihyZ0RhdGEubHN0ZXBidWYsIHJnRGF0YS5sc3RlcCArIHJnRGF0YS50b3RzYW1wLFxuICAgICAgICAgICAgICAgIHJnRGF0YS5sb3V0YnVmLCByZ0RhdGEubG91dCArIHJnRGF0YS50b3RzYW1wLCBjdXJzYW1wbGVzLFxuICAgICAgICAgICAgICAgIEFCQnV0dGVyW3JnRGF0YS5yZXFpbmRleF0pO1xuICAgICAgICAgICAgZmlsdGVyQnV0dGVyKHJnRGF0YS5yc3RlcGJ1ZiwgcmdEYXRhLnJzdGVwICsgcmdEYXRhLnRvdHNhbXAsXG4gICAgICAgICAgICAgICAgcmdEYXRhLnJvdXRidWYsIHJnRGF0YS5yb3V0ICsgcmdEYXRhLnRvdHNhbXAsIGN1cnNhbXBsZXMsXG4gICAgICAgICAgICAgICAgQUJCdXR0ZXJbcmdEYXRhLnJlcWluZGV4XSk7XG5cbiAgICAgICAgICAgIGN1cmxlZnQgPSByZ0RhdGEubG91dCArIHJnRGF0YS50b3RzYW1wO1xuICAgICAgICAgICAgLyogR2V0IHRoZSBzcXVhcmVkIHZhbHVlcyAqL1xuICAgICAgICAgICAgY3VybGVmdEJhc2UgPSByZ0RhdGEubG91dGJ1ZjtcbiAgICAgICAgICAgIGN1cnJpZ2h0ID0gcmdEYXRhLnJvdXQgKyByZ0RhdGEudG90c2FtcDtcbiAgICAgICAgICAgIGN1cnJpZ2h0QmFzZSA9IHJnRGF0YS5yb3V0YnVmO1xuXG4gICAgICAgICAgICB2YXIgaSA9IGN1cnNhbXBsZXMgJSA4O1xuICAgICAgICAgICAgd2hpbGUgKChpLS0pICE9IDApIHtcbiAgICAgICAgICAgICAgICByZ0RhdGEubHN1bSArPSBmc3FyKGN1cmxlZnRCYXNlW2N1cmxlZnQrK10pO1xuICAgICAgICAgICAgICAgIHJnRGF0YS5yc3VtICs9IGZzcXIoY3VycmlnaHRCYXNlW2N1cnJpZ2h0KytdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSBjdXJzYW1wbGVzIC8gODtcbiAgICAgICAgICAgIHdoaWxlICgoaS0tKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcmdEYXRhLmxzdW0gKz0gZnNxcihjdXJsZWZ0QmFzZVtjdXJsZWZ0ICsgMF0pXG4gICAgICAgICAgICAgICAgICAgICsgZnNxcihjdXJsZWZ0QmFzZVtjdXJsZWZ0ICsgMV0pXG4gICAgICAgICAgICAgICAgICAgICsgZnNxcihjdXJsZWZ0QmFzZVtjdXJsZWZ0ICsgMl0pXG4gICAgICAgICAgICAgICAgICAgICsgZnNxcihjdXJsZWZ0QmFzZVtjdXJsZWZ0ICsgM10pXG4gICAgICAgICAgICAgICAgICAgICsgZnNxcihjdXJsZWZ0QmFzZVtjdXJsZWZ0ICsgNF0pXG4gICAgICAgICAgICAgICAgICAgICsgZnNxcihjdXJsZWZ0QmFzZVtjdXJsZWZ0ICsgNV0pXG4gICAgICAgICAgICAgICAgICAgICsgZnNxcihjdXJsZWZ0QmFzZVtjdXJsZWZ0ICsgNl0pXG4gICAgICAgICAgICAgICAgICAgICsgZnNxcihjdXJsZWZ0QmFzZVtjdXJsZWZ0ICsgN10pO1xuICAgICAgICAgICAgICAgIGN1cmxlZnQgKz0gODtcbiAgICAgICAgICAgICAgICByZ0RhdGEucnN1bSArPSBmc3FyKGN1cnJpZ2h0QmFzZVtjdXJyaWdodCArIDBdKVxuICAgICAgICAgICAgICAgICAgICArIGZzcXIoY3VycmlnaHRCYXNlW2N1cnJpZ2h0ICsgMV0pXG4gICAgICAgICAgICAgICAgICAgICsgZnNxcihjdXJyaWdodEJhc2VbY3VycmlnaHQgKyAyXSlcbiAgICAgICAgICAgICAgICAgICAgKyBmc3FyKGN1cnJpZ2h0QmFzZVtjdXJyaWdodCArIDNdKVxuICAgICAgICAgICAgICAgICAgICArIGZzcXIoY3VycmlnaHRCYXNlW2N1cnJpZ2h0ICsgNF0pXG4gICAgICAgICAgICAgICAgICAgICsgZnNxcihjdXJyaWdodEJhc2VbY3VycmlnaHQgKyA1XSlcbiAgICAgICAgICAgICAgICAgICAgKyBmc3FyKGN1cnJpZ2h0QmFzZVtjdXJyaWdodCArIDZdKVxuICAgICAgICAgICAgICAgICAgICArIGZzcXIoY3VycmlnaHRCYXNlW2N1cnJpZ2h0ICsgN10pO1xuICAgICAgICAgICAgICAgIGN1cnJpZ2h0ICs9IDg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhdGNoc2FtcGxlcyAtPSBjdXJzYW1wbGVzO1xuICAgICAgICAgICAgY3Vyc2FtcGxlcG9zICs9IGN1cnNhbXBsZXM7XG4gICAgICAgICAgICByZ0RhdGEudG90c2FtcCArPSBjdXJzYW1wbGVzO1xuICAgICAgICAgICAgaWYgKHJnRGF0YS50b3RzYW1wID09IHJnRGF0YS5zYW1wbGVXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICAvKiBHZXQgdGhlIFJvb3QgTWVhbiBTcXVhcmUgKFJNUykgZm9yIHRoaXMgc2V0IG9mIHNhbXBsZXMgKi9cbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gR2FpbkFuYWx5c2lzJDEuU1RFUFNfcGVyX2RCXG4gICAgICAgICAgICAgICAgICAgICogMTAuXG4gICAgICAgICAgICAgICAgICAgICogTWF0aC5sb2cxMCgocmdEYXRhLmxzdW0gKyByZ0RhdGEucnN1bSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8gcmdEYXRhLnRvdHNhbXAgKiAwLjUgKyAxLmUtMzcpO1xuICAgICAgICAgICAgICAgIHZhciBpdmFsID0gKHZhbCA8PSAwKSA/IDAgOiAwIHwgdmFsO1xuICAgICAgICAgICAgICAgIGlmIChpdmFsID49IHJnRGF0YS5BLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgaXZhbCA9IHJnRGF0YS5BLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgcmdEYXRhLkFbaXZhbF0rKztcbiAgICAgICAgICAgICAgICByZ0RhdGEubHN1bSA9IHJnRGF0YS5yc3VtID0gMC47XG5cbiAgICAgICAgICAgICAgICBTeXN0ZW0kMTUuYXJyYXljb3B5KHJnRGF0YS5sb3V0YnVmLCByZ0RhdGEudG90c2FtcCxcbiAgICAgICAgICAgICAgICAgICAgcmdEYXRhLmxvdXRidWYsIDAsIE1BWF9PUkRFUik7XG4gICAgICAgICAgICAgICAgU3lzdGVtJDE1LmFycmF5Y29weShyZ0RhdGEucm91dGJ1ZiwgcmdEYXRhLnRvdHNhbXAsXG4gICAgICAgICAgICAgICAgICAgIHJnRGF0YS5yb3V0YnVmLCAwLCBNQVhfT1JERVIpO1xuICAgICAgICAgICAgICAgIFN5c3RlbSQxNS5hcnJheWNvcHkocmdEYXRhLmxzdGVwYnVmLCByZ0RhdGEudG90c2FtcCxcbiAgICAgICAgICAgICAgICAgICAgcmdEYXRhLmxzdGVwYnVmLCAwLCBNQVhfT1JERVIpO1xuICAgICAgICAgICAgICAgIFN5c3RlbSQxNS5hcnJheWNvcHkocmdEYXRhLnJzdGVwYnVmLCByZ0RhdGEudG90c2FtcCxcbiAgICAgICAgICAgICAgICAgICAgcmdEYXRhLnJzdGVwYnVmLCAwLCBNQVhfT1JERVIpO1xuICAgICAgICAgICAgICAgIHJnRGF0YS50b3RzYW1wID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZ0RhdGEudG90c2FtcCA+IHJnRGF0YS5zYW1wbGVXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHNvbWVob3cgSSByZWFsbHkgc2NyZXdlZCB1cDogRXJyb3IgaW4gcHJvZ3JhbW1pbmchIENvbnRhY3RcbiAgICAgICAgICAgICAgICAgKiBhdXRob3IgYWJvdXQgdG90c2FtcCA+IHNhbXBsZVdpbmRvd1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBHQUlOX0FOQUxZU0lTX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChudW1fc2FtcGxlcyA8IE1BWF9PUkRFUikge1xuICAgICAgICAgICAgU3lzdGVtJDE1LmFycmF5Y29weShyZ0RhdGEubGlucHJlYnVmLCBudW1fc2FtcGxlcywgcmdEYXRhLmxpbnByZWJ1ZixcbiAgICAgICAgICAgICAgICAwLCBNQVhfT1JERVIgLSBudW1fc2FtcGxlcyk7XG4gICAgICAgICAgICBTeXN0ZW0kMTUuYXJyYXljb3B5KHJnRGF0YS5yaW5wcmVidWYsIG51bV9zYW1wbGVzLCByZ0RhdGEucmlucHJlYnVmLFxuICAgICAgICAgICAgICAgIDAsIE1BWF9PUkRFUiAtIG51bV9zYW1wbGVzKTtcbiAgICAgICAgICAgIFN5c3RlbSQxNS5hcnJheWNvcHkobGVmdF9zYW1wbGVzLCBsZWZ0X3NhbXBsZXNQb3MsIHJnRGF0YS5saW5wcmVidWYsXG4gICAgICAgICAgICAgICAgTUFYX09SREVSIC0gbnVtX3NhbXBsZXMsIG51bV9zYW1wbGVzKTtcbiAgICAgICAgICAgIFN5c3RlbSQxNS5hcnJheWNvcHkocmlnaHRfc2FtcGxlcywgcmlnaHRfc2FtcGxlc1BvcywgcmdEYXRhLnJpbnByZWJ1ZixcbiAgICAgICAgICAgICAgICBNQVhfT1JERVIgLSBudW1fc2FtcGxlcywgbnVtX3NhbXBsZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgU3lzdGVtJDE1LmFycmF5Y29weShsZWZ0X3NhbXBsZXMsIGxlZnRfc2FtcGxlc1BvcyArIG51bV9zYW1wbGVzXG4gICAgICAgICAgICAgICAgLSBNQVhfT1JERVIsIHJnRGF0YS5saW5wcmVidWYsIDAsIE1BWF9PUkRFUik7XG4gICAgICAgICAgICBTeXN0ZW0kMTUuYXJyYXljb3B5KHJpZ2h0X3NhbXBsZXMsIHJpZ2h0X3NhbXBsZXNQb3MgKyBudW1fc2FtcGxlc1xuICAgICAgICAgICAgICAgIC0gTUFYX09SREVSLCByZ0RhdGEucmlucHJlYnVmLCAwLCBNQVhfT1JERVIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEdBSU5fQU5BTFlTSVNfT0s7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFuYWx5emVSZXN1bHQoQXJyYXksIGxlbikge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICB2YXIgZWxlbXMgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICBlbGVtcyArPSBBcnJheVtpXTtcbiAgICAgICAgaWYgKGVsZW1zID09IDApXG4gICAgICAgICAgICByZXR1cm4gR0FJTl9OT1RfRU5PVUdIX1NBTVBMRVM7XG5cbiAgICAgICAgdmFyIHVwcGVyID0gMCB8IE1hdGguY2VpbChlbGVtcyAqICgxLiAtIFJNU19QRVJDRU5USUxFKSk7XG4gICAgICAgIGZvciAoaSA9IGxlbjsgaS0tID4gMDspIHtcbiAgICAgICAgICAgIGlmICgodXBwZXIgLT0gQXJyYXlbaV0pIDw9IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvL3JldHVybiAoZmxvYXQpICgoZmxvYXQpIFBJTktfUkVGIC0gKGZsb2F0KSBpIC8gKGZsb2F0KSBTVEVQU19wZXJfZEIpO1xuICAgICAgICByZXR1cm4gKFBJTktfUkVGIC0gaSAvIEdhaW5BbmFseXNpcyQxLlNURVBTX3Blcl9kQik7XG4gICAgfVxuXG4gICAgdGhpcy5HZXRUaXRsZUdhaW4gPSBmdW5jdGlvbiAocmdEYXRhKSB7XG4gICAgICAgIHZhciByZXR2YWwgPSBhbmFseXplUmVzdWx0KHJnRGF0YS5BLCByZ0RhdGEuQS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdEYXRhLkEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJnRGF0YS5CW2ldICs9IHJnRGF0YS5BW2ldO1xuICAgICAgICAgICAgcmdEYXRhLkFbaV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNQVhfT1JERVI7IGkrKylcbiAgICAgICAgICAgIHJnRGF0YS5saW5wcmVidWZbaV0gPSByZ0RhdGEubHN0ZXBidWZbaV0gPSByZ0RhdGEubG91dGJ1ZltpXSA9IHJnRGF0YS5yaW5wcmVidWZbaV0gPSByZ0RhdGEucnN0ZXBidWZbaV0gPSByZ0RhdGEucm91dGJ1ZltpXSA9IDAuO1xuXG4gICAgICAgIHJnRGF0YS50b3RzYW1wID0gMDtcbiAgICAgICAgcmdEYXRhLmxzdW0gPSByZ0RhdGEucnN1bSA9IDAuO1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH07XG5cbn1cblxudmFyIEdhaW5BbmFseXNpc18xID0gR2FpbkFuYWx5c2lzJDE7XG5cbnZhciBuZXdfZmxvYXQkMTQgPSBjb21tb24ubmV3X2Zsb2F0O1xudmFyIG5ld19pbnQkMTQgPSBjb21tb24ubmV3X2ludDtcbmZ1bmN0aW9uIFJlcGxheUdhaW4oKSB7XG4gICAgdGhpcy5saW5wcmVidWYgPSBuZXdfZmxvYXQkMTQoR2FpbkFuYWx5c2lzXzEuTUFYX09SREVSICogMik7XG4gICAgLyoqXG4gICAgICogbGVmdCBpbnB1dCBzYW1wbGVzLCB3aXRoIHByZS1idWZmZXJcbiAgICAgKi9cbiAgICB0aGlzLmxpbnByZSA9IDA7XG4gICAgdGhpcy5sc3RlcGJ1ZiA9IG5ld19mbG9hdCQxNChHYWluQW5hbHlzaXNfMS5NQVhfU0FNUExFU19QRVJfV0lORE9XICsgR2FpbkFuYWx5c2lzXzEuTUFYX09SREVSKTtcbiAgICAvKipcbiAgICAgKiBsZWZ0IFwiZmlyc3Qgc3RlcFwiIChpLmUuIHBvc3QgZmlyc3QgZmlsdGVyKSBzYW1wbGVzXG4gICAgICovXG4gICAgdGhpcy5sc3RlcCA9IDA7XG4gICAgdGhpcy5sb3V0YnVmID0gbmV3X2Zsb2F0JDE0KEdhaW5BbmFseXNpc18xLk1BWF9TQU1QTEVTX1BFUl9XSU5ET1cgKyBHYWluQW5hbHlzaXNfMS5NQVhfT1JERVIpO1xuICAgIC8qKlxuICAgICAqIGxlZnQgXCJvdXRcIiAoaS5lLiBwb3N0IHNlY29uZCBmaWx0ZXIpIHNhbXBsZXNcbiAgICAgKi9cbiAgICB0aGlzLmxvdXQgPSAwO1xuICAgIHRoaXMucmlucHJlYnVmID0gbmV3X2Zsb2F0JDE0KEdhaW5BbmFseXNpc18xLk1BWF9PUkRFUiAqIDIpO1xuICAgIC8qKlxuICAgICAqIHJpZ2h0IGlucHV0IHNhbXBsZXMgLi4uXG4gICAgICovXG4gICAgdGhpcy5yaW5wcmUgPSAwO1xuICAgIHRoaXMucnN0ZXBidWYgPSBuZXdfZmxvYXQkMTQoR2FpbkFuYWx5c2lzXzEuTUFYX1NBTVBMRVNfUEVSX1dJTkRPVyArIEdhaW5BbmFseXNpc18xLk1BWF9PUkRFUik7XG4gICAgdGhpcy5yc3RlcCA9IDA7XG4gICAgdGhpcy5yb3V0YnVmID0gbmV3X2Zsb2F0JDE0KEdhaW5BbmFseXNpc18xLk1BWF9TQU1QTEVTX1BFUl9XSU5ET1cgKyBHYWluQW5hbHlzaXNfMS5NQVhfT1JERVIpO1xuICAgIHRoaXMucm91dCA9IDA7XG4gICAgLyoqXG4gICAgICogbnVtYmVyIG9mIHNhbXBsZXMgcmVxdWlyZWQgdG8gcmVhY2ggbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyByZXF1aXJlZFxuICAgICAqIGZvciBSTVMgd2luZG93XG4gICAgICovXG4gICAgdGhpcy5zYW1wbGVXaW5kb3cgPSAwO1xuICAgIHRoaXMudG90c2FtcCA9IDA7XG4gICAgdGhpcy5sc3VtID0gMC47XG4gICAgdGhpcy5yc3VtID0gMC47XG4gICAgdGhpcy5mcmVxaW5kZXggPSAwO1xuICAgIHRoaXMuZmlyc3QgPSAwO1xuICAgIHRoaXMuQSA9IG5ld19pbnQkMTQoMCB8IChHYWluQW5hbHlzaXNfMS5TVEVQU19wZXJfZEIgKiBHYWluQW5hbHlzaXNfMS5NQVhfZEIpKTtcbiAgICB0aGlzLkIgPSBuZXdfaW50JDE0KDAgfCAoR2FpbkFuYWx5c2lzXzEuU1RFUFNfcGVyX2RCICogR2FpbkFuYWx5c2lzXzEuTUFYX2RCKSk7XG5cbn1cblxudmFyIFJlcGxheUdhaW5fMSA9IFJlcGxheUdhaW47XG5cbmZ1bmN0aW9uIE1lYW5CaXRzJDEobWVhbkJpdHMpIHtcbiAgICB0aGlzLmJpdHMgPSBtZWFuQml0cztcbn1cblxudmFyIE1lYW5CaXRzXzEgPSBNZWFuQml0cyQxO1xuXG52YXIgbmV3X2Zsb2F0JDE2ID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfaW50JDE2ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgYXNzZXJ0JDE2ID0gY29tbW9uLmFzc2VydDtcblxuXG5cblxuXG5cbmZ1bmN0aW9uIENCUk5ld0l0ZXJhdGlvbkxvb3AoX3F1YW50aXplKSAge1xuICAgIHZhciBxdWFudGl6ZSA9IF9xdWFudGl6ZTtcbiAgICB0aGlzLnF1YW50aXplID0gcXVhbnRpemU7XG5cdHRoaXMuaXRlcmF0aW9uX2xvb3AgPSBmdW5jdGlvbihnZnAsIHBlLCBtc19lbmVyX3JhdGlvLCByYXRpbykge1xuXHRcdHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBsM194bWluID0gbmV3X2Zsb2F0JDE2KEwzU2lkZV8xLlNGQk1BWCk7XG5cdFx0dmFyIHhycG93ID0gbmV3X2Zsb2F0JDE2KDU3Nik7XG5cdFx0dmFyIHRhcmdfYml0cyA9IG5ld19pbnQkMTYoMik7XG5cdFx0dmFyIG1lYW5fYml0cyA9IDAsIG1heF9iaXRzO1xuXHRcdHZhciBsM19zaWRlID0gZ2ZjLmwzX3NpZGU7XG5cblx0XHR2YXIgbWIgPSBuZXcgTWVhbkJpdHNfMShtZWFuX2JpdHMpO1xuXHRcdHRoaXMucXVhbnRpemUucnYuUmVzdkZyYW1lQmVnaW4oZ2ZwLCBtYik7XG5cdFx0bWVhbl9iaXRzID0gbWIuYml0cztcblxuXHRcdC8qIHF1YW50aXplISAqL1xuXHRcdGZvciAodmFyIGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuXG5cdFx0XHQvKlxuXHRcdFx0ICogY2FsY3VsYXRlIG5lZWRlZCBiaXRzXG5cdFx0XHQgKi9cblx0XHRcdG1heF9iaXRzID0gdGhpcy5xdWFudGl6ZS5xdXB2dC5vbl9wZShnZnAsIHBlLCB0YXJnX2JpdHMsIG1lYW5fYml0cyxcblx0XHRcdFx0XHRnciwgZ3IpO1xuXG5cdFx0XHRpZiAoZ2ZjLm1vZGVfZXh0ID09IEVuY29kZXJfMS5NUEdfTURfTVNfTFIpIHtcblx0XHRcdFx0dGhpcy5xdWFudGl6ZS5tc19jb252ZXJ0KGdmYy5sM19zaWRlLCBncik7XG5cdFx0XHRcdHRoaXMucXVhbnRpemUucXVwdnQucmVkdWNlX3NpZGUodGFyZ19iaXRzLCBtc19lbmVyX3JhdGlvW2dyXSxcblx0XHRcdFx0XHRcdG1lYW5fYml0cywgbWF4X2JpdHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuXHRcdFx0XHR2YXIgYWRqdXN0LCBtYXNraW5nX2xvd2VyX2RiO1xuXHRcdFx0XHR2YXIgY29kX2luZm8gPSBsM19zaWRlLnR0W2dyXVtjaF07XG5cblx0XHRcdFx0aWYgKGNvZF9pbmZvLmJsb2NrX3R5cGUgIT0gRW5jb2Rlcl8xLlNIT1JUX1RZUEUpIHtcblx0XHRcdFx0XHQvLyBOT1JNLCBTVEFSVCBvciBTVE9QIHR5cGVcblx0XHRcdFx0XHRhZGp1c3QgPSAwO1xuXHRcdFx0XHRcdG1hc2tpbmdfbG93ZXJfZGIgPSBnZmMuUFNZLm1hc2tfYWRqdXN0IC0gYWRqdXN0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFkanVzdCA9IDA7XG5cdFx0XHRcdFx0bWFza2luZ19sb3dlcl9kYiA9IGdmYy5QU1kubWFza19hZGp1c3Rfc2hvcnQgLSBhZGp1c3Q7XG5cdFx0XHRcdH1cblx0XHRcdFx0Z2ZjLm1hc2tpbmdfbG93ZXIgPSAgTWF0aC5wb3coMTAuMCxcblx0XHRcdFx0XHRcdG1hc2tpbmdfbG93ZXJfZGIgKiAwLjEpO1xuXG5cdFx0XHRcdC8qXG5cdFx0XHRcdCAqIGluaXRfb3V0ZXJfbG9vcCBzZXRzIHVwIGNvZF9pbmZvLCBzY2FsZWZhYyBhbmQgeHJwb3dcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMucXVhbnRpemUuaW5pdF9vdXRlcl9sb29wKGdmYywgY29kX2luZm8pO1xuXHRcdFx0XHRpZiAodGhpcy5xdWFudGl6ZS5pbml0X3hycG93KGdmYywgY29kX2luZm8sIHhycG93KSkge1xuXHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0ICogeHIgY29udGFpbnMgZW5lcmd5IHdlIHdpbGwgaGF2ZSB0byBlbmNvZGUgY2FsY3VsYXRlIHRoZVxuXHRcdFx0XHRcdCAqIG1hc2tpbmcgYWJpbGl0aWVzIGZpbmQgc29tZSBnb29kIHF1YW50aXphdGlvbiBpblxuXHRcdFx0XHRcdCAqIG91dGVyX2xvb3Bcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHR0aGlzLnF1YW50aXplLnF1cHZ0LmNhbGNfeG1pbihnZnAsIHJhdGlvW2dyXVtjaF0sIGNvZF9pbmZvLFxuXHRcdFx0XHRcdFx0XHRsM194bWluKTtcblx0XHRcdFx0XHR0aGlzLnF1YW50aXplLm91dGVyX2xvb3AoZ2ZwLCBjb2RfaW5mbywgbDNfeG1pbiwgeHJwb3csIGNoLFxuXHRcdFx0XHRcdFx0XHR0YXJnX2JpdHNbY2hdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMucXVhbnRpemUuaXRlcmF0aW9uX2ZpbmlzaF9vbmUoZ2ZjLCBnciwgY2gpO1xuXHRcdFx0XHRhc3NlcnQkMTYgKGNvZF9pbmZvLnBhcnQyXzNfbGVuZ3RoIDw9IExhbWVJbnRlcm5hbEZsYWdzXzEuTUFYX0JJVFNfUEVSX0NIQU5ORUwpO1xuXHRcdFx0XHRhc3NlcnQkMTYgKGNvZF9pbmZvLnBhcnQyXzNfbGVuZ3RoIDw9IHRhcmdfYml0c1tjaF0pO1xuXHRcdFx0fSAvKiBmb3IgY2ggKi9cblx0XHR9IC8qIGZvciBnciAqL1xuXG5cdFx0dGhpcy5xdWFudGl6ZS5ydi5SZXN2RnJhbWVFbmQoZ2ZjLCBtZWFuX2JpdHMpO1xuXHR9O1xufVxudmFyIENCUk5ld0l0ZXJhdGlvbkxvb3BfMSA9IENCUk5ld0l0ZXJhdGlvbkxvb3A7XG5cbmZ1bmN0aW9uIEh1ZmZDb2RlVGFiKGxlbiwgbWF4LCB0YWIsIGhsKSB7XG4gICAgdGhpcy54bGVuID0gbGVuO1xuICAgIHRoaXMubGlubWF4ID0gbWF4O1xuICAgIHRoaXMudGFibGUgPSB0YWI7XG4gICAgdGhpcy5obGVuID0gaGw7XG59XG5cbnZhciBUYWJsZXMkMSA9IHt9O1xuXG5cblRhYmxlcyQxLnQxSEIgPSBbXG4gICAgMSwgMSxcbiAgICAxLCAwXG5dO1xuXG5UYWJsZXMkMS50MkhCID0gW1xuICAgIDEsIDIsIDEsXG4gICAgMywgMSwgMSxcbiAgICAzLCAyLCAwXG5dO1xuXG5UYWJsZXMkMS50M0hCID0gW1xuICAgIDMsIDIsIDEsXG4gICAgMSwgMSwgMSxcbiAgICAzLCAyLCAwXG5dO1xuXG5UYWJsZXMkMS50NUhCID0gW1xuICAgIDEsIDIsIDYsIDUsXG4gICAgMywgMSwgNCwgNCxcbiAgICA3LCA1LCA3LCAxLFxuICAgIDYsIDEsIDEsIDBcbl07XG5cblRhYmxlcyQxLnQ2SEIgPSBbXG4gICAgNywgMywgNSwgMSxcbiAgICA2LCAyLCAzLCAyLFxuICAgIDUsIDQsIDQsIDEsXG4gICAgMywgMywgMiwgMFxuXTtcblxuVGFibGVzJDEudDdIQiA9IFtcbiAgICAxLCAyLCAxMCwgMTksIDE2LCAxMCxcbiAgICAzLCAzLCA3LCAxMCwgNSwgMyxcbiAgICAxMSwgNCwgMTMsIDE3LCA4LCA0LFxuICAgIDEyLCAxMSwgMTgsIDE1LCAxMSwgMixcbiAgICA3LCA2LCA5LCAxNCwgMywgMSxcbiAgICA2LCA0LCA1LCAzLCAyLCAwXG5dO1xuXG5UYWJsZXMkMS50OEhCID0gW1xuICAgIDMsIDQsIDYsIDE4LCAxMiwgNSxcbiAgICA1LCAxLCAyLCAxNiwgOSwgMyxcbiAgICA3LCAzLCA1LCAxNCwgNywgMyxcbiAgICAxOSwgMTcsIDE1LCAxMywgMTAsIDQsXG4gICAgMTMsIDUsIDgsIDExLCA1LCAxLFxuICAgIDEyLCA0LCA0LCAxLCAxLCAwXG5dO1xuXG5UYWJsZXMkMS50OUhCID0gW1xuICAgIDcsIDUsIDksIDE0LCAxNSwgNyxcbiAgICA2LCA0LCA1LCA1LCA2LCA3LFxuICAgIDcsIDYsIDgsIDgsIDgsIDUsXG4gICAgMTUsIDYsIDksIDEwLCA1LCAxLFxuICAgIDExLCA3LCA5LCA2LCA0LCAxLFxuICAgIDE0LCA0LCA2LCAyLCA2LCAwXG5dO1xuXG5UYWJsZXMkMS50MTBIQiA9IFtcbiAgICAxLCAyLCAxMCwgMjMsIDM1LCAzMCwgMTIsIDE3LFxuICAgIDMsIDMsIDgsIDEyLCAxOCwgMjEsIDEyLCA3LFxuICAgIDExLCA5LCAxNSwgMjEsIDMyLCA0MCwgMTksIDYsXG4gICAgMTQsIDEzLCAyMiwgMzQsIDQ2LCAyMywgMTgsIDcsXG4gICAgMjAsIDE5LCAzMywgNDcsIDI3LCAyMiwgOSwgMyxcbiAgICAzMSwgMjIsIDQxLCAyNiwgMjEsIDIwLCA1LCAzLFxuICAgIDE0LCAxMywgMTAsIDExLCAxNiwgNiwgNSwgMSxcbiAgICA5LCA4LCA3LCA4LCA0LCA0LCAyLCAwXG5dO1xuXG5UYWJsZXMkMS50MTFIQiA9IFtcbiAgICAzLCA0LCAxMCwgMjQsIDM0LCAzMywgMjEsIDE1LFxuICAgIDUsIDMsIDQsIDEwLCAzMiwgMTcsIDExLCAxMCxcbiAgICAxMSwgNywgMTMsIDE4LCAzMCwgMzEsIDIwLCA1LFxuICAgIDI1LCAxMSwgMTksIDU5LCAyNywgMTgsIDEyLCA1LFxuICAgIDM1LCAzMywgMzEsIDU4LCAzMCwgMTYsIDcsIDUsXG4gICAgMjgsIDI2LCAzMiwgMTksIDE3LCAxNSwgOCwgMTQsXG4gICAgMTQsIDEyLCA5LCAxMywgMTQsIDksIDQsIDEsXG4gICAgMTEsIDQsIDYsIDYsIDYsIDMsIDIsIDBcbl07XG5cblRhYmxlcyQxLnQxMkhCID0gW1xuICAgIDksIDYsIDE2LCAzMywgNDEsIDM5LCAzOCwgMjYsXG4gICAgNywgNSwgNiwgOSwgMjMsIDE2LCAyNiwgMTEsXG4gICAgMTcsIDcsIDExLCAxNCwgMjEsIDMwLCAxMCwgNyxcbiAgICAxNywgMTAsIDE1LCAxMiwgMTgsIDI4LCAxNCwgNSxcbiAgICAzMiwgMTMsIDIyLCAxOSwgMTgsIDE2LCA5LCA1LFxuICAgIDQwLCAxNywgMzEsIDI5LCAxNywgMTMsIDQsIDIsXG4gICAgMjcsIDEyLCAxMSwgMTUsIDEwLCA3LCA0LCAxLFxuICAgIDI3LCAxMiwgOCwgMTIsIDYsIDMsIDEsIDBcbl07XG5cblRhYmxlcyQxLnQxM0hCID0gW1xuICAgIDEsIDUsIDE0LCAyMSwgMzQsIDUxLCA0NiwgNzEsIDQyLCA1MiwgNjgsIDUyLCA2NywgNDQsIDQzLCAxOSxcbiAgICAzLCA0LCAxMiwgMTksIDMxLCAyNiwgNDQsIDMzLCAzMSwgMjQsIDMyLCAyNCwgMzEsIDM1LCAyMiwgMTQsXG4gICAgMTUsIDEzLCAyMywgMzYsIDU5LCA0OSwgNzcsIDY1LCAyOSwgNDAsIDMwLCA0MCwgMjcsIDMzLCA0MiwgMTYsXG4gICAgMjIsIDIwLCAzNywgNjEsIDU2LCA3OSwgNzMsIDY0LCA0MywgNzYsIDU2LCAzNywgMjYsIDMxLCAyNSwgMTQsXG4gICAgMzUsIDE2LCA2MCwgNTcsIDk3LCA3NSwgMTE0LCA5MSwgNTQsIDczLCA1NSwgNDEsIDQ4LCA1MywgMjMsIDI0LFxuICAgIDU4LCAyNywgNTAsIDk2LCA3NiwgNzAsIDkzLCA4NCwgNzcsIDU4LCA3OSwgMjksIDc0LCA0OSwgNDEsIDE3LFxuICAgIDQ3LCA0NSwgNzgsIDc0LCAxMTUsIDk0LCA5MCwgNzksIDY5LCA4MywgNzEsIDUwLCA1OSwgMzgsIDM2LCAxNSxcbiAgICA3MiwgMzQsIDU2LCA5NSwgOTIsIDg1LCA5MSwgOTAsIDg2LCA3MywgNzcsIDY1LCA1MSwgNDQsIDQzLCA0MixcbiAgICA0MywgMjAsIDMwLCA0NCwgNTUsIDc4LCA3MiwgODcsIDc4LCA2MSwgNDYsIDU0LCAzNywgMzAsIDIwLCAxNixcbiAgICA1MywgMjUsIDQxLCAzNywgNDQsIDU5LCA1NCwgODEsIDY2LCA3NiwgNTcsIDU0LCAzNywgMTgsIDM5LCAxMSxcbiAgICAzNSwgMzMsIDMxLCA1NywgNDIsIDgyLCA3MiwgODAsIDQ3LCA1OCwgNTUsIDIxLCAyMiwgMjYsIDM4LCAyMixcbiAgICA1MywgMjUsIDIzLCAzOCwgNzAsIDYwLCA1MSwgMzYsIDU1LCAyNiwgMzQsIDIzLCAyNywgMTQsIDksIDcsXG4gICAgMzQsIDMyLCAyOCwgMzksIDQ5LCA3NSwgMzAsIDUyLCA0OCwgNDAsIDUyLCAyOCwgMTgsIDE3LCA5LCA1LFxuICAgIDQ1LCAyMSwgMzQsIDY0LCA1NiwgNTAsIDQ5LCA0NSwgMzEsIDE5LCAxMiwgMTUsIDEwLCA3LCA2LCAzLFxuICAgIDQ4LCAyMywgMjAsIDM5LCAzNiwgMzUsIDUzLCAyMSwgMTYsIDIzLCAxMywgMTAsIDYsIDEsIDQsIDIsXG4gICAgMTYsIDE1LCAxNywgMjcsIDI1LCAyMCwgMjksIDExLCAxNywgMTIsIDE2LCA4LCAxLCAxLCAwLCAxXG5dO1xuXG5UYWJsZXMkMS50MTVIQiA9IFtcbiAgICA3LCAxMiwgMTgsIDUzLCA0NywgNzYsIDEyNCwgMTA4LCA4OSwgMTIzLCAxMDgsIDExOSwgMTA3LCA4MSwgMTIyLCA2MyxcbiAgICAxMywgNSwgMTYsIDI3LCA0NiwgMzYsIDYxLCA1MSwgNDIsIDcwLCA1MiwgODMsIDY1LCA0MSwgNTksIDM2LFxuICAgIDE5LCAxNywgMTUsIDI0LCA0MSwgMzQsIDU5LCA0OCwgNDAsIDY0LCA1MCwgNzgsIDYyLCA4MCwgNTYsIDMzLFxuICAgIDI5LCAyOCwgMjUsIDQzLCAzOSwgNjMsIDU1LCA5MywgNzYsIDU5LCA5MywgNzIsIDU0LCA3NSwgNTAsIDI5LFxuICAgIDUyLCAyMiwgNDIsIDQwLCA2NywgNTcsIDk1LCA3OSwgNzIsIDU3LCA4OSwgNjksIDQ5LCA2NiwgNDYsIDI3LFxuICAgIDc3LCAzNywgMzUsIDY2LCA1OCwgNTIsIDkxLCA3NCwgNjIsIDQ4LCA3OSwgNjMsIDkwLCA2MiwgNDAsIDM4LFxuICAgIDEyNSwgMzIsIDYwLCA1NiwgNTAsIDkyLCA3OCwgNjUsIDU1LCA4NywgNzEsIDUxLCA3MywgNTEsIDcwLCAzMCxcbiAgICAxMDksIDUzLCA0OSwgOTQsIDg4LCA3NSwgNjYsIDEyMiwgOTEsIDczLCA1NiwgNDIsIDY0LCA0NCwgMjEsIDI1LFxuICAgIDkwLCA0MywgNDEsIDc3LCA3MywgNjMsIDU2LCA5MiwgNzcsIDY2LCA0NywgNjcsIDQ4LCA1MywgMzYsIDIwLFxuICAgIDcxLCAzNCwgNjcsIDYwLCA1OCwgNDksIDg4LCA3NiwgNjcsIDEwNiwgNzEsIDU0LCAzOCwgMzksIDIzLCAxNSxcbiAgICAxMDksIDUzLCA1MSwgNDcsIDkwLCA4MiwgNTgsIDU3LCA0OCwgNzIsIDU3LCA0MSwgMjMsIDI3LCA2MiwgOSxcbiAgICA4NiwgNDIsIDQwLCAzNywgNzAsIDY0LCA1MiwgNDMsIDcwLCA1NSwgNDIsIDI1LCAyOSwgMTgsIDExLCAxMSxcbiAgICAxMTgsIDY4LCAzMCwgNTUsIDUwLCA0NiwgNzQsIDY1LCA0OSwgMzksIDI0LCAxNiwgMjIsIDEzLCAxNCwgNyxcbiAgICA5MSwgNDQsIDM5LCAzOCwgMzQsIDYzLCA1MiwgNDUsIDMxLCA1MiwgMjgsIDE5LCAxNCwgOCwgOSwgMyxcbiAgICAxMjMsIDYwLCA1OCwgNTMsIDQ3LCA0MywgMzIsIDIyLCAzNywgMjQsIDE3LCAxMiwgMTUsIDEwLCAyLCAxLFxuICAgIDcxLCAzNywgMzQsIDMwLCAyOCwgMjAsIDE3LCAyNiwgMjEsIDE2LCAxMCwgNiwgOCwgNiwgMiwgMFxuXTtcblxuVGFibGVzJDEudDE2SEIgPSBbXG4gICAgMSwgNSwgMTQsIDQ0LCA3NCwgNjMsIDExMCwgOTMsIDE3MiwgMTQ5LCAxMzgsIDI0MiwgMjI1LCAxOTUsIDM3NiwgMTcsXG4gICAgMywgNCwgMTIsIDIwLCAzNSwgNjIsIDUzLCA0NywgODMsIDc1LCA2OCwgMTE5LCAyMDEsIDEwNywgMjA3LCA5LFxuICAgIDE1LCAxMywgMjMsIDM4LCA2NywgNTgsIDEwMywgOTAsIDE2MSwgNzIsIDEyNywgMTE3LCAxMTAsIDIwOSwgMjA2LCAxNixcbiAgICA0NSwgMjEsIDM5LCA2OSwgNjQsIDExNCwgOTksIDg3LCAxNTgsIDE0MCwgMjUyLCAyMTIsIDE5OSwgMzg3LCAzNjUsIDI2LFxuICAgIDc1LCAzNiwgNjgsIDY1LCAxMTUsIDEwMSwgMTc5LCAxNjQsIDE1NSwgMjY0LCAyNDYsIDIyNiwgMzk1LCAzODIsIDM2MiwgOSxcbiAgICA2NiwgMzAsIDU5LCA1NiwgMTAyLCAxODUsIDE3MywgMjY1LCAxNDIsIDI1MywgMjMyLCA0MDAsIDM4OCwgMzc4LCA0NDUsIDE2LFxuICAgIDExMSwgNTQsIDUyLCAxMDAsIDE4NCwgMTc4LCAxNjAsIDEzMywgMjU3LCAyNDQsIDIyOCwgMjE3LCAzODUsIDM2NiwgNzE1LCAxMCxcbiAgICA5OCwgNDgsIDkxLCA4OCwgMTY1LCAxNTcsIDE0OCwgMjYxLCAyNDgsIDQwNywgMzk3LCAzNzIsIDM4MCwgODg5LCA4ODQsIDgsXG4gICAgODUsIDg0LCA4MSwgMTU5LCAxNTYsIDE0MywgMjYwLCAyNDksIDQyNywgNDAxLCAzOTIsIDM4MywgNzI3LCA3MTMsIDcwOCwgNyxcbiAgICAxNTQsIDc2LCA3MywgMTQxLCAxMzEsIDI1NiwgMjQ1LCA0MjYsIDQwNiwgMzk0LCAzODQsIDczNSwgMzU5LCA3MTAsIDM1MiwgMTEsXG4gICAgMTM5LCAxMjksIDY3LCAxMjUsIDI0NywgMjMzLCAyMjksIDIxOSwgMzkzLCA3NDMsIDczNywgNzIwLCA4ODUsIDg4MiwgNDM5LCA0LFxuICAgIDI0MywgMTIwLCAxMTgsIDExNSwgMjI3LCAyMjMsIDM5NiwgNzQ2LCA3NDIsIDczNiwgNzIxLCA3MTIsIDcwNiwgMjIzLCA0MzYsIDYsXG4gICAgMjAyLCAyMjQsIDIyMiwgMjE4LCAyMTYsIDM4OSwgMzg2LCAzODEsIDM2NCwgODg4LCA0NDMsIDcwNywgNDQwLCA0MzcsIDE3MjgsIDQsXG4gICAgNzQ3LCAyMTEsIDIxMCwgMjA4LCAzNzAsIDM3OSwgNzM0LCA3MjMsIDcxNCwgMTczNSwgODgzLCA4NzcsIDg3NiwgMzQ1OSwgODY1LCAyLFxuICAgIDM3NywgMzY5LCAxMDIsIDE4NywgNzI2LCA3MjIsIDM1OCwgNzExLCA3MDksIDg2NiwgMTczNCwgODcxLCAzNDU4LCA4NzAsIDQzNCwgMCxcbiAgICAxMiwgMTAsIDcsIDExLCAxMCwgMTcsIDExLCA5LCAxMywgMTIsIDEwLCA3LCA1LCAzLCAxLCAzXG5dO1xuXG5UYWJsZXMkMS50MjRIQiA9IFtcbiAgICAxNSwgMTMsIDQ2LCA4MCwgMTQ2LCAyNjIsIDI0OCwgNDM0LCA0MjYsIDY2OSwgNjUzLCA2NDksIDYyMSwgNTE3LCAxMDMyLCA4OCxcbiAgICAxNCwgMTIsIDIxLCAzOCwgNzEsIDEzMCwgMTIyLCAyMTYsIDIwOSwgMTk4LCAzMjcsIDM0NSwgMzE5LCAyOTcsIDI3OSwgNDIsXG4gICAgNDcsIDIyLCA0MSwgNzQsIDY4LCAxMjgsIDEyMCwgMjIxLCAyMDcsIDE5NCwgMTgyLCAzNDAsIDMxNSwgMjk1LCA1NDEsIDE4LFxuICAgIDgxLCAzOSwgNzUsIDcwLCAxMzQsIDEyNSwgMTE2LCAyMjAsIDIwNCwgMTkwLCAxNzgsIDMyNSwgMzExLCAyOTMsIDI3MSwgMTYsXG4gICAgMTQ3LCA3MiwgNjksIDEzNSwgMTI3LCAxMTgsIDExMiwgMjEwLCAyMDAsIDE4OCwgMzUyLCAzMjMsIDMwNiwgMjg1LCA1NDAsIDE0LFxuICAgIDI2MywgNjYsIDEyOSwgMTI2LCAxMTksIDExNCwgMjE0LCAyMDIsIDE5MiwgMTgwLCAzNDEsIDMxNywgMzAxLCAyODEsIDI2MiwgMTIsXG4gICAgMjQ5LCAxMjMsIDEyMSwgMTE3LCAxMTMsIDIxNSwgMjA2LCAxOTUsIDE4NSwgMzQ3LCAzMzAsIDMwOCwgMjkxLCAyNzIsIDUyMCwgMTAsXG4gICAgNDM1LCAxMTUsIDExMSwgMTA5LCAyMTEsIDIwMywgMTk2LCAxODcsIDM1MywgMzMyLCAzMTMsIDI5OCwgMjgzLCA1MzEsIDM4MSwgMTcsXG4gICAgNDI3LCAyMTIsIDIwOCwgMjA1LCAyMDEsIDE5MywgMTg2LCAxNzcsIDE2OSwgMzIwLCAzMDMsIDI4NiwgMjY4LCA1MTQsIDM3NywgMTYsXG4gICAgMzM1LCAxOTksIDE5NywgMTkxLCAxODksIDE4MSwgMTc0LCAzMzMsIDMyMSwgMzA1LCAyODksIDI3NSwgNTIxLCAzNzksIDM3MSwgMTEsXG4gICAgNjY4LCAxODQsIDE4MywgMTc5LCAxNzUsIDM0NCwgMzMxLCAzMTQsIDMwNCwgMjkwLCAyNzcsIDUzMCwgMzgzLCAzNzMsIDM2NiwgMTAsXG4gICAgNjUyLCAzNDYsIDE3MSwgMTY4LCAxNjQsIDMxOCwgMzA5LCAyOTksIDI4NywgMjc2LCAyNjMsIDUxMywgMzc1LCAzNjgsIDM2MiwgNixcbiAgICA2NDgsIDMyMiwgMzE2LCAzMTIsIDMwNywgMzAyLCAyOTIsIDI4NCwgMjY5LCAyNjEsIDUxMiwgMzc2LCAzNzAsIDM2NCwgMzU5LCA0LFxuICAgIDYyMCwgMzAwLCAyOTYsIDI5NCwgMjg4LCAyODIsIDI3MywgMjY2LCA1MTUsIDM4MCwgMzc0LCAzNjksIDM2NSwgMzYxLCAzNTcsIDIsXG4gICAgMTAzMywgMjgwLCAyNzgsIDI3NCwgMjY3LCAyNjQsIDI1OSwgMzgyLCAzNzgsIDM3MiwgMzY3LCAzNjMsIDM2MCwgMzU4LCAzNTYsIDAsXG4gICAgNDMsIDIwLCAxOSwgMTcsIDE1LCAxMywgMTEsIDksIDcsIDYsIDQsIDcsIDUsIDMsIDEsIDNcbl07XG5cblRhYmxlcyQxLnQzMkhCID0gW1xuICAgIDEgPDwgMCwgNSA8PCAxLCA0IDw8IDEsIDUgPDwgMiwgNiA8PCAxLCA1IDw8IDIsIDQgPDwgMiwgNCA8PCAzLFxuICAgIDcgPDwgMSwgMyA8PCAyLCA2IDw8IDIsIDAgPDwgMywgNyA8PCAyLCAyIDw8IDMsIDMgPDwgMywgMSA8PCA0XG5dO1xuXG5UYWJsZXMkMS50MzNIQiA9IFtcbiAgICAxNSA8PCAwLCAxNCA8PCAxLCAxMyA8PCAxLCAxMiA8PCAyLCAxMSA8PCAxLCAxMCA8PCAyLCA5IDw8IDIsIDggPDwgMyxcbiAgICA3IDw8IDEsIDYgPDwgMiwgNSA8PCAyLCA0IDw8IDMsIDMgPDwgMiwgMiA8PCAzLCAxIDw8IDMsIDAgPDwgNFxuXTtcblxuVGFibGVzJDEudDFsID0gW1xuICAgIDEsIDQsXG4gICAgMywgNVxuXTtcblxuVGFibGVzJDEudDJsID0gW1xuICAgIDEsIDQsIDcsXG4gICAgNCwgNSwgNyxcbiAgICA2LCA3LCA4XG5dO1xuXG5UYWJsZXMkMS50M2wgPSBbXG4gICAgMiwgMywgNyxcbiAgICA0LCA0LCA3LFxuICAgIDYsIDcsIDhcbl07XG5cblRhYmxlcyQxLnQ1bCA9IFtcbiAgICAxLCA0LCA3LCA4LFxuICAgIDQsIDUsIDgsIDksXG4gICAgNywgOCwgOSwgMTAsXG4gICAgOCwgOCwgOSwgMTBcbl07XG5cblRhYmxlcyQxLnQ2bCA9IFtcbiAgICAzLCA0LCA2LCA4LFxuICAgIDQsIDQsIDYsIDcsXG4gICAgNSwgNiwgNywgOCxcbiAgICA3LCA3LCA4LCA5XG5dO1xuXG5UYWJsZXMkMS50N2wgPSBbXG4gICAgMSwgNCwgNywgOSwgOSwgMTAsXG4gICAgNCwgNiwgOCwgOSwgOSwgMTAsXG4gICAgNywgNywgOSwgMTAsIDEwLCAxMSxcbiAgICA4LCA5LCAxMCwgMTEsIDExLCAxMSxcbiAgICA4LCA5LCAxMCwgMTEsIDExLCAxMixcbiAgICA5LCAxMCwgMTEsIDEyLCAxMiwgMTJcbl07XG5cblRhYmxlcyQxLnQ4bCA9IFtcbiAgICAyLCA0LCA3LCA5LCA5LCAxMCxcbiAgICA0LCA0LCA2LCAxMCwgMTAsIDEwLFxuICAgIDcsIDYsIDgsIDEwLCAxMCwgMTEsXG4gICAgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLFxuICAgIDksIDksIDEwLCAxMSwgMTIsIDEyLFxuICAgIDEwLCAxMCwgMTEsIDExLCAxMywgMTNcbl07XG5cblRhYmxlcyQxLnQ5bCA9IFtcbiAgICAzLCA0LCA2LCA3LCA5LCAxMCxcbiAgICA0LCA1LCA2LCA3LCA4LCAxMCxcbiAgICA1LCA2LCA3LCA4LCA5LCAxMCxcbiAgICA3LCA3LCA4LCA5LCA5LCAxMCxcbiAgICA4LCA4LCA5LCA5LCAxMCwgMTEsXG4gICAgOSwgOSwgMTAsIDEwLCAxMSwgMTFcbl07XG5cblRhYmxlcyQxLnQxMGwgPSBbXG4gICAgMSwgNCwgNywgOSwgMTAsIDEwLCAxMCwgMTEsXG4gICAgNCwgNiwgOCwgOSwgMTAsIDExLCAxMCwgMTAsXG4gICAgNywgOCwgOSwgMTAsIDExLCAxMiwgMTEsIDExLFxuICAgIDgsIDksIDEwLCAxMSwgMTIsIDEyLCAxMSwgMTIsXG4gICAgOSwgMTAsIDExLCAxMiwgMTIsIDEyLCAxMiwgMTIsXG4gICAgMTAsIDExLCAxMiwgMTIsIDEzLCAxMywgMTIsIDEzLFxuICAgIDksIDEwLCAxMSwgMTIsIDEyLCAxMiwgMTMsIDEzLFxuICAgIDEwLCAxMCwgMTEsIDEyLCAxMiwgMTMsIDEzLCAxM1xuXTtcblxuVGFibGVzJDEudDExbCA9IFtcbiAgICAyLCA0LCA2LCA4LCA5LCAxMCwgOSwgMTAsXG4gICAgNCwgNSwgNiwgOCwgMTAsIDEwLCA5LCAxMCxcbiAgICA2LCA3LCA4LCA5LCAxMCwgMTEsIDEwLCAxMCxcbiAgICA4LCA4LCA5LCAxMSwgMTAsIDEyLCAxMCwgMTEsXG4gICAgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMSwgMTIsXG4gICAgOSwgMTAsIDExLCAxMiwgMTIsIDEzLCAxMiwgMTMsXG4gICAgOSwgOSwgOSwgMTAsIDExLCAxMiwgMTIsIDEyLFxuICAgIDksIDksIDEwLCAxMSwgMTIsIDEyLCAxMiwgMTJcbl07XG5cblRhYmxlcyQxLnQxMmwgPSBbXG4gICAgNCwgNCwgNiwgOCwgOSwgMTAsIDEwLCAxMCxcbiAgICA0LCA1LCA2LCA3LCA5LCA5LCAxMCwgMTAsXG4gICAgNiwgNiwgNywgOCwgOSwgMTAsIDksIDEwLFxuICAgIDcsIDcsIDgsIDgsIDksIDEwLCAxMCwgMTAsXG4gICAgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMCwgMTEsXG4gICAgOSwgOSwgMTAsIDEwLCAxMCwgMTEsIDEwLCAxMSxcbiAgICA5LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsXG4gICAgMTAsIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDEyXG5dO1xuXG5UYWJsZXMkMS50MTNsID0gW1xuICAgIDEsIDUsIDcsIDgsIDksIDEwLCAxMCwgMTEsIDEwLCAxMSwgMTIsIDEyLCAxMywgMTMsIDE0LCAxNCxcbiAgICA0LCA2LCA4LCA5LCAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEzLCAxNCwgMTQsIDE0LFxuICAgIDcsIDgsIDksIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTEsIDEyLCAxMiwgMTMsIDEzLCAxNCwgMTUsIDE1LFxuICAgIDgsIDksIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTQsIDE1LCAxNSxcbiAgICA5LCA5LCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNSwgMTYsXG4gICAgMTAsIDEwLCAxMSwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTMsIDE0LCAxMywgMTUsIDE1LCAxNiwgMTYsXG4gICAgMTAsIDExLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTUsIDE1LCAxNiwgMTYsXG4gICAgMTEsIDExLCAxMiwgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE2LCAxOCwgMTgsXG4gICAgMTAsIDEwLCAxMSwgMTIsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE2LCAxNywgMTcsXG4gICAgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgMTMsIDE1LCAxNCwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxOCwgMTcsXG4gICAgMTEsIDEyLCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNCwgMTUsIDE2LCAxNSwgMTYsIDE3LCAxOCwgMTksXG4gICAgMTIsIDEyLCAxMiwgMTMsIDE0LCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNiwgMTcsIDE3LCAxNywgMTgsXG4gICAgMTIsIDEzLCAxMywgMTQsIDE0LCAxNSwgMTQsIDE1LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsXG4gICAgMTMsIDEzLCAxNCwgMTUsIDE1LCAxNSwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTgsIDE3LCAxOCwgMTgsXG4gICAgMTQsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTcsIDE2LCAxNiwgMTksIDE3LCAxNywgMTcsIDE5LCAxOCwgMTgsXG4gICAgMTMsIDE0LCAxNSwgMTYsIDE2LCAxNiwgMTcsIDE2LCAxNywgMTcsIDE4LCAxOCwgMjEsIDIwLCAyMSwgMThcbl07XG5cblRhYmxlcyQxLnQxNWwgPSBbXG4gICAgMywgNSwgNiwgOCwgOCwgOSwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTQsXG4gICAgNSwgNSwgNywgOCwgOSwgOSwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsXG4gICAgNiwgNywgNywgOCwgOSwgOSwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgMTMsXG4gICAgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLFxuICAgIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsXG4gICAgOSwgOSwgOSwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTQsXG4gICAgMTAsIDksIDEwLCAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsIDE0LCAxNCxcbiAgICAxMCwgMTAsIDEwLCAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxNCxcbiAgICAxMCwgMTAsIDEwLCAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTQsIDE0LCAxNCxcbiAgICAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCxcbiAgICAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTQsIDE1LCAxNCxcbiAgICAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNSxcbiAgICAxMiwgMTIsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNSxcbiAgICAxMiwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE1LCAxNSxcbiAgICAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE0LCAxNSxcbiAgICAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNVxuXTtcblxuVGFibGVzJDEudDE2XzVsID0gW1xuICAgIDEsIDUsIDcsIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxNCwgMTEsXG4gICAgNCwgNiwgOCwgOSwgMTAsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEzLCAxNCwgMTMsIDE0LCAxMSxcbiAgICA3LCA4LCA5LCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMiwgMTMsIDEzLCAxMywgMTQsIDE0LCAxMixcbiAgICA5LCA5LCAxMCwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTMsXG4gICAgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTIsXG4gICAgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMywgMTMsIDE0LCAxMywgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNiwgMTMsXG4gICAgMTEsIDExLCAxMSwgMTIsIDEzLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTUsIDE1LCAxNiwgMTMsXG4gICAgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE3LCAxNywgMTMsXG4gICAgMTEsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTYsIDE2LCAxNiwgMTMsXG4gICAgMTIsIDEyLCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNiwgMTUsIDE2LCAxNSwgMTQsXG4gICAgMTIsIDEzLCAxMiwgMTMsIDE0LCAxNCwgMTQsIDE0LCAxNSwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNiwgMTMsXG4gICAgMTMsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE1LCAxNiwgMTQsXG4gICAgMTMsIDE0LCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTcsIDE2LCAxNiwgMTYsIDE2LCAxOCwgMTQsXG4gICAgMTUsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTYsIDE2LCAxNiwgMTgsIDE3LCAxNywgMTcsIDE5LCAxNywgMTQsXG4gICAgMTQsIDE1LCAxMywgMTQsIDE2LCAxNiwgMTUsIDE2LCAxNiwgMTcsIDE4LCAxNywgMTksIDE3LCAxNiwgMTQsXG4gICAgMTEsIDExLCAxMSwgMTIsIDEyLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTJcbl07XG5cblRhYmxlcyQxLnQxNmwgPSBbXG4gICAgMSwgNSwgNywgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDE0LCAxMCxcbiAgICA0LCA2LCA4LCA5LCAxMCwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTMsIDE0LCAxMywgMTQsIDEwLFxuICAgIDcsIDgsIDksIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEyLCAxMywgMTMsIDEzLCAxNCwgMTQsIDExLFxuICAgIDksIDksIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTUsIDE1LCAxMixcbiAgICAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE1LCAxMSxcbiAgICAxMCwgMTAsIDExLCAxMSwgMTIsIDEzLCAxMywgMTQsIDEzLCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE2LCAxMixcbiAgICAxMSwgMTEsIDExLCAxMiwgMTMsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE2LCAxMixcbiAgICAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTcsIDE3LCAxMixcbiAgICAxMSwgMTIsIDEyLCAxMywgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxMixcbiAgICAxMiwgMTIsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNSwgMTYsIDE1LCAxMyxcbiAgICAxMiwgMTMsIDEyLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE1LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE2LCAxMixcbiAgICAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNSwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTUsIDE2LCAxMyxcbiAgICAxMywgMTQsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNywgMTYsIDE2LCAxNiwgMTYsIDE4LCAxMyxcbiAgICAxNSwgMTQsIDE0LCAxNCwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxOCwgMTcsIDE3LCAxNywgMTksIDE3LCAxMyxcbiAgICAxNCwgMTUsIDEzLCAxNCwgMTYsIDE2LCAxNSwgMTYsIDE2LCAxNywgMTgsIDE3LCAxOSwgMTcsIDE2LCAxMyxcbiAgICAxMCwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMFxuXTtcblxuVGFibGVzJDEudDI0bCA9IFtcbiAgICA0LCA1LCA3LCA4LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTAsXG4gICAgNSwgNiwgNywgOCwgOSwgMTAsIDEwLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEwLFxuICAgIDcsIDcsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEzLCA5LFxuICAgIDgsIDgsIDksIDksIDEwLCAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMiwgOSxcbiAgICA5LCA5LCA5LCAxMCwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEzLCA5LFxuICAgIDEwLCA5LCAxMCwgMTAsIDEwLCAxMCwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEyLCAxMiwgOSxcbiAgICAxMCwgMTAsIDEwLCAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEzLCA5LFxuICAgIDExLCAxMCwgMTAsIDEwLCAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEwLFxuICAgIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEwLFxuICAgIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDEwLFxuICAgIDEyLCAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTMsIDEwLFxuICAgIDEyLCAxMiwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTMsIDEwLFxuICAgIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTMsIDEwLFxuICAgIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEwLFxuICAgIDEzLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEwLFxuICAgIDksIDksIDksIDksIDksIDksIDksIDksIDksIDksIDksIDEwLCAxMCwgMTAsIDEwLCA2XG5dO1xuXG5UYWJsZXMkMS50MzJsID0gW1xuICAgIDEgKyAwLCA0ICsgMSwgNCArIDEsIDUgKyAyLCA0ICsgMSwgNiArIDIsIDUgKyAyLCA2ICsgMyxcbiAgICA0ICsgMSwgNSArIDIsIDUgKyAyLCA2ICsgMywgNSArIDIsIDYgKyAzLCA2ICsgMywgNiArIDRcbl07XG5cblRhYmxlcyQxLnQzM2wgPSBbXG4gICAgNCArIDAsIDQgKyAxLCA0ICsgMSwgNCArIDIsIDQgKyAxLCA0ICsgMiwgNCArIDIsIDQgKyAzLFxuICAgIDQgKyAxLCA0ICsgMiwgNCArIDIsIDQgKyAzLCA0ICsgMiwgNCArIDMsIDQgKyAzLCA0ICsgNFxuXTtcblxuVGFibGVzJDEuaHQgPSBbXG4gICAgLyogeGxlbiwgbGlubWF4LCB0YWJsZSwgaGxlbiAqL1xuICAgIG5ldyBIdWZmQ29kZVRhYigwLCAwLCBudWxsLCBudWxsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoMiwgMCwgVGFibGVzJDEudDFIQiwgVGFibGVzJDEudDFsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoMywgMCwgVGFibGVzJDEudDJIQiwgVGFibGVzJDEudDJsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoMywgMCwgVGFibGVzJDEudDNIQiwgVGFibGVzJDEudDNsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoMCwgMCwgbnVsbCwgbnVsbCksIC8qIEFwcGFyZW50bHkgbm90IHVzZWQgKi9cbiAgICBuZXcgSHVmZkNvZGVUYWIoNCwgMCwgVGFibGVzJDEudDVIQiwgVGFibGVzJDEudDVsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoNCwgMCwgVGFibGVzJDEudDZIQiwgVGFibGVzJDEudDZsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoNiwgMCwgVGFibGVzJDEudDdIQiwgVGFibGVzJDEudDdsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoNiwgMCwgVGFibGVzJDEudDhIQiwgVGFibGVzJDEudDhsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoNiwgMCwgVGFibGVzJDEudDlIQiwgVGFibGVzJDEudDlsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoOCwgMCwgVGFibGVzJDEudDEwSEIsIFRhYmxlcyQxLnQxMGwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYig4LCAwLCBUYWJsZXMkMS50MTFIQiwgVGFibGVzJDEudDExbCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDgsIDAsIFRhYmxlcyQxLnQxMkhCLCBUYWJsZXMkMS50MTJsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoMTYsIDAsIFRhYmxlcyQxLnQxM0hCLCBUYWJsZXMkMS50MTNsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoMCwgMCwgbnVsbCwgVGFibGVzJDEudDE2XzVsKSwgLyogQXBwYXJlbnRseSBub3QgdXNlZCAqL1xuICAgIG5ldyBIdWZmQ29kZVRhYigxNiwgMCwgVGFibGVzJDEudDE1SEIsIFRhYmxlcyQxLnQxNWwpLFxuXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDEsIDEsIFRhYmxlcyQxLnQxNkhCLCBUYWJsZXMkMS50MTZsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoMiwgMywgVGFibGVzJDEudDE2SEIsIFRhYmxlcyQxLnQxNmwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYigzLCA3LCBUYWJsZXMkMS50MTZIQiwgVGFibGVzJDEudDE2bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDQsIDE1LCBUYWJsZXMkMS50MTZIQiwgVGFibGVzJDEudDE2bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDYsIDYzLCBUYWJsZXMkMS50MTZIQiwgVGFibGVzJDEudDE2bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDgsIDI1NSwgVGFibGVzJDEudDE2SEIsIFRhYmxlcyQxLnQxNmwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYigxMCwgMTAyMywgVGFibGVzJDEudDE2SEIsIFRhYmxlcyQxLnQxNmwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYigxMywgODE5MSwgVGFibGVzJDEudDE2SEIsIFRhYmxlcyQxLnQxNmwpLFxuXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDQsIDE1LCBUYWJsZXMkMS50MjRIQiwgVGFibGVzJDEudDI0bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDUsIDMxLCBUYWJsZXMkMS50MjRIQiwgVGFibGVzJDEudDI0bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDYsIDYzLCBUYWJsZXMkMS50MjRIQiwgVGFibGVzJDEudDI0bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDcsIDEyNywgVGFibGVzJDEudDI0SEIsIFRhYmxlcyQxLnQyNGwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYig4LCAyNTUsIFRhYmxlcyQxLnQyNEhCLCBUYWJsZXMkMS50MjRsKSxcbiAgICBuZXcgSHVmZkNvZGVUYWIoOSwgNTExLCBUYWJsZXMkMS50MjRIQiwgVGFibGVzJDEudDI0bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDExLCAyMDQ3LCBUYWJsZXMkMS50MjRIQiwgVGFibGVzJDEudDI0bCksXG4gICAgbmV3IEh1ZmZDb2RlVGFiKDEzLCA4MTkxLCBUYWJsZXMkMS50MjRIQiwgVGFibGVzJDEudDI0bCksXG5cbiAgICBuZXcgSHVmZkNvZGVUYWIoMCwgMCwgVGFibGVzJDEudDMySEIsIFRhYmxlcyQxLnQzMmwpLFxuICAgIG5ldyBIdWZmQ29kZVRhYigwLCAwLCBUYWJsZXMkMS50MzNIQiwgVGFibGVzJDEudDMzbCksXG5dO1xuXG4vKipcbiAqIDxDT0RFPlxuICogIGZvciAoaSA9IDA7IGkgPCAxNioxNjsgaSsrKSBbXG4gKiAgICAgIGxhcmdldGJsW2ldID0gKChodFsxNl0uaGxlbltpXSkgPDwgMTYpICsgaHRbMjRdLmhsZW5baV07XG4gKiAgXVxuICogPC9DT0RFPlxuICpcbiAqL1xuVGFibGVzJDEubGFyZ2V0YmwgPSBbXG4gICAgMHgwMTAwMDQsIDB4MDUwMDA1LCAweDA3MDAwNywgMHgwOTAwMDgsIDB4MGEwMDA5LCAweDBhMDAwYSwgMHgwYjAwMGEsIDB4MGIwMDBiLFxuICAgIDB4MGMwMDBiLCAweDBjMDAwYywgMHgwYzAwMGMsIDB4MGQwMDBjLCAweDBkMDAwYywgMHgwZDAwMGMsIDB4MGUwMDBkLCAweDBhMDAwYSxcbiAgICAweDA0MDAwNSwgMHgwNjAwMDYsIDB4MDgwMDA3LCAweDA5MDAwOCwgMHgwYTAwMDksIDB4MGIwMDBhLCAweDBiMDAwYSwgMHgwYjAwMGIsXG4gICAgMHgwYzAwMGIsIDB4MGMwMDBiLCAweDBjMDAwYywgMHgwZDAwMGMsIDB4MGUwMDBjLCAweDBkMDAwYywgMHgwZTAwMGMsIDB4MGEwMDBhLFxuICAgIDB4MDcwMDA3LCAweDA4MDAwNywgMHgwOTAwMDgsIDB4MGEwMDA5LCAweDBiMDAwOSwgMHgwYjAwMGEsIDB4MGMwMDBhLCAweDBjMDAwYixcbiAgICAweDBkMDAwYiwgMHgwYzAwMGIsIDB4MGQwMDBiLCAweDBkMDAwYywgMHgwZDAwMGMsIDB4MGUwMDBjLCAweDBlMDAwZCwgMHgwYjAwMDksXG4gICAgMHgwOTAwMDgsIDB4MDkwMDA4LCAweDBhMDAwOSwgMHgwYjAwMDksIDB4MGIwMDBhLCAweDBjMDAwYSwgMHgwYzAwMGEsIDB4MGMwMDBiLFxuICAgIDB4MGQwMDBiLCAweDBkMDAwYiwgMHgwZTAwMGIsIDB4MGUwMDBjLCAweDBlMDAwYywgMHgwZjAwMGMsIDB4MGYwMDBjLCAweDBjMDAwOSxcbiAgICAweDBhMDAwOSwgMHgwYTAwMDksIDB4MGIwMDA5LCAweDBiMDAwYSwgMHgwYzAwMGEsIDB4MGMwMDBhLCAweDBkMDAwYSwgMHgwZDAwMGIsXG4gICAgMHgwZDAwMGIsIDB4MGUwMDBiLCAweDBlMDAwYywgMHgwZTAwMGMsIDB4MGYwMDBjLCAweDBmMDAwYywgMHgwZjAwMGQsIDB4MGIwMDA5LFxuICAgIDB4MGEwMDBhLCAweDBhMDAwOSwgMHgwYjAwMGEsIDB4MGIwMDBhLCAweDBjMDAwYSwgMHgwZDAwMGEsIDB4MGQwMDBiLCAweDBlMDAwYixcbiAgICAweDBkMDAwYiwgMHgwZTAwMGIsIDB4MGUwMDBjLCAweDBmMDAwYywgMHgwZjAwMGMsIDB4MGYwMDBjLCAweDEwMDAwYywgMHgwYzAwMDksXG4gICAgMHgwYjAwMGEsIDB4MGIwMDBhLCAweDBiMDAwYSwgMHgwYzAwMGEsIDB4MGQwMDBhLCAweDBkMDAwYiwgMHgwZDAwMGIsIDB4MGQwMDBiLFxuICAgIDB4MGUwMDBiLCAweDBlMDAwYywgMHgwZTAwMGMsIDB4MGUwMDBjLCAweDBmMDAwYywgMHgwZjAwMGMsIDB4MTAwMDBkLCAweDBjMDAwOSxcbiAgICAweDBiMDAwYiwgMHgwYjAwMGEsIDB4MGMwMDBhLCAweDBjMDAwYSwgMHgwZDAwMGIsIDB4MGQwMDBiLCAweDBkMDAwYiwgMHgwZTAwMGIsXG4gICAgMHgwZTAwMGMsIDB4MGYwMDBjLCAweDBmMDAwYywgMHgwZjAwMGMsIDB4MGYwMDBjLCAweDExMDAwZCwgMHgxMTAwMGQsIDB4MGMwMDBhLFxuICAgIDB4MGIwMDBiLCAweDBjMDAwYiwgMHgwYzAwMGIsIDB4MGQwMDBiLCAweDBkMDAwYiwgMHgwZDAwMGIsIDB4MGUwMDBiLCAweDBlMDAwYixcbiAgICAweDBmMDAwYiwgMHgwZjAwMGMsIDB4MGYwMDBjLCAweDBmMDAwYywgMHgxMDAwMGMsIDB4MTAwMDBkLCAweDEwMDAwZCwgMHgwYzAwMGEsXG4gICAgMHgwYzAwMGIsIDB4MGMwMDBiLCAweDBjMDAwYiwgMHgwZDAwMGIsIDB4MGQwMDBiLCAweDBlMDAwYiwgMHgwZTAwMGIsIDB4MGYwMDBjLFxuICAgIDB4MGYwMDBjLCAweDBmMDAwYywgMHgwZjAwMGMsIDB4MTAwMDBjLCAweDBmMDAwZCwgMHgxMDAwMGQsIDB4MGYwMDBkLCAweDBkMDAwYSxcbiAgICAweDBjMDAwYywgMHgwZDAwMGIsIDB4MGMwMDBiLCAweDBkMDAwYiwgMHgwZTAwMGIsIDB4MGUwMDBjLCAweDBlMDAwYywgMHgwZTAwMGMsXG4gICAgMHgwZjAwMGMsIDB4MTAwMDBjLCAweDEwMDAwYywgMHgxMDAwMGQsIDB4MTEwMDBkLCAweDExMDAwZCwgMHgxMDAwMGQsIDB4MGMwMDBhLFxuICAgIDB4MGQwMDBjLCAweDBkMDAwYywgMHgwZDAwMGIsIDB4MGQwMDBiLCAweDBlMDAwYiwgMHgwZTAwMGMsIDB4MGYwMDBjLCAweDEwMDAwYyxcbiAgICAweDEwMDAwYywgMHgxMDAwMGMsIDB4MTAwMDBjLCAweDEwMDAwZCwgMHgxMDAwMGQsIDB4MGYwMDBkLCAweDEwMDAwZCwgMHgwZDAwMGEsXG4gICAgMHgwZDAwMGMsIDB4MGUwMDBjLCAweDBlMDAwYywgMHgwZTAwMGMsIDB4MGUwMDBjLCAweDBmMDAwYywgMHgwZjAwMGMsIDB4MGYwMDBjLFxuICAgIDB4MGYwMDBjLCAweDExMDAwYywgMHgxMDAwMGQsIDB4MTAwMDBkLCAweDEwMDAwZCwgMHgxMDAwMGQsIDB4MTIwMDBkLCAweDBkMDAwYSxcbiAgICAweDBmMDAwYywgMHgwZTAwMGMsIDB4MGUwMDBjLCAweDBlMDAwYywgMHgwZjAwMGMsIDB4MGYwMDBjLCAweDEwMDAwYywgMHgxMDAwMGMsXG4gICAgMHgxMDAwMGQsIDB4MTIwMDBkLCAweDExMDAwZCwgMHgxMTAwMGQsIDB4MTEwMDBkLCAweDEzMDAwZCwgMHgxMTAwMGQsIDB4MGQwMDBhLFxuICAgIDB4MGUwMDBkLCAweDBmMDAwYywgMHgwZDAwMGMsIDB4MGUwMDBjLCAweDEwMDAwYywgMHgxMDAwMGMsIDB4MGYwMDBjLCAweDEwMDAwZCxcbiAgICAweDEwMDAwZCwgMHgxMTAwMGQsIDB4MTIwMDBkLCAweDExMDAwZCwgMHgxMzAwMGQsIDB4MTEwMDBkLCAweDEwMDAwZCwgMHgwZDAwMGEsXG4gICAgMHgwYTAwMDksIDB4MGEwMDA5LCAweDBhMDAwOSwgMHgwYjAwMDksIDB4MGIwMDA5LCAweDBjMDAwOSwgMHgwYzAwMDksIDB4MGMwMDA5LFxuICAgIDB4MGQwMDA5LCAweDBkMDAwOSwgMHgwZDAwMDksIDB4MGQwMDBhLCAweDBkMDAwYSwgMHgwZDAwMGEsIDB4MGQwMDBhLCAweDBhMDAwNlxuXTtcbi8qKlxuICogPENPREU+XG4gKiAgZm9yIChpID0gMDsgaSA8IDMqMzsgaSsrKSBbXG4gKiAgICAgIHRhYmxlMjNbaV0gPSAoKGh0WzJdLmhsZW5baV0pIDw8IDE2KSArIGh0WzNdLmhsZW5baV07XG4gKiAgXVxuICogPC9DT0RFPlxuICpcbiAqL1xuVGFibGVzJDEudGFibGUyMyA9IFtcbiAgICAweDAxMDAwMiwgMHgwNDAwMDMsIDB4MDcwMDA3LFxuICAgIDB4MDQwMDA0LCAweDA1MDAwNCwgMHgwNzAwMDcsXG4gICAgMHgwNjAwMDYsIDB4MDcwMDA3LCAweDA4MDAwOFxuXTtcblxuLyoqXG4gKiA8Q09ERT5cbiAqICBmb3IgKGkgPSAwOyBpIDwgNCo0OyBpKyspIFtcbiAqICAgICAgIHRhYmxlNTZbaV0gPSAoKGh0WzVdLmhsZW5baV0pIDw8IDE2KSArIGh0WzZdLmhsZW5baV07XG4gKiAgIF1cbiAqIDwvQ09ERT5cbiAqXG4gKi9cblRhYmxlcyQxLnRhYmxlNTYgPSBbXG4gICAgMHgwMTAwMDMsIDB4MDQwMDA0LCAweDA3MDAwNiwgMHgwODAwMDgsIDB4MDQwMDA0LCAweDA1MDAwNCwgMHgwODAwMDYsIDB4MDkwMDA3LFxuICAgIDB4MDcwMDA1LCAweDA4MDAwNiwgMHgwOTAwMDcsIDB4MGEwMDA4LCAweDA4MDAwNywgMHgwODAwMDcsIDB4MDkwMDA4LCAweDBhMDAwOVxuXTtcblxuVGFibGVzJDEuYml0cmF0ZV90YWJsZSA9IFtcbiAgICBbMCwgOCwgMTYsIDI0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwLCAtMV0sIC8qIE1QRUcgMiAqL1xuICAgIFswLCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAtMV0sIC8qIE1QRUcgMSAqL1xuICAgIFswLCA4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLCAvKiBNUEVHIDIuNSAqL1xuXTtcblxuLyoqXG4gKiBNUEVHIDIsIE1QRUcgMSwgTVBFRyAyLjUuXG4gKi9cblRhYmxlcyQxLnNhbXBsZXJhdGVfdGFibGUgPSBbXG4gICAgWzIyMDUwLCAyNDAwMCwgMTYwMDAsIC0xXSxcbiAgICBbNDQxMDAsIDQ4MDAwLCAzMjAwMCwgLTFdLFxuICAgIFsxMTAyNSwgMTIwMDAsIDgwMDAsIC0xXSxcbl07XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgc2Nmc2lfYmFuZCB0YWJsZSBmcm9tIDIuNC4yLjcgb2YgdGhlIElTLlxuICovXG5UYWJsZXMkMS5zY2ZzaV9iYW5kID0gWzAsIDYsIDExLCAxNiwgMjFdO1xuXG52YXIgVGFibGVzXzEgPSBUYWJsZXMkMTtcblxudmFyIFZick1vZGUkMTkgPSBjb21tb24uVmJyTW9kZTtcbnZhciBGbG9hdCQxOSA9IGNvbW1vbi5GbG9hdDtcbnZhciBVdGlsJDE5ID0gY29tbW9uLlV0aWw7XG52YXIgbmV3X2Zsb2F0JDE5ID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBuZXdfaW50JDE5ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgYXNzZXJ0JDE5ID0gY29tbW9uLmFzc2VydDtcblxuXG5cblxuXG5RdWFudGl6ZVBWVCQxLlFfTUFYID0gKDI1NiArIDEpO1xuUXVhbnRpemVQVlQkMS5RX01BWDIgPSAxMTY7XG5RdWFudGl6ZVBWVCQxLkxBUkdFX0JJVFMgPSAxMDAwMDA7XG5RdWFudGl6ZVBWVCQxLklYTUFYX1ZBTCA9IDgyMDY7XG5cbmZ1bmN0aW9uIFF1YW50aXplUFZUJDEoKSB7XG5cbiAgICB2YXIgdGFrID0gbnVsbDtcbiAgICB2YXIgcnYgPSBudWxsO1xuICAgIHZhciBwc3kgPSBudWxsO1xuXG4gICAgdGhpcy5zZXRNb2R1bGVzID0gZnVuY3Rpb24gKF90aywgX3J2LCBfcHN5KSB7XG4gICAgICAgIHRhayA9IF90aztcbiAgICAgICAgcnYgPSBfcnY7XG4gICAgICAgIHBzeSA9IF9wc3k7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFBPVzIwKHgpIHtcbiAgICAgICAgYXNzZXJ0JDE5KDAgPD0gKHggKyBRdWFudGl6ZVBWVCQxLlFfTUFYMikgJiYgeCA8IFF1YW50aXplUFZUJDEuUV9NQVgpO1xuICAgICAgICByZXR1cm4gcG93MjBbeCArIFF1YW50aXplUFZUJDEuUV9NQVgyXTtcbiAgICB9XG5cbiAgICB0aGlzLklQT1cyMCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGFzc2VydCQxOSgwIDw9IHggJiYgeCA8IFF1YW50aXplUFZUJDEuUV9NQVgpO1xuICAgICAgICByZXR1cm4gaXBvdzIwW3hdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzbWFsbGVzdCBzdWNoIHRoYXQgMS4wK0RCTF9FUFNJTE9OICE9IDEuMFxuICAgICAqL1xuICAgIHZhciBEQkxfRVBTSUxPTiA9IDIuMjIwNDQ2MDQ5MjUwMzEzMWUtMDE2O1xuXG4gICAgLyoqXG4gICAgICogaXggYWx3YXlzIDw9IDgxOTErMTUuIHNlZSBjb3VudF9iaXRzKClcbiAgICAgKi9cbiAgICB2YXIgSVhNQVhfVkFMID0gUXVhbnRpemVQVlQkMS5JWE1BWF9WQUw7XG5cbiAgICB2YXIgUFJFQ0FMQ19TSVpFID0gKElYTUFYX1ZBTCArIDIpO1xuXG4gICAgdmFyIFFfTUFYID0gUXVhbnRpemVQVlQkMS5RX01BWDtcblxuXG4gICAgLyoqXG4gICAgICogPENPREU+XG4gICAgICogbWluaW11bSBwb3NzaWJsZSBudW1iZXIgb2ZcbiAgICAgKiAtY29kX2luZm8uZ2xvYmFsX2dhaW4gKyAoKHNjYWxlZmFjW10gKyAoY29kX2luZm8ucHJlZmxhZyA/IHByZXRhYltzZmJdIDogMCkpXG4gICAgICogPDwgKGNvZF9pbmZvLnNjYWxlZmFjX3NjYWxlICsgMSkpICsgY29kX2luZm8uc3ViYmxvY2tfZ2Fpbltjb2RfaW5mby53aW5kb3dbc2ZiXV0gKiA4O1xuICAgICAqXG4gICAgICogZm9yIGxvbmcgYmxvY2ssIDArKCgxNSszKTw8MikgPSAxOCo0ID0gNzJcbiAgICAgKiBmb3Igc2hvcnQgYmxvY2ssIDArKDE1PDwyKSs3KjggPSAxNSo0KzU2ID0gMTE2XG4gICAgICogPC9DT0RFPlxuICAgICAqL1xuICAgIHZhciBRX01BWDIgPSBRdWFudGl6ZVBWVCQxLlFfTUFYMjtcblxuICAgIHZhciBMQVJHRV9CSVRTID0gUXVhbnRpemVQVlQkMS5MQVJHRV9CSVRTO1xuXG5cbiAgICAvKipcbiAgICAgKiBBc3N1bWluZyBkeW5hbWljIHJhbmdlPTk2ZEIsIHRoaXMgdmFsdWUgc2hvdWxkIGJlIDkyXG4gICAgICovXG4gICAgdmFyIE5TQVRIU0NBTEUgPSAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9sbG93aW5nIHRhYmxlIGlzIHVzZWQgdG8gaW1wbGVtZW50IHRoZSBzY2FsZWZhY3RvciBwYXJ0aXRpb25pbmcgZm9yXG4gICAgICogTVBFRzIgYXMgZGVzY3JpYmVkIGluIHNlY3Rpb24gMi40LjMuMiBvZiB0aGUgSVMuIFRoZSBpbmRleGluZyBjb3JyZXNwb25kc1xuICAgICAqIHRvIHRoZSB3YXkgdGhlIHRhYmxlcyBhcmUgcHJlc2VudGVkIGluIHRoZSBJUzpcbiAgICAgKlxuICAgICAqIFt0YWJsZV9udW1iZXJdW3Jvd19pbl90YWJsZV1bY29sdW1uIG9mIG5yX29mX3NmYl1cbiAgICAgKi9cbiAgICB0aGlzLm5yX29mX3NmYl9ibG9jayA9IFtcbiAgICAgICAgW1s2LCA1LCA1LCA1XSwgWzksIDksIDksIDldLCBbNiwgOSwgOSwgOV1dLFxuICAgICAgICBbWzYsIDUsIDcsIDNdLCBbOSwgOSwgMTIsIDZdLCBbNiwgOSwgMTIsIDZdXSxcbiAgICAgICAgW1sxMSwgMTAsIDAsIDBdLCBbMTgsIDE4LCAwLCAwXSwgWzE1LCAxOCwgMCwgMF1dLFxuICAgICAgICBbWzcsIDcsIDcsIDBdLCBbMTIsIDEyLCAxMiwgMF0sIFs2LCAxNSwgMTIsIDBdXSxcbiAgICAgICAgW1s2LCA2LCA2LCAzXSwgWzEyLCA5LCA5LCA2XSwgWzYsIDEyLCA5LCA2XV0sXG4gICAgICAgIFtbOCwgOCwgNSwgMF0sIFsxNSwgMTIsIDksIDBdLCBbNiwgMTgsIDksIDBdXV07XG5cbiAgICAvKipcbiAgICAgKiBUYWJsZSBCLjY6IGxheWVyMyBwcmVlbXBoYXNpc1xuICAgICAqL1xuICAgIHZhciBwcmV0YWIgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSxcbiAgICAgICAgMiwgMiwgMywgMywgMywgMiwgMF07XG4gICAgdGhpcy5wcmV0YWIgPSBwcmV0YWI7XG5cbiAgICAvKipcbiAgICAgKiBIZXJlIGFyZSBNUEVHMSBUYWJsZSBCLjggYW5kIE1QRUcyIFRhYmxlIEIuMSAtLSBMYXllciBJSUkgc2NhbGVmYWN0b3JcbiAgICAgKiBiYW5kcy4gPEJSPlxuICAgICAqIEluZGV4IGludG8gdGhpcyB1c2luZyBhIG1ldGhvZCBzdWNoIGFzOjxCUj5cbiAgICAgKiBpZHggPSBmcl9wcy5oZWFkZXIuc2FtcGxpbmdfZnJlcXVlbmN5ICsgKGZyX3BzLmhlYWRlci52ZXJzaW9uICogMylcbiAgICAgKi9cbiAgICB0aGlzLnNmQmFuZEluZGV4ID0gW1xuICAgICAgICAvLyBUYWJsZSBCLjIuYjogMjIuMDUga0h6XG4gICAgICAgIG5ldyBTY2FsZUZhY18xKFswLCA2LCAxMiwgMTgsIDI0LCAzMCwgMzYsIDQ0LCA1NCwgNjYsIDgwLCA5NiwgMTE2LCAxNDAsIDE2OCwgMjAwLCAyMzgsIDI4NCwgMzM2LCAzOTYsIDQ2NCxcbiAgICAgICAgICAgICAgICA1MjIsIDU3Nl0sXG4gICAgICAgICAgICBbMCwgNCwgOCwgMTIsIDE4LCAyNCwgMzIsIDQyLCA1NiwgNzQsIDEwMCwgMTMyLCAxNzQsIDE5Ml1cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8vICBzZmIyMSBwc2V1ZG8gc3ViIGJhbmRzXG4gICAgICAgICAgICAsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSAvLyAgc2ZiMTIgcHNldWRvIHN1YiBiYW5kc1xuICAgICAgICApLFxuICAgICAgICAvKiBUYWJsZSBCLjIuYzogMjQga0h6ICovIC8qIGRvY3M6IDMzMi4gbXBnMTIzKGJyb2tlbik6IDMzMCAqL1xuICAgICAgICBuZXcgU2NhbGVGYWNfMShbMCwgNiwgMTIsIDE4LCAyNCwgMzAsIDM2LCA0NCwgNTQsIDY2LCA4MCwgOTYsIDExNCwgMTM2LCAxNjIsIDE5NCwgMjMyLCAyNzgsIDMzMiwgMzk0LCA0NjQsXG4gICAgICAgICAgICAgICAgNTQwLCA1NzZdLFxuICAgICAgICAgICAgWzAsIDQsIDgsIDEyLCAxOCwgMjYsIDM2LCA0OCwgNjIsIDgwLCAxMDQsIDEzNiwgMTgwLCAxOTJdXG4gICAgICAgICAgICAsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSAvKiAgc2ZiMjEgcHNldWRvIHN1YiBiYW5kcyAqL1xuICAgICAgICAgICAgLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0gLyogIHNmYjEyIHBzZXVkbyBzdWIgYmFuZHMgKi9cbiAgICAgICAgKSxcbiAgICAgICAgLyogVGFibGUgQi4yLmE6IDE2IGtIeiAqL1xuICAgICAgICBuZXcgU2NhbGVGYWNfMShbMCwgNiwgMTIsIDE4LCAyNCwgMzAsIDM2LCA0NCwgNTQsIDY2LCA4MCwgOTYsIDExNiwgMTQwLCAxNjgsIDIwMCwgMjM4LCAyODQsIDMzNiwgMzk2LCA0NjQsXG4gICAgICAgICAgICAgICAgNTIyLCA1NzZdLFxuICAgICAgICAgICAgWzAsIDQsIDgsIDEyLCAxOCwgMjYsIDM2LCA0OCwgNjIsIDgwLCAxMDQsIDEzNCwgMTc0LCAxOTJdXG4gICAgICAgICAgICAsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSAvKiAgc2ZiMjEgcHNldWRvIHN1YiBiYW5kcyAqL1xuICAgICAgICAgICAgLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0gLyogIHNmYjEyIHBzZXVkbyBzdWIgYmFuZHMgKi9cbiAgICAgICAgKSxcbiAgICAgICAgLyogVGFibGUgQi44LmI6IDQ0LjEga0h6ICovXG4gICAgICAgIG5ldyBTY2FsZUZhY18xKFswLCA0LCA4LCAxMiwgMTYsIDIwLCAyNCwgMzAsIDM2LCA0NCwgNTIsIDYyLCA3NCwgOTAsIDExMCwgMTM0LCAxNjIsIDE5NiwgMjM4LCAyODgsIDM0MiwgNDE4LFxuICAgICAgICAgICAgICAgIDU3Nl0sXG4gICAgICAgICAgICBbMCwgNCwgOCwgMTIsIDE2LCAyMiwgMzAsIDQwLCA1MiwgNjYsIDg0LCAxMDYsIDEzNiwgMTkyXVxuICAgICAgICAgICAgLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0gLyogIHNmYjIxIHBzZXVkbyBzdWIgYmFuZHMgKi9cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8qICBzZmIxMiBwc2V1ZG8gc3ViIGJhbmRzICovXG4gICAgICAgICksXG4gICAgICAgIC8qIFRhYmxlIEIuOC5jOiA0OCBrSHogKi9cbiAgICAgICAgbmV3IFNjYWxlRmFjXzEoWzAsIDQsIDgsIDEyLCAxNiwgMjAsIDI0LCAzMCwgMzYsIDQyLCA1MCwgNjAsIDcyLCA4OCwgMTA2LCAxMjgsIDE1NiwgMTkwLCAyMzAsIDI3NiwgMzMwLCAzODQsXG4gICAgICAgICAgICAgICAgNTc2XSxcbiAgICAgICAgICAgIFswLCA0LCA4LCAxMiwgMTYsIDIyLCAyOCwgMzgsIDUwLCA2NCwgODAsIDEwMCwgMTI2LCAxOTJdXG4gICAgICAgICAgICAsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSAvKiAgc2ZiMjEgcHNldWRvIHN1YiBiYW5kcyAqL1xuICAgICAgICAgICAgLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0gLyogIHNmYjEyIHBzZXVkbyBzdWIgYmFuZHMgKi9cbiAgICAgICAgKSxcbiAgICAgICAgLyogVGFibGUgQi44LmE6IDMyIGtIeiAqL1xuICAgICAgICBuZXcgU2NhbGVGYWNfMShbMCwgNCwgOCwgMTIsIDE2LCAyMCwgMjQsIDMwLCAzNiwgNDQsIDU0LCA2NiwgODIsIDEwMiwgMTI2LCAxNTYsIDE5NCwgMjQwLCAyOTYsIDM2NCwgNDQ4LCA1NTAsXG4gICAgICAgICAgICAgICAgNTc2XSxcbiAgICAgICAgICAgIFswLCA0LCA4LCAxMiwgMTYsIDIyLCAzMCwgNDIsIDU4LCA3OCwgMTA0LCAxMzgsIDE4MCwgMTkyXVxuICAgICAgICAgICAgLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0gLyogIHNmYjIxIHBzZXVkbyBzdWIgYmFuZHMgKi9cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8qICBzZmIxMiBwc2V1ZG8gc3ViIGJhbmRzICovXG4gICAgICAgICksXG4gICAgICAgIC8qIE1QRUctMi41IDExLjAyNSBrSHogKi9cbiAgICAgICAgbmV3IFNjYWxlRmFjXzEoWzAsIDYsIDEyLCAxOCwgMjQsIDMwLCAzNiwgNDQsIDU0LCA2NiwgODAsIDk2LCAxMTYsIDE0MCwgMTY4LCAyMDAsIDIzOCwgMjg0LCAzMzYsIDM5NiwgNDY0LFxuICAgICAgICAgICAgICAgIDUyMiwgNTc2XSxcbiAgICAgICAgICAgIFswIC8gMywgMTIgLyAzLCAyNCAvIDMsIDM2IC8gMywgNTQgLyAzLCA3OCAvIDMsIDEwOCAvIDMsIDE0NCAvIDMsIDE4NiAvIDMsIDI0MCAvIDMsIDMxMiAvIDMsXG4gICAgICAgICAgICAgICAgNDAyIC8gMywgNTIyIC8gMywgNTc2IC8gM11cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8qICBzZmIyMSBwc2V1ZG8gc3ViIGJhbmRzICovXG4gICAgICAgICAgICAsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSAvKiAgc2ZiMTIgcHNldWRvIHN1YiBiYW5kcyAqL1xuICAgICAgICApLFxuICAgICAgICAvKiBNUEVHLTIuNSAxMiBrSHogKi9cbiAgICAgICAgbmV3IFNjYWxlRmFjXzEoWzAsIDYsIDEyLCAxOCwgMjQsIDMwLCAzNiwgNDQsIDU0LCA2NiwgODAsIDk2LCAxMTYsIDE0MCwgMTY4LCAyMDAsIDIzOCwgMjg0LCAzMzYsIDM5NiwgNDY0LFxuICAgICAgICAgICAgICAgIDUyMiwgNTc2XSxcbiAgICAgICAgICAgIFswIC8gMywgMTIgLyAzLCAyNCAvIDMsIDM2IC8gMywgNTQgLyAzLCA3OCAvIDMsIDEwOCAvIDMsIDE0NCAvIDMsIDE4NiAvIDMsIDI0MCAvIDMsIDMxMiAvIDMsXG4gICAgICAgICAgICAgICAgNDAyIC8gMywgNTIyIC8gMywgNTc2IC8gM11cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8qICBzZmIyMSBwc2V1ZG8gc3ViIGJhbmRzICovXG4gICAgICAgICAgICAsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSAvKiAgc2ZiMTIgcHNldWRvIHN1YiBiYW5kcyAqL1xuICAgICAgICApLFxuICAgICAgICAvKiBNUEVHLTIuNSA4IGtIeiAqL1xuICAgICAgICBuZXcgU2NhbGVGYWNfMShbMCwgMTIsIDI0LCAzNiwgNDgsIDYwLCA3MiwgODgsIDEwOCwgMTMyLCAxNjAsIDE5MiwgMjMyLCAyODAsIDMzNiwgNDAwLCA0NzYsIDU2NiwgNTY4LCA1NzAsXG4gICAgICAgICAgICAgICAgNTcyLCA1NzQsIDU3Nl0sXG4gICAgICAgICAgICBbMCAvIDMsIDI0IC8gMywgNDggLyAzLCA3MiAvIDMsIDEwOCAvIDMsIDE1NiAvIDMsIDIxNiAvIDMsIDI4OCAvIDMsIDM3MiAvIDMsIDQ4MCAvIDMsIDQ4NiAvIDMsXG4gICAgICAgICAgICAgICAgNDkyIC8gMywgNDk4IC8gMywgNTc2IC8gM11cbiAgICAgICAgICAgICwgWzAsIDAsIDAsIDAsIDAsIDAsIDBdIC8qICBzZmIyMSBwc2V1ZG8gc3ViIGJhbmRzICovXG4gICAgICAgICAgICAsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSAvKiAgc2ZiMTIgcHNldWRvIHN1YiBiYW5kcyAqL1xuICAgICAgICApXG4gICAgXTtcblxuICAgIHZhciBwb3cyMCA9IG5ld19mbG9hdCQxOShRX01BWCArIFFfTUFYMiArIDEpO1xuICAgIHZhciBpcG93MjAgPSBuZXdfZmxvYXQkMTkoUV9NQVgpO1xuICAgIHZhciBwb3c0MyA9IG5ld19mbG9hdCQxOShQUkVDQUxDX1NJWkUpO1xuXG4gICAgdmFyIGFkajQzID0gbmV3X2Zsb2F0JDE5KFBSRUNBTENfU0laRSk7XG4gICAgdGhpcy5hZGo0MyA9IGFkajQzO1xuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiBjb21wdXRlIHRoZSBBVEggZm9yIGVhY2ggc2NhbGVmYWN0b3IgYmFuZCBjZCByYW5nZTogMC4uOTZkYlxuICAgICAqXG4gICAgICogSW5wdXQ6IDMuM2tIeiBzaWduYWwgMzI3NjcgYW1wbGl0dWRlICgzLjNrSHogaXMgd2hlcmUgQVRIIGlzIHNtYWxsZXN0ID1cbiAgICAgKiAtNWRiKSBsb25nYmxvY2tzOiBzZmI9MTIgZW4wL2J3PS0xMWRiIG1heF9lbjAgPSAxLjNkYiBzaG9ydGJsb2Nrczogc2ZiPTVcbiAgICAgKiAtOWRiIDBkYlxuICAgICAqXG4gICAgICogSW5wdXQ6IDEgMSAxIDEgMSAxIDEgLTEgLTEgLTEgLTEgLTEgLTEgLTEgKHJlcGVhdGVkKSBsb25nYmxvY2tzOiBhbXA9MVxuICAgICAqIHNmYj0xMiBlbjAvYnc9LTEwMyBkYiBtYXhfZW4wID0gLTkyZGIgYW1wPTMyNzY3IHNmYj0xMiAtMTIgZGIgLTEuNGRiXG4gICAgICpcbiAgICAgKiBJbnB1dDogMSAxIDEgMSAxIDEgMSAtMSAtMSAtMSAtMSAtMSAtMSAtMSAocmVwZWF0ZWQpIHNob3J0YmxvY2tzOiBhbXA9MVxuICAgICAqIHNmYj01IGVuMC9idz0gLTk5IC04NiBhbXA9MzI3Njcgc2ZiPTUgLTkgZGIgNGRiXG4gICAgICpcbiAgICAgKlxuICAgICAqIE1BWCBlbmVyZ3kgb2YgbGFyZ2VzdCB3YXZlIGF0IDMuM2tIeiA9IDFkYiBBVkUgZW5lcmd5IG9mIGxhcmdlc3Qgd2F2ZSBhdFxuICAgICAqIDMuM2tIeiA9IC0xMWRiIExldCdzIHRha2UgQVZFOiAtMTFkYiA9IG1heGltdW0gc2lnbmFsIGluIHNmYj0xMi4gRHluYW1pY1xuICAgICAqIHJhbmdlIG9mIENEOiA5NmRiLiBUaGVyZWZvciBlbmVyZ3kgb2Ygc21hbGxlc3QgYXVkaWJsZSB3YXZlIGluIHNmYj0xMiA9XG4gICAgICogLTExIC0gOTYgPSAtMTA3ZGIgPSBBVEggYXQgMy4za0h6LlxuICAgICAqXG4gICAgICogQVRIIGZvcm11bGEgZm9yIHRoaXMgd2F2ZTogLTVkYi4gVG8gYWRqdXN0IHRvIExBTUUgc2NhbGluZywgd2UgbmVlZCBBVEggPVxuICAgICAqIEFUSF9mb3JtdWxhIC0gMTAzIChkYikgQVRIID0gQVRIICogMi41ZS0xMCAoZW5lcilcbiAgICAgKiA8L1BSRT5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBVEhtZGN0KGdmcCwgZikge1xuICAgICAgICB2YXIgYXRoID0gcHN5LkFUSGZvcm11bGEoZiwgZ2ZwKTtcblxuICAgICAgICBhdGggLT0gTlNBVEhTQ0FMRTtcblxuICAgICAgICAvKiBtb2RpZnkgdGhlIE1EQ1Qgc2NhbGluZyBmb3IgdGhlIEFUSCBhbmQgY29udmVydCB0byBlbmVyZ3kgKi9cbiAgICAgICAgYXRoID0gTWF0aC5wb3coMTAuMCwgYXRoIC8gMTAuMCArIGdmcC5BVEhsb3dlcik7XG4gICAgICAgIHJldHVybiBhdGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZV9hdGgoZ2ZwKSB7XG4gICAgICAgIHZhciBBVEhfbCA9IGdmcC5pbnRlcm5hbF9mbGFncy5BVEgubDtcbiAgICAgICAgdmFyIEFUSF9wc2ZiMjEgPSBnZnAuaW50ZXJuYWxfZmxhZ3MuQVRILnBzZmIyMTtcbiAgICAgICAgdmFyIEFUSF9zID0gZ2ZwLmludGVybmFsX2ZsYWdzLkFUSC5zO1xuICAgICAgICB2YXIgQVRIX3BzZmIxMiA9IGdmcC5pbnRlcm5hbF9mbGFncy5BVEgucHNmYjEyO1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgc2FtcF9mcmVxID0gZ2ZwLm91dF9zYW1wbGVyYXRlO1xuXG4gICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IEVuY29kZXJfMS5TQk1BWF9sOyBzZmIrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ2ZjLnNjYWxlZmFjX2JhbmQubFtzZmJdO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGdmYy5zY2FsZWZhY19iYW5kLmxbc2ZiICsgMV07XG4gICAgICAgICAgICBBVEhfbFtzZmJdID0gRmxvYXQkMTkuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJlcSA9IGkgKiBzYW1wX2ZyZXEgLyAoMiAqIDU3Nik7XG4gICAgICAgICAgICAgICAgdmFyIEFUSF9mID0gQVRIbWRjdChnZnAsIGZyZXEpO1xuICAgICAgICAgICAgICAgIC8qIGZyZXEgaW4ga0h6ICovXG4gICAgICAgICAgICAgICAgQVRIX2xbc2ZiXSA9IE1hdGgubWluKEFUSF9sW3NmYl0sIEFUSF9mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IEVuY29kZXJfMS5QU0ZCMjE7IHNmYisrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBnZmMuc2NhbGVmYWNfYmFuZC5wc2ZiMjFbc2ZiXTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBnZmMuc2NhbGVmYWNfYmFuZC5wc2ZiMjFbc2ZiICsgMV07XG4gICAgICAgICAgICBBVEhfcHNmYjIxW3NmYl0gPSBGbG9hdCQxOS5NQVhfVkFMVUU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmcmVxID0gaSAqIHNhbXBfZnJlcSAvICgyICogNTc2KTtcbiAgICAgICAgICAgICAgICB2YXIgQVRIX2YgPSBBVEhtZGN0KGdmcCwgZnJlcSk7XG4gICAgICAgICAgICAgICAgLyogZnJlcSBpbiBrSHogKi9cbiAgICAgICAgICAgICAgICBBVEhfcHNmYjIxW3NmYl0gPSBNYXRoLm1pbihBVEhfcHNmYjIxW3NmYl0sIEFUSF9mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IEVuY29kZXJfMS5TQk1BWF9zOyBzZmIrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ2ZjLnNjYWxlZmFjX2JhbmQuc1tzZmJdO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGdmYy5zY2FsZWZhY19iYW5kLnNbc2ZiICsgMV07XG4gICAgICAgICAgICBBVEhfc1tzZmJdID0gRmxvYXQkMTkuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJlcSA9IGkgKiBzYW1wX2ZyZXEgLyAoMiAqIDE5Mik7XG4gICAgICAgICAgICAgICAgdmFyIEFUSF9mID0gQVRIbWRjdChnZnAsIGZyZXEpO1xuICAgICAgICAgICAgICAgIC8qIGZyZXEgaW4ga0h6ICovXG4gICAgICAgICAgICAgICAgQVRIX3Nbc2ZiXSA9IE1hdGgubWluKEFUSF9zW3NmYl0sIEFUSF9mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEFUSF9zW3NmYl0gKj0gKGdmYy5zY2FsZWZhY19iYW5kLnNbc2ZiICsgMV0gLSBnZmMuc2NhbGVmYWNfYmFuZC5zW3NmYl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgRW5jb2Rlcl8xLlBTRkIxMjsgc2ZiKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGdmYy5zY2FsZWZhY19iYW5kLnBzZmIxMltzZmJdO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGdmYy5zY2FsZWZhY19iYW5kLnBzZmIxMltzZmIgKyAxXTtcbiAgICAgICAgICAgIEFUSF9wc2ZiMTJbc2ZiXSA9IEZsb2F0JDE5Lk1BWF9WQUxVRTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyZXEgPSBpICogc2FtcF9mcmVxIC8gKDIgKiAxOTIpO1xuICAgICAgICAgICAgICAgIHZhciBBVEhfZiA9IEFUSG1kY3QoZ2ZwLCBmcmVxKTtcbiAgICAgICAgICAgICAgICAvKiBmcmVxIGluIGtIeiAqL1xuICAgICAgICAgICAgICAgIEFUSF9wc2ZiMTJbc2ZiXSA9IE1hdGgubWluKEFUSF9wc2ZiMTJbc2ZiXSwgQVRIX2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogbm90IHN1cmUgYWJvdXQgdGhlIGZvbGxvd2luZyAqL1xuICAgICAgICAgICAgQVRIX3BzZmIxMltzZmJdICo9IChnZmMuc2NhbGVmYWNfYmFuZC5zWzEzXSAtIGdmYy5zY2FsZWZhY19iYW5kLnNbMTJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIG5vLUFUSCBtb2RlOiByZWR1Y2UgQVRIIHRvIC0yMDAgZEJcbiAgICAgICAgICovXG4gICAgICAgIGlmIChnZnAubm9BVEgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IEVuY29kZXJfMS5TQk1BWF9sOyBzZmIrKykge1xuICAgICAgICAgICAgICAgIEFUSF9sW3NmYl0gPSAxRS0yMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IEVuY29kZXJfMS5QU0ZCMjE7IHNmYisrKSB7XG4gICAgICAgICAgICAgICAgQVRIX3BzZmIyMVtzZmJdID0gMUUtMjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBzZmIgPSAwOyBzZmIgPCBFbmNvZGVyXzEuU0JNQVhfczsgc2ZiKyspIHtcbiAgICAgICAgICAgICAgICBBVEhfc1tzZmJdID0gMUUtMjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBzZmIgPSAwOyBzZmIgPCBFbmNvZGVyXzEuUFNGQjEyOyBzZmIrKykge1xuICAgICAgICAgICAgICAgIEFUSF9wc2ZiMTJbc2ZiXSA9IDFFLTIwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogd29yayBpbiBwcm9ncmVzcywgZG9uJ3QgcmVseSBvbiBpdCB0b28gbXVjaFxuICAgICAgICAgKi9cbiAgICAgICAgZ2ZjLkFUSC5mbG9vciA9IDEwLiAqIE1hdGgubG9nMTAoQVRIbWRjdChnZnAsIC0xLikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemF0aW9uIGZvciBpdGVyYXRpb25fbG9vcFxuICAgICAqL1xuICAgIHRoaXMuaXRlcmF0aW9uX2luaXQgPSBmdW5jdGlvbiAoZ2ZwKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBsM19zaWRlID0gZ2ZjLmwzX3NpZGU7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGlmIChnZmMuaXRlcmF0aW9uX2luaXRfaW5pdCA9PSAwKSB7XG4gICAgICAgICAgICBnZmMuaXRlcmF0aW9uX2luaXRfaW5pdCA9IDE7XG5cbiAgICAgICAgICAgIGwzX3NpZGUubWFpbl9kYXRhX2JlZ2luID0gMDtcbiAgICAgICAgICAgIGNvbXB1dGVfYXRoKGdmcCk7XG5cbiAgICAgICAgICAgIHBvdzQzWzBdID0gMC4wO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IFBSRUNBTENfU0laRTsgaSsrKVxuICAgICAgICAgICAgICAgIHBvdzQzW2ldID0gTWF0aC5wb3coaSwgNC4wIC8gMy4wKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IFBSRUNBTENfU0laRSAtIDE7IGkrKylcbiAgICAgICAgICAgICAgICBhZGo0M1tpXSA9ICgoaSArIDEpIC0gTWF0aC5wb3coXG4gICAgICAgICAgICAgICAgICAgIDAuNSAqIChwb3c0M1tpXSArIHBvdzQzW2kgKyAxXSksIDAuNzUpKTtcbiAgICAgICAgICAgIGFkajQzW2ldID0gMC41O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgUV9NQVg7IGkrKylcbiAgICAgICAgICAgICAgICBpcG93MjBbaV0gPSBNYXRoLnBvdygyLjAsIChpIC0gMjEwKSAqIC0wLjE4NzUpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBRX01BWCArIFFfTUFYMjsgaSsrKVxuICAgICAgICAgICAgICAgIHBvdzIwW2ldID0gTWF0aC5wb3coMi4wLCAoaSAtIDIxMCAtIFFfTUFYMikgKiAwLjI1KTtcblxuICAgICAgICAgICAgdGFrLmh1ZmZtYW5faW5pdChnZmMpO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGJhc3MsIGFsdG8sIHRyZWJsZSwgc2ZiMjE7XG5cbiAgICAgICAgICAgICAgICBpID0gKGdmcC5leHBfbnNwc3l0dW5lID4+IDIpICYgNjM7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gMzIpXG4gICAgICAgICAgICAgICAgICAgIGkgLT0gNjQ7XG4gICAgICAgICAgICAgICAgYmFzcyA9IE1hdGgucG93KDEwLCBpIC8gNC4wIC8gMTAuMCk7XG5cbiAgICAgICAgICAgICAgICBpID0gKGdmcC5leHBfbnNwc3l0dW5lID4+IDgpICYgNjM7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gMzIpXG4gICAgICAgICAgICAgICAgICAgIGkgLT0gNjQ7XG4gICAgICAgICAgICAgICAgYWx0byA9IE1hdGgucG93KDEwLCBpIC8gNC4wIC8gMTAuMCk7XG5cbiAgICAgICAgICAgICAgICBpID0gKGdmcC5leHBfbnNwc3l0dW5lID4+IDE0KSAmIDYzO1xuICAgICAgICAgICAgICAgIGlmIChpID49IDMyKVxuICAgICAgICAgICAgICAgICAgICBpIC09IDY0O1xuICAgICAgICAgICAgICAgIHRyZWJsZSA9IE1hdGgucG93KDEwLCBpIC8gNC4wIC8gMTAuMCk7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHRvIGJlIGNvbXBhdGlibGUgd2l0aCBOYW9raSdzIG9yaWdpbmFsIGNvZGUsIHRoZSBuZXh0IDYgYml0c1xuICAgICAgICAgICAgICAgICAqIGRlZmluZSBvbmx5IHRoZSBhbW91bnQgb2YgY2hhbmdpbmcgdHJlYmxlIGZvciBzZmIyMVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGkgPSAoZ2ZwLmV4cF9uc3BzeXR1bmUgPj4gMjApICYgNjM7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gMzIpXG4gICAgICAgICAgICAgICAgICAgIGkgLT0gNjQ7XG4gICAgICAgICAgICAgICAgc2ZiMjEgPSB0cmVibGUgKiBNYXRoLnBvdygxMCwgaSAvIDQuMCAvIDEwLjApO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBFbmNvZGVyXzEuU0JNQVhfbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8PSA2KVxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGJhc3M7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPD0gMTMpXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gYWx0bztcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA8PSAyMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSB0cmVibGU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBzZmIyMTtcblxuICAgICAgICAgICAgICAgICAgICBnZmMubnNQc3kubG9uZ2ZhY3RbaV0gPSBmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgRW5jb2Rlcl8xLlNCTUFYX3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPD0gNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBiYXNzO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpIDw9IDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGFsdG87XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPD0gMTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gdHJlYmxlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gc2ZiMjE7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2ZjLm5zUHN5LnNob3J0ZmFjdFtpXSA9IGY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFsbG9jYXRlIGJpdHMgYW1vbmcgMiBjaGFubmVscyBiYXNlZCBvbiBQRTxCUj5cbiAgICAgKiBtdCA2Lzk5PEJSPlxuICAgICAqIGJ1Z2ZpeGVzIHJoIDgvMDE6IG9mdGVuIGFsbG9jYXRlZCBtb3JlIHRoYW4gdGhlIGFsbG93ZWQgNDA5NSBiaXRzXG4gICAgICovXG4gICAgdGhpcy5vbl9wZSA9IGZ1bmN0aW9uIChnZnAsIHBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ19iaXRzLCBtZWFuX2JpdHMsIGdyLCBjYnIpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIHRiaXRzID0gMCwgYml0cztcbiAgICAgICAgdmFyIGFkZF9iaXRzID0gbmV3X2ludCQxOSgyKTtcbiAgICAgICAgdmFyIGNoO1xuXG4gICAgICAgIC8qIGFsbG9jYXRlIHRhcmdfYml0cyBmb3IgZ3JhbnVsZSAqL1xuICAgICAgICB2YXIgbWIgPSBuZXcgTWVhbkJpdHNfMSh0Yml0cyk7XG4gICAgICAgIHZhciBleHRyYV9iaXRzID0gcnYuUmVzdk1heEJpdHMoZ2ZwLCBtZWFuX2JpdHMsIG1iLCBjYnIpO1xuICAgICAgICB0Yml0cyA9IG1iLmJpdHM7XG4gICAgICAgIC8qIG1heGltdW0gYWxsb3dlZCBiaXRzIGZvciB0aGlzIGdyYW51bGUgKi9cbiAgICAgICAgdmFyIG1heF9iaXRzID0gdGJpdHMgKyBleHRyYV9iaXRzO1xuICAgICAgICBpZiAobWF4X2JpdHMgPiBMYW1lSW50ZXJuYWxGbGFnc18xLk1BWF9CSVRTX1BFUl9HUkFOVUxFKSB7XG4gICAgICAgICAgICAvLyBoYXJkIGxpbWl0IHBlciBncmFudWxlXG4gICAgICAgICAgICBtYXhfYml0cyA9IExhbWVJbnRlcm5hbEZsYWdzXzEuTUFYX0JJVFNfUEVSX0dSQU5VTEU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChiaXRzID0gMCwgY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7ICsrY2gpIHtcbiAgICAgICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICAgICAqIGFsbG9jYXRlIGJpdHMgZm9yIGVhY2ggY2hhbm5lbFxuICAgICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgICAgIHRhcmdfYml0c1tjaF0gPSBNYXRoLm1pbihMYW1lSW50ZXJuYWxGbGFnc18xLk1BWF9CSVRTX1BFUl9DSEFOTkVMLFxuICAgICAgICAgICAgICAgIHRiaXRzIC8gZ2ZjLmNoYW5uZWxzX291dCk7XG5cbiAgICAgICAgICAgIGFkZF9iaXRzW2NoXSA9IDAgfCAodGFyZ19iaXRzW2NoXSAqIHBlW2dyXVtjaF0gLyA3MDAuMCAtIHRhcmdfYml0c1tjaF0pO1xuXG4gICAgICAgICAgICAvKiBhdCBtb3N0IGluY3JlYXNlIGJpdHMgYnkgMS41KmF2ZXJhZ2UgKi9cbiAgICAgICAgICAgIGlmIChhZGRfYml0c1tjaF0gPiBtZWFuX2JpdHMgKiAzIC8gNClcbiAgICAgICAgICAgICAgICBhZGRfYml0c1tjaF0gPSBtZWFuX2JpdHMgKiAzIC8gNDtcbiAgICAgICAgICAgIGlmIChhZGRfYml0c1tjaF0gPCAwKVxuICAgICAgICAgICAgICAgIGFkZF9iaXRzW2NoXSA9IDA7XG5cbiAgICAgICAgICAgIGlmIChhZGRfYml0c1tjaF0gKyB0YXJnX2JpdHNbY2hdID4gTGFtZUludGVybmFsRmxhZ3NfMS5NQVhfQklUU19QRVJfQ0hBTk5FTClcbiAgICAgICAgICAgICAgICBhZGRfYml0c1tjaF0gPSBNYXRoLm1heCgwLFxuICAgICAgICAgICAgICAgICAgICBMYW1lSW50ZXJuYWxGbGFnc18xLk1BWF9CSVRTX1BFUl9DSEFOTkVMIC0gdGFyZ19iaXRzW2NoXSk7XG5cbiAgICAgICAgICAgIGJpdHMgKz0gYWRkX2JpdHNbY2hdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXRzID4gZXh0cmFfYml0cykge1xuICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgKytjaCkge1xuICAgICAgICAgICAgICAgIGFkZF9iaXRzW2NoXSA9IGV4dHJhX2JpdHMgKiBhZGRfYml0c1tjaF0gLyBiaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgKytjaCkge1xuICAgICAgICAgICAgdGFyZ19iaXRzW2NoXSArPSBhZGRfYml0c1tjaF07XG4gICAgICAgICAgICBleHRyYV9iaXRzIC09IGFkZF9iaXRzW2NoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoYml0cyA9IDAsIGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyArK2NoKSB7XG4gICAgICAgICAgICBiaXRzICs9IHRhcmdfYml0c1tjaF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpdHMgPiBMYW1lSW50ZXJuYWxGbGFnc18xLk1BWF9CSVRTX1BFUl9HUkFOVUxFKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7ICsrY2gpIHtcbiAgICAgICAgICAgICAgICB0YXJnX2JpdHNbY2hdICo9IExhbWVJbnRlcm5hbEZsYWdzXzEuTUFYX0JJVFNfUEVSX0dSQU5VTEU7XG4gICAgICAgICAgICAgICAgdGFyZ19iaXRzW2NoXSAvPSBiaXRzO1xuICAgICAgICAgICAgICAgIHN1bSArPSB0YXJnX2JpdHNbY2hdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0JDE5KHN1bSA8PSBMYW1lSW50ZXJuYWxGbGFnc18xLk1BWF9CSVRTX1BFUl9HUkFOVUxFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXhfYml0cztcbiAgICB9O1xuXG4gICAgdGhpcy5yZWR1Y2Vfc2lkZSA9IGZ1bmN0aW9uICh0YXJnX2JpdHMsIG1zX2VuZXJfcmF0aW8sIG1lYW5fYml0cywgbWF4X2JpdHMpIHtcbiAgICAgICAgYXNzZXJ0JDE5KG1heF9iaXRzIDw9IExhbWVJbnRlcm5hbEZsYWdzXzEuTUFYX0JJVFNfUEVSX0dSQU5VTEUpO1xuICAgICAgICBhc3NlcnQkMTkodGFyZ19iaXRzWzBdICsgdGFyZ19iaXRzWzFdIDw9IExhbWVJbnRlcm5hbEZsYWdzXzEuTUFYX0JJVFNfUEVSX0dSQU5VTEUpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIG1zX2VuZXJfcmF0aW8gPSAwOiBhbGxvY2F0ZSA2Ni8zMyBtaWQvc2lkZSBmYWM9LjMzIG1zX2VuZXJfcmF0aW8gPS41OlxuICAgICAgICAgKiBhbGxvY2F0ZSA1MC81MCBtaWQvc2lkZSBmYWM9IDBcbiAgICAgICAgICovXG4gICAgICAgIC8qIDc1LzI1IHNwbGl0IGlzIGZhYz0uNSAqL1xuICAgICAgICB2YXIgZmFjID0gLjMzICogKC41IC0gbXNfZW5lcl9yYXRpbykgLyAuNTtcbiAgICAgICAgaWYgKGZhYyA8IDApXG4gICAgICAgICAgICBmYWMgPSAwO1xuICAgICAgICBpZiAoZmFjID4gLjUpXG4gICAgICAgICAgICBmYWMgPSAuNTtcblxuICAgICAgICAvKiBudW1iZXIgb2YgYml0cyB0byBtb3ZlIGZyb20gc2lkZSBjaGFubmVsIHRvIG1pZCBjaGFubmVsICovXG4gICAgICAgIC8qIG1vdmVfYml0cyA9IGZhYyp0YXJnX2JpdHNbMV07ICovXG4gICAgICAgIHZhciBtb3ZlX2JpdHMgPSAwIHwgKGZhYyAqIC41ICogKHRhcmdfYml0c1swXSArIHRhcmdfYml0c1sxXSkpO1xuXG4gICAgICAgIGlmIChtb3ZlX2JpdHMgPiBMYW1lSW50ZXJuYWxGbGFnc18xLk1BWF9CSVRTX1BFUl9DSEFOTkVMIC0gdGFyZ19iaXRzWzBdKSB7XG4gICAgICAgICAgICBtb3ZlX2JpdHMgPSBMYW1lSW50ZXJuYWxGbGFnc18xLk1BWF9CSVRTX1BFUl9DSEFOTkVMIC0gdGFyZ19iaXRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlX2JpdHMgPCAwKVxuICAgICAgICAgICAgbW92ZV9iaXRzID0gMDtcblxuICAgICAgICBpZiAodGFyZ19iaXRzWzFdID49IDEyNSkge1xuICAgICAgICAgICAgLyogZG9udCByZWR1Y2Ugc2lkZSBjaGFubmVsIGJlbG93IDEyNSBiaXRzICovXG4gICAgICAgICAgICBpZiAodGFyZ19iaXRzWzFdIC0gbW92ZV9iaXRzID4gMTI1KSB7XG5cbiAgICAgICAgICAgICAgICAvKiBpZiBtaWQgY2hhbm5lbCBhbHJlYWR5IGhhcyAyeCBtb3JlIHRoYW4gYXZlcmFnZSwgZG9udCBib3RoZXIgKi9cbiAgICAgICAgICAgICAgICAvKiBtZWFuX2JpdHMgPSBiaXRzIHBlciBncmFudWxlIChmb3IgYm90aCBjaGFubmVscykgKi9cbiAgICAgICAgICAgICAgICBpZiAodGFyZ19iaXRzWzBdIDwgbWVhbl9iaXRzKVxuICAgICAgICAgICAgICAgICAgICB0YXJnX2JpdHNbMF0gKz0gbW92ZV9iaXRzO1xuICAgICAgICAgICAgICAgIHRhcmdfYml0c1sxXSAtPSBtb3ZlX2JpdHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdfYml0c1swXSArPSB0YXJnX2JpdHNbMV0gLSAxMjU7XG4gICAgICAgICAgICAgICAgdGFyZ19iaXRzWzFdID0gMTI1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbW92ZV9iaXRzID0gdGFyZ19iaXRzWzBdICsgdGFyZ19iaXRzWzFdO1xuICAgICAgICBpZiAobW92ZV9iaXRzID4gbWF4X2JpdHMpIHtcbiAgICAgICAgICAgIHRhcmdfYml0c1swXSA9IChtYXhfYml0cyAqIHRhcmdfYml0c1swXSkgLyBtb3ZlX2JpdHM7XG4gICAgICAgICAgICB0YXJnX2JpdHNbMV0gPSAobWF4X2JpdHMgKiB0YXJnX2JpdHNbMV0pIC8gbW92ZV9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCQxOSh0YXJnX2JpdHNbMF0gPD0gTGFtZUludGVybmFsRmxhZ3NfMS5NQVhfQklUU19QRVJfQ0hBTk5FTCk7XG4gICAgICAgIGFzc2VydCQxOSh0YXJnX2JpdHNbMV0gPD0gTGFtZUludGVybmFsRmxhZ3NfMS5NQVhfQklUU19QRVJfQ0hBTk5FTCk7XG4gICAgICAgIGFzc2VydCQxOSh0YXJnX2JpdHNbMF0gKyB0YXJnX2JpdHNbMV0gPD0gTGFtZUludGVybmFsRmxhZ3NfMS5NQVhfQklUU19QRVJfR1JBTlVMRSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBSb2JlcnQgSGVnZW1hbm4gMjAwMS0wNC0yNzpcbiAgICAgKiAgdGhpcyBhZGp1c3RzIHRoZSBBVEgsIGtlZXBpbmcgdGhlIG9yaWdpbmFsIG5vaXNlIGZsb29yXG4gICAgICogIGFmZmVjdHMgdGhlIGhpZ2hlciBmcmVxdWVuY2llcyBtb3JlIHRoYW4gdGhlIGxvd2VyIG9uZXNcbiAgICAgKi9cbiAgICB0aGlzLmF0aEFkanVzdCA9IGZ1bmN0aW9uIChhLCB4LCBhdGhGbG9vcikge1xuICAgICAgICAvKlxuICAgICAgICAgKiB3b3JrIGluIHByb2dyZXNzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbyA9IDkwLjMwODczMzYyO1xuICAgICAgICB2YXIgcCA9IDk0LjgyNDQ0ODYzO1xuICAgICAgICB2YXIgdSA9IFV0aWwkMTkuRkFTVF9MT0cxMF9YKHgsIDEwLjApO1xuICAgICAgICB2YXIgdiA9IGEgKiBhO1xuICAgICAgICB2YXIgdyA9IDAuMDtcbiAgICAgICAgdSAtPSBhdGhGbG9vcjtcbiAgICAgICAgLyogdW5kbyBzY2FsaW5nICovXG4gICAgICAgIGlmICh2ID4gMUUtMjApXG4gICAgICAgICAgICB3ID0gMS4gKyBVdGlsJDE5LkZBU1RfTE9HMTBfWCh2LCAxMC4wIC8gbyk7XG4gICAgICAgIGlmICh3IDwgMClcbiAgICAgICAgICAgIHcgPSAwLjtcbiAgICAgICAgdSAqPSB3O1xuICAgICAgICB1ICs9IGF0aEZsb29yICsgbyAtIHA7XG4gICAgICAgIC8qIHJlZG8gc2NhbGluZyAqL1xuXG4gICAgICAgIHJldHVybiBNYXRoLnBvdygxMC4sIDAuMSAqIHUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGFsbG93ZWQgZGlzdG9ydGlvbiBmb3IgZWFjaCBzY2FsZWZhY3RvciBiYW5kLCBhcyBkZXRlcm1pbmVkXG4gICAgICogYnkgdGhlIHBzeWNob2Fjb3VzdGljIG1vZGVsLiB4bWluKHNiKSA9IHJhdGlvKHNiKSAqIGVuKHNiKSAvIGJ3KHNiKVxuICAgICAqXG4gICAgICogcmV0dXJucyBudW1iZXIgb2Ygc2ZiJ3Mgd2l0aCBlbmVyZ3kgPiBBVEhcbiAgICAgKi9cbiAgICB0aGlzLmNhbGNfeG1pbiA9IGZ1bmN0aW9uIChnZnAsIHJhdGlvLCBjb2RfaW5mbywgcHhtaW4pIHtcbiAgICAgICAgdmFyIHB4bWluUG9zID0gMDtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGdzZmIsIGogPSAwLCBhdGhfb3ZlciA9IDA7XG4gICAgICAgIHZhciBBVEggPSBnZmMuQVRIO1xuICAgICAgICB2YXIgeHIgPSBjb2RfaW5mby54cjtcbiAgICAgICAgdmFyIGVuYWJsZV9hdGhhYV9maXggPSAoZ2ZwLlZCUiA9PSBWYnJNb2RlJDE5LnZicl9tdHJoKSA/IDEgOiAwO1xuICAgICAgICB2YXIgbWFza2luZ19sb3dlciA9IGdmYy5tYXNraW5nX2xvd2VyO1xuXG4gICAgICAgIGlmIChnZnAuVkJSID09IFZick1vZGUkMTkudmJyX210cmggfHwgZ2ZwLlZCUiA9PSBWYnJNb2RlJDE5LnZicl9tdCkge1xuICAgICAgICAgICAgLyogd2FzIGFscmVhZHkgZG9uZSBpbiBQU1ktTW9kZWwgKi9cbiAgICAgICAgICAgIG1hc2tpbmdfbG93ZXIgPSAxLjA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGdzZmIgPSAwOyBnc2ZiIDwgY29kX2luZm8ucHN5X2xtYXg7IGdzZmIrKykge1xuICAgICAgICAgICAgdmFyIGVuMCwgeG1pbjtcbiAgICAgICAgICAgIHZhciByaDEsIHJoMjtcbiAgICAgICAgICAgIHZhciB3aWR0aCwgbDtcblxuICAgICAgICAgICAgaWYgKGdmcC5WQlIgPT0gVmJyTW9kZSQxOS52YnJfcmggfHwgZ2ZwLlZCUiA9PSBWYnJNb2RlJDE5LnZicl9tdHJoKVxuICAgICAgICAgICAgICAgIHhtaW4gPSBhdGhBZGp1c3QoQVRILmFkanVzdCwgQVRILmxbZ3NmYl0sIEFUSC5mbG9vcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgeG1pbiA9IEFUSC5hZGp1c3QgKiBBVEgubFtnc2ZiXTtcblxuICAgICAgICAgICAgd2lkdGggPSBjb2RfaW5mby53aWR0aFtnc2ZiXTtcbiAgICAgICAgICAgIHJoMSA9IHhtaW4gLyB3aWR0aDtcbiAgICAgICAgICAgIHJoMiA9IERCTF9FUFNJTE9OO1xuICAgICAgICAgICAgbCA9IHdpZHRoID4+IDE7XG4gICAgICAgICAgICBlbjAgPSAwLjA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIHhhLCB4YjtcbiAgICAgICAgICAgICAgICB4YSA9IHhyW2pdICogeHJbal07XG4gICAgICAgICAgICAgICAgZW4wICs9IHhhO1xuICAgICAgICAgICAgICAgIHJoMiArPSAoeGEgPCByaDEpID8geGEgOiByaDE7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIHhiID0geHJbal0gKiB4cltqXTtcbiAgICAgICAgICAgICAgICBlbjAgKz0geGI7XG4gICAgICAgICAgICAgICAgcmgyICs9ICh4YiA8IHJoMSkgPyB4YiA6IHJoMTtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9IHdoaWxlICgtLWwgPiAwKTtcbiAgICAgICAgICAgIGlmIChlbjAgPiB4bWluKVxuICAgICAgICAgICAgICAgIGF0aF9vdmVyKys7XG5cbiAgICAgICAgICAgIGlmIChnc2ZiID09IEVuY29kZXJfMS5TQlBTWV9sKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB4bWluICogZ2ZjLm5zUHN5LmxvbmdmYWN0W2dzZmJdO1xuICAgICAgICAgICAgICAgIGlmIChyaDIgPCB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJoMiA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuYWJsZV9hdGhhYV9maXggIT0gMCkge1xuICAgICAgICAgICAgICAgIHhtaW4gPSByaDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdmcC5BVEhvbmx5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSByYXRpby5lbi5sW2dzZmJdO1xuICAgICAgICAgICAgICAgIGlmIChlID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgICAgICAgICB4ID0gZW4wICogcmF0aW8udGhtLmxbZ3NmYl0gKiBtYXNraW5nX2xvd2VyIC8gZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZV9hdGhhYV9maXggIT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKj0gZ2ZjLm5zUHN5LmxvbmdmYWN0W2dzZmJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeG1pbiA8IHgpXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWluID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5hYmxlX2F0aGFhX2ZpeCAhPSAwKVxuICAgICAgICAgICAgICAgIHB4bWluW3B4bWluUG9zKytdID0geG1pbjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBweG1pbltweG1pblBvcysrXSA9IHhtaW4gKiBnZmMubnNQc3kubG9uZ2ZhY3RbZ3NmYl07XG4gICAgICAgIH1cbiAgICAgICAgLyogZW5kIG9mIGxvbmcgYmxvY2sgbG9vcCAqL1xuXG4gICAgICAgIC8qIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGRldGVybWluZSB0aGUgaGlnaGVzdCBub24temVybyBjb2VmZiAqL1xuICAgICAgICB2YXIgbWF4X25vbnplcm8gPSA1NzU7XG4gICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlICE9IEVuY29kZXJfMS5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICAvLyBOT1JNLCBTVEFSVCBvciBTVE9QIHR5cGUsIGJ1dCBub3QgU0hPUlRcbiAgICAgICAgICAgIHZhciBrID0gNTc2O1xuICAgICAgICAgICAgd2hpbGUgKGstLSAhPSAwICYmIEJpdFN0cmVhbS5FUSh4cltrXSwgMCkpIHtcbiAgICAgICAgICAgICAgICBtYXhfbm9uemVybyA9IGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29kX2luZm8ubWF4X25vbnplcm9fY29lZmYgPSBtYXhfbm9uemVybztcblxuICAgICAgICBmb3IgKHZhciBzZmIgPSBjb2RfaW5mby5zZmJfc21pbjsgZ3NmYiA8IGNvZF9pbmZvLnBzeW1heDsgc2ZiKyssIGdzZmIgKz0gMykge1xuICAgICAgICAgICAgdmFyIHdpZHRoLCBiO1xuICAgICAgICAgICAgdmFyIHRtcEFUSDtcbiAgICAgICAgICAgIGlmIChnZnAuVkJSID09IFZick1vZGUkMTkudmJyX3JoIHx8IGdmcC5WQlIgPT0gVmJyTW9kZSQxOS52YnJfbXRyaClcbiAgICAgICAgICAgICAgICB0bXBBVEggPSBhdGhBZGp1c3QoQVRILmFkanVzdCwgQVRILnNbc2ZiXSwgQVRILmZsb29yKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0bXBBVEggPSBBVEguYWRqdXN0ICogQVRILnNbc2ZiXTtcblxuICAgICAgICAgICAgd2lkdGggPSBjb2RfaW5mby53aWR0aFtnc2ZiXTtcbiAgICAgICAgICAgIGZvciAoYiA9IDA7IGIgPCAzOyBiKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZW4wID0gMC4wLCB4bWluO1xuICAgICAgICAgICAgICAgIHZhciByaDEsIHJoMjtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHdpZHRoID4+IDE7XG5cbiAgICAgICAgICAgICAgICByaDEgPSB0bXBBVEggLyB3aWR0aDtcbiAgICAgICAgICAgICAgICByaDIgPSBEQkxfRVBTSUxPTjtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4YSwgeGI7XG4gICAgICAgICAgICAgICAgICAgIHhhID0geHJbal0gKiB4cltqXTtcbiAgICAgICAgICAgICAgICAgICAgZW4wICs9IHhhO1xuICAgICAgICAgICAgICAgICAgICByaDIgKz0gKHhhIDwgcmgxKSA/IHhhIDogcmgxO1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgIHhiID0geHJbal0gKiB4cltqXTtcbiAgICAgICAgICAgICAgICAgICAgZW4wICs9IHhiO1xuICAgICAgICAgICAgICAgICAgICByaDIgKz0gKHhiIDwgcmgxKSA/IHhiIDogcmgxO1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sID4gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuMCA+IHRtcEFUSClcbiAgICAgICAgICAgICAgICAgICAgYXRoX292ZXIrKztcbiAgICAgICAgICAgICAgICBpZiAoc2ZiID09IEVuY29kZXJfMS5TQlBTWV9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gdG1wQVRIICogZ2ZjLm5zUHN5LnNob3J0ZmFjdFtzZmJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmgyIDwgeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmgyID0geDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlX2F0aGFhX2ZpeCAhPSAwKVxuICAgICAgICAgICAgICAgICAgICB4bWluID0gcmgyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgeG1pbiA9IHRtcEFUSDtcblxuICAgICAgICAgICAgICAgIGlmICghZ2ZwLkFUSG9ubHkgJiYgIWdmcC5BVEhzaG9ydCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHJhdGlvLmVuLnNbc2ZiXVtiXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGVuMCAqIHJhdGlvLnRobS5zW3NmYl1bYl0gKiBtYXNraW5nX2xvd2VyIC8gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVfYXRoYWFfZml4ICE9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCAqPSBnZmMubnNQc3kuc2hvcnRmYWN0W3NmYl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeG1pbiA8IHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeG1pbiA9IHg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZV9hdGhhYV9maXggIT0gMClcbiAgICAgICAgICAgICAgICAgICAgcHhtaW5bcHhtaW5Qb3MrK10gPSB4bWluO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcHhtaW5bcHhtaW5Qb3MrK10gPSB4bWluICogZ2ZjLm5zUHN5LnNob3J0ZmFjdFtzZmJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYiAqL1xuICAgICAgICAgICAgaWYgKGdmcC51c2VUZW1wb3JhbCkge1xuICAgICAgICAgICAgICAgIGlmIChweG1pbltweG1pblBvcyAtIDNdID4gcHhtaW5bcHhtaW5Qb3MgLSAzICsgMV0pXG4gICAgICAgICAgICAgICAgICAgIHB4bWluW3B4bWluUG9zIC0gMyArIDFdICs9IChweG1pbltweG1pblBvcyAtIDNdIC0gcHhtaW5bcHhtaW5Qb3MgLSAzICsgMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAqIGdmYy5kZWNheTtcbiAgICAgICAgICAgICAgICBpZiAocHhtaW5bcHhtaW5Qb3MgLSAzICsgMV0gPiBweG1pbltweG1pblBvcyAtIDMgKyAyXSlcbiAgICAgICAgICAgICAgICAgICAgcHhtaW5bcHhtaW5Qb3MgLSAzICsgMl0gKz0gKHB4bWluW3B4bWluUG9zIC0gMyArIDFdIC0gcHhtaW5bcHhtaW5Qb3MgLSAzICsgMl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAqIGdmYy5kZWNheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBlbmQgb2Ygc2hvcnQgYmxvY2sgc2ZiIGxvb3AgKi9cblxuICAgICAgICByZXR1cm4gYXRoX292ZXI7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFN0YXJ0TGluZShqKSB7XG4gICAgICAgIHRoaXMucyA9IGo7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxjX25vaXNlX2NvcmUgPSBmdW5jdGlvbiAoY29kX2luZm8sIHN0YXJ0bGluZSwgbCwgc3RlcCkge1xuICAgICAgICB2YXIgbm9pc2UgPSAwO1xuICAgICAgICB2YXIgaiA9IHN0YXJ0bGluZS5zO1xuICAgICAgICB2YXIgaXggPSBjb2RfaW5mby5sM19lbmM7XG5cbiAgICAgICAgaWYgKGogPiBjb2RfaW5mby5jb3VudDEpIHtcbiAgICAgICAgICAgIHdoaWxlICgobC0tKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXA7XG4gICAgICAgICAgICAgICAgdGVtcCA9IGNvZF9pbmZvLnhyW2pdO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICBub2lzZSArPSB0ZW1wICogdGVtcDtcbiAgICAgICAgICAgICAgICB0ZW1wID0gY29kX2luZm8ueHJbal07XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIG5vaXNlICs9IHRlbXAgKiB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGogPiBjb2RfaW5mby5iaWdfdmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgaXgwMSA9IG5ld19mbG9hdCQxOSgyKTtcbiAgICAgICAgICAgIGl4MDFbMF0gPSAwO1xuICAgICAgICAgICAgaXgwMVsxXSA9IHN0ZXA7XG4gICAgICAgICAgICB3aGlsZSAoKGwtLSkgIT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wO1xuICAgICAgICAgICAgICAgIHRlbXAgPSBNYXRoLmFicyhjb2RfaW5mby54cltqXSkgLSBpeDAxW2l4W2pdXTtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgbm9pc2UgKz0gdGVtcCAqIHRlbXA7XG4gICAgICAgICAgICAgICAgdGVtcCA9IE1hdGguYWJzKGNvZF9pbmZvLnhyW2pdKSAtIGl4MDFbaXhbal1dO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICBub2lzZSArPSB0ZW1wICogdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICgobC0tKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXA7XG4gICAgICAgICAgICAgICAgdGVtcCA9IE1hdGguYWJzKGNvZF9pbmZvLnhyW2pdKSAtIHBvdzQzW2l4W2pdXSAqIHN0ZXA7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIG5vaXNlICs9IHRlbXAgKiB0ZW1wO1xuICAgICAgICAgICAgICAgIHRlbXAgPSBNYXRoLmFicyhjb2RfaW5mby54cltqXSkgLSBwb3c0M1tpeFtqXV0gKiBzdGVwO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICBub2lzZSArPSB0ZW1wICogdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0bGluZS5zID0gajtcbiAgICAgICAgcmV0dXJuIG5vaXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiA8UFJFPlxuICAgICAqIC1vbyBkQiAgPT4gIC0xLjAwXG4gICAgICogLSA2IGRCICA9PiAgLTAuOTdcbiAgICAgKiAtIDMgZEIgID0+ICAtMC44MFxuICAgICAqIC0gMiBkQiAgPT4gIC0wLjY0XG4gICAgICogLSAxIGRCICA9PiAgLTAuMzhcbiAgICAgKiAgIDAgZEIgID0+ICAgMC4wMFxuICAgICAqICsgMSBkQiAgPT4gICswLjQ5XG4gICAgICogKyAyIGRCICA9PiAgKzEuMDZcbiAgICAgKiArIDMgZEIgID0+ICArMS42OFxuICAgICAqICsgNiBkQiAgPT4gICszLjY5XG4gICAgICogKzEwIGRCICA9PiAgKzYuNDVcbiAgICAgKiA8L1BSRT5cbiAgICAgKi9cbiAgICB0aGlzLmNhbGNfbm9pc2UgPSBmdW5jdGlvbiAoY29kX2luZm8sIGwzX3htaW4sIGRpc3RvcnQsIHJlcywgcHJldl9ub2lzZSkge1xuICAgICAgICB2YXIgZGlzdG9ydFBvcyA9IDA7XG4gICAgICAgIHZhciBsM194bWluUG9zID0gMDtcbiAgICAgICAgdmFyIHNmYiwgbCwgb3ZlciA9IDA7XG4gICAgICAgIHZhciBvdmVyX25vaXNlX2RiID0gMDtcbiAgICAgICAgLyogMCBkQiByZWxhdGl2ZSB0byBtYXNraW5nICovXG4gICAgICAgIHZhciB0b3Rfbm9pc2VfZGIgPSAwO1xuICAgICAgICAvKiAtMjAwIGRCIHJlbGF0aXZlIHRvIG1hc2tpbmcgKi9cbiAgICAgICAgdmFyIG1heF9ub2lzZSA9IC0yMC4wO1xuICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgIHZhciBzY2FsZWZhYyA9IGNvZF9pbmZvLnNjYWxlZmFjO1xuICAgICAgICB2YXIgc2NhbGVmYWNQb3MgPSAwO1xuXG4gICAgICAgIHJlcy5vdmVyX1NTRCA9IDA7XG5cbiAgICAgICAgZm9yIChzZmIgPSAwOyBzZmIgPCBjb2RfaW5mby5wc3ltYXg7IHNmYisrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGNvZF9pbmZvLmdsb2JhbF9nYWluXG4gICAgICAgICAgICAgICAgLSAoKChzY2FsZWZhY1tzY2FsZWZhY1BvcysrXSkgKyAoY29kX2luZm8ucHJlZmxhZyAhPSAwID8gcHJldGFiW3NmYl1cbiAgICAgICAgICAgICAgICAgICAgOiAwKSkgPDwgKGNvZF9pbmZvLnNjYWxlZmFjX3NjYWxlICsgMSkpXG4gICAgICAgICAgICAgICAgLSBjb2RfaW5mby5zdWJibG9ja19nYWluW2NvZF9pbmZvLndpbmRvd1tzZmJdXSAqIDg7XG4gICAgICAgICAgICB2YXIgbm9pc2UgPSAwLjA7XG5cbiAgICAgICAgICAgIGlmIChwcmV2X25vaXNlICE9IG51bGwgJiYgKHByZXZfbm9pc2Uuc3RlcFtzZmJdID09IHMpKSB7XG5cbiAgICAgICAgICAgICAgICAvKiB1c2UgcHJldmlvdXNseSBjb21wdXRlZCB2YWx1ZXMgKi9cbiAgICAgICAgICAgICAgICBub2lzZSA9IHByZXZfbm9pc2Uubm9pc2Vbc2ZiXTtcbiAgICAgICAgICAgICAgICBqICs9IGNvZF9pbmZvLndpZHRoW3NmYl07XG4gICAgICAgICAgICAgICAgZGlzdG9ydFtkaXN0b3J0UG9zKytdID0gbm9pc2UgLyBsM194bWluW2wzX3htaW5Qb3MrK107XG5cbiAgICAgICAgICAgICAgICBub2lzZSA9IHByZXZfbm9pc2Uubm9pc2VfbG9nW3NmYl07XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBQT1cyMChzKTtcbiAgICAgICAgICAgICAgICBsID0gY29kX2luZm8ud2lkdGhbc2ZiXSA+PiAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKChqICsgY29kX2luZm8ud2lkdGhbc2ZiXSkgPiBjb2RfaW5mby5tYXhfbm9uemVyb19jb2VmZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXNlZnVsbHNpemU7XG4gICAgICAgICAgICAgICAgICAgIHVzZWZ1bGxzaXplID0gY29kX2luZm8ubWF4X25vbnplcm9fY29lZmYgLSBqICsgMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodXNlZnVsbHNpemUgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHVzZWZ1bGxzaXplID4+IDE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzbCA9IG5ldyBTdGFydExpbmUoaik7XG4gICAgICAgICAgICAgICAgbm9pc2UgPSB0aGlzLmNhbGNfbm9pc2VfY29yZShjb2RfaW5mbywgc2wsIGwsIHN0ZXApO1xuICAgICAgICAgICAgICAgIGogPSBzbC5zO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZfbm9pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBzYXZlIG5vaXNlIHZhbHVlcyAqL1xuICAgICAgICAgICAgICAgICAgICBwcmV2X25vaXNlLnN0ZXBbc2ZiXSA9IHM7XG4gICAgICAgICAgICAgICAgICAgIHByZXZfbm9pc2Uubm9pc2Vbc2ZiXSA9IG5vaXNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vaXNlID0gZGlzdG9ydFtkaXN0b3J0UG9zKytdID0gbm9pc2UgLyBsM194bWluW2wzX3htaW5Qb3MrK107XG5cbiAgICAgICAgICAgICAgICAvKiBtdWx0aXBseWluZyBoZXJlIGlzIGFkZGluZyBpbiBkQiwgYnV0IGNhbiBvdmVyZmxvdyAqL1xuICAgICAgICAgICAgICAgIG5vaXNlID0gVXRpbCQxOS5GQVNUX0xPRzEwKE1hdGgubWF4KG5vaXNlLCAxRS0yMCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZfbm9pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBzYXZlIG5vaXNlIHZhbHVlcyAqL1xuICAgICAgICAgICAgICAgICAgICBwcmV2X25vaXNlLm5vaXNlX2xvZ1tzZmJdID0gbm9pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldl9ub2lzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLyogc2F2ZSBub2lzZSB2YWx1ZXMgKi9cbiAgICAgICAgICAgICAgICBwcmV2X25vaXNlLmdsb2JhbF9nYWluID0gY29kX2luZm8uZ2xvYmFsX2dhaW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvdF9ub2lzZV9kYiArPSBub2lzZTtcblxuICAgICAgICAgICAgaWYgKG5vaXNlID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcDtcblxuICAgICAgICAgICAgICAgIHRtcCA9IE1hdGgubWF4KDAgfCAobm9pc2UgKiAxMCArIC41KSwgMSk7XG4gICAgICAgICAgICAgICAgcmVzLm92ZXJfU1NEICs9IHRtcCAqIHRtcDtcblxuICAgICAgICAgICAgICAgIG92ZXIrKztcbiAgICAgICAgICAgICAgICAvKiBtdWx0aXBseWluZyBoZXJlIGlzIGFkZGluZyBpbiBkQiAtYnV0IGNhbiBvdmVyZmxvdyAqL1xuICAgICAgICAgICAgICAgIC8qIG92ZXJfbm9pc2UgKj0gbm9pc2U7ICovXG4gICAgICAgICAgICAgICAgb3Zlcl9ub2lzZV9kYiArPSBub2lzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1heF9ub2lzZSA9IE1hdGgubWF4KG1heF9ub2lzZSwgbm9pc2UpO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXMub3Zlcl9jb3VudCA9IG92ZXI7XG4gICAgICAgIHJlcy50b3Rfbm9pc2UgPSB0b3Rfbm9pc2VfZGI7XG4gICAgICAgIHJlcy5vdmVyX25vaXNlID0gb3Zlcl9ub2lzZV9kYjtcbiAgICAgICAgcmVzLm1heF9ub2lzZSA9IG1heF9ub2lzZTtcblxuICAgICAgICByZXR1cm4gb3ZlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdXBkYXRlcyBwbG90dGluZyBkYXRhXG4gICAgICpcbiAgICAgKiBNYXJrIFRheWxvciAyMDAwLT8/LT8/XG4gICAgICpcbiAgICAgKiBSb2JlcnQgSGVnZW1hbm46IG1vdmVkIG5vaXNlL2Rpc3RvcnRpb24gY2FsYyBpbnRvIGl0XG4gICAgICovXG4gICAgdGhpcy5zZXRfcGluZm8gPSBmdW5jdGlvbiAoZ2ZwLCBjb2RfaW5mbywgcmF0aW8sIGdyLCBjaCkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgc2ZiLCBzZmIyO1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgdmFyIGVuMCwgZW4xO1xuICAgICAgICB2YXIgaWZxc3RlcCA9IChjb2RfaW5mby5zY2FsZWZhY19zY2FsZSA9PSAwKSA/IC41IDogMS4wO1xuICAgICAgICB2YXIgc2NhbGVmYWMgPSBjb2RfaW5mby5zY2FsZWZhYztcblxuICAgICAgICB2YXIgbDNfeG1pbiA9IG5ld19mbG9hdCQxOShMM1NpZGUuU0ZCTUFYKTtcbiAgICAgICAgdmFyIHhmc2YgPSBuZXdfZmxvYXQkMTkoTDNTaWRlLlNGQk1BWCk7XG4gICAgICAgIHZhciBub2lzZSA9IG5ldyBDYWxjTm9pc2VSZXN1bHQoKTtcblxuICAgICAgICBjYWxjX3htaW4oZ2ZwLCByYXRpbywgY29kX2luZm8sIGwzX3htaW4pO1xuICAgICAgICBjYWxjX25vaXNlKGNvZF9pbmZvLCBsM194bWluLCB4ZnNmLCBub2lzZSwgbnVsbCk7XG5cbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICBzZmIyID0gY29kX2luZm8uc2ZiX2xtYXg7XG4gICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlICE9IEVuY29kZXJfMS5TSE9SVF9UWVBFXG4gICAgICAgICAgICAmJiAwID09IGNvZF9pbmZvLm1peGVkX2Jsb2NrX2ZsYWcpXG4gICAgICAgICAgICBzZmIyID0gMjI7XG4gICAgICAgIGZvciAoc2ZiID0gMDsgc2ZiIDwgc2ZiMjsgc2ZiKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGdmYy5zY2FsZWZhY19iYW5kLmxbc2ZiXTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBnZmMuc2NhbGVmYWNfYmFuZC5sW3NmYiArIDFdO1xuICAgICAgICAgICAgdmFyIGJ3ID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgICBmb3IgKGVuMCA9IDAuMDsgaiA8IGVuZDsgaisrKVxuICAgICAgICAgICAgICAgIGVuMCArPSBjb2RfaW5mby54cltqXSAqIGNvZF9pbmZvLnhyW2pdO1xuICAgICAgICAgICAgZW4wIC89IGJ3O1xuICAgICAgICAgICAgLyogY29udmVydCB0byBNRENUIHVuaXRzICovXG4gICAgICAgICAgICAvKiBzY2FsaW5nIHNvIGl0IHNob3dzIHVwIG9uIEZGVCBwbG90ICovXG4gICAgICAgICAgICBlbjEgPSAxZTE1O1xuICAgICAgICAgICAgZ2ZjLnBpbmZvLmVuW2dyXVtjaF1bc2ZiXSA9IGVuMSAqIGVuMDtcbiAgICAgICAgICAgIGdmYy5waW5mby54ZnNmW2dyXVtjaF1bc2ZiXSA9IGVuMSAqIGwzX3htaW5bc2ZiXSAqIHhmc2Zbc2ZiXSAvIGJ3O1xuXG4gICAgICAgICAgICBpZiAocmF0aW8uZW4ubFtzZmJdID4gMCAmJiAhZ2ZwLkFUSG9ubHkpXG4gICAgICAgICAgICAgICAgZW4wID0gZW4wIC8gcmF0aW8uZW4ubFtzZmJdO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVuMCA9IDAuMDtcblxuICAgICAgICAgICAgZ2ZjLnBpbmZvLnRocltncl1bY2hdW3NmYl0gPSBlbjFcbiAgICAgICAgICAgICAgICAqIE1hdGgubWF4KGVuMCAqIHJhdGlvLnRobS5sW3NmYl0sIGdmYy5BVEgubFtzZmJdKTtcblxuICAgICAgICAgICAgLyogdGhlcmUgaXMgbm8gc2NhbGVmYWN0b3IgYmFuZHMgPj0gU0JQU1lfbCAqL1xuICAgICAgICAgICAgZ2ZjLnBpbmZvLkxBTUVzZmJbZ3JdW2NoXVtzZmJdID0gMDtcbiAgICAgICAgICAgIGlmIChjb2RfaW5mby5wcmVmbGFnICE9IDAgJiYgc2ZiID49IDExKVxuICAgICAgICAgICAgICAgIGdmYy5waW5mby5MQU1Fc2ZiW2dyXVtjaF1bc2ZiXSA9IC1pZnFzdGVwICogcHJldGFiW3NmYl07XG5cbiAgICAgICAgICAgIGlmIChzZmIgPCBFbmNvZGVyXzEuU0JQU1lfbCkge1xuICAgICAgICAgICAgICAgIC8qIHNjZnNpIHNob3VsZCBiZSBkZWNvZGVkIGJ5IGNhbGxlciBzaWRlICovXG4gICAgICAgICAgICAgICAgYXNzZXJ0JDE5KHNjYWxlZmFjW3NmYl0gPj0gMCk7XG4gICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLkxBTUVzZmJbZ3JdW2NoXVtzZmJdIC09IGlmcXN0ZXAgKiBzY2FsZWZhY1tzZmJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGZvciBzZmIgKi9cblxuICAgICAgICBpZiAoY29kX2luZm8uYmxvY2tfdHlwZSA9PSBFbmNvZGVyXzEuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgc2ZiMiA9IHNmYjtcbiAgICAgICAgICAgIGZvciAoc2ZiID0gY29kX2luZm8uc2ZiX3NtaW47IHNmYiA8IEVuY29kZXJfMS5TQk1BWF9zOyBzZmIrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGdmYy5zY2FsZWZhY19iYW5kLnNbc2ZiXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gZ2ZjLnNjYWxlZmFjX2JhbmQuc1tzZmIgKyAxXTtcbiAgICAgICAgICAgICAgICB2YXIgYncgPSBlbmQgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGVuMCA9IDAuMCwgbCA9IHN0YXJ0OyBsIDwgZW5kOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuMCArPSBjb2RfaW5mby54cltqXSAqIGNvZF9pbmZvLnhyW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVuMCA9IE1hdGgubWF4KGVuMCAvIGJ3LCAxZS0yMCk7XG4gICAgICAgICAgICAgICAgICAgIC8qIGNvbnZlcnQgdG8gTURDVCB1bml0cyAqL1xuICAgICAgICAgICAgICAgICAgICAvKiBzY2FsaW5nIHNvIGl0IHNob3dzIHVwIG9uIEZGVCBwbG90ICovXG4gICAgICAgICAgICAgICAgICAgIGVuMSA9IDFlMTU7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLmVuX3NbZ3JdW2NoXVszICogc2ZiICsgaV0gPSBlbjEgKiBlbjA7XG4gICAgICAgICAgICAgICAgICAgIGdmYy5waW5mby54ZnNmX3NbZ3JdW2NoXVszICogc2ZiICsgaV0gPSBlbjEgKiBsM194bWluW3NmYjJdXG4gICAgICAgICAgICAgICAgICAgICAgICAqIHhmc2Zbc2ZiMl0gLyBidztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhdGlvLmVuLnNbc2ZiXVtpXSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBlbjAgPSBlbjAgLyByYXRpby5lbi5zW3NmYl1baV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuMCA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdmcC5BVEhvbmx5IHx8IGdmcC5BVEhzaG9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuMCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLnRocl9zW2dyXVtjaF1bMyAqIHNmYiArIGldID0gZW4xXG4gICAgICAgICAgICAgICAgICAgICAgICAqIE1hdGgubWF4KGVuMCAqIHJhdGlvLnRobS5zW3NmYl1baV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2ZjLkFUSC5zW3NmYl0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIHRoZXJlIGlzIG5vIHNjYWxlZmFjdG9yIGJhbmRzID49IFNCUFNZX3MgKi9cbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnBpbmZvLkxBTUVzZmJfc1tncl1bY2hdWzMgKiBzZmIgKyBpXSA9IC0yLjBcbiAgICAgICAgICAgICAgICAgICAgICAgICogY29kX2luZm8uc3ViYmxvY2tfZ2FpbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNmYiA8IEVuY29kZXJfMS5TQlBTWV9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZmMucGluZm8uTEFNRXNmYl9zW2dyXVtjaF1bMyAqIHNmYiArIGldIC09IGlmcXN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHNjYWxlZmFjW3NmYjJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNmYjIrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogYmxvY2sgdHlwZSBzaG9ydCAqL1xuICAgICAgICBnZmMucGluZm8uTEFNRXFzc1tncl1bY2hdID0gY29kX2luZm8uZ2xvYmFsX2dhaW47XG4gICAgICAgIGdmYy5waW5mby5MQU1FbWFpbmJpdHNbZ3JdW2NoXSA9IGNvZF9pbmZvLnBhcnQyXzNfbGVuZ3RoXG4gICAgICAgICAgICArIGNvZF9pbmZvLnBhcnQyX2xlbmd0aDtcbiAgICAgICAgZ2ZjLnBpbmZvLkxBTUVzZmJpdHNbZ3JdW2NoXSA9IGNvZF9pbmZvLnBhcnQyX2xlbmd0aDtcblxuICAgICAgICBnZmMucGluZm8ub3Zlcltncl1bY2hdID0gbm9pc2Uub3Zlcl9jb3VudDtcbiAgICAgICAgZ2ZjLnBpbmZvLm1heF9ub2lzZVtncl1bY2hdID0gbm9pc2UubWF4X25vaXNlICogMTAuMDtcbiAgICAgICAgZ2ZjLnBpbmZvLm92ZXJfbm9pc2VbZ3JdW2NoXSA9IG5vaXNlLm92ZXJfbm9pc2UgKiAxMC4wO1xuICAgICAgICBnZmMucGluZm8udG90X25vaXNlW2dyXVtjaF0gPSBub2lzZS50b3Rfbm9pc2UgKiAxMC4wO1xuICAgICAgICBnZmMucGluZm8ub3Zlcl9TU0RbZ3JdW2NoXSA9IG5vaXNlLm92ZXJfU1NEO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGVzIHBsb3R0aW5nIGRhdGEgZm9yIGEgd2hvbGUgZnJhbWVcbiAgICAgKlxuICAgICAqIFJvYmVydCBIZWdlbWFubiAyMDAwLTEwLTIxXG4gICAgICovXG4gICAgXG5cbn1cblxudmFyIFF1YW50aXplUFZUXzEgPSBRdWFudGl6ZVBWVCQxO1xuXG4vKlxuICpcdE1QMyBodWZmbWFuIHRhYmxlIHNlbGVjdGluZyBhbmQgYml0IGNvdW50aW5nXG4gKlxuICpcdENvcHlyaWdodCAoYykgMTk5OS0yMDA1IFRha2VoaXJvIFRPTUlOQUdBXG4gKlx0Q29weXJpZ2h0IChjKSAyMDAyLTIwMDUgR2FicmllbCBCb3V2aWduZVxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAqIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlclxuICogdmVyc2lvbiAyIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS5cdCBTZWUgdGhlIEdOVVxuICogTGlicmFyeSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGVcbiAqIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLFxuICogQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4gKi9cblxuLyogJElkOiBUYWtlaGlyby5qYXZhLHYgMS4yNiAyMDExLzA1LzI0IDIwOjQ4OjA2IGtlbmNoaXMgRXhwICQgKi9cblxuLy9wYWNrYWdlIG1wMztcblxuLy9pbXBvcnQgamF2YS51dGlsLkFycmF5cztcblxudmFyIFN5c3RlbSQxOCA9IGNvbW1vbi5TeXN0ZW07XG52YXIgQXJyYXlzJDE4ID0gY29tbW9uLkFycmF5cztcbnZhciBuZXdfaW50JDE4ID0gY29tbW9uLm5ld19pbnQ7XG52YXIgYXNzZXJ0JDE4ID0gY29tbW9uLmFzc2VydDtcblxuXG5cblxuXG5cblxuZnVuY3Rpb24gVGFrZWhpcm8kMSgpIHtcblxuICAgIHZhciBxdXB2dCA9IG51bGw7XG4gICAgdGhpcy5xdXB2dCA9IG51bGw7XG5cbiAgICB0aGlzLnNldE1vZHVsZXMgPSBmdW5jdGlvbiAoX3F1cHZ0KSB7XG4gICAgICAgIHRoaXMucXVwdnQgPSBfcXVwdnQ7XG4gICAgICAgIHF1cHZ0ID0gX3F1cHZ0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBCaXRzKGIpIHtcbiAgICAgICAgdGhpcy5iaXRzID0gMCB8IGI7XG4gICAgfVxuXG4gICAgdmFyIHN1YmR2X3RhYmxlID0gW1swLCAwXSwgLyogMCBiYW5kcyAqL1xuICAgICAgICBbMCwgMF0sIC8qIDEgYmFuZHMgKi9cbiAgICAgICAgWzAsIDBdLCAvKiAyIGJhbmRzICovXG4gICAgICAgIFswLCAwXSwgLyogMyBiYW5kcyAqL1xuICAgICAgICBbMCwgMF0sIC8qIDQgYmFuZHMgKi9cbiAgICAgICAgWzAsIDFdLCAvKiA1IGJhbmRzICovXG4gICAgICAgIFsxLCAxXSwgLyogNiBiYW5kcyAqL1xuICAgICAgICBbMSwgMV0sIC8qIDcgYmFuZHMgKi9cbiAgICAgICAgWzEsIDJdLCAvKiA4IGJhbmRzICovXG4gICAgICAgIFsyLCAyXSwgLyogOSBiYW5kcyAqL1xuICAgICAgICBbMiwgM10sIC8qIDEwIGJhbmRzICovXG4gICAgICAgIFsyLCAzXSwgLyogMTEgYmFuZHMgKi9cbiAgICAgICAgWzMsIDRdLCAvKiAxMiBiYW5kcyAqL1xuICAgICAgICBbMywgNF0sIC8qIDEzIGJhbmRzICovXG4gICAgICAgIFszLCA0XSwgLyogMTQgYmFuZHMgKi9cbiAgICAgICAgWzQsIDVdLCAvKiAxNSBiYW5kcyAqL1xuICAgICAgICBbNCwgNV0sIC8qIDE2IGJhbmRzICovXG4gICAgICAgIFs0LCA2XSwgLyogMTcgYmFuZHMgKi9cbiAgICAgICAgWzUsIDZdLCAvKiAxOCBiYW5kcyAqL1xuICAgICAgICBbNSwgNl0sIC8qIDE5IGJhbmRzICovXG4gICAgICAgIFs1LCA3XSwgLyogMjAgYmFuZHMgKi9cbiAgICAgICAgWzYsIDddLCAvKiAyMSBiYW5kcyAqL1xuICAgICAgICBbNiwgN10sIC8qIDIyIGJhbmRzICovXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIG5vbmxpbmVhciBxdWFudGl6YXRpb24gb2YgeHIgTW9yZSBhY2N1cmF0ZSBmb3JtdWxhIHRoYW4gdGhlIElTTyBmb3JtdWxhLlxuICAgICAqIFRha2VzIGludG8gYWNjb3VudCB0aGUgZmFjdCB0aGF0IHdlIGFyZSBxdWFudGl6aW5nIHhyIC4gaXgsIGJ1dCB3ZSB3YW50XG4gICAgICogaXheNC8zIHRvIGJlIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIHheNC8zLiAodGFraW5nIHRoZSBuZWFyZXN0IGludCB3b3VsZFxuICAgICAqIG1lYW4gaXggaXMgYXMgY2xvc2UgYXMgcG9zc2libGUgdG8geHIsIHdoaWNoIGlzIGRpZmZlcmVudC4pXG4gICAgICpcbiAgICAgKiBGcm9tIFNlZ2hlciBCb2Vzc2Vua29vbCA8c2VnaGVyQGVhc3RzaXRlLm5sPiAxMS8xOTk5XG4gICAgICpcbiAgICAgKiAwOS8yMDAwOiBBU00gY29kZSByZW1vdmVkIGluIGZhdm9yIG9mIElFRUU3NTQgaGFjayBieSBUYWtlaGlybyBUb21pbmFnYS5cbiAgICAgKiBJZiB5b3UgbmVlZCB0aGUgQVNNIGNvZGUsIGNoZWNrIENWUyBjaXJjYSBBdWcgMjAwMC5cbiAgICAgKlxuICAgICAqIDAxLzIwMDQ6IE9wdGltaXphdGlvbnMgYnkgR2FicmllbCBCb3V2aWduZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YW50aXplX2xpbmVzX3hycG93XzAxKGwsIGlzdGVwLCB4ciwgeHJQb3MsIGl4LCBpeFBvcykge1xuICAgICAgICB2YXIgY29tcGFyZXZhbDAgPSAoMS4wIC0gMC40MDU0KSAvIGlzdGVwO1xuXG4gICAgICAgIGFzc2VydCQxOChsID4gMCk7XG4gICAgICAgIGwgPSBsID4+IDE7XG4gICAgICAgIHdoaWxlICgobC0tKSAhPSAwKSB7XG4gICAgICAgICAgICBpeFtpeFBvcysrXSA9IChjb21wYXJldmFsMCA+IHhyW3hyUG9zKytdKSA/IDAgOiAxO1xuICAgICAgICAgICAgaXhbaXhQb3MrK10gPSAoY29tcGFyZXZhbDAgPiB4clt4clBvcysrXSkgPyAwIDogMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFhSUE9XX0ZUT0kgaXMgYSBtYWNybyB0byBjb252ZXJ0IGZsb2F0cyB0byBpbnRzLjxCUj5cbiAgICAgKiBpZiBYUlBPV19GVE9JKHgpID0gbmVhcmVzdF9pbnQoeCksIHRoZW4gUVVBTlRGQUMoeCk9YWRqNDNhc21beF08QlI+XG4gICAgICogUk9VTkRGQUM9IC0wLjA5NDY8QlI+XG4gICAgICpcbiAgICAgKiBpZiBYUlBPV19GVE9JKHgpID0gZmxvb3IoeCksIHRoZW4gUVVBTlRGQUMoeCk9YXNqNDNbeF08QlI+XG4gICAgICogUk9VTkRGQUM9MC40MDU0PEJSPlxuICAgICAqXG4gICAgICogTm90ZTogdXNpbmcgZmxvb3IoKSBvciAwfCBpcyBleHRyZW1lbHkgc2xvdy4gT24gbWFjaGluZXMgd2hlcmUgdGhlXG4gICAgICogVEFLRUhJUk9fSUVFRTc1NF9IQUNLIGNvZGUgYWJvdmUgZG9lcyBub3Qgd29yaywgaXQgaXMgd29ydGh3aWxlIHRvIHdyaXRlXG4gICAgICogc29tZSBBU00gZm9yIFhSUE9XX0ZUT0koKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFudGl6ZV9saW5lc194cnBvdyhsLCBpc3RlcCwgeHIsIHhyUG9zLCBpeCwgaXhQb3MpIHtcbiAgICAgICAgYXNzZXJ0JDE4KGwgPiAwKTtcblxuICAgICAgICBsID0gbCA+PiAxO1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gbCAlIDI7XG4gICAgICAgIGwgPSBsID4+IDE7XG4gICAgICAgIHdoaWxlIChsLS0gIT0gMCkge1xuICAgICAgICAgICAgdmFyIHgwLCB4MSwgeDIsIHgzO1xuICAgICAgICAgICAgdmFyIHJ4MCwgcngxLCByeDIsIHJ4MztcblxuICAgICAgICAgICAgeDAgPSB4clt4clBvcysrXSAqIGlzdGVwO1xuICAgICAgICAgICAgeDEgPSB4clt4clBvcysrXSAqIGlzdGVwO1xuICAgICAgICAgICAgcngwID0gMCB8IHgwO1xuICAgICAgICAgICAgeDIgPSB4clt4clBvcysrXSAqIGlzdGVwO1xuICAgICAgICAgICAgcngxID0gMCB8IHgxO1xuICAgICAgICAgICAgeDMgPSB4clt4clBvcysrXSAqIGlzdGVwO1xuICAgICAgICAgICAgcngyID0gMCB8IHgyO1xuICAgICAgICAgICAgeDAgKz0gcXVwdnQuYWRqNDNbcngwXTtcbiAgICAgICAgICAgIHJ4MyA9IDAgfCB4MztcbiAgICAgICAgICAgIHgxICs9IHF1cHZ0LmFkajQzW3J4MV07XG4gICAgICAgICAgICBpeFtpeFBvcysrXSA9IDAgfCB4MDtcbiAgICAgICAgICAgIHgyICs9IHF1cHZ0LmFkajQzW3J4Ml07XG4gICAgICAgICAgICBpeFtpeFBvcysrXSA9IDAgfCB4MTtcbiAgICAgICAgICAgIHgzICs9IHF1cHZ0LmFkajQzW3J4M107XG4gICAgICAgICAgICBpeFtpeFBvcysrXSA9IDAgfCB4MjtcbiAgICAgICAgICAgIGl4W2l4UG9zKytdID0gMCB8IHgzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1haW5pbmcgIT0gMCkge1xuICAgICAgICAgICAgdmFyIHgwLCB4MTtcbiAgICAgICAgICAgIHZhciByeDAsIHJ4MTtcblxuICAgICAgICAgICAgeDAgPSB4clt4clBvcysrXSAqIGlzdGVwO1xuICAgICAgICAgICAgeDEgPSB4clt4clBvcysrXSAqIGlzdGVwO1xuICAgICAgICAgICAgcngwID0gMCB8IHgwO1xuICAgICAgICAgICAgcngxID0gMCB8IHgxO1xuICAgICAgICAgICAgeDAgKz0gcXVwdnQuYWRqNDNbcngwXTtcbiAgICAgICAgICAgIHgxICs9IHF1cHZ0LmFkajQzW3J4MV07XG4gICAgICAgICAgICBpeFtpeFBvcysrXSA9IDAgfCB4MDtcbiAgICAgICAgICAgIGl4W2l4UG9zKytdID0gMCB8IHgxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVhbnRpemF0aW9uIGZ1bmN0aW9uIFRoaXMgZnVuY3Rpb24gd2lsbCBzZWxlY3Qgd2hpY2ggbGluZXMgdG8gcXVhbnRpemVcbiAgICAgKiBhbmQgY2FsbCB0aGUgcHJvcGVyIHF1YW50aXphdGlvbiBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YW50aXplX3hycG93KHhwLCBwaSwgaXN0ZXAsIGNvZEluZm8sIHByZXZOb2lzZSkge1xuICAgICAgICAvKiBxdWFudGl6ZSBvbiB4cl4oMy80KSBpbnN0ZWFkIG9mIHhyICovXG4gICAgICAgIHZhciBzZmI7XG4gICAgICAgIHZhciBzZmJtYXg7XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgdmFyIHByZXZfZGF0YV91c2U7XG4gICAgICAgIHZhciBhY2N1bXVsYXRlID0gMDtcbiAgICAgICAgdmFyIGFjY3VtdWxhdGUwMSA9IDA7XG4gICAgICAgIHZhciB4cFBvcyA9IDA7XG4gICAgICAgIHZhciBpRGF0YSA9IHBpO1xuICAgICAgICB2YXIgaURhdGFQb3MgPSAwO1xuICAgICAgICB2YXIgYWNjX2lEYXRhID0gaURhdGE7XG4gICAgICAgIHZhciBhY2NfaURhdGFQb3MgPSAwO1xuICAgICAgICB2YXIgYWNjX3hwID0geHA7XG4gICAgICAgIHZhciBhY2NfeHBQb3MgPSAwO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJldXNpbmcgcHJldmlvdXNseSBjb21wdXRlZCBkYXRhIGRvZXMgbm90IHNlZW1zIHRvIHdvcmsgaWYgZ2xvYmFsXG4gICAgICAgICAqIGdhaW4gaXMgY2hhbmdlZC4gRmluZGluZyB3aHkgaXQgYmVoYXZlcyB0aGlzIHdheSB3b3VsZCBhbGxvdyB0byB1c2UgYVxuICAgICAgICAgKiBjYWNoZSBvZiBwcmV2aW91c2x5IGNvbXB1dGVkIHZhbHVlcyAobGV0J3MgMTAgY2FjaGVkIHZhbHVlcyBwZXIgc2ZiKVxuICAgICAgICAgKiB0aGF0IHdvdWxkIHByb2JhYmx5IHByb3ZpZGUgYSBub3RpY2VhYmxlIHNwZWVkdXBcbiAgICAgICAgICovXG4gICAgICAgIHByZXZfZGF0YV91c2UgPSAocHJldk5vaXNlICE9IG51bGwgJiYgKGNvZEluZm8uZ2xvYmFsX2dhaW4gPT0gcHJldk5vaXNlLmdsb2JhbF9nYWluKSk7XG5cbiAgICAgICAgaWYgKGNvZEluZm8uYmxvY2tfdHlwZSA9PSBFbmNvZGVyXzEuU0hPUlRfVFlQRSlcbiAgICAgICAgICAgIHNmYm1heCA9IDM4O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZmJtYXggPSAyMTtcblxuICAgICAgICBmb3IgKHNmYiA9IDA7IHNmYiA8PSBzZmJtYXg7IHNmYisrKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IC0xO1xuXG4gICAgICAgICAgICBpZiAocHJldl9kYXRhX3VzZSB8fCBjb2RJbmZvLmJsb2NrX3R5cGUgPT0gRW5jb2Rlcl8xLk5PUk1fVFlQRSkge1xuICAgICAgICAgICAgICAgIHN0ZXAgPSBjb2RJbmZvLmdsb2JhbF9nYWluXG4gICAgICAgICAgICAgICAgICAgIC0gKChjb2RJbmZvLnNjYWxlZmFjW3NmYl0gKyAoY29kSW5mby5wcmVmbGFnICE9IDAgPyBxdXB2dC5wcmV0YWJbc2ZiXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwKSkgPDwgKGNvZEluZm8uc2NhbGVmYWNfc2NhbGUgKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgLSBjb2RJbmZvLnN1YmJsb2NrX2dhaW5bY29kSW5mby53aW5kb3dbc2ZiXV0gKiA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0JDE4KGNvZEluZm8ud2lkdGhbc2ZiXSA+PSAwKTtcbiAgICAgICAgICAgIGlmIChwcmV2X2RhdGFfdXNlICYmIChwcmV2Tm9pc2Uuc3RlcFtzZmJdID09IHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBkbyBub3QgcmVjb21wdXRlIHRoaXMgcGFydCwgYnV0IGNvbXB1dGUgYWNjdW11bGF0ZWQgbGluZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoYWNjdW11bGF0ZSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1YW50aXplX2xpbmVzX3hycG93KGFjY3VtdWxhdGUsIGlzdGVwLCBhY2NfeHAsIGFjY194cFBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY19pRGF0YSwgYWNjX2lEYXRhUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhY2N1bXVsYXRlMDEgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBxdWFudGl6ZV9saW5lc194cnBvd18wMShhY2N1bXVsYXRlMDEsIGlzdGVwLCBhY2NfeHAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NfeHBQb3MsIGFjY19pRGF0YSwgYWNjX2lEYXRhUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZTAxID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvKiBzaG91bGQgY29tcHV0ZSB0aGlzIHBhcnQgKi9cbiAgICAgICAgICAgICAgICB2YXIgbCA9IGNvZEluZm8ud2lkdGhbc2ZiXTtcblxuICAgICAgICAgICAgICAgIGlmICgoaiArIGNvZEluZm8ud2lkdGhbc2ZiXSkgPiBjb2RJbmZvLm1heF9ub256ZXJvX2NvZWZmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGRvIG5vdCBjb21wdXRlIHVwcGVyIHplcm8gcGFydCAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXNlZnVsbHNpemU7XG4gICAgICAgICAgICAgICAgICAgIHVzZWZ1bGxzaXplID0gY29kSW5mby5tYXhfbm9uemVyb19jb2VmZiAtIGogKyAxO1xuICAgICAgICAgICAgICAgICAgICBBcnJheXMkMTguZmlsbChwaSwgY29kSW5mby5tYXhfbm9uemVyb19jb2VmZiwgNTc2LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgbCA9IHVzZWZ1bGxzaXplO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKiBubyBuZWVkIHRvIGNvbXB1dGUgaGlnaGVyIHNmYiB2YWx1ZXMgKi9cbiAgICAgICAgICAgICAgICAgICAgc2ZiID0gc2ZibWF4ICsgMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBhY2N1bXVsYXRlIGxpbmVzIHRvIHF1YW50aXplICovXG4gICAgICAgICAgICAgICAgaWYgKDAgPT0gYWNjdW11bGF0ZSAmJiAwID09IGFjY3VtdWxhdGUwMSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NfaURhdGEgPSBpRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgYWNjX2lEYXRhUG9zID0gaURhdGFQb3M7XG4gICAgICAgICAgICAgICAgICAgIGFjY194cCA9IHhwO1xuICAgICAgICAgICAgICAgICAgICBhY2NfeHBQb3MgPSB4cFBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZOb2lzZSAhPSBudWxsICYmIHByZXZOb2lzZS5zZmJfY291bnQxID4gMFxuICAgICAgICAgICAgICAgICAgICAmJiBzZmIgPj0gcHJldk5vaXNlLnNmYl9jb3VudDFcbiAgICAgICAgICAgICAgICAgICAgJiYgcHJldk5vaXNlLnN0ZXBbc2ZiXSA+IDBcbiAgICAgICAgICAgICAgICAgICAgJiYgc3RlcCA+PSBwcmV2Tm9pc2Uuc3RlcFtzZmJdKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY3VtdWxhdGUgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpemVfbGluZXNfeHJwb3coYWNjdW11bGF0ZSwgaXN0ZXAsIGFjY194cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NfeHBQb3MsIGFjY19pRGF0YSwgYWNjX2lEYXRhUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjX2lEYXRhID0gaURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NfaURhdGFQb3MgPSBpRGF0YVBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY194cCA9IHhwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjX3hwUG9zID0geHBQb3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZTAxICs9IGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY3VtdWxhdGUwMSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl6ZV9saW5lc194cnBvd18wMShhY2N1bXVsYXRlMDEsIGlzdGVwLCBhY2NfeHAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjX3hwUG9zLCBhY2NfaURhdGEsIGFjY19pRGF0YVBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlMDEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjX2lEYXRhID0gaURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NfaURhdGFQb3MgPSBpRGF0YVBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY194cCA9IHhwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjX3hwUG9zID0geHBQb3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZSArPSBsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogcmg6IDIwMDQwMjE1IG1heSBoYXBwZW4gZHVlIHRvIFwicHJldl9kYXRhX3VzZVwiXG4gICAgICAgICAgICAgICAgICAgICAqIG9wdGltaXphdGlvblxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY3VtdWxhdGUwMSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl6ZV9saW5lc194cnBvd18wMShhY2N1bXVsYXRlMDEsIGlzdGVwLCBhY2NfeHAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjX3hwUG9zLCBhY2NfaURhdGEsIGFjY19pRGF0YVBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlMDEgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2N1bXVsYXRlICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXplX2xpbmVzX3hycG93KGFjY3VtdWxhdGUsIGlzdGVwLCBhY2NfeHAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjX3hwUG9zLCBhY2NfaURhdGEsIGFjY19pRGF0YVBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvKiBlbmRzIGZvci1sb29wICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNmYiA8PSBzZmJtYXgpIHtcbiAgICAgICAgICAgICAgICBpRGF0YVBvcyArPSBjb2RJbmZvLndpZHRoW3NmYl07XG4gICAgICAgICAgICAgICAgeHBQb3MgKz0gY29kSW5mby53aWR0aFtzZmJdO1xuICAgICAgICAgICAgICAgIGogKz0gY29kSW5mby53aWR0aFtzZmJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY2N1bXVsYXRlICE9IDApIHsgLyogbGFzdCBkYXRhIHBhcnQgKi9cbiAgICAgICAgICAgIHF1YW50aXplX2xpbmVzX3hycG93KGFjY3VtdWxhdGUsIGlzdGVwLCBhY2NfeHAsIGFjY194cFBvcyxcbiAgICAgICAgICAgICAgICBhY2NfaURhdGEsIGFjY19pRGF0YVBvcyk7XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWNjdW11bGF0ZTAxICE9IDApIHsgLyogbGFzdCBkYXRhIHBhcnQgKi9cbiAgICAgICAgICAgIHF1YW50aXplX2xpbmVzX3hycG93XzAxKGFjY3VtdWxhdGUwMSwgaXN0ZXAsIGFjY194cCwgYWNjX3hwUG9zLFxuICAgICAgICAgICAgICAgIGFjY19pRGF0YSwgYWNjX2lEYXRhUG9zKTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUwMSA9IDA7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGl4X21heFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl4X21heChpeCwgaXhQb3MsIGVuZFBvcykge1xuICAgICAgICB2YXIgbWF4MSA9IDAsIG1heDIgPSAwO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciB4MSA9IGl4W2l4UG9zKytdO1xuICAgICAgICAgICAgdmFyIHgyID0gaXhbaXhQb3MrK107XG4gICAgICAgICAgICBpZiAobWF4MSA8IHgxKVxuICAgICAgICAgICAgICAgIG1heDEgPSB4MTtcblxuICAgICAgICAgICAgaWYgKG1heDIgPCB4MilcbiAgICAgICAgICAgICAgICBtYXgyID0geDI7XG4gICAgICAgIH0gd2hpbGUgKGl4UG9zIDwgZW5kUG9zKTtcbiAgICAgICAgaWYgKG1heDEgPCBtYXgyKVxuICAgICAgICAgICAgbWF4MSA9IG1heDI7XG4gICAgICAgIHJldHVybiBtYXgxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvdW50X2JpdF9FU0MoaXgsIGl4UG9zLCBlbmQsIHQxLCB0Miwgcykge1xuICAgICAgICAvKiBFU0MtdGFibGUgaXMgdXNlZCAqL1xuICAgICAgICB2YXIgbGluYml0cyA9IFRhYmxlc18xLmh0W3QxXS54bGVuICogNjU1MzYgKyBUYWJsZXNfMS5odFt0Ml0ueGxlbjtcbiAgICAgICAgdmFyIHN1bSA9IDAsIHN1bTI7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIHggPSBpeFtpeFBvcysrXTtcbiAgICAgICAgICAgIHZhciB5ID0gaXhbaXhQb3MrK107XG5cbiAgICAgICAgICAgIGlmICh4ICE9IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoeCA+IDE0KSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSAxNTtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGxpbmJpdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHggKj0gMTY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh5ICE9IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA+IDE0KSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAxNTtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGxpbmJpdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHggKz0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3VtICs9IFRhYmxlc18xLmxhcmdldGJsW3hdO1xuICAgICAgICB9IHdoaWxlIChpeFBvcyA8IGVuZCk7XG5cbiAgICAgICAgc3VtMiA9IHN1bSAmIDB4ZmZmZjtcbiAgICAgICAgc3VtID4+PSAxNjtcblxuICAgICAgICBpZiAoc3VtID4gc3VtMikge1xuICAgICAgICAgICAgc3VtID0gc3VtMjtcbiAgICAgICAgICAgIHQxID0gdDI7XG4gICAgICAgIH1cblxuICAgICAgICBzLmJpdHMgKz0gc3VtO1xuICAgICAgICByZXR1cm4gdDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY291bnRfYml0X25vRVNDKGl4LCBpeFBvcywgZW5kLCBzKSB7XG4gICAgICAgIC8qIE5vIEVTQy13b3JkcyAqL1xuICAgICAgICB2YXIgc3VtMSA9IDA7XG4gICAgICAgIHZhciBobGVuMSA9IFRhYmxlc18xLmh0WzFdLmhsZW47XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIHggPSBpeFtpeFBvcyArIDBdICogMiArIGl4W2l4UG9zICsgMV07XG4gICAgICAgICAgICBpeFBvcyArPSAyO1xuICAgICAgICAgICAgc3VtMSArPSBobGVuMVt4XTtcbiAgICAgICAgfSB3aGlsZSAoaXhQb3MgPCBlbmQpO1xuXG4gICAgICAgIHMuYml0cyArPSBzdW0xO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3VudF9iaXRfbm9FU0NfZnJvbTIoaXgsIGl4UG9zLCBlbmQsIHQxLCBzKSB7XG4gICAgICAgIC8qIE5vIEVTQy13b3JkcyAqL1xuICAgICAgICB2YXIgc3VtID0gMCwgc3VtMjtcbiAgICAgICAgdmFyIHhsZW4gPSBUYWJsZXNfMS5odFt0MV0ueGxlbjtcbiAgICAgICAgdmFyIGhsZW47XG4gICAgICAgIGlmICh0MSA9PSAyKVxuICAgICAgICAgICAgaGxlbiA9IFRhYmxlc18xLnRhYmxlMjM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGhsZW4gPSBUYWJsZXNfMS50YWJsZTU2O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciB4ID0gaXhbaXhQb3MgKyAwXSAqIHhsZW4gKyBpeFtpeFBvcyArIDFdO1xuICAgICAgICAgICAgaXhQb3MgKz0gMjtcbiAgICAgICAgICAgIHN1bSArPSBobGVuW3hdO1xuICAgICAgICB9IHdoaWxlIChpeFBvcyA8IGVuZCk7XG5cbiAgICAgICAgc3VtMiA9IHN1bSAmIDB4ZmZmZjtcbiAgICAgICAgc3VtID4+PSAxNjtcblxuICAgICAgICBpZiAoc3VtID4gc3VtMikge1xuICAgICAgICAgICAgc3VtID0gc3VtMjtcbiAgICAgICAgICAgIHQxKys7XG4gICAgICAgIH1cblxuICAgICAgICBzLmJpdHMgKz0gc3VtO1xuICAgICAgICByZXR1cm4gdDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY291bnRfYml0X25vRVNDX2Zyb20zKGl4LCBpeFBvcywgZW5kLCB0MSwgcykge1xuICAgICAgICAvKiBObyBFU0Mtd29yZHMgKi9cbiAgICAgICAgdmFyIHN1bTEgPSAwO1xuICAgICAgICB2YXIgc3VtMiA9IDA7XG4gICAgICAgIHZhciBzdW0zID0gMDtcbiAgICAgICAgdmFyIHhsZW4gPSBUYWJsZXNfMS5odFt0MV0ueGxlbjtcbiAgICAgICAgdmFyIGhsZW4xID0gVGFibGVzXzEuaHRbdDFdLmhsZW47XG4gICAgICAgIHZhciBobGVuMiA9IFRhYmxlc18xLmh0W3QxICsgMV0uaGxlbjtcbiAgICAgICAgdmFyIGhsZW4zID0gVGFibGVzXzEuaHRbdDEgKyAyXS5obGVuO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciB4ID0gaXhbaXhQb3MgKyAwXSAqIHhsZW4gKyBpeFtpeFBvcyArIDFdO1xuICAgICAgICAgICAgaXhQb3MgKz0gMjtcbiAgICAgICAgICAgIHN1bTEgKz0gaGxlbjFbeF07XG4gICAgICAgICAgICBzdW0yICs9IGhsZW4yW3hdO1xuICAgICAgICAgICAgc3VtMyArPSBobGVuM1t4XTtcbiAgICAgICAgfSB3aGlsZSAoaXhQb3MgPCBlbmQpO1xuICAgICAgICB2YXIgdCA9IHQxO1xuICAgICAgICBpZiAoc3VtMSA+IHN1bTIpIHtcbiAgICAgICAgICAgIHN1bTEgPSBzdW0yO1xuICAgICAgICAgICAgdCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdW0xID4gc3VtMykge1xuICAgICAgICAgICAgc3VtMSA9IHN1bTM7XG4gICAgICAgICAgICB0ID0gdDEgKyAyO1xuICAgICAgICB9XG4gICAgICAgIHMuYml0cyArPSBzdW0xO1xuXG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qIGNob29zZSB0YWJsZSAqL1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIGh1Zl90Ymxfbm9FU0MgPSBbMSwgMiwgNSwgNywgNywgMTAsIDEwLCAxMywgMTMsXG4gICAgICAgIDEzLCAxMywgMTMsIDEzLCAxMywgMTNdO1xuXG4gICAgLyoqXG4gICAgICogQ2hvb3NlIHRoZSBIdWZmbWFuIHRhYmxlIHRoYXQgd2lsbCBlbmNvZGUgaXhbYmVnaW4uLmVuZF0gd2l0aCB0aGUgZmV3ZXN0XG4gICAgICogYml0cy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgY29kZSBjb250YWlucyBrbm93bGVkZ2UgYWJvdXQgdGhlIHNpemVzIGFuZCBjaGFyYWN0ZXJpc3RpY3Mgb2ZcbiAgICAgKiB0aGUgSHVmZm1hbiB0YWJsZXMgYXMgZGVmaW5lZCBpbiB0aGUgSVMgKFRhYmxlIEIuNyksIGFuZCB3aWxsIG5vdCB3b3JrXG4gICAgICogd2l0aCBhbnkgYXJiaXRyYXJ5IHRhYmxlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaG9vc2VfdGFibGUoaXgsIGl4UG9zLCBlbmRQb3MsIHMpIHtcbiAgICAgICAgdmFyIG1heCA9IGl4X21heChpeCwgaXhQb3MsIGVuZFBvcyk7XG5cbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4O1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50X2JpdF9ub0VTQyhpeCwgaXhQb3MsIGVuZFBvcywgcyk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnRfYml0X25vRVNDX2Zyb20yKGl4LCBpeFBvcywgZW5kUG9zLFxuICAgICAgICAgICAgICAgICAgICBodWZfdGJsX25vRVNDW21heCAtIDFdLCBzKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIHJldHVybiBjb3VudF9iaXRfbm9FU0NfZnJvbTMoaXgsIGl4UG9zLCBlbmRQb3MsXG4gICAgICAgICAgICAgICAgICAgIGh1Zl90Ymxfbm9FU0NbbWF4IC0gMV0sIHMpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8qIHRyeSB0YWJsZXMgd2l0aCBsaW5iaXRzICovXG4gICAgICAgICAgICAgICAgaWYgKG1heCA+IFF1YW50aXplUFZUXzEuSVhNQVhfVkFMKSB7XG4gICAgICAgICAgICAgICAgICAgIHMuYml0cyA9IFF1YW50aXplUFZUXzEuTEFSR0VfQklUUztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXggLT0gMTU7XG4gICAgICAgICAgICAgICAgdmFyIGNob2ljZTI7XG4gICAgICAgICAgICAgICAgZm9yIChjaG9pY2UyID0gMjQ7IGNob2ljZTIgPCAzMjsgY2hvaWNlMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChUYWJsZXNfMS5odFtjaG9pY2UyXS5saW5tYXggPj0gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hvaWNlO1xuICAgICAgICAgICAgICAgIGZvciAoY2hvaWNlID0gY2hvaWNlMiAtIDg7IGNob2ljZSA8IDI0OyBjaG9pY2UrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVGFibGVzXzEuaHRbY2hvaWNlXS5saW5tYXggPj0gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnRfYml0X0VTQyhpeCwgaXhQb3MsIGVuZFBvcywgY2hvaWNlLCBjaG9pY2UyLCBzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvdW50X2JpdFxuICAgICAqL1xuICAgIHRoaXMubm9xdWFudF9jb3VudF9iaXRzID0gZnVuY3Rpb24gKGdmYywgZ2ksIHByZXZfbm9pc2UpIHtcbiAgICAgICAgdmFyIGl4ID0gZ2kubDNfZW5jO1xuICAgICAgICB2YXIgaSA9IE1hdGgubWluKDU3NiwgKChnaS5tYXhfbm9uemVyb19jb2VmZiArIDIpID4+IDEpIDw8IDEpO1xuXG4gICAgICAgIGlmIChwcmV2X25vaXNlICE9IG51bGwpXG4gICAgICAgICAgICBwcmV2X25vaXNlLnNmYl9jb3VudDEgPSAwO1xuXG4gICAgICAgIC8qIERldGVybWluZSBjb3VudDEgcmVnaW9uICovXG4gICAgICAgIGZvciAoOyBpID4gMTsgaSAtPSAyKVxuICAgICAgICAgICAgaWYgKChpeFtpIC0gMV0gfCBpeFtpIC0gMl0pICE9IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGdpLmNvdW50MSA9IGk7XG5cbiAgICAgICAgLyogRGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIGJpdHMgdG8gZW5jb2RlIHRoZSBxdWFkcnVwbGVzLiAqL1xuICAgICAgICB2YXIgYTEgPSAwO1xuICAgICAgICB2YXIgYTIgPSAwO1xuICAgICAgICBmb3IgKDsgaSA+IDM7IGkgLT0gNCkge1xuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICAvKiBoYWNrIHRvIGNoZWNrIGlmIGFsbCB2YWx1ZXMgPD0gMSAqL1xuICAgICAgICAgICAgLy90aHJvdyBcIlRPRE86IEhBQ0sgICAgICAgICBpZiAoKCgobG9uZykgaXhbaSAtIDFdIHwgKGxvbmcpIGl4W2kgLSAyXSB8IChsb25nKSBpeFtpIC0gM10gfCAobG9uZykgaXhbaSAtIDRdKSAmIDB4ZmZmZmZmZmZMKSA+IDFMICAgICAgICBcIlxuICAgICAgICAgICAgLy9pZiAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCgoaXhbaSAtIDFdIHwgaXhbaSAtIDJdIHwgaXhbaSAtIDNdIHwgaXhbaSAtIDRdKSAmIDB4N2ZmZmZmZmYpID4gMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9ICgoaXhbaSAtIDRdICogMiArIGl4W2kgLSAzXSkgKiAyICsgaXhbaSAtIDJdKSAqIDIgKyBpeFtpIC0gMV07XG4gICAgICAgICAgICBhMSArPSBUYWJsZXNfMS50MzJsW3BdO1xuICAgICAgICAgICAgYTIgKz0gVGFibGVzXzEudDMzbFtwXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYml0cyA9IGExO1xuICAgICAgICBnaS5jb3VudDF0YWJsZV9zZWxlY3QgPSAwO1xuICAgICAgICBpZiAoYTEgPiBhMikge1xuICAgICAgICAgICAgYml0cyA9IGEyO1xuICAgICAgICAgICAgZ2kuY291bnQxdGFibGVfc2VsZWN0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdpLmNvdW50MWJpdHMgPSBiaXRzO1xuICAgICAgICBnaS5iaWdfdmFsdWVzID0gaTtcbiAgICAgICAgaWYgKGkgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuXG4gICAgICAgIGlmIChnaS5ibG9ja190eXBlID09IEVuY29kZXJfMS5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICBhMSA9IDMgKiBnZmMuc2NhbGVmYWNfYmFuZC5zWzNdO1xuICAgICAgICAgICAgaWYgKGExID4gZ2kuYmlnX3ZhbHVlcylcbiAgICAgICAgICAgICAgICBhMSA9IGdpLmJpZ192YWx1ZXM7XG4gICAgICAgICAgICBhMiA9IGdpLmJpZ192YWx1ZXM7XG5cbiAgICAgICAgfSBlbHNlIGlmIChnaS5ibG9ja190eXBlID09IEVuY29kZXJfMS5OT1JNX1RZUEUpIHtcbiAgICAgICAgICAgIGFzc2VydCQxOChpIDw9IDU3Nik7XG4gICAgICAgICAgICAvKiBidl9zY2YgaGFzIDU3NiBlbnRyaWVzICgwLi41NzUpICovXG4gICAgICAgICAgICBhMSA9IGdpLnJlZ2lvbjBfY291bnQgPSBnZmMuYnZfc2NmW2kgLSAyXTtcbiAgICAgICAgICAgIGEyID0gZ2kucmVnaW9uMV9jb3VudCA9IGdmYy5idl9zY2ZbaSAtIDFdO1xuXG4gICAgICAgICAgICBhc3NlcnQkMTgoYTEgKyBhMiArIDIgPCBFbmNvZGVyXzEuU0JQU1lfbCk7XG4gICAgICAgICAgICBhMiA9IGdmYy5zY2FsZWZhY19iYW5kLmxbYTEgKyBhMiArIDJdO1xuICAgICAgICAgICAgYTEgPSBnZmMuc2NhbGVmYWNfYmFuZC5sW2ExICsgMV07XG4gICAgICAgICAgICBpZiAoYTIgPCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpID0gbmV3IEJpdHMoYml0cyk7XG4gICAgICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzJdID0gY2hvb3NlX3RhYmxlKGl4LCBhMiwgaSwgYmkpO1xuICAgICAgICAgICAgICAgIGJpdHMgPSBiaS5iaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2kucmVnaW9uMF9jb3VudCA9IDc7XG4gICAgICAgICAgICAvKiBnaS5yZWdpb24xX2NvdW50ID0gU0JQU1lfbCAtIDcgLSAxOyAqL1xuICAgICAgICAgICAgZ2kucmVnaW9uMV9jb3VudCA9IEVuY29kZXJfMS5TQk1BWF9sIC0gMSAtIDcgLSAxO1xuICAgICAgICAgICAgYTEgPSBnZmMuc2NhbGVmYWNfYmFuZC5sWzcgKyAxXTtcbiAgICAgICAgICAgIGEyID0gaTtcbiAgICAgICAgICAgIGlmIChhMSA+IGEyKSB7XG4gICAgICAgICAgICAgICAgYTEgPSBhMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhdmUgdG8gYWxsb3cgZm9yIHRoZSBjYXNlIHdoZW4gYmlndmFsdWVzIDwgcmVnaW9uMCA8IHJlZ2lvbjEgKi9cbiAgICAgICAgLyogKGFuZCByZWdpb24wLCByZWdpb24xIGFyZSBpZ25vcmVkKSAqL1xuICAgICAgICBhMSA9IE1hdGgubWluKGExLCBpKTtcbiAgICAgICAgYTIgPSBNYXRoLm1pbihhMiwgaSk7XG5cbiAgICAgICAgYXNzZXJ0JDE4KGExID49IDApO1xuICAgICAgICBhc3NlcnQkMTgoYTIgPj0gMCk7XG5cbiAgICAgICAgLyogQ291bnQgdGhlIG51bWJlciBvZiBiaXRzIG5lY2Vzc2FyeSB0byBjb2RlIHRoZSBiaWd2YWx1ZXMgcmVnaW9uLiAqL1xuICAgICAgICBpZiAoMCA8IGExKSB7XG4gICAgICAgICAgICB2YXIgYmkgPSBuZXcgQml0cyhiaXRzKTtcbiAgICAgICAgICAgIGdpLnRhYmxlX3NlbGVjdFswXSA9IGNob29zZV90YWJsZShpeCwgMCwgYTEsIGJpKTtcbiAgICAgICAgICAgIGJpdHMgPSBiaS5iaXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhMSA8IGEyKSB7XG4gICAgICAgICAgICB2YXIgYmkgPSBuZXcgQml0cyhiaXRzKTtcbiAgICAgICAgICAgIGdpLnRhYmxlX3NlbGVjdFsxXSA9IGNob29zZV90YWJsZShpeCwgYTEsIGEyLCBiaSk7XG4gICAgICAgICAgICBiaXRzID0gYmkuYml0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2ZjLnVzZV9iZXN0X2h1ZmZtYW4gPT0gMikge1xuICAgICAgICAgICAgZ2kucGFydDJfM19sZW5ndGggPSBiaXRzO1xuICAgICAgICAgICAgYmVzdF9odWZmbWFuX2RpdmlkZShnZmMsIGdpKTtcbiAgICAgICAgICAgIGJpdHMgPSBnaS5wYXJ0Ml8zX2xlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2X25vaXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChnaS5ibG9ja190eXBlID09IEVuY29kZXJfMS5OT1JNX1RZUEUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2ZiID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZ2ZjLnNjYWxlZmFjX2JhbmQubFtzZmJdIDwgZ2kuYmlnX3ZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBzZmIrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldl9ub2lzZS5zZmJfY291bnQxID0gc2ZiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfTtcblxuICAgIHRoaXMuY291bnRfYml0cyA9IGZ1bmN0aW9uIChnZmMsIHhyLCBnaSwgcHJldl9ub2lzZSkge1xuICAgICAgICB2YXIgaXggPSBnaS5sM19lbmM7XG5cbiAgICAgICAgLyogc2luY2UgcXVhbnRpemVfeHJwb3cgdXNlcyB0YWJsZSBsb29rdXAsIHdlIG5lZWQgdG8gY2hlY2sgdGhpcyBmaXJzdDogKi9cbiAgICAgICAgdmFyIHcgPSAoUXVhbnRpemVQVlRfMS5JWE1BWF9WQUwpIC8gcXVwdnQuSVBPVzIwKGdpLmdsb2JhbF9nYWluKTtcblxuICAgICAgICBpZiAoZ2kueHJwb3dfbWF4ID4gdylcbiAgICAgICAgICAgIHJldHVybiBRdWFudGl6ZVBWVF8xLkxBUkdFX0JJVFM7XG5cbiAgICAgICAgcXVhbnRpemVfeHJwb3coeHIsIGl4LCBxdXB2dC5JUE9XMjAoZ2kuZ2xvYmFsX2dhaW4pLCBnaSwgcHJldl9ub2lzZSk7XG5cbiAgICAgICAgaWYgKChnZmMuc3Vic3RlcF9zaGFwaW5nICYgMikgIT0gMCkge1xuICAgICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgICAgLyogMC42MzQ1MjE2ODIyNDI0MzkgPSAwLjU5NDYqMioqKC41KjAuMTg3NSkgKi9cbiAgICAgICAgICAgIHZhciBnYWluID0gZ2kuZ2xvYmFsX2dhaW4gKyBnaS5zY2FsZWZhY19zY2FsZTtcbiAgICAgICAgICAgIHZhciByb3VuZGZhYyA9IDAuNjM0NTIxNjgyMjQyNDM5IC8gcXVwdnQuSVBPVzIwKGdhaW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgZ2kuc2ZibWF4OyBzZmIrKykge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGdpLndpZHRoW3NmYl07XG4gICAgICAgICAgICAgICAgYXNzZXJ0JDE4KHdpZHRoID49IDApO1xuICAgICAgICAgICAgICAgIGlmICgwID09IGdmYy5wc2V1ZG9oYWxmW3NmYl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaiArPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gaiwgaiArPSB3aWR0aDsgayA8IGo7ICsraykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXhba10gPSAoeHJba10gPj0gcm91bmRmYWMpID8gaXhba10gOiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vcXVhbnRfY291bnRfYml0cyhnZmMsIGdpLCBwcmV2X25vaXNlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmUtY2FsY3VsYXRlIHRoZSBiZXN0IHNjYWxlZmFjX2NvbXByZXNzIHVzaW5nIHNjZnNpIHRoZSBzYXZlZCBiaXRzIGFyZVxuICAgICAqIGtlcHQgaW4gdGhlIGJpdCByZXNlcnZvaXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjYWxjX2RpdmlkZV9pbml0KGdmYywgY29kX2luZm8sIGl4LCByMDFfYml0cywgcjAxX2RpdiwgcjBfdGJsLCByMV90YmwpIHtcbiAgICAgICAgdmFyIGJpZ3YgPSBjb2RfaW5mby5iaWdfdmFsdWVzO1xuXG4gICAgICAgIGZvciAodmFyIHIwID0gMDsgcjAgPD0gNyArIDE1OyByMCsrKSB7XG4gICAgICAgICAgICByMDFfYml0c1tyMF0gPSBRdWFudGl6ZVBWVF8xLkxBUkdFX0JJVFM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciByMCA9IDA7IHIwIDwgMTY7IHIwKyspIHtcbiAgICAgICAgICAgIHZhciBhMSA9IGdmYy5zY2FsZWZhY19iYW5kLmxbcjAgKyAxXTtcbiAgICAgICAgICAgIGlmIChhMSA+PSBiaWd2KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFyIHIwYml0cyA9IDA7XG4gICAgICAgICAgICB2YXIgYmkgPSBuZXcgQml0cyhyMGJpdHMpO1xuICAgICAgICAgICAgdmFyIHIwdCA9IGNob29zZV90YWJsZShpeCwgMCwgYTEsIGJpKTtcbiAgICAgICAgICAgIHIwYml0cyA9IGJpLmJpdHM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHIxID0gMDsgcjEgPCA4OyByMSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEyID0gZ2ZjLnNjYWxlZmFjX2JhbmQubFtyMCArIHIxICsgMl07XG4gICAgICAgICAgICAgICAgaWYgKGEyID49IGJpZ3YpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHZhciBiaXRzID0gcjBiaXRzO1xuICAgICAgICAgICAgICAgIGJpID0gbmV3IEJpdHMoYml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIHIxdCA9IGNob29zZV90YWJsZShpeCwgYTEsIGEyLCBiaSk7XG4gICAgICAgICAgICAgICAgYml0cyA9IGJpLmJpdHM7XG4gICAgICAgICAgICAgICAgaWYgKHIwMV9iaXRzW3IwICsgcjFdID4gYml0cykge1xuICAgICAgICAgICAgICAgICAgICByMDFfYml0c1tyMCArIHIxXSA9IGJpdHM7XG4gICAgICAgICAgICAgICAgICAgIHIwMV9kaXZbcjAgKyByMV0gPSByMDtcbiAgICAgICAgICAgICAgICAgICAgcjBfdGJsW3IwICsgcjFdID0gcjB0O1xuICAgICAgICAgICAgICAgICAgICByMV90YmxbcjAgKyByMV0gPSByMXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVjYWxjX2RpdmlkZV9zdWIoZ2ZjLCBjb2RfaW5mbzIsIGdpLCBpeCwgcjAxX2JpdHMsIHIwMV9kaXYsIHIwX3RibCwgcjFfdGJsKSB7XG4gICAgICAgIHZhciBiaWd2ID0gY29kX2luZm8yLmJpZ192YWx1ZXM7XG5cbiAgICAgICAgZm9yICh2YXIgcjIgPSAyOyByMiA8IEVuY29kZXJfMS5TQk1BWF9sICsgMTsgcjIrKykge1xuICAgICAgICAgICAgdmFyIGEyID0gZ2ZjLnNjYWxlZmFjX2JhbmQubFtyMl07XG4gICAgICAgICAgICBpZiAoYTIgPj0gYmlndilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhciBiaXRzID0gcjAxX2JpdHNbcjIgLSAyXSArIGNvZF9pbmZvMi5jb3VudDFiaXRzO1xuICAgICAgICAgICAgaWYgKGdpLnBhcnQyXzNfbGVuZ3RoIDw9IGJpdHMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIHZhciBiaSA9IG5ldyBCaXRzKGJpdHMpO1xuICAgICAgICAgICAgdmFyIHIydCA9IGNob29zZV90YWJsZShpeCwgYTIsIGJpZ3YsIGJpKTtcbiAgICAgICAgICAgIGJpdHMgPSBiaS5iaXRzO1xuICAgICAgICAgICAgaWYgKGdpLnBhcnQyXzNfbGVuZ3RoIDw9IGJpdHMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGdpLmFzc2lnbihjb2RfaW5mbzIpO1xuICAgICAgICAgICAgZ2kucGFydDJfM19sZW5ndGggPSBiaXRzO1xuICAgICAgICAgICAgZ2kucmVnaW9uMF9jb3VudCA9IHIwMV9kaXZbcjIgLSAyXTtcbiAgICAgICAgICAgIGdpLnJlZ2lvbjFfY291bnQgPSByMiAtIDIgLSByMDFfZGl2W3IyIC0gMl07XG4gICAgICAgICAgICBnaS50YWJsZV9zZWxlY3RbMF0gPSByMF90YmxbcjIgLSAyXTtcbiAgICAgICAgICAgIGdpLnRhYmxlX3NlbGVjdFsxXSA9IHIxX3RibFtyMiAtIDJdO1xuICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzJdID0gcjJ0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5iZXN0X2h1ZmZtYW5fZGl2aWRlID0gZnVuY3Rpb24gKGdmYywgZ2kpIHtcbiAgICAgICAgdmFyIGNvZF9pbmZvMiA9IG5ldyBHckluZm9fMSgpO1xuICAgICAgICB2YXIgaXggPSBnaS5sM19lbmM7XG4gICAgICAgIHZhciByMDFfYml0cyA9IG5ld19pbnQkMTgoNyArIDE1ICsgMSk7XG4gICAgICAgIHZhciByMDFfZGl2ID0gbmV3X2ludCQxOCg3ICsgMTUgKyAxKTtcbiAgICAgICAgdmFyIHIwX3RibCA9IG5ld19pbnQkMTgoNyArIDE1ICsgMSk7XG4gICAgICAgIHZhciByMV90YmwgPSBuZXdfaW50JDE4KDcgKyAxNSArIDEpO1xuXG4gICAgICAgIC8qIFNIT1JUIEJMT0NLIHN0dWZmIGZhaWxzIGZvciBNUEVHMiAqL1xuICAgICAgICBpZiAoZ2kuYmxvY2tfdHlwZSA9PSBFbmNvZGVyXzEuU0hPUlRfVFlQRSAmJiBnZmMubW9kZV9nciA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNvZF9pbmZvMi5hc3NpZ24oZ2kpO1xuICAgICAgICBpZiAoZ2kuYmxvY2tfdHlwZSA9PSBFbmNvZGVyXzEuTk9STV9UWVBFKSB7XG4gICAgICAgICAgICByZWNhbGNfZGl2aWRlX2luaXQoZ2ZjLCBnaSwgaXgsIHIwMV9iaXRzLCByMDFfZGl2LCByMF90YmwsIHIxX3RibCk7XG4gICAgICAgICAgICByZWNhbGNfZGl2aWRlX3N1YihnZmMsIGNvZF9pbmZvMiwgZ2ksIGl4LCByMDFfYml0cywgcjAxX2RpdixcbiAgICAgICAgICAgICAgICByMF90YmwsIHIxX3RibCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSBjb2RfaW5mbzIuYmlnX3ZhbHVlcztcbiAgICAgICAgaWYgKGkgPT0gMCB8fCAoaXhbaSAtIDJdIHwgaXhbaSAtIDFdKSA+IDEpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaSA9IGdpLmNvdW50MSArIDI7XG4gICAgICAgIGlmIChpID4gNTc2KVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8qIERldGVybWluZXMgdGhlIG51bWJlciBvZiBiaXRzIHRvIGVuY29kZSB0aGUgcXVhZHJ1cGxlcy4gKi9cbiAgICAgICAgY29kX2luZm8yLmFzc2lnbihnaSk7XG4gICAgICAgIGNvZF9pbmZvMi5jb3VudDEgPSBpO1xuICAgICAgICB2YXIgYTEgPSAwO1xuICAgICAgICB2YXIgYTIgPSAwO1xuXG4gICAgICAgIGFzc2VydCQxOChpIDw9IDU3Nik7XG5cbiAgICAgICAgZm9yICg7IGkgPiBjb2RfaW5mbzIuYmlnX3ZhbHVlczsgaSAtPSA0KSB7XG4gICAgICAgICAgICB2YXIgcCA9ICgoaXhbaSAtIDRdICogMiArIGl4W2kgLSAzXSkgKiAyICsgaXhbaSAtIDJdKSAqIDJcbiAgICAgICAgICAgICAgICArIGl4W2kgLSAxXTtcbiAgICAgICAgICAgIGExICs9IFRhYmxlc18xLnQzMmxbcF07XG4gICAgICAgICAgICBhMiArPSBUYWJsZXNfMS50MzNsW3BdO1xuICAgICAgICB9XG4gICAgICAgIGNvZF9pbmZvMi5iaWdfdmFsdWVzID0gaTtcblxuICAgICAgICBjb2RfaW5mbzIuY291bnQxdGFibGVfc2VsZWN0ID0gMDtcbiAgICAgICAgaWYgKGExID4gYTIpIHtcbiAgICAgICAgICAgIGExID0gYTI7XG4gICAgICAgICAgICBjb2RfaW5mbzIuY291bnQxdGFibGVfc2VsZWN0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZF9pbmZvMi5jb3VudDFiaXRzID0gYTE7XG5cbiAgICAgICAgaWYgKGNvZF9pbmZvMi5ibG9ja190eXBlID09IEVuY29kZXJfMS5OT1JNX1RZUEUpXG4gICAgICAgICAgICByZWNhbGNfZGl2aWRlX3N1YihnZmMsIGNvZF9pbmZvMiwgZ2ksIGl4LCByMDFfYml0cywgcjAxX2RpdixcbiAgICAgICAgICAgICAgICByMF90YmwsIHIxX3RibCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogQ291bnQgdGhlIG51bWJlciBvZiBiaXRzIG5lY2Vzc2FyeSB0byBjb2RlIHRoZSBiaWd2YWx1ZXMgcmVnaW9uLiAqL1xuICAgICAgICAgICAgY29kX2luZm8yLnBhcnQyXzNfbGVuZ3RoID0gYTE7XG4gICAgICAgICAgICBhMSA9IGdmYy5zY2FsZWZhY19iYW5kLmxbNyArIDFdO1xuICAgICAgICAgICAgaWYgKGExID4gaSkge1xuICAgICAgICAgICAgICAgIGExID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhMSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgYmkgPSBuZXcgQml0cyhjb2RfaW5mbzIucGFydDJfM19sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvZF9pbmZvMi50YWJsZV9zZWxlY3RbMF0gPSBjaG9vc2VfdGFibGUoaXgsIDAsIGExLCBiaSk7XG4gICAgICAgICAgICAgICAgY29kX2luZm8yLnBhcnQyXzNfbGVuZ3RoID0gYmkuYml0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gYTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmkgPSBuZXcgQml0cyhjb2RfaW5mbzIucGFydDJfM19sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvZF9pbmZvMi50YWJsZV9zZWxlY3RbMV0gPSBjaG9vc2VfdGFibGUoaXgsIGExLCBpLCBiaSk7XG4gICAgICAgICAgICAgICAgY29kX2luZm8yLnBhcnQyXzNfbGVuZ3RoID0gYmkuYml0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnaS5wYXJ0Ml8zX2xlbmd0aCA+IGNvZF9pbmZvMi5wYXJ0Ml8zX2xlbmd0aClcbiAgICAgICAgICAgICAgICBnaS5hc3NpZ24oY29kX2luZm8yKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2xlbjFfbiA9IFsxLCAxLCAxLCAxLCA4LCAyLCAyLCAyLCA0LCA0LCA0LCA4LCA4LCA4LCAxNiwgMTZdO1xuICAgIHZhciBzbGVuMl9uID0gWzEsIDIsIDQsIDgsIDEsIDIsIDQsIDgsIDIsIDQsIDgsIDIsIDQsIDgsIDQsIDhdO1xuICAgIHZhciBzbGVuMV90YWIgPSBbMCwgMCwgMCwgMCwgMywgMSwgMSwgMSwgMiwgMiwgMiwgMywgMywgMywgNCwgNF07XG4gICAgdmFyIHNsZW4yX3RhYiA9IFswLCAxLCAyLCAzLCAwLCAxLCAyLCAzLCAxLCAyLCAzLCAxLCAyLCAzLCAyLCAzXTtcbiAgICBUYWtlaGlybyQxLnNsZW4xX3RhYiA9IHNsZW4xX3RhYjtcbiAgICBUYWtlaGlybyQxLnNsZW4yX3RhYiA9IHNsZW4yX3RhYjtcblxuICAgIGZ1bmN0aW9uIHNjZnNpX2NhbGMoY2gsIGwzX3NpZGUpIHtcbiAgICAgICAgdmFyIHNmYjtcbiAgICAgICAgdmFyIGdpID0gbDNfc2lkZS50dFsxXVtjaF07XG4gICAgICAgIHZhciBnMCA9IGwzX3NpZGUudHRbMF1bY2hdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVGFibGVzXzEuc2Nmc2lfYmFuZC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoc2ZiID0gVGFibGVzXzEuc2Nmc2lfYmFuZFtpXTsgc2ZiIDwgVGFibGVzXzEuc2Nmc2lfYmFuZFtpICsgMV07IHNmYisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGcwLnNjYWxlZmFjW3NmYl0gIT0gZ2kuc2NhbGVmYWNbc2ZiXVxuICAgICAgICAgICAgICAgICAgICAmJiBnaS5zY2FsZWZhY1tzZmJdID49IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNmYiA9PSBUYWJsZXNfMS5zY2ZzaV9iYW5kW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgIGZvciAoc2ZiID0gVGFibGVzXzEuc2Nmc2lfYmFuZFtpXTsgc2ZiIDwgVGFibGVzXzEuc2Nmc2lfYmFuZFtpICsgMV07IHNmYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdpLnNjYWxlZmFjW3NmYl0gPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbDNfc2lkZS5zY2ZzaVtjaF1baV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzMSA9IDA7XG4gICAgICAgIHZhciBjMSA9IDA7XG4gICAgICAgIGZvciAoc2ZiID0gMDsgc2ZiIDwgMTE7IHNmYisrKSB7XG4gICAgICAgICAgICBpZiAoZ2kuc2NhbGVmYWNbc2ZiXSA9PSAtMSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGMxKys7XG4gICAgICAgICAgICBpZiAoczEgPCBnaS5zY2FsZWZhY1tzZmJdKVxuICAgICAgICAgICAgICAgIHMxID0gZ2kuc2NhbGVmYWNbc2ZiXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgczIgPSAwO1xuICAgICAgICB2YXIgYzIgPSAwO1xuICAgICAgICBmb3IgKDsgc2ZiIDwgRW5jb2Rlcl8xLlNCUFNZX2w7IHNmYisrKSB7XG4gICAgICAgICAgICBpZiAoZ2kuc2NhbGVmYWNbc2ZiXSA9PSAtMSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGMyKys7XG4gICAgICAgICAgICBpZiAoczIgPCBnaS5zY2FsZWZhY1tzZmJdKVxuICAgICAgICAgICAgICAgIHMyID0gZ2kuc2NhbGVmYWNbc2ZiXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgaWYgKHMxIDwgc2xlbjFfbltpXSAmJiBzMiA8IHNsZW4yX25baV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNsZW4xX3RhYltpXSAqIGMxICsgc2xlbjJfdGFiW2ldICogYzI7XG4gICAgICAgICAgICAgICAgaWYgKGdpLnBhcnQyX2xlbmd0aCA+IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2kucGFydDJfbGVuZ3RoID0gYztcbiAgICAgICAgICAgICAgICAgICAgZ2kuc2NhbGVmYWNfY29tcHJlc3MgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIG9wdGltYWwgd2F5IHRvIHN0b3JlIHRoZSBzY2FsZWZhY3RvcnMuIE9ubHkgY2FsbCB0aGlzIHJvdXRpbmVcbiAgICAgKiBhZnRlciBmaW5hbCBzY2FsZWZhY3RvcnMgaGF2ZSBiZWVuIGNob3NlbiBhbmQgdGhlIGNoYW5uZWwvZ3JhbnVsZSB3aWxsXG4gICAgICogbm90IGJlIHJlLWVuY29kZWQuXG4gICAgICovXG4gICAgdGhpcy5iZXN0X3NjYWxlZmFjX3N0b3JlID0gZnVuY3Rpb24gKGdmYywgZ3IsIGNoLCBsM19zaWRlKSB7XG4gICAgICAgIC8qIHVzZSBzY2FsZWZhY19zY2FsZSBpZiB3ZSBjYW4gKi9cbiAgICAgICAgdmFyIGdpID0gbDNfc2lkZS50dFtncl1bY2hdO1xuICAgICAgICB2YXIgc2ZiLCBpLCBqLCBsO1xuICAgICAgICB2YXIgcmVjYWxjID0gMDtcblxuICAgICAgICAvKlxuICAgICAgICAgKiByZW1vdmUgc2NhbGVmYWNzIGZyb20gYmFuZHMgd2l0aCBpeD0wLiBUaGlzIGlkZWEgY29tZXMgZnJvbSB0aGUgQUFDXG4gICAgICAgICAqIElTTyBkb2NzLiBhZGRlZCBtdCAzLzAwXG4gICAgICAgICAqL1xuICAgICAgICAvKiBjaGVjayBpZiBsM19lbmM9MCAqL1xuICAgICAgICBqID0gMDtcbiAgICAgICAgZm9yIChzZmIgPSAwOyBzZmIgPCBnaS5zZmJtYXg7IHNmYisrKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBnaS53aWR0aFtzZmJdO1xuICAgICAgICAgICAgYXNzZXJ0JDE4KHdpZHRoID49IDApO1xuICAgICAgICAgICAgaiArPSB3aWR0aDtcbiAgICAgICAgICAgIGZvciAobCA9IC13aWR0aDsgbCA8IDA7IGwrKykge1xuICAgICAgICAgICAgICAgIGlmIChnaS5sM19lbmNbbCArIGpdICE9IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGwgPT0gMClcbiAgICAgICAgICAgICAgICBnaS5zY2FsZWZhY1tzZmJdID0gcmVjYWxjID0gLTI7XG4gICAgICAgICAgICAvKiBhbnl0aGluZyBnb2VzLiAqL1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIG9ubHkgYmVzdF9zY2FsZWZhY19zdG9yZSBhbmQgY2FsY19zY2ZzaSBrbm93LS1hbmQgb25seSB0aGV5XG4gICAgICAgICAgICAgKiBzaG91bGQga25vdy0tYWJvdXQgdGhlIG1hZ2ljIG51bWJlciAtMi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKDAgPT0gZ2kuc2NhbGVmYWNfc2NhbGUgJiYgMCA9PSBnaS5wcmVmbGFnKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgICAgICBmb3IgKHNmYiA9IDA7IHNmYiA8IGdpLnNmYm1heDsgc2ZiKyspXG4gICAgICAgICAgICAgICAgaWYgKGdpLnNjYWxlZmFjW3NmYl0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBzIHw9IGdpLnNjYWxlZmFjW3NmYl07XG5cbiAgICAgICAgICAgIGlmICgwID09IChzICYgMSkgJiYgcyAhPSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChzZmIgPSAwOyBzZmIgPCBnaS5zZmJtYXg7IHNmYisrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2kuc2NhbGVmYWNbc2ZiXSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBnaS5zY2FsZWZhY1tzZmJdID4+PSAxO1xuXG4gICAgICAgICAgICAgICAgZ2kuc2NhbGVmYWNfc2NhbGUgPSByZWNhbGMgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKDAgPT0gZ2kucHJlZmxhZyAmJiBnaS5ibG9ja190eXBlICE9IEVuY29kZXJfMS5TSE9SVF9UWVBFXG4gICAgICAgICAgICAmJiBnZmMubW9kZV9nciA9PSAyKSB7XG4gICAgICAgICAgICBmb3IgKHNmYiA9IDExOyBzZmIgPCBFbmNvZGVyXzEuU0JQU1lfbDsgc2ZiKyspXG4gICAgICAgICAgICAgICAgaWYgKGdpLnNjYWxlZmFjW3NmYl0gPCBxdXB2dC5wcmV0YWJbc2ZiXVxuICAgICAgICAgICAgICAgICAgICAmJiBnaS5zY2FsZWZhY1tzZmJdICE9IC0yKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChzZmIgPT0gRW5jb2Rlcl8xLlNCUFNZX2wpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHNmYiA9IDExOyBzZmIgPCBFbmNvZGVyXzEuU0JQU1lfbDsgc2ZiKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChnaS5zY2FsZWZhY1tzZmJdID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGdpLnNjYWxlZmFjW3NmYl0gLT0gcXVwdnQucHJldGFiW3NmYl07XG5cbiAgICAgICAgICAgICAgICBnaS5wcmVmbGFnID0gcmVjYWxjID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICAgICAgICBsM19zaWRlLnNjZnNpW2NoXVtpXSA9IDA7XG5cbiAgICAgICAgaWYgKGdmYy5tb2RlX2dyID09IDIgJiYgZ3IgPT0gMVxuICAgICAgICAgICAgJiYgbDNfc2lkZS50dFswXVtjaF0uYmxvY2tfdHlwZSAhPSBFbmNvZGVyXzEuU0hPUlRfVFlQRVxuICAgICAgICAgICAgJiYgbDNfc2lkZS50dFsxXVtjaF0uYmxvY2tfdHlwZSAhPSBFbmNvZGVyXzEuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgc2Nmc2lfY2FsYyhjaCwgbDNfc2lkZSk7XG4gICAgICAgICAgICByZWNhbGMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoc2ZiID0gMDsgc2ZiIDwgZ2kuc2ZibWF4OyBzZmIrKykge1xuICAgICAgICAgICAgaWYgKGdpLnNjYWxlZmFjW3NmYl0gPT0gLTIpIHtcbiAgICAgICAgICAgICAgICBnaS5zY2FsZWZhY1tzZmJdID0gMDtcbiAgICAgICAgICAgICAgICAvKiBpZiBhbnl0aGluZyBnb2VzLCB0aGVuIDAgaXMgYSBnb29kIGNob2ljZSAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWNhbGMgIT0gMCkge1xuICAgICAgICAgICAgaWYgKGdmYy5tb2RlX2dyID09IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlX2JpdGNvdW50KGdpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZV9iaXRjb3VudF9sc2YoZ2ZjLCBnaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYWxsX3NjYWxlZmFjdG9yc19ub3RfbmVnYXRpdmUoc2NhbGVmYWMsIG4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChzY2FsZWZhY1tpXSA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG51bWJlciBvZiBiaXRzIHVzZWQgdG8gZW5jb2RlIHNjYWxlZmFjcy5cbiAgICAgKlxuICAgICAqIDE4KnNsZW4xX3RhYltpXSArIDE4KnNsZW4yX3RhYltpXVxuICAgICAqL1xuICAgIHZhciBzY2FsZV9zaG9ydCA9IFswLCAxOCwgMzYsIDU0LCA1NCwgMzYsIDU0LCA3MixcbiAgICAgICAgNTQsIDcyLCA5MCwgNzIsIDkwLCAxMDgsIDEwOCwgMTI2XTtcblxuICAgIC8qKlxuICAgICAqIG51bWJlciBvZiBiaXRzIHVzZWQgdG8gZW5jb2RlIHNjYWxlZmFjcy5cbiAgICAgKlxuICAgICAqIDE3KnNsZW4xX3RhYltpXSArIDE4KnNsZW4yX3RhYltpXVxuICAgICAqL1xuICAgIHZhciBzY2FsZV9taXhlZCA9IFswLCAxOCwgMzYsIDU0LCA1MSwgMzUsIDUzLCA3MSxcbiAgICAgICAgNTIsIDcwLCA4OCwgNjksIDg3LCAxMDUsIDEwNCwgMTIyXTtcblxuICAgIC8qKlxuICAgICAqIG51bWJlciBvZiBiaXRzIHVzZWQgdG8gZW5jb2RlIHNjYWxlZmFjcy5cbiAgICAgKlxuICAgICAqIDExKnNsZW4xX3RhYltpXSArIDEwKnNsZW4yX3RhYltpXVxuICAgICAqL1xuICAgIHZhciBzY2FsZV9sb25nID0gWzAsIDEwLCAyMCwgMzAsIDMzLCAyMSwgMzEsIDQxLCAzMiwgNDIsXG4gICAgICAgIDUyLCA0MywgNTMsIDYzLCA2NCwgNzRdO1xuXG4gICAgLyoqXG4gICAgICogQWxzbyBjYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgYml0cyBuZWNlc3NhcnkgdG8gY29kZSB0aGUgc2NhbGVmYWN0b3JzLlxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVfYml0Y291bnQgPSBmdW5jdGlvbiAoY29kX2luZm8pIHtcbiAgICAgICAgdmFyIGssIHNmYiwgbWF4X3NsZW4xID0gMCwgbWF4X3NsZW4yID0gMDtcblxuICAgICAgICAvKiBtYXhpbXVtIHZhbHVlcyAqL1xuICAgICAgICB2YXIgdGFiO1xuICAgICAgICB2YXIgc2NhbGVmYWMgPSBjb2RfaW5mby5zY2FsZWZhYztcblxuICAgICAgICBhc3NlcnQkMTgoYWxsX3NjYWxlZmFjdG9yc19ub3RfbmVnYXRpdmUoc2NhbGVmYWMsIGNvZF9pbmZvLnNmYm1heCkpO1xuXG4gICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlID09IEVuY29kZXJfMS5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICB0YWIgPSBzY2FsZV9zaG9ydDtcbiAgICAgICAgICAgIGlmIChjb2RfaW5mby5taXhlZF9ibG9ja19mbGFnICE9IDApXG4gICAgICAgICAgICAgICAgdGFiID0gc2NhbGVfbWl4ZWQ7XG4gICAgICAgIH0gZWxzZSB7IC8qIGJsb2NrX3R5cGUgPT0gMSwyLG9yIDMgKi9cbiAgICAgICAgICAgIHRhYiA9IHNjYWxlX2xvbmc7XG4gICAgICAgICAgICBpZiAoMCA9PSBjb2RfaW5mby5wcmVmbGFnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChzZmIgPSAxMTsgc2ZiIDwgRW5jb2Rlcl8xLlNCUFNZX2w7IHNmYisrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGVmYWNbc2ZiXSA8IHF1cHZ0LnByZXRhYltzZmJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2ZiID09IEVuY29kZXJfMS5TQlBTWV9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZF9pbmZvLnByZWZsYWcgPSAxO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHNmYiA9IDExOyBzZmIgPCBFbmNvZGVyXzEuU0JQU1lfbDsgc2ZiKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZWZhY1tzZmJdIC09IHF1cHZ0LnByZXRhYltzZmJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoc2ZiID0gMDsgc2ZiIDwgY29kX2luZm8uc2ZiZGl2aWRlOyBzZmIrKylcbiAgICAgICAgICAgIGlmIChtYXhfc2xlbjEgPCBzY2FsZWZhY1tzZmJdKVxuICAgICAgICAgICAgICAgIG1heF9zbGVuMSA9IHNjYWxlZmFjW3NmYl07XG5cbiAgICAgICAgZm9yICg7IHNmYiA8IGNvZF9pbmZvLnNmYm1heDsgc2ZiKyspXG4gICAgICAgICAgICBpZiAobWF4X3NsZW4yIDwgc2NhbGVmYWNbc2ZiXSlcbiAgICAgICAgICAgICAgICBtYXhfc2xlbjIgPSBzY2FsZWZhY1tzZmJdO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGZyb20gVGFrZWhpcm8gVE9NSU5BR0EgPHRvbWluYWdhQGlzb3Rlcm5ldC5vcmc+IDEwLzk5IGxvb3Agb3ZlciAqYWxsKlxuICAgICAgICAgKiBwb3NpYmxlIHZhbHVlcyBvZiBzY2FsZWZhY19jb21wcmVzcyB0byBmaW5kIHRoZSBvbmUgd2hpY2ggdXNlcyB0aGVcbiAgICAgICAgICogc21hbGxlc3QgbnVtYmVyIG9mIGJpdHMuIElTTyB3b3VsZCBzdG9wIGF0IGZpcnN0IHZhbGlkIGluZGV4XG4gICAgICAgICAqL1xuICAgICAgICBjb2RfaW5mby5wYXJ0Ml9sZW5ndGggPSBRdWFudGl6ZVBWVF8xLkxBUkdFX0JJVFM7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCAxNjsgaysrKSB7XG4gICAgICAgICAgICBpZiAobWF4X3NsZW4xIDwgc2xlbjFfbltrXSAmJiBtYXhfc2xlbjIgPCBzbGVuMl9uW2tdXG4gICAgICAgICAgICAgICAgJiYgY29kX2luZm8ucGFydDJfbGVuZ3RoID4gdGFiW2tdKSB7XG4gICAgICAgICAgICAgICAgY29kX2luZm8ucGFydDJfbGVuZ3RoID0gdGFiW2tdO1xuICAgICAgICAgICAgICAgIGNvZF9pbmZvLnNjYWxlZmFjX2NvbXByZXNzID0gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kX2luZm8ucGFydDJfbGVuZ3RoID09IFF1YW50aXplUFZUXzEuTEFSR0VfQklUUztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGFibGUgb2YgbGFyZ2VzdCBzY2FsZWZhY3RvciB2YWx1ZXMgZm9yIE1QRUcyXG4gICAgICovXG4gICAgdmFyIG1heF9yYW5nZV9zZmFjX3RhYiA9IFtbMTUsIDE1LCA3LCA3XSxcbiAgICAgICAgWzE1LCAxNSwgNywgMF0sIFs3LCAzLCAwLCAwXSwgWzE1LCAzMSwgMzEsIDBdLFxuICAgICAgICBbNywgNywgNywgMF0sIFszLCAzLCAwLCAwXV07XG5cbiAgICAvKipcbiAgICAgKiBBbHNvIGNvdW50cyB0aGUgbnVtYmVyIG9mIGJpdHMgdG8gZW5jb2RlIHRoZSBzY2FsZWZhY3MgYnV0IGZvciBNUEVHIDJcbiAgICAgKiBMb3dlciBzYW1wbGluZyBmcmVxdWVuY2llcyAoMjQsIDIyLjA1IGFuZCAxNiBrSHouKVxuICAgICAqXG4gICAgICogVGhpcyBpcyByZXZlcnNlLWVuZ2luZWVyZWQgZnJvbSBzZWN0aW9uIDIuNC4zLjIgb2YgdGhlIE1QRUcyIElTLFxuICAgICAqIFwiQXVkaW8gRGVjb2RpbmcgTGF5ZXIgSUlJXCJcbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlX2JpdGNvdW50X2xzZiA9IGZ1bmN0aW9uIChnZmMsIGNvZF9pbmZvKSB7XG4gICAgICAgIHZhciB0YWJsZV9udW1iZXIsIHJvd19pbl90YWJsZSwgcGFydGl0aW9uLCBucl9zZmIsIHdpbmRvdztcbiAgICAgICAgdmFyIG92ZXI7XG4gICAgICAgIHZhciBpLCBzZmI7XG4gICAgICAgIHZhciBtYXhfc2ZhYyA9IG5ld19pbnQkMTgoNCk7XG4vL3ZhciBwYXJ0aXRpb25fdGFibGU7XG4gICAgICAgIHZhciBzY2FsZWZhYyA9IGNvZF9pbmZvLnNjYWxlZmFjO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFNldCBwYXJ0aXRpb24gdGFibGUuIE5vdGUgdGhhdCBzaG91bGQgdHJ5IHRvIHVzZSB0YWJsZSBvbmUsIGJ1dCBkb1xuICAgICAgICAgKiBub3QgeWV0Li4uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoY29kX2luZm8ucHJlZmxhZyAhPSAwKVxuICAgICAgICAgICAgdGFibGVfbnVtYmVyID0gMjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFibGVfbnVtYmVyID0gMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICAgICAgbWF4X3NmYWNbaV0gPSAwO1xuXG4gICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlID09IEVuY29kZXJfMS5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICByb3dfaW5fdGFibGUgPSAxO1xuICAgICAgICAgICAgdmFyIHBhcnRpdGlvbl90YWJsZSA9IHF1cHZ0Lm5yX29mX3NmYl9ibG9ja1t0YWJsZV9udW1iZXJdW3Jvd19pbl90YWJsZV07XG4gICAgICAgICAgICBmb3IgKHNmYiA9IDAsIHBhcnRpdGlvbiA9IDA7IHBhcnRpdGlvbiA8IDQ7IHBhcnRpdGlvbisrKSB7XG4gICAgICAgICAgICAgICAgbnJfc2ZiID0gcGFydGl0aW9uX3RhYmxlW3BhcnRpdGlvbl0gLyAzO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBucl9zZmI7IGkrKywgc2ZiKyspXG4gICAgICAgICAgICAgICAgICAgIGZvciAod2luZG93ID0gMDsgd2luZG93IDwgMzsgd2luZG93KyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGVmYWNbc2ZiICogMyArIHdpbmRvd10gPiBtYXhfc2ZhY1twYXJ0aXRpb25dKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heF9zZmFjW3BhcnRpdGlvbl0gPSBzY2FsZWZhY1tzZmIgKiAzICsgd2luZG93XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvd19pbl90YWJsZSA9IDA7XG4gICAgICAgICAgICB2YXIgcGFydGl0aW9uX3RhYmxlID0gcXVwdnQubnJfb2Zfc2ZiX2Jsb2NrW3RhYmxlX251bWJlcl1bcm93X2luX3RhYmxlXTtcbiAgICAgICAgICAgIGZvciAoc2ZiID0gMCwgcGFydGl0aW9uID0gMDsgcGFydGl0aW9uIDwgNDsgcGFydGl0aW9uKyspIHtcbiAgICAgICAgICAgICAgICBucl9zZmIgPSBwYXJ0aXRpb25fdGFibGVbcGFydGl0aW9uXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnJfc2ZiOyBpKyssIHNmYisrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGVmYWNbc2ZiXSA+IG1heF9zZmFjW3BhcnRpdGlvbl0pXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhfc2ZhY1twYXJ0aXRpb25dID0gc2NhbGVmYWNbc2ZiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAob3ZlciA9IGZhbHNlLCBwYXJ0aXRpb24gPSAwOyBwYXJ0aXRpb24gPCA0OyBwYXJ0aXRpb24rKykge1xuICAgICAgICAgICAgaWYgKG1heF9zZmFjW3BhcnRpdGlvbl0gPiBtYXhfcmFuZ2Vfc2ZhY190YWJbdGFibGVfbnVtYmVyXVtwYXJ0aXRpb25dKVxuICAgICAgICAgICAgICAgIG92ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3Zlcikge1xuICAgICAgICAgICAgdmFyIHNsZW4xLCBzbGVuMiwgc2xlbjMsIHNsZW40O1xuXG4gICAgICAgICAgICBjb2RfaW5mby5zZmJfcGFydGl0aW9uX3RhYmxlID0gcXVwdnQubnJfb2Zfc2ZiX2Jsb2NrW3RhYmxlX251bWJlcl1bcm93X2luX3RhYmxlXTtcbiAgICAgICAgICAgIGZvciAocGFydGl0aW9uID0gMDsgcGFydGl0aW9uIDwgNDsgcGFydGl0aW9uKyspXG4gICAgICAgICAgICAgICAgY29kX2luZm8uc2xlbltwYXJ0aXRpb25dID0gbG9nMnRhYlttYXhfc2ZhY1twYXJ0aXRpb25dXTtcblxuICAgICAgICAgICAgLyogc2V0IHNjYWxlZmFjX2NvbXByZXNzICovXG4gICAgICAgICAgICBzbGVuMSA9IGNvZF9pbmZvLnNsZW5bMF07XG4gICAgICAgICAgICBzbGVuMiA9IGNvZF9pbmZvLnNsZW5bMV07XG4gICAgICAgICAgICBzbGVuMyA9IGNvZF9pbmZvLnNsZW5bMl07XG4gICAgICAgICAgICBzbGVuNCA9IGNvZF9pbmZvLnNsZW5bM107XG5cbiAgICAgICAgICAgIHN3aXRjaCAodGFibGVfbnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mby5zY2FsZWZhY19jb21wcmVzcyA9ICgoKHNsZW4xICogNSkgKyBzbGVuMikgPDwgNClcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKHNsZW4zIDw8IDIpICsgc2xlbjQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mby5zY2FsZWZhY19jb21wcmVzcyA9IDQwMCArICgoKHNsZW4xICogNSkgKyBzbGVuMikgPDwgMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgc2xlbjM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mby5zY2FsZWZhY19jb21wcmVzcyA9IDUwMCArIChzbGVuMSAqIDMpICsgc2xlbjI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgU3lzdGVtJDE4LmVyci5wcmludGYoXCJpbnRlbnNpdHkgc3RlcmVvIG5vdCBpbXBsZW1lbnRlZCB5ZXRcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb3Zlcikge1xuICAgICAgICAgICAgYXNzZXJ0JDE4KGNvZF9pbmZvLnNmYl9wYXJ0aXRpb25fdGFibGUgIT0gbnVsbCk7XG4gICAgICAgICAgICBjb2RfaW5mby5wYXJ0Ml9sZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yIChwYXJ0aXRpb24gPSAwOyBwYXJ0aXRpb24gPCA0OyBwYXJ0aXRpb24rKylcbiAgICAgICAgICAgICAgICBjb2RfaW5mby5wYXJ0Ml9sZW5ndGggKz0gY29kX2luZm8uc2xlbltwYXJ0aXRpb25dXG4gICAgICAgICAgICAgICAgICAgICogY29kX2luZm8uc2ZiX3BhcnRpdGlvbl90YWJsZVtwYXJ0aXRpb25dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdmVyO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFNpbmNlIG5vIGJhbmRzIGhhdmUgYmVlbiBvdmVyLWFtcGxpZmllZCwgd2UgY2FuIHNldCBzY2FsZWZhY19jb21wcmVzcyBhbmRcbiAgICAgKiBzbGVuW10gZm9yIHRoZSBmb3JtYXR0ZXJcbiAgICAgKi9cbiAgICB2YXIgbG9nMnRhYiA9IFswLCAxLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LFxuICAgICAgICA0LCA0LCA0LCA0XTtcblxuICAgIHRoaXMuaHVmZm1hbl9pbml0ID0gZnVuY3Rpb24gKGdmYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8PSA1NzY7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIHNjZmJfYW56ID0gMCwgYnZfaW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoZ2ZjLnNjYWxlZmFjX2JhbmQubFsrK3NjZmJfYW56XSA8IGkpXG4gICAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICBidl9pbmRleCA9IHN1YmR2X3RhYmxlW3NjZmJfYW56XVswXTsgLy8gLnJlZ2lvbjBfY291bnRcbiAgICAgICAgICAgIHdoaWxlIChnZmMuc2NhbGVmYWNfYmFuZC5sW2J2X2luZGV4ICsgMV0gPiBpKVxuICAgICAgICAgICAgICAgIGJ2X2luZGV4LS07XG5cbiAgICAgICAgICAgIGlmIChidl9pbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHRoaXMgaXMgYW4gaW5kaWNhdGlvbiB0aGF0IGV2ZXJ5dGhpbmcgaXMgZ29pbmcgdG8gYmUgZW5jb2RlZFxuICAgICAgICAgICAgICAgICAqIGFzIHJlZ2lvbjA6IGJpZ3ZhbHVlcyA8IHJlZ2lvbjAgPCByZWdpb24xIHNvIGxldHMgc2V0XG4gICAgICAgICAgICAgICAgICogcmVnaW9uMCwgcmVnaW9uMSB0byBzb21lIHZhbHVlIGxhcmdlciB0aGFuIGJpZ3ZhbHVlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGJ2X2luZGV4ID0gc3ViZHZfdGFibGVbc2NmYl9hbnpdWzBdOyAvLyAucmVnaW9uMF9jb3VudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZmMuYnZfc2NmW2kgLSAyXSA9IGJ2X2luZGV4O1xuXG4gICAgICAgICAgICBidl9pbmRleCA9IHN1YmR2X3RhYmxlW3NjZmJfYW56XVsxXTsgLy8gLnJlZ2lvbjFfY291bnRcbiAgICAgICAgICAgIHdoaWxlIChnZmMuc2NhbGVmYWNfYmFuZC5sW2J2X2luZGV4ICsgZ2ZjLmJ2X3NjZltpIC0gMl0gKyAyXSA+IGkpXG4gICAgICAgICAgICAgICAgYnZfaW5kZXgtLTtcblxuICAgICAgICAgICAgaWYgKGJ2X2luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIGJ2X2luZGV4ID0gc3ViZHZfdGFibGVbc2NmYl9hbnpdWzFdOyAvLyAucmVnaW9uMV9jb3VudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZmMuYnZfc2NmW2kgLSAxXSA9IGJ2X2luZGV4O1xuICAgICAgICB9XG4gICAgfTtcbn1cblxudmFyIFRha2VoaXJvXzEgPSBUYWtlaGlybyQxO1xuXG52YXIgU3lzdGVtJDE3ID0gY29tbW9uLlN5c3RlbTtcbnZhciBBcnJheXMkMTcgPSBjb21tb24uQXJyYXlzO1xudmFyIG5ld19ieXRlJDE3ID0gY29tbW9uLm5ld19ieXRlO1xudmFyIG5ld19mbG9hdF9uJDE3ID0gY29tbW9uLm5ld19mbG9hdF9uO1xudmFyIG5ld19pbnQkMTcgPSBjb21tb24ubmV3X2ludDtcbnZhciBhc3NlcnQkMTcgPSBjb21tb24uYXNzZXJ0O1xuXG5cblxuXG5cblxuQml0U3RyZWFtJDEuRVEgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiAoTWF0aC5hYnMoYSkgPiBNYXRoLmFicyhiKSkgPyAoTWF0aC5hYnMoKGEpIC0gKGIpKSA8PSAoTWF0aFxuICAgICAgICAuYWJzKGEpICogMWUtNikpXG4gICAgICAgIDogKE1hdGguYWJzKChhKSAtIChiKSkgPD0gKE1hdGguYWJzKGIpICogMWUtNikpO1xufTtcblxuQml0U3RyZWFtJDEuTkVRID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gIUJpdFN0cmVhbSQxLkVRKGEsIGIpO1xufTtcblxuZnVuY3Rpb24gQml0U3RyZWFtJDEoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBDUkMxNl9QT0xZTk9NSUFMID0gMHg4MDA1O1xuXG4gICAgLypcbiAgICAgKiB3ZSB3b3JrIHdpdGggaW50cywgc28gd2hlbiBkb2luZyBiaXQgbWFuaXB1bGF0aW9uLCB3ZSBsaW1pdCBvdXJzZWx2ZXMgdG9cbiAgICAgKiBNQVhfTEVOR1RILTIganVzdCB0byBiZSBvbiB0aGUgc2FmZSBzaWRlXG4gICAgICovXG4gICAgdmFyIE1BWF9MRU5HVEggPSAzMjtcblxuICAgIC8vR2FpbkFuYWx5c2lzIGdhO1xuICAgIC8vTVBHTGliIG1wZztcbiAgICAvL1ZlcnNpb24gdmVyO1xuICAgIC8vVkJSVGFnIHZicjtcbiAgICB2YXIgZ2EgPSBudWxsO1xuICAgIHZhciBtcGcgPSBudWxsO1xuICAgIHZhciB2ZXIgPSBudWxsO1xuICAgIHZhciB2YnIgPSBudWxsO1xuXG4gICAgLy9wdWJsaWMgZmluYWwgdm9pZCBzZXRNb2R1bGVzKEdhaW5BbmFseXNpcyBnYSwgTVBHTGliIG1wZywgVmVyc2lvbiB2ZXIsXG4gICAgLy9cdFZCUlRhZyB2YnIpIHtcblxuICAgIHRoaXMuc2V0TW9kdWxlcyA9IGZ1bmN0aW9uIChfZ2EsIF9tcGcsIF92ZXIsIF92YnIpIHtcbiAgICAgICAgZ2EgPSBfZ2E7XG4gICAgICAgIG1wZyA9IF9tcGc7XG4gICAgICAgIHZlciA9IF92ZXI7XG4gICAgICAgIHZiciA9IF92YnI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEJpdCBzdHJlYW0gYnVmZmVyLlxuICAgICAqL1xuICAgIC8vcHJpdmF0ZSBieXRlW10gYnVmO1xuICAgIHZhciBidWYgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEJpdCBjb3VudGVyIG9mIGJpdCBzdHJlYW0uXG4gICAgICovXG4gICAgdmFyIHRvdGJpdCA9IDA7XG4gICAgLyoqXG4gICAgICogUG9pbnRlciB0byB0b3AgYnl0ZSBpbiBidWZmZXIuXG4gICAgICovXG4gICAgdmFyIGJ1ZkJ5dGVJZHggPSAwO1xuICAgIC8qKlxuICAgICAqIFBvaW50ZXIgdG8gdG9wIGJpdCBvZiB0b3AgYnl0ZSBpbiBidWZmZXIuXG4gICAgICovXG4gICAgdmFyIGJ1ZkJpdElkeCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIGJpdHNwZXJmcmFtZSBhbmQgbWVhbl9iaXRzIGZvciBhIGxheWVyIElJSSBmcmFtZVxuICAgICAqL1xuICAgIHRoaXMuZ2V0ZnJhbWViaXRzID0gZnVuY3Rpb24gKGdmcCkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgYml0X3JhdGU7XG5cbiAgICAgICAgLyogZ2V0IGJpdHJhdGUgaW4ga2JwcyBbP10gKi9cbiAgICAgICAgaWYgKGdmYy5iaXRyYXRlX2luZGV4ICE9IDApXG4gICAgICAgICAgICBiaXRfcmF0ZSA9IFRhYmxlc18xLmJpdHJhdGVfdGFibGVbZ2ZwLnZlcnNpb25dW2dmYy5iaXRyYXRlX2luZGV4XTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYml0X3JhdGUgPSBnZnAuYnJhdGU7XG4gICAgICAgIGFzc2VydCQxNyg4IDw9IGJpdF9yYXRlICYmIGJpdF9yYXRlIDw9IDY0MCk7XG5cbiAgICAgICAgLyogbWFpbiBlbmNvZGluZyByb3V0aW5lIHRvZ2dsZXMgcGFkZGluZyBvbiBhbmQgb2ZmICovXG4gICAgICAgIC8qIG9uZSBMYXllcjMgU2xvdCBjb25zaXN0cyBvZiA4IGJpdHMgKi9cbiAgICAgICAgdmFyIGJ5dGVzID0gMCB8IChnZnAudmVyc2lvbiArIDEpICogNzIwMDAgKiBiaXRfcmF0ZSAvIGdmcC5vdXRfc2FtcGxlcmF0ZSArIGdmYy5wYWRkaW5nO1xuICAgICAgICByZXR1cm4gOCAqIGJ5dGVzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwdXRoZWFkZXJfYml0cyhnZmMpIHtcbiAgICAgICAgU3lzdGVtJDE3LmFycmF5Y29weShnZmMuaGVhZGVyW2dmYy53X3B0cl0uYnVmLCAwLCBidWYsIGJ1ZkJ5dGVJZHgsIGdmYy5zaWRlaW5mb19sZW4pO1xuICAgICAgICBidWZCeXRlSWR4ICs9IGdmYy5zaWRlaW5mb19sZW47XG4gICAgICAgIHRvdGJpdCArPSBnZmMuc2lkZWluZm9fbGVuICogODtcbiAgICAgICAgZ2ZjLndfcHRyID0gKGdmYy53X3B0ciArIDEpICYgKExhbWVJbnRlcm5hbEZsYWdzXzEuTUFYX0hFQURFUl9CVUYgLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB3cml0ZSBqIGJpdHMgaW50byB0aGUgYml0IHN0cmVhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1dGJpdHMyKGdmYywgdmFsLCBqKSB7XG4gICAgICAgIGFzc2VydCQxNyhqIDwgTUFYX0xFTkdUSCAtIDIpO1xuXG4gICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBpZiAoYnVmQml0SWR4ID09IDApIHtcbiAgICAgICAgICAgICAgICBidWZCaXRJZHggPSA4O1xuICAgICAgICAgICAgICAgIGJ1ZkJ5dGVJZHgrKztcbiAgICAgICAgICAgICAgICBhc3NlcnQkMTcoYnVmQnl0ZUlkeCA8IExhbWUuTEFNRV9NQVhNUDNCVUZGRVIpO1xuICAgICAgICAgICAgICAgIGFzc2VydCQxNyhnZmMuaGVhZGVyW2dmYy53X3B0cl0ud3JpdGVfdGltaW5nID49IHRvdGJpdCk7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5oZWFkZXJbZ2ZjLndfcHRyXS53cml0ZV90aW1pbmcgPT0gdG90Yml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHB1dGhlYWRlcl9iaXRzKGdmYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZltidWZCeXRlSWR4XSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGsgPSBNYXRoLm1pbihqLCBidWZCaXRJZHgpO1xuICAgICAgICAgICAgaiAtPSBrO1xuXG4gICAgICAgICAgICBidWZCaXRJZHggLT0gaztcblxuICAgICAgICAgICAgYXNzZXJ0JDE3KGogPCBNQVhfTEVOR1RIKTtcbiAgICAgICAgICAgIC8qIDMyIHRvbyBsYXJnZSBvbiAzMiBiaXQgbWFjaGluZXMgKi9cbiAgICAgICAgICAgIGFzc2VydCQxNyhidWZCaXRJZHggPCBNQVhfTEVOR1RIKTtcblxuICAgICAgICAgICAgYnVmW2J1ZkJ5dGVJZHhdIHw9ICgodmFsID4+IGopIDw8IGJ1ZkJpdElkeCk7XG4gICAgICAgICAgICB0b3RiaXQgKz0gaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHdyaXRlIGogYml0cyBpbnRvIHRoZSBiaXQgc3RyZWFtLCBpZ25vcmluZyBmcmFtZSBoZWFkZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHV0Yml0c19ub2hlYWRlcnMoZ2ZjLCB2YWwsIGopIHtcbiAgICAgICAgYXNzZXJ0JDE3KGogPCBNQVhfTEVOR1RIIC0gMik7XG5cbiAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGlmIChidWZCaXRJZHggPT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1ZkJpdElkeCA9IDg7XG4gICAgICAgICAgICAgICAgYnVmQnl0ZUlkeCsrO1xuICAgICAgICAgICAgICAgIGFzc2VydCQxNyhidWZCeXRlSWR4IDwgTGFtZS5MQU1FX01BWE1QM0JVRkZFUik7XG4gICAgICAgICAgICAgICAgYnVmW2J1ZkJ5dGVJZHhdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgayA9IE1hdGgubWluKGosIGJ1ZkJpdElkeCk7XG4gICAgICAgICAgICBqIC09IGs7XG5cbiAgICAgICAgICAgIGJ1ZkJpdElkeCAtPSBrO1xuXG4gICAgICAgICAgICBhc3NlcnQkMTcoaiA8IE1BWF9MRU5HVEgpO1xuICAgICAgICAgICAgLyogMzIgdG9vIGxhcmdlIG9uIDMyIGJpdCBtYWNoaW5lcyAqL1xuICAgICAgICAgICAgYXNzZXJ0JDE3KGJ1ZkJpdElkeCA8IE1BWF9MRU5HVEgpO1xuXG4gICAgICAgICAgICBidWZbYnVmQnl0ZUlkeF0gfD0gKCh2YWwgPj4gaikgPDwgYnVmQml0SWR4KTtcbiAgICAgICAgICAgIHRvdGJpdCArPSBrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU29tZSBjb21iaW5hdGlvbnMgb2YgYml0cmF0ZSwgRnMsIGFuZCBzdGVyZW8gbWFrZSBpdCBpbXBvc3NpYmxlIHRvIHN0dWZmXG4gICAgICogb3V0IGEgZnJhbWUgdXNpbmcganVzdCBtYWluX2RhdGEsIGR1ZSB0byB0aGUgbGltaXRlZCBudW1iZXIgb2YgYml0cyB0b1xuICAgICAqIGluZGljYXRlIG1haW5fZGF0YV9sZW5ndGguIEluIHRoZXNlIHNpdHVhdGlvbnMsIHdlIHB1dCBzdHVmZmluZyBiaXRzIGludG9cbiAgICAgKiB0aGUgYW5jaWxsYXJ5IGRhdGEuLi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmFpbl9pbnRvX2FuY2lsbGFyeShnZnAsIHJlbWFpbmluZ0JpdHMpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGFzc2VydCQxNyhyZW1haW5pbmdCaXRzID49IDApO1xuXG4gICAgICAgIGlmIChyZW1haW5pbmdCaXRzID49IDgpIHtcbiAgICAgICAgICAgIHB1dGJpdHMyKGdmYywgMHg0YywgOCk7XG4gICAgICAgICAgICByZW1haW5pbmdCaXRzIC09IDg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbWFpbmluZ0JpdHMgPj0gOCkge1xuICAgICAgICAgICAgcHV0Yml0czIoZ2ZjLCAweDQxLCA4KTtcbiAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgLT0gODtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtYWluaW5nQml0cyA+PSA4KSB7XG4gICAgICAgICAgICBwdXRiaXRzMihnZmMsIDB4NGQsIDgpO1xuICAgICAgICAgICAgcmVtYWluaW5nQml0cyAtPSA4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1haW5pbmdCaXRzID49IDgpIHtcbiAgICAgICAgICAgIHB1dGJpdHMyKGdmYywgMHg0NSwgOCk7XG4gICAgICAgICAgICByZW1haW5pbmdCaXRzIC09IDg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVtYWluaW5nQml0cyA+PSAzMikge1xuICAgICAgICAgICAgdmFyIHZlcnNpb24gPSB2ZXIuZ2V0TGFtZVNob3J0VmVyc2lvbigpO1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0JpdHMgPj0gMzIpXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnNpb24ubGVuZ3RoICYmIHJlbWFpbmluZ0JpdHMgPj0gODsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgLT0gODtcbiAgICAgICAgICAgICAgICAgICAgcHV0Yml0czIoZ2ZjLCB2ZXJzaW9uLmNoYXJBdChpKSwgOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IHJlbWFpbmluZ0JpdHMgPj0gMTsgcmVtYWluaW5nQml0cyAtPSAxKSB7XG4gICAgICAgICAgICBwdXRiaXRzMihnZmMsIGdmYy5hbmNpbGxhcnlfZmxhZywgMSk7XG4gICAgICAgICAgICBnZmMuYW5jaWxsYXJ5X2ZsYWcgXj0gKCFnZnAuZGlzYWJsZV9yZXNlcnZvaXIgPyAxIDogMCk7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQkMTcocmVtYWluaW5nQml0cyA9PSAwKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHdyaXRlIE4gYml0cyBpbnRvIHRoZSBoZWFkZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cml0ZWhlYWRlcihnZmMsIHZhbCwgaikge1xuICAgICAgICB2YXIgcHRyID0gZ2ZjLmhlYWRlcltnZmMuaF9wdHJdLnB0cjtcblxuICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgIHZhciBrID0gTWF0aC5taW4oaiwgOCAtIChwdHIgJiA3KSk7XG4gICAgICAgICAgICBqIC09IGs7XG4gICAgICAgICAgICBhc3NlcnQkMTcoaiA8IE1BWF9MRU5HVEgpO1xuICAgICAgICAgICAgLyogPj4gMzIgdG9vIGxhcmdlIGZvciAzMiBiaXQgbWFjaGluZXMgKi9cblxuICAgICAgICAgICAgZ2ZjLmhlYWRlcltnZmMuaF9wdHJdLmJ1ZltwdHIgPj4gM10gfD0gKCh2YWwgPj4gaikpIDw8ICg4IC0gKHB0ciAmIDcpIC0gayk7XG4gICAgICAgICAgICBwdHIgKz0gaztcbiAgICAgICAgfVxuICAgICAgICBnZmMuaGVhZGVyW2dmYy5oX3B0cl0ucHRyID0gcHRyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENSQ191cGRhdGUodmFsdWUsIGNyYykge1xuICAgICAgICB2YWx1ZSA8PD0gODtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlIDw8PSAxO1xuICAgICAgICAgICAgY3JjIDw8PSAxO1xuXG4gICAgICAgICAgICBpZiAoKCgoY3JjIF4gdmFsdWUpICYgMHgxMDAwMCkgIT0gMCkpXG4gICAgICAgICAgICAgICAgY3JjIF49IENSQzE2X1BPTFlOT01JQUw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyYztcbiAgICB9XG5cbiAgICB0aGlzLkNSQ193cml0ZWhlYWRlciA9IGZ1bmN0aW9uIChnZmMsIGhlYWRlcikge1xuICAgICAgICB2YXIgY3JjID0gMHhmZmZmO1xuICAgICAgICAvKiAoam8pIGluaXQgY3JjMTYgZm9yIGVycm9yX3Byb3RlY3Rpb24gKi9cblxuICAgICAgICBjcmMgPSBDUkNfdXBkYXRlKGhlYWRlclsyXSAmIDB4ZmYsIGNyYyk7XG4gICAgICAgIGNyYyA9IENSQ191cGRhdGUoaGVhZGVyWzNdICYgMHhmZiwgY3JjKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDY7IGkgPCBnZmMuc2lkZWluZm9fbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNyYyA9IENSQ191cGRhdGUoaGVhZGVyW2ldICYgMHhmZiwgY3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWRlcls0XSA9IChieXRlKShjcmMgPj4gOCk7XG4gICAgICAgIGhlYWRlcls1XSA9IChieXRlKShjcmMgJiAyNTUpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlbmNvZGVTaWRlSW5mbzIoZ2ZwLCBiaXRzUGVyRnJhbWUpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGwzX3NpZGU7XG4gICAgICAgIHZhciBnciwgY2g7XG5cbiAgICAgICAgbDNfc2lkZSA9IGdmYy5sM19zaWRlO1xuICAgICAgICBnZmMuaGVhZGVyW2dmYy5oX3B0cl0ucHRyID0gMDtcbiAgICAgICAgQXJyYXlzJDE3LmZpbGwoZ2ZjLmhlYWRlcltnZmMuaF9wdHJdLmJ1ZiwgMCwgZ2ZjLnNpZGVpbmZvX2xlbiwgMCk7XG4gICAgICAgIGlmIChnZnAub3V0X3NhbXBsZXJhdGUgPCAxNjAwMClcbiAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgMHhmZmUsIDEyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAweGZmZiwgMTIpO1xuICAgICAgICB3cml0ZWhlYWRlcihnZmMsIChnZnAudmVyc2lvbiksIDEpO1xuICAgICAgICB3cml0ZWhlYWRlcihnZmMsIDQgLSAzLCAyKTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoIWdmcC5lcnJvcl9wcm90ZWN0aW9uID8gMSA6IDApLCAxKTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoZ2ZjLmJpdHJhdGVfaW5kZXgpLCA0KTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoZ2ZjLnNhbXBsZXJhdGVfaW5kZXgpLCAyKTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoZ2ZjLnBhZGRpbmcpLCAxKTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoZ2ZwLmV4dGVuc2lvbiksIDEpO1xuICAgICAgICB3cml0ZWhlYWRlcihnZmMsIChnZnAubW9kZS5vcmRpbmFsKCkpLCAyKTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoZ2ZjLm1vZGVfZXh0KSwgMik7XG4gICAgICAgIHdyaXRlaGVhZGVyKGdmYywgKGdmcC5jb3B5cmlnaHQpLCAxKTtcbiAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAoZ2ZwLm9yaWdpbmFsKSwgMSk7XG4gICAgICAgIHdyaXRlaGVhZGVyKGdmYywgKGdmcC5lbXBoYXNpcyksIDIpO1xuICAgICAgICBpZiAoZ2ZwLmVycm9yX3Byb3RlY3Rpb24pIHtcbiAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgMCwgMTYpO1xuICAgICAgICAgICAgLyogZHVtbXkgKi9cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZnAudmVyc2lvbiA9PSAxKSB7XG4gICAgICAgICAgICAvKiBNUEVHMSAqL1xuICAgICAgICAgICAgYXNzZXJ0JDE3KGwzX3NpZGUubWFpbl9kYXRhX2JlZ2luID49IDApO1xuICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCAobDNfc2lkZS5tYWluX2RhdGFfYmVnaW4pLCA5KTtcblxuICAgICAgICAgICAgaWYgKGdmYy5jaGFubmVsc19vdXQgPT0gMilcbiAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGwzX3NpZGUucHJpdmF0ZV9iaXRzLCAzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGwzX3NpZGUucHJpdmF0ZV9iaXRzLCA1KTtcblxuICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgIHZhciBiYW5kO1xuICAgICAgICAgICAgICAgIGZvciAoYmFuZCA9IDA7IGJhbmQgPCA0OyBiYW5kKyspIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBsM19zaWRlLnNjZnNpW2NoXVtiYW5kXSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGdyID0gMDsgZ3IgPCAyOyBncisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2kgPSBsM19zaWRlLnR0W2dyXVtjaF07XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kucGFydDJfM19sZW5ndGggKyBnaS5wYXJ0Ml9sZW5ndGgsIDEyKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5iaWdfdmFsdWVzIC8gMiwgOSk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kuZ2xvYmFsX2dhaW4sIDgpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnNjYWxlZmFjX2NvbXByZXNzLCA0KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2kuYmxvY2tfdHlwZSAhPSBFbmNvZGVyXzEuTk9STV9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIDEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogd2luZG93X3N3aXRjaGluZ19mbGFnICovXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLmJsb2NrX3R5cGUsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5taXhlZF9ibG9ja19mbGFnLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdpLnRhYmxlX3NlbGVjdFswXSA9PSAxNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaS50YWJsZV9zZWxlY3RbMF0gPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kudGFibGVfc2VsZWN0WzBdLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnaS50YWJsZV9zZWxlY3RbMV0gPT0gMTQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzFdID0gMTY7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnRhYmxlX3NlbGVjdFsxXSwgNSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kuc3ViYmxvY2tfZ2FpblswXSwgMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnN1YmJsb2NrX2dhaW5bMV0sIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5zdWJibG9ja19nYWluWzJdLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiB3aW5kb3dfc3dpdGNoaW5nX2ZsYWcgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnaS50YWJsZV9zZWxlY3RbMF0gPT0gMTQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzBdID0gMTY7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnRhYmxlX3NlbGVjdFswXSwgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2kudGFibGVfc2VsZWN0WzFdID09IDE0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdpLnRhYmxlX3NlbGVjdFsxXSA9IDE2O1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS50YWJsZV9zZWxlY3RbMV0sIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdpLnRhYmxlX3NlbGVjdFsyXSA9PSAxNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaS50YWJsZV9zZWxlY3RbMl0gPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kudGFibGVfc2VsZWN0WzJdLCA1KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0JDE3KDAgPD0gZ2kucmVnaW9uMF9jb3VudCAmJiBnaS5yZWdpb24wX2NvdW50IDwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0JDE3KDAgPD0gZ2kucmVnaW9uMV9jb3VudCAmJiBnaS5yZWdpb24xX2NvdW50IDwgOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnJlZ2lvbjBfY291bnQsIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5yZWdpb24xX2NvdW50LCAzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnByZWZsYWcsIDEpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnNjYWxlZmFjX3NjYWxlLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5jb3VudDF0YWJsZV9zZWxlY3QsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIE1QRUcyICovXG4gICAgICAgICAgICBhc3NlcnQkMTcobDNfc2lkZS5tYWluX2RhdGFfYmVnaW4gPj0gMCk7XG4gICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIChsM19zaWRlLm1haW5fZGF0YV9iZWdpbiksIDgpO1xuICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBsM19zaWRlLnByaXZhdGVfYml0cywgZ2ZjLmNoYW5uZWxzX291dCk7XG5cbiAgICAgICAgICAgIGdyID0gMDtcbiAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2kgPSBsM19zaWRlLnR0W2dyXVtjaF07XG4gICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5wYXJ0Ml8zX2xlbmd0aCArIGdpLnBhcnQyX2xlbmd0aCwgMTIpO1xuICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kuYmlnX3ZhbHVlcyAvIDIsIDkpO1xuICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kuZ2xvYmFsX2dhaW4sIDgpO1xuICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kuc2NhbGVmYWNfY29tcHJlc3MsIDkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGdpLmJsb2NrX3R5cGUgIT0gRW5jb2Rlcl8xLk5PUk1fVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIDEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAvKiB3aW5kb3dfc3dpdGNoaW5nX2ZsYWcgKi9cbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5ibG9ja190eXBlLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5taXhlZF9ibG9ja19mbGFnLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2kudGFibGVfc2VsZWN0WzBdID09IDE0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzBdID0gMTY7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kudGFibGVfc2VsZWN0WzBdLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdpLnRhYmxlX3NlbGVjdFsxXSA9PSAxNClcbiAgICAgICAgICAgICAgICAgICAgICAgIGdpLnRhYmxlX3NlbGVjdFsxXSA9IDE2O1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnRhYmxlX3NlbGVjdFsxXSwgNSk7XG5cbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5zdWJibG9ja19nYWluWzBdLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5zdWJibG9ja19nYWluWzFdLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS5zdWJibG9ja19nYWluWzJdLCAzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAvKiB3aW5kb3dfc3dpdGNoaW5nX2ZsYWcgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdpLnRhYmxlX3NlbGVjdFswXSA9PSAxNClcbiAgICAgICAgICAgICAgICAgICAgICAgIGdpLnRhYmxlX3NlbGVjdFswXSA9IDE2O1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnRhYmxlX3NlbGVjdFswXSwgNSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnaS50YWJsZV9zZWxlY3RbMV0gPT0gMTQpXG4gICAgICAgICAgICAgICAgICAgICAgICBnaS50YWJsZV9zZWxlY3RbMV0gPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVoZWFkZXIoZ2ZjLCBnaS50YWJsZV9zZWxlY3RbMV0sIDUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2kudGFibGVfc2VsZWN0WzJdID09IDE0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2kudGFibGVfc2VsZWN0WzJdID0gMTY7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kudGFibGVfc2VsZWN0WzJdLCA1KTtcblxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQkMTcoMCA8PSBnaS5yZWdpb24wX2NvdW50ICYmIGdpLnJlZ2lvbjBfY291bnQgPCAxNik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCQxNygwIDw9IGdpLnJlZ2lvbjFfY291bnQgJiYgZ2kucmVnaW9uMV9jb3VudCA8IDgpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnJlZ2lvbjBfY291bnQsIDQpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZWhlYWRlcihnZmMsIGdpLnJlZ2lvbjFfY291bnQsIDMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kuc2NhbGVmYWNfc2NhbGUsIDEpO1xuICAgICAgICAgICAgICAgIHdyaXRlaGVhZGVyKGdmYywgZ2kuY291bnQxdGFibGVfc2VsZWN0LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZnAuZXJyb3JfcHJvdGVjdGlvbikge1xuICAgICAgICAgICAgLyogKGpvKSBlcnJvcl9wcm90ZWN0aW9uOiBhZGQgY3JjMTYgaW5mb3JtYXRpb24gdG8gaGVhZGVyICovXG4gICAgICAgICAgICBDUkNfd3JpdGVoZWFkZXIoZ2ZjLCBnZmMuaGVhZGVyW2dmYy5oX3B0cl0uYnVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvbGQgPSBnZmMuaF9wdHI7XG4gICAgICAgICAgICBhc3NlcnQkMTcoZ2ZjLmhlYWRlcltvbGRdLnB0ciA9PSBnZmMuc2lkZWluZm9fbGVuICogOCk7XG5cbiAgICAgICAgICAgIGdmYy5oX3B0ciA9IChvbGQgKyAxKSAmIChMYW1lSW50ZXJuYWxGbGFnc18xLk1BWF9IRUFERVJfQlVGIC0gMSk7XG4gICAgICAgICAgICBnZmMuaGVhZGVyW2dmYy5oX3B0cl0ud3JpdGVfdGltaW5nID0gZ2ZjLmhlYWRlcltvbGRdLndyaXRlX3RpbWluZ1xuICAgICAgICAgICAgICAgICsgYml0c1BlckZyYW1lO1xuXG4gICAgICAgICAgICBpZiAoZ2ZjLmhfcHRyID09IGdmYy53X3B0cikge1xuICAgICAgICAgICAgICAgIC8qIHlpa2VzISB3ZSBhcmUgb3V0IG9mIGhlYWRlciBidWZmZXIgc3BhY2UgKi9cbiAgICAgICAgICAgICAgICBTeXN0ZW0kMTcuZXJyXG4gICAgICAgICAgICAgICAgICAgIC5wcmludGxuKFwiRXJyb3I6IE1BWF9IRUFERVJfQlVGIHRvbyBzbWFsbCBpbiBiaXRzdHJlYW0uYyBcXG5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1ZmZtYW5fY29kZXJfY291bnQxKGdmYywgZ2kpIHtcbiAgICAgICAgLyogV3JpdGUgY291bnQxIGFyZWEgKi9cbiAgICAgICAgdmFyIGggPSBUYWJsZXNfMS5odFtnaS5jb3VudDF0YWJsZV9zZWxlY3QgKyAzMl07XG4gICAgICAgIHZhciBpLCBiaXRzID0gMDtcblxuICAgICAgICB2YXIgaXggPSBnaS5iaWdfdmFsdWVzO1xuICAgICAgICB2YXIgeHIgPSBnaS5iaWdfdmFsdWVzO1xuICAgICAgICBhc3NlcnQkMTcoZ2kuY291bnQxdGFibGVfc2VsZWN0IDwgMik7XG5cbiAgICAgICAgZm9yIChpID0gKGdpLmNvdW50MSAtIGdpLmJpZ192YWx1ZXMpIC8gNDsgaSA+IDA7IC0taSkge1xuICAgICAgICAgICAgdmFyIGh1ZmZiaXRzID0gMDtcbiAgICAgICAgICAgIHZhciBwID0gMCwgdjtcblxuICAgICAgICAgICAgdiA9IGdpLmwzX2VuY1tpeCArIDBdO1xuICAgICAgICAgICAgaWYgKHYgIT0gMCkge1xuICAgICAgICAgICAgICAgIHAgKz0gODtcbiAgICAgICAgICAgICAgICBpZiAoZ2kueHJbeHIgKyAwXSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGh1ZmZiaXRzKys7XG4gICAgICAgICAgICAgICAgYXNzZXJ0JDE3KHYgPD0gMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHYgPSBnaS5sM19lbmNbaXggKyAxXTtcbiAgICAgICAgICAgIGlmICh2ICE9IDApIHtcbiAgICAgICAgICAgICAgICBwICs9IDQ7XG4gICAgICAgICAgICAgICAgaHVmZmJpdHMgKj0gMjtcbiAgICAgICAgICAgICAgICBpZiAoZ2kueHJbeHIgKyAxXSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGh1ZmZiaXRzKys7XG4gICAgICAgICAgICAgICAgYXNzZXJ0JDE3KHYgPD0gMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHYgPSBnaS5sM19lbmNbaXggKyAyXTtcbiAgICAgICAgICAgIGlmICh2ICE9IDApIHtcbiAgICAgICAgICAgICAgICBwICs9IDI7XG4gICAgICAgICAgICAgICAgaHVmZmJpdHMgKj0gMjtcbiAgICAgICAgICAgICAgICBpZiAoZ2kueHJbeHIgKyAyXSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGh1ZmZiaXRzKys7XG4gICAgICAgICAgICAgICAgYXNzZXJ0JDE3KHYgPD0gMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHYgPSBnaS5sM19lbmNbaXggKyAzXTtcbiAgICAgICAgICAgIGlmICh2ICE9IDApIHtcbiAgICAgICAgICAgICAgICBwKys7XG4gICAgICAgICAgICAgICAgaHVmZmJpdHMgKj0gMjtcbiAgICAgICAgICAgICAgICBpZiAoZ2kueHJbeHIgKyAzXSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGh1ZmZiaXRzKys7XG4gICAgICAgICAgICAgICAgYXNzZXJ0JDE3KHYgPD0gMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl4ICs9IDQ7XG4gICAgICAgICAgICB4ciArPSA0O1xuICAgICAgICAgICAgcHV0Yml0czIoZ2ZjLCBodWZmYml0cyArIGgudGFibGVbcF0sIGguaGxlbltwXSk7XG4gICAgICAgICAgICBiaXRzICs9IGguaGxlbltwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYml0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBwc2V1ZG9jb2RlIG9mIHBhZ2UgOTggb2YgdGhlIElTXG4gICAgICovXG4gICAgZnVuY3Rpb24gSHVmZm1hbmNvZGUoZ2ZjLCB0YWJsZWluZGV4LCBzdGFydCwgZW5kLCBnaSkge1xuICAgICAgICB2YXIgaCA9IFRhYmxlc18xLmh0W3RhYmxlaW5kZXhdO1xuICAgICAgICB2YXIgYml0cyA9IDA7XG5cbiAgICAgICAgYXNzZXJ0JDE3KHRhYmxlaW5kZXggPCAzMik7XG4gICAgICAgIGlmICgwID09IHRhYmxlaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcblxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIGNiaXRzID0gMDtcbiAgICAgICAgICAgIHZhciB4Yml0cyA9IDA7XG4gICAgICAgICAgICB2YXIgbGluYml0cyA9IGgueGxlbjtcbiAgICAgICAgICAgIHZhciB4bGVuID0gaC54bGVuO1xuICAgICAgICAgICAgdmFyIGV4dCA9IDA7XG4gICAgICAgICAgICB2YXIgeDEgPSBnaS5sM19lbmNbaV07XG4gICAgICAgICAgICB2YXIgeDIgPSBnaS5sM19lbmNbaSArIDFdO1xuXG4gICAgICAgICAgICBpZiAoeDEgIT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChnaS54cltpXSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGV4dCsrO1xuICAgICAgICAgICAgICAgIGNiaXRzLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YWJsZWluZGV4ID4gMTUpIHtcbiAgICAgICAgICAgICAgICAvKiB1c2UgRVNDLXdvcmRzICovXG4gICAgICAgICAgICAgICAgaWYgKHgxID4gMTQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmJpdHNfeDEgPSB4MSAtIDE1O1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQkMTcobGluYml0c194MSA8PSBoLmxpbm1heCk7XG4gICAgICAgICAgICAgICAgICAgIGV4dCB8PSBsaW5iaXRzX3gxIDw8IDE7XG4gICAgICAgICAgICAgICAgICAgIHhiaXRzID0gbGluYml0cztcbiAgICAgICAgICAgICAgICAgICAgeDEgPSAxNTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeDIgPiAxNCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluYml0c194MiA9IHgyIC0gMTU7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCQxNyhsaW5iaXRzX3gyIDw9IGgubGlubWF4KTtcbiAgICAgICAgICAgICAgICAgICAgZXh0IDw8PSBsaW5iaXRzO1xuICAgICAgICAgICAgICAgICAgICBleHQgfD0gbGluYml0c194MjtcbiAgICAgICAgICAgICAgICAgICAgeGJpdHMgKz0gbGluYml0cztcbiAgICAgICAgICAgICAgICAgICAgeDIgPSAxNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeGxlbiA9IDE2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeDIgIT0gMCkge1xuICAgICAgICAgICAgICAgIGV4dCA8PD0gMTtcbiAgICAgICAgICAgICAgICBpZiAoZ2kueHJbaSArIDFdIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZXh0Kys7XG4gICAgICAgICAgICAgICAgY2JpdHMtLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXNzZXJ0JDE3KCh4MSB8IHgyKSA8IDE2KTtcblxuICAgICAgICAgICAgeDEgPSB4MSAqIHhsZW4gKyB4MjtcbiAgICAgICAgICAgIHhiaXRzIC09IGNiaXRzO1xuICAgICAgICAgICAgY2JpdHMgKz0gaC5obGVuW3gxXTtcblxuICAgICAgICAgICAgYXNzZXJ0JDE3KGNiaXRzIDw9IE1BWF9MRU5HVEgpO1xuICAgICAgICAgICAgYXNzZXJ0JDE3KHhiaXRzIDw9IE1BWF9MRU5HVEgpO1xuXG4gICAgICAgICAgICBwdXRiaXRzMihnZmMsIGgudGFibGVbeDFdLCBjYml0cyk7XG4gICAgICAgICAgICBwdXRiaXRzMihnZmMsIGV4dCwgeGJpdHMpO1xuICAgICAgICAgICAgYml0cyArPSBjYml0cyArIHhiaXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGUgdGhlIGRpc2N1c3Npb24gb2YgaHVmZm1hbmNvZGViaXRzKCkgb24gcGFnZXMgMjggYW5kIDI5IG9mIHRoZSBJUywgYXNcbiAgICAgKiB3ZWxsIGFzIHRoZSBkZWZpbml0aW9ucyBvZiB0aGUgc2lkZSBpbmZvcm1hdGlvbiBvbiBwYWdlcyAyNiBhbmQgMjcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2hvcnRIdWZmbWFuY29kZWJpdHMoZ2ZjLCBnaSkge1xuICAgICAgICB2YXIgcmVnaW9uMVN0YXJ0ID0gMyAqIGdmYy5zY2FsZWZhY19iYW5kLnNbM107XG4gICAgICAgIGlmIChyZWdpb24xU3RhcnQgPiBnaS5iaWdfdmFsdWVzKVxuICAgICAgICAgICAgcmVnaW9uMVN0YXJ0ID0gZ2kuYmlnX3ZhbHVlcztcblxuICAgICAgICAvKiBzaG9ydCBibG9ja3MgZG8gbm90IGhhdmUgYSByZWdpb24yICovXG4gICAgICAgIHZhciBiaXRzID0gSHVmZm1hbmNvZGUoZ2ZjLCBnaS50YWJsZV9zZWxlY3RbMF0sIDAsIHJlZ2lvbjFTdGFydCwgZ2kpO1xuICAgICAgICBiaXRzICs9IEh1ZmZtYW5jb2RlKGdmYywgZ2kudGFibGVfc2VsZWN0WzFdLCByZWdpb24xU3RhcnQsXG4gICAgICAgICAgICBnaS5iaWdfdmFsdWVzLCBnaSk7XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvbmdIdWZmbWFuY29kZWJpdHMoZ2ZjLCBnaSkge1xuICAgICAgICB2YXIgYmlndmFsdWVzLCBiaXRzO1xuICAgICAgICB2YXIgcmVnaW9uMVN0YXJ0LCByZWdpb24yU3RhcnQ7XG5cbiAgICAgICAgYmlndmFsdWVzID0gZ2kuYmlnX3ZhbHVlcztcbiAgICAgICAgYXNzZXJ0JDE3KDAgPD0gYmlndmFsdWVzICYmIGJpZ3ZhbHVlcyA8PSA1NzYpO1xuXG4gICAgICAgIHZhciBpID0gZ2kucmVnaW9uMF9jb3VudCArIDE7XG4gICAgICAgIGFzc2VydCQxNygwIDw9IGkpO1xuICAgICAgICBhc3NlcnQkMTcoaSA8IGdmYy5zY2FsZWZhY19iYW5kLmwubGVuZ3RoKTtcbiAgICAgICAgcmVnaW9uMVN0YXJ0ID0gZ2ZjLnNjYWxlZmFjX2JhbmQubFtpXTtcbiAgICAgICAgaSArPSBnaS5yZWdpb24xX2NvdW50ICsgMTtcbiAgICAgICAgYXNzZXJ0JDE3KDAgPD0gaSk7XG4gICAgICAgIGFzc2VydCQxNyhpIDwgZ2ZjLnNjYWxlZmFjX2JhbmQubC5sZW5ndGgpO1xuICAgICAgICByZWdpb24yU3RhcnQgPSBnZmMuc2NhbGVmYWNfYmFuZC5sW2ldO1xuXG4gICAgICAgIGlmIChyZWdpb24xU3RhcnQgPiBiaWd2YWx1ZXMpXG4gICAgICAgICAgICByZWdpb24xU3RhcnQgPSBiaWd2YWx1ZXM7XG5cbiAgICAgICAgaWYgKHJlZ2lvbjJTdGFydCA+IGJpZ3ZhbHVlcylcbiAgICAgICAgICAgIHJlZ2lvbjJTdGFydCA9IGJpZ3ZhbHVlcztcblxuICAgICAgICBiaXRzID0gSHVmZm1hbmNvZGUoZ2ZjLCBnaS50YWJsZV9zZWxlY3RbMF0sIDAsIHJlZ2lvbjFTdGFydCwgZ2kpO1xuICAgICAgICBiaXRzICs9IEh1ZmZtYW5jb2RlKGdmYywgZ2kudGFibGVfc2VsZWN0WzFdLCByZWdpb24xU3RhcnQsXG4gICAgICAgICAgICByZWdpb24yU3RhcnQsIGdpKTtcbiAgICAgICAgYml0cyArPSBIdWZmbWFuY29kZShnZmMsIGdpLnRhYmxlX3NlbGVjdFsyXSwgcmVnaW9uMlN0YXJ0LCBiaWd2YWx1ZXMsXG4gICAgICAgICAgICBnaSk7XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyaXRlTWFpbkRhdGEoZ2ZwKSB7XG4gICAgICAgIHZhciBnciwgY2gsIHNmYiwgZGF0YV9iaXRzLCB0b3RfYml0cyA9IDA7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBsM19zaWRlID0gZ2ZjLmwzX3NpZGU7XG5cbiAgICAgICAgaWYgKGdmcC52ZXJzaW9uID09IDEpIHtcbiAgICAgICAgICAgIC8qIE1QRUcgMSAqL1xuICAgICAgICAgICAgZm9yIChnciA9IDA7IGdyIDwgMjsgZ3IrKykge1xuICAgICAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdpID0gbDNfc2lkZS50dFtncl1bY2hdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xlbjEgPSBUYWtlaGlyb18xLnNsZW4xX3RhYltnaS5zY2FsZWZhY19jb21wcmVzc107XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGVuMiA9IFRha2VoaXJvXzEuc2xlbjJfdGFiW2dpLnNjYWxlZmFjX2NvbXByZXNzXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YV9iaXRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChzZmIgPSAwOyBzZmIgPCBnaS5zZmJkaXZpZGU7IHNmYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2kuc2NhbGVmYWNbc2ZiXSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIHNjZnNpIGlzIHVzZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dGJpdHMyKGdmYywgZ2kuc2NhbGVmYWNbc2ZiXSwgc2xlbjEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV9iaXRzICs9IHNsZW4xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBzZmIgPCBnaS5zZmJtYXg7IHNmYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2kuc2NhbGVmYWNbc2ZiXSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIHNjZnNpIGlzIHVzZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dGJpdHMyKGdmYywgZ2kuc2NhbGVmYWNbc2ZiXSwgc2xlbjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV9iaXRzICs9IHNsZW4yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCQxNyhkYXRhX2JpdHMgPT0gZ2kucGFydDJfbGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2kuYmxvY2tfdHlwZSA9PSBFbmNvZGVyXzEuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV9iaXRzICs9IFNob3J0SHVmZm1hbmNvZGViaXRzKGdmYywgZ2kpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV9iaXRzICs9IExvbmdIdWZmbWFuY29kZWJpdHMoZ2ZjLCBnaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YV9iaXRzICs9IGh1ZmZtYW5fY29kZXJfY291bnQxKGdmYywgZ2kpO1xuICAgICAgICAgICAgICAgICAgICAvKiBkb2VzIGJpdGNvdW50IGluIHF1YW50aXplLmMgYWdyZWUgd2l0aCBhY3R1YWwgYml0IGNvdW50PyAqL1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQkMTcoZGF0YV9iaXRzID09IGdpLnBhcnQyXzNfbGVuZ3RoICsgZ2kucGFydDJfbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdG90X2JpdHMgKz0gZGF0YV9iaXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBmb3IgY2ggKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGZvciBnciAqL1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogTVBFRyAyICovXG4gICAgICAgICAgICBnciA9IDA7XG4gICAgICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdpID0gbDNfc2lkZS50dFtncl1bY2hdO1xuICAgICAgICAgICAgICAgIHZhciBpLCBzZmJfcGFydGl0aW9uLCBzY2FsZV9iaXRzID0gMDtcbiAgICAgICAgICAgICAgICBhc3NlcnQkMTcoZ2kuc2ZiX3BhcnRpdGlvbl90YWJsZSAhPSBudWxsKTtcbiAgICAgICAgICAgICAgICBkYXRhX2JpdHMgPSAwO1xuICAgICAgICAgICAgICAgIHNmYiA9IDA7XG4gICAgICAgICAgICAgICAgc2ZiX3BhcnRpdGlvbiA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2kuYmxvY2tfdHlwZSA9PSBFbmNvZGVyXzEuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgc2ZiX3BhcnRpdGlvbiA8IDQ7IHNmYl9wYXJ0aXRpb24rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNmYnMgPSBnaS5zZmJfcGFydGl0aW9uX3RhYmxlW3NmYl9wYXJ0aXRpb25dIC8gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbGVuID0gZ2kuc2xlbltzZmJfcGFydGl0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZmJzOyBpKyssIHNmYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0Yml0czIoZ2ZjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChnaS5zY2FsZWZhY1tzZmIgKiAzICsgMF0sIDApLCBzbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRiaXRzMihnZmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGdpLnNjYWxlZmFjW3NmYiAqIDMgKyAxXSwgMCksIHNsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dGJpdHMyKGdmYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZ2kuc2NhbGVmYWNbc2ZiICogMyArIDJdLCAwKSwgc2xlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVfYml0cyArPSAzICogc2xlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhX2JpdHMgKz0gU2hvcnRIdWZmbWFuY29kZWJpdHMoZ2ZjLCBnaSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHNmYl9wYXJ0aXRpb24gPCA0OyBzZmJfcGFydGl0aW9uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZmJzID0gZ2kuc2ZiX3BhcnRpdGlvbl90YWJsZVtzZmJfcGFydGl0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbGVuID0gZ2kuc2xlbltzZmJfcGFydGl0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZmJzOyBpKyssIHNmYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0Yml0czIoZ2ZjLCBNYXRoLm1heChnaS5zY2FsZWZhY1tzZmJdLCAwKSwgc2xlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVfYml0cyArPSBzbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGFfYml0cyArPSBMb25nSHVmZm1hbmNvZGViaXRzKGdmYywgZ2kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhX2JpdHMgKz0gaHVmZm1hbl9jb2Rlcl9jb3VudDEoZ2ZjLCBnaSk7XG4gICAgICAgICAgICAgICAgLyogZG9lcyBiaXRjb3VudCBpbiBxdWFudGl6ZS5jIGFncmVlIHdpdGggYWN0dWFsIGJpdCBjb3VudD8gKi9cbiAgICAgICAgICAgICAgICBhc3NlcnQkMTcoZGF0YV9iaXRzID09IGdpLnBhcnQyXzNfbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQkMTcoc2NhbGVfYml0cyA9PSBnaS5wYXJ0Ml9sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdF9iaXRzICs9IHNjYWxlX2JpdHMgKyBkYXRhX2JpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmb3IgY2ggKi9cbiAgICAgICAgfVxuICAgICAgICAvKiBmb3IgZ2YgKi9cbiAgICAgICAgcmV0dXJuIHRvdF9iaXRzO1xuICAgIH1cblxuICAgIC8qIG1haW5fZGF0YSAqL1xuXG4gICAgZnVuY3Rpb24gVG90YWxCeXRlcygpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IDA7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBjb21wdXRlIHRoZSBudW1iZXIgb2YgYml0cyByZXF1aXJlZCB0byBmbHVzaCBhbGwgbXAzIGZyYW1lcyBjdXJyZW50bHkgaW5cbiAgICAgKiB0aGUgYnVmZmVyLiBUaGlzIHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGUgcmVzZXJ2b2lyIHNpemUuIE9ubHkgY2FsbCB0aGlzXG4gICAgICogcm91dGluZSBiZXR3ZWVuIGZyYW1lcyAtIGkuZS4gb25seSBhZnRlciBhbGwgaGVhZGVycyBhbmQgZGF0YSBoYXZlIGJlZW5cbiAgICAgKiBhZGRlZCB0byB0aGUgYnVmZmVyIGJ5IGZvcm1hdF9iaXRzdHJlYW0oKS5cbiAgICAgKlxuICAgICAqIEFsc28gY29tcHV0ZSB0b3RhbF9iaXRzX291dHB1dCA9IHNpemUgb2YgbXAzIGJ1ZmZlciAoaW5jbHVkaW5nIGZyYW1lXG4gICAgICogaGVhZGVycyB3aGljaCBtYXkgbm90IGhhdmUgeWV0IGJlZW4gc2VuZCB0byB0aGUgbXAzIGJ1ZmZlcikgKyBudW1iZXIgb2ZcbiAgICAgKiBiaXRzIG5lZWRlZCB0byBmbHVzaCBhbGwgbXAzIGZyYW1lcy5cbiAgICAgKlxuICAgICAqIHRvdGFsX2J5dGVzX291dHB1dCBpcyB0aGUgc2l6ZSBvZiB0aGUgbXAzIG91dHB1dCBidWZmZXIgaWZcbiAgICAgKiBsYW1lX2VuY29kZV9mbHVzaF9ub2dhcCgpIHdhcyBjYWxsZWQgcmlnaHQgbm93LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXB1dGVfZmx1c2hiaXRzKGdmcCwgdG90YWxfYnl0ZXNfb3V0cHV0KSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBmbHVzaGJpdHMsIHJlbWFpbmluZ19oZWFkZXJzO1xuICAgICAgICB2YXIgYml0c1BlckZyYW1lO1xuICAgICAgICB2YXIgbGFzdF9wdHIsIGZpcnN0X3B0cjtcbiAgICAgICAgZmlyc3RfcHRyID0gZ2ZjLndfcHRyO1xuICAgICAgICAvKiBmaXJzdCBoZWFkZXIgdG8gYWRkIHRvIGJpdHN0cmVhbSAqL1xuICAgICAgICBsYXN0X3B0ciA9IGdmYy5oX3B0ciAtIDE7XG4gICAgICAgIC8qIGxhc3QgaGVhZGVyIHRvIGFkZCB0byBiaXRzdHJlYW0gKi9cbiAgICAgICAgaWYgKGxhc3RfcHRyID09IC0xKVxuICAgICAgICAgICAgbGFzdF9wdHIgPSBMYW1lSW50ZXJuYWxGbGFnc18xLk1BWF9IRUFERVJfQlVGIC0gMTtcblxuICAgICAgICAvKiBhZGQgdGhpcyBtYW55IGJpdHMgdG8gYml0c3RyZWFtIHNvIHdlIGNhbiBmbHVzaCBhbGwgaGVhZGVycyAqL1xuICAgICAgICBmbHVzaGJpdHMgPSBnZmMuaGVhZGVyW2xhc3RfcHRyXS53cml0ZV90aW1pbmcgLSB0b3RiaXQ7XG4gICAgICAgIHRvdGFsX2J5dGVzX291dHB1dC50b3RhbCA9IGZsdXNoYml0cztcblxuICAgICAgICBpZiAoZmx1c2hiaXRzID49IDApIHtcbiAgICAgICAgICAgIC8qIGlmIGZsdXNoYml0cyA+PSAwLCBzb21lIGhlYWRlcnMgaGF2ZSBub3QgeWV0IGJlZW4gd3JpdHRlbiAqL1xuICAgICAgICAgICAgLyogcmVkdWNlIGZsdXNoYml0cyBieSB0aGUgc2l6ZSBvZiB0aGUgaGVhZGVycyAqL1xuICAgICAgICAgICAgcmVtYWluaW5nX2hlYWRlcnMgPSAxICsgbGFzdF9wdHIgLSBmaXJzdF9wdHI7XG4gICAgICAgICAgICBpZiAobGFzdF9wdHIgPCBmaXJzdF9wdHIpXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nX2hlYWRlcnMgPSAxICsgbGFzdF9wdHIgLSBmaXJzdF9wdHJcbiAgICAgICAgICAgICAgICAgICAgKyBMYW1lSW50ZXJuYWxGbGFnc18xLk1BWF9IRUFERVJfQlVGO1xuICAgICAgICAgICAgZmx1c2hiaXRzIC09IHJlbWFpbmluZ19oZWFkZXJzICogOCAqIGdmYy5zaWRlaW5mb19sZW47XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBmaW5hbGx5LCBhZGQgc29tZSBiaXRzIHNvIHRoYXQgdGhlIGxhc3QgZnJhbWUgaXMgY29tcGxldGUgdGhlc2UgYml0c1xuICAgICAgICAgKiBhcmUgbm90IG5lY2Vzc2FyeSB0byBkZWNvZGUgdGhlIGxhc3QgZnJhbWUsIGJ1dCBzb21lIGRlY29kZXJzIHdpbGxcbiAgICAgICAgICogaWdub3JlIGxhc3QgZnJhbWUgaWYgdGhlc2UgYml0cyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgYml0c1BlckZyYW1lID0gc2VsZi5nZXRmcmFtZWJpdHMoZ2ZwKTtcbiAgICAgICAgZmx1c2hiaXRzICs9IGJpdHNQZXJGcmFtZTtcbiAgICAgICAgdG90YWxfYnl0ZXNfb3V0cHV0LnRvdGFsICs9IGJpdHNQZXJGcmFtZTtcbiAgICAgICAgLyogcm91bmQgdXA6ICovXG4gICAgICAgIGlmICgodG90YWxfYnl0ZXNfb3V0cHV0LnRvdGFsICUgOCkgIT0gMClcbiAgICAgICAgICAgIHRvdGFsX2J5dGVzX291dHB1dC50b3RhbCA9IDEgKyAodG90YWxfYnl0ZXNfb3V0cHV0LnRvdGFsIC8gOCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRvdGFsX2J5dGVzX291dHB1dC50b3RhbCA9ICh0b3RhbF9ieXRlc19vdXRwdXQudG90YWwgLyA4KTtcbiAgICAgICAgdG90YWxfYnl0ZXNfb3V0cHV0LnRvdGFsICs9IGJ1ZkJ5dGVJZHggKyAxO1xuXG4gICAgICAgIGlmIChmbHVzaGJpdHMgPCAwKSB7XG4gICAgICAgICAgICBTeXN0ZW0kMTcuZXJyLnByaW50bG4oXCJzdHJhbmdlIGVycm9yIGZsdXNoaW5nIGJ1ZmZlciAuLi4gXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbHVzaGJpdHM7XG4gICAgfVxuXG4gICAgdGhpcy5mbHVzaF9iaXRzdHJlYW0gPSBmdW5jdGlvbiAoZ2ZwKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBsM19zaWRlO1xuICAgICAgICB2YXIgZmx1c2hiaXRzO1xuICAgICAgICB2YXIgbGFzdF9wdHIgPSBnZmMuaF9wdHIgLSAxO1xuICAgICAgICAvKiBsYXN0IGhlYWRlciB0byBhZGQgdG8gYml0c3RyZWFtICovXG4gICAgICAgIGlmIChsYXN0X3B0ciA9PSAtMSlcbiAgICAgICAgICAgIGxhc3RfcHRyID0gTGFtZUludGVybmFsRmxhZ3NfMS5NQVhfSEVBREVSX0JVRiAtIDE7XG4gICAgICAgIGwzX3NpZGUgPSBnZmMubDNfc2lkZTtcblxuICAgICAgICBpZiAoKGZsdXNoYml0cyA9IGNvbXB1dGVfZmx1c2hiaXRzKGdmcCwgbmV3IFRvdGFsQnl0ZXMoKSkpIDwgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZHJhaW5faW50b19hbmNpbGxhcnkoZ2ZwLCBmbHVzaGJpdHMpO1xuXG4gICAgICAgIC8qIGNoZWNrIHRoYXQgdGhlIDEwMCUgb2YgdGhlIGxhc3QgZnJhbWUgaGFzIGJlZW4gd3JpdHRlbiB0byBiaXRzdHJlYW0gKi9cbiAgICAgICAgYXNzZXJ0JDE3KGdmYy5oZWFkZXJbbGFzdF9wdHJdLndyaXRlX3RpbWluZyArIHRoaXMuZ2V0ZnJhbWViaXRzKGdmcCkgPT0gdG90Yml0KTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiB3ZSBoYXZlIHBhZGRlZCBvdXQgYWxsIGZyYW1lcyB3aXRoIGFuY2lsbGFyeSBkYXRhLCB3aGljaCBpcyB0aGUgc2FtZVxuICAgICAgICAgKiBhcyBmaWxsaW5nIHRoZSBiaXRyZXNlcnZvaXIgd2l0aCBhbmNpbGxhcnkgZGF0YSwgc28gOlxuICAgICAgICAgKi9cbiAgICAgICAgZ2ZjLlJlc3ZTaXplID0gMDtcbiAgICAgICAgbDNfc2lkZS5tYWluX2RhdGFfYmVnaW4gPSAwO1xuXG4gICAgICAgIC8qIHNhdmUgdGhlIFJlcGxheUdhaW4gdmFsdWUgKi9cbiAgICAgICAgaWYgKGdmYy5maW5kUmVwbGF5R2Fpbikge1xuICAgICAgICAgICAgdmFyIFJhZGlvR2FpbiA9IGdhLkdldFRpdGxlR2FpbihnZmMucmdkYXRhKTtcbiAgICAgICAgICAgIGFzc2VydCQxNyhORVEoUmFkaW9HYWluLCBHYWluQW5hbHlzaXMuR0FJTl9OT1RfRU5PVUdIX1NBTVBMRVMpKTtcbiAgICAgICAgICAgIGdmYy5SYWRpb0dhaW4gPSBNYXRoLmZsb29yKFJhZGlvR2FpbiAqIDEwLjAgKyAwLjUpIHwgMDtcbiAgICAgICAgICAgIC8qIHJvdW5kIHRvIG5lYXJlc3QgKi9cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGZpbmQgdGhlIGdhaW4gYW5kIHNjYWxlIGNoYW5nZSByZXF1aXJlZCBmb3Igbm8gY2xpcHBpbmcgKi9cbiAgICAgICAgaWYgKGdmYy5maW5kUGVha1NhbXBsZSkge1xuICAgICAgICAgICAgZ2ZjLm5vY2xpcEdhaW5DaGFuZ2UgPSBNYXRoLmNlaWwoTWF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLmxvZzEwKGdmYy5QZWFrU2FtcGxlIC8gMzI3NjcuMCkgKiAyMC4wICogMTAuMCkgfCAwO1xuICAgICAgICAgICAgLyogcm91bmQgdXAgKi9cblxuICAgICAgICAgICAgaWYgKGdmYy5ub2NsaXBHYWluQ2hhbmdlID4gMCkge1xuICAgICAgICAgICAgICAgIC8qIGNsaXBwaW5nIG9jY3VycyAqL1xuICAgICAgICAgICAgICAgIGlmIChFUShnZnAuc2NhbGUsIDEuMCkgfHwgRVEoZ2ZwLnNjYWxlLCAwLjApKVxuICAgICAgICAgICAgICAgICAgICBnZmMubm9jbGlwU2NhbGUgPSAoTWF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLmZsb29yKCgzMjc2Ny4wIC8gZ2ZjLlBlYWtTYW1wbGUpICogMTAwLjApIC8gMTAwLjApO1xuICAgICAgICAgICAgICAgIC8qIHJvdW5kIGRvd24gKi9cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIHVzZXIgc3BlY2lmaWVkIGhpcyBvd24gc2NhbGluZyBmYWN0b3IuIFdlIGNvdWxkXG4gICAgICAgICAgICAgICAgICAgICAqIHN1Z2dlc3QgdGhlIHNjYWxpbmcgZmFjdG9yIG9mXG4gICAgICAgICAgICAgICAgICAgICAqICgzMjc2Ny4wL2dmcC5QZWFrU2FtcGxlKSooZ2ZwLnNjYWxlKSBidXQgaXQncyB1c3VhbGx5XG4gICAgICAgICAgICAgICAgICAgICAqIHZlcnkgaW5hY2N1cmF0ZS4gU28gd2UnZCByYXRoZXIgbm90IGFkdmljZSBoaW0gb24gdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIHNjYWxpbmcgZmFjdG9yLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgZ2ZjLm5vY2xpcFNjYWxlID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAvKiBubyBjbGlwcGluZyAqL1xuICAgICAgICAgICAgICAgIGdmYy5ub2NsaXBTY2FsZSA9IC0xO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuYWRkX2R1bW15X2J5dGUgPSBmdW5jdGlvbiAoZ2ZwLCB2YWwsIG4pIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICAgICAgICAgIHB1dGJpdHNfbm9oZWFkZXJzKGdmYywgdmFsLCA4KTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IExhbWVJbnRlcm5hbEZsYWdzXzEuTUFYX0hFQURFUl9CVUY7ICsraSlcbiAgICAgICAgICAgICAgICBnZmMuaGVhZGVyW2ldLndyaXRlX3RpbWluZyArPSA4O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGFmdGVyIGEgZnJhbWUgb2YgYXVkaW8gaGFzIGJlZW4gcXVhbnRpemVkIGFuZCBjb2RlZC4gSXRcbiAgICAgKiB3aWxsIHdyaXRlIHRoZSBlbmNvZGVkIGF1ZGlvIHRvIHRoZSBiaXRzdHJlYW0uIE5vdGUgdGhhdCBmcm9tIGEgbGF5ZXIzXG4gICAgICogZW5jb2RlcidzIHBlcnNwZWN0aXZlIHRoZSBiaXQgc3RyZWFtIGlzIHByaW1hcmlseSBhIHNlcmllcyBvZiBtYWluX2RhdGEoKVxuICAgICAqIGJsb2Nrcywgd2l0aCBoZWFkZXIgYW5kIHNpZGUgaW5mb3JtYXRpb24gaW5zZXJ0ZWQgYXQgdGhlIHByb3BlciBsb2NhdGlvbnNcbiAgICAgKiB0byBtYWludGFpbiBmcmFtaW5nLiAoU2VlIEZpZ3VyZSBBLjcgaW4gdGhlIElTKS5cbiAgICAgKi9cbiAgICB0aGlzLmZvcm1hdF9iaXRzdHJlYW0gPSBmdW5jdGlvbiAoZ2ZwKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBsM19zaWRlO1xuICAgICAgICBsM19zaWRlID0gZ2ZjLmwzX3NpZGU7XG5cbiAgICAgICAgdmFyIGJpdHNQZXJGcmFtZSA9IHRoaXMuZ2V0ZnJhbWViaXRzKGdmcCk7XG4gICAgICAgIGRyYWluX2ludG9fYW5jaWxsYXJ5KGdmcCwgbDNfc2lkZS5yZXN2RHJhaW5fcHJlKTtcblxuICAgICAgICBlbmNvZGVTaWRlSW5mbzIoZ2ZwLCBiaXRzUGVyRnJhbWUpO1xuICAgICAgICB2YXIgYml0cyA9IDggKiBnZmMuc2lkZWluZm9fbGVuO1xuICAgICAgICBiaXRzICs9IHdyaXRlTWFpbkRhdGEoZ2ZwKTtcbiAgICAgICAgZHJhaW5faW50b19hbmNpbGxhcnkoZ2ZwLCBsM19zaWRlLnJlc3ZEcmFpbl9wb3N0KTtcbiAgICAgICAgYml0cyArPSBsM19zaWRlLnJlc3ZEcmFpbl9wb3N0O1xuXG4gICAgICAgIGwzX3NpZGUubWFpbl9kYXRhX2JlZ2luICs9IChiaXRzUGVyRnJhbWUgLSBiaXRzKSAvIDg7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogY29tcGFyZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gY2xlYXIgYWxsIGJ1ZmZlcmVkIG1wMyBmcmFtZXMgd2l0aFxuICAgICAgICAgKiB3aGF0IHdlIHRoaW5rIHRoZSByZXN2c2l6ZSBpczpcbiAgICAgICAgICovXG4gICAgICAgIGlmIChjb21wdXRlX2ZsdXNoYml0cyhnZnAsIG5ldyBUb3RhbEJ5dGVzKCkpICE9IGdmYy5SZXN2U2l6ZSkge1xuICAgICAgICAgICAgU3lzdGVtJDE3LmVyci5wcmludGxuKFwiSW50ZXJuYWwgYnVmZmVyIGluY29uc2lzdGVuY3kuIGZsdXNoYml0cyA8PiBSZXN2U2l6ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGNvbXBhcmUgbWFpbl9kYXRhX2JlZ2luIGZvciB0aGUgbmV4dCBmcmFtZSB3aXRoIHdoYXQgd2UgdGhpbmsgdGhlXG4gICAgICAgICAqIHJlc3ZzaXplIGlzOlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKChsM19zaWRlLm1haW5fZGF0YV9iZWdpbiAqIDgpICE9IGdmYy5SZXN2U2l6ZSkge1xuICAgICAgICAgICAgU3lzdGVtJDE3LmVyci5wcmludGYoXCJiaXQgcmVzZXJ2b2lyIGVycm9yOiBcXG5cIlxuICAgICAgICAgICAgICAgICsgXCJsM19zaWRlLm1haW5fZGF0YV9iZWdpbjogJWQgXFxuXCJcbiAgICAgICAgICAgICAgICArIFwiUmVzdm9pciBzaXplOiAgICAgICAgICAgICAlZCBcXG5cIlxuICAgICAgICAgICAgICAgICsgXCJyZXN2IGRyYWluIChwb3N0KSAgICAgICAgICVkIFxcblwiXG4gICAgICAgICAgICAgICAgKyBcInJlc3YgZHJhaW4gKHByZSkgICAgICAgICAgJWQgXFxuXCJcbiAgICAgICAgICAgICAgICArIFwiaGVhZGVyIGFuZCBzaWRlaW5mbzogICAgICAlZCBcXG5cIlxuICAgICAgICAgICAgICAgICsgXCJkYXRhIGJpdHM6ICAgICAgICAgICAgICAgICVkIFxcblwiXG4gICAgICAgICAgICAgICAgKyBcInRvdGFsIGJpdHM6ICAgICAgICAgICAgICAgJWQgKHJlbWFpbmRlcjogJWQpIFxcblwiXG4gICAgICAgICAgICAgICAgKyBcImJpdHNwZXJmcmFtZTogICAgICAgICAgICAgJWQgXFxuXCIsXG4gICAgICAgICAgICAgICAgOCAqIGwzX3NpZGUubWFpbl9kYXRhX2JlZ2luLCBnZmMuUmVzdlNpemUsXG4gICAgICAgICAgICAgICAgbDNfc2lkZS5yZXN2RHJhaW5fcG9zdCwgbDNfc2lkZS5yZXN2RHJhaW5fcHJlLFxuICAgICAgICAgICAgICAgIDggKiBnZmMuc2lkZWluZm9fbGVuLCBiaXRzIC0gbDNfc2lkZS5yZXN2RHJhaW5fcG9zdCAtIDhcbiAgICAgICAgICAgICAgICAqIGdmYy5zaWRlaW5mb19sZW4sIGJpdHMsIGJpdHMgJSA4LCBiaXRzUGVyRnJhbWUpO1xuXG4gICAgICAgICAgICBTeXN0ZW0kMTcuZXJyLnByaW50bG4oXCJUaGlzIGlzIGEgZmF0YWwgZXJyb3IuICBJdCBoYXMgc2V2ZXJhbCBwb3NzaWJsZSBjYXVzZXM6XCIpO1xuICAgICAgICAgICAgU3lzdGVtJDE3LmVyci5wcmludGxuKFwiOTAlJSAgTEFNRSBjb21waWxlZCB3aXRoIGJ1Z2d5IHZlcnNpb24gb2YgZ2NjIHVzaW5nIGFkdmFuY2VkIG9wdGltaXphdGlvbnNcIik7XG4gICAgICAgICAgICBTeXN0ZW0kMTcuZXJyLnByaW50bG4oXCIgOSUlICBZb3VyIHN5c3RlbSBpcyBvdmVyY2xvY2tlZFwiKTtcbiAgICAgICAgICAgIFN5c3RlbSQxNy5lcnIucHJpbnRsbihcIiAxJSUgIGJ1ZyBpbiBMQU1FIGVuY29kaW5nIGxpYnJhcnlcIik7XG5cbiAgICAgICAgICAgIGdmYy5SZXN2U2l6ZSA9IGwzX3NpZGUubWFpbl9kYXRhX2JlZ2luICogODtcbiAgICAgICAgfVxuICAgICAgICAvLztcbiAgICAgICAgYXNzZXJ0JDE3KHRvdGJpdCAlIDggPT0gMCk7XG5cbiAgICAgICAgaWYgKHRvdGJpdCA+IDEwMDAwMDAwMDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiB0byBhdm9pZCB0b3RiaXQgb3ZlcmZsb3csIChhdCA4aCBlbmNvZGluZyBhdCAxMjhrYnMpIGxldHMgcmVzZXRcbiAgICAgICAgICAgICAqIGJpdCBjb3VudGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IExhbWVJbnRlcm5hbEZsYWdzXzEuTUFYX0hFQURFUl9CVUY7ICsraSlcbiAgICAgICAgICAgICAgICBnZmMuaGVhZGVyW2ldLndyaXRlX3RpbWluZyAtPSB0b3RiaXQ7XG4gICAgICAgICAgICB0b3RiaXQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIDxQUkU+XG4gICAgICogY29weSBkYXRhIG91dCBvZiB0aGUgaW50ZXJuYWwgTVAzIGJpdCBidWZmZXIgaW50byBhIHVzZXIgc3VwcGxpZWRcbiAgICAgKiAgICAgICB1bnNpZ25lZCBjaGFyIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqICAgICAgIG1wM2RhdGE9MCAgICAgIGluZGljYXRlcyBkYXRhIGluIGJ1ZmZlciBpcyBhbiBpZDN0YWdzIGFuZCBWQlIgdGFnc1xuICAgICAqICAgICAgIG1wM2RhdGE9MSAgICAgIGRhdGEgaXMgcmVhbCBtcDMgZnJhbWUgZGF0YS5cbiAgICAgKiA8L1BSRT5cbiAgICAgKi9cbiAgICB0aGlzLmNvcHlfYnVmZmVyID0gZnVuY3Rpb24gKGdmYywgYnVmZmVyLCBidWZmZXJQb3MsIHNpemUsIG1wM2RhdGEpIHtcbiAgICAgICAgdmFyIG1pbmltdW0gPSBidWZCeXRlSWR4ICsgMTtcbiAgICAgICAgaWYgKG1pbmltdW0gPD0gMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBpZiAoc2l6ZSAhPSAwICYmIG1pbmltdW0gPiBzaXplKSB7XG4gICAgICAgICAgICAvKiBidWZmZXIgaXMgdG9vIHNtYWxsICovXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgU3lzdGVtJDE3LmFycmF5Y29weShidWYsIDAsIGJ1ZmZlciwgYnVmZmVyUG9zLCBtaW5pbXVtKTtcbiAgICAgICAgYnVmQnl0ZUlkeCA9IC0xO1xuICAgICAgICBidWZCaXRJZHggPSAwO1xuXG4gICAgICAgIGlmIChtcDNkYXRhICE9IDApIHtcbiAgICAgICAgICAgIHZhciBjcmMgPSBuZXdfaW50JDE3KDEpO1xuICAgICAgICAgICAgY3JjWzBdID0gZ2ZjLm5NdXNpY0NSQztcbiAgICAgICAgICAgIHZici51cGRhdGVNdXNpY0NSQyhjcmMsIGJ1ZmZlciwgYnVmZmVyUG9zLCBtaW5pbXVtKTtcbiAgICAgICAgICAgIGdmYy5uTXVzaWNDUkMgPSBjcmNbMF07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc3VtIG51bWJlciBvZiBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIG1wMyBzdHJlYW0gdGhpcyBpbmZvIHdpbGwgYmVcbiAgICAgICAgICAgICAqIHdyaXR0ZW4gaW50byB0aGUgWGluZy9MQU1FIGhlYWRlciBmb3Igc2Vla2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobWluaW11bSA+IDApIHtcbiAgICAgICAgICAgICAgICBnZmMuVkJSX3NlZWtfdGFibGUubkJ5dGVzV3JpdHRlbiArPSBtaW5pbXVtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2ZjLmRlY29kZV9vbl90aGVfZmx5KSB7IC8qIGRlY29kZSB0aGUgZnJhbWUgKi9cbiAgICAgICAgICAgICAgICB2YXIgcGNtX2J1ZiA9IG5ld19mbG9hdF9uJDE3KFsyLCAxMTUyXSk7XG4gICAgICAgICAgICAgICAgdmFyIG1wM19pbiA9IG1pbmltdW07XG4gICAgICAgICAgICAgICAgdmFyIHNhbXBsZXNfb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgICAgICAvKiByZS1zeW50aGVzaXMgdG8gcGNtLiBSZXBlYXQgdW50aWwgd2UgZ2V0IGEgc2FtcGxlc19vdXQ9MCAqL1xuICAgICAgICAgICAgICAgIHdoaWxlIChzYW1wbGVzX291dCAhPSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlc19vdXQgPSBtcGcuaGlwX2RlY29kZTFfdW5jbGlwcGVkKGdmYy5oaXAsIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclBvcywgbXAzX2luLCBwY21fYnVmWzBdLCBwY21fYnVmWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogc2FtcGxlc19vdXQgPSAwOiBuZWVkIG1vcmUgZGF0YSB0byBkZWNvZGUgc2FtcGxlc19vdXQgPVxuICAgICAgICAgICAgICAgICAgICAgKiAtMTogZXJyb3IuIExldHMgYXNzdW1lIDAgcGNtIG91dHB1dCBzYW1wbGVzX291dCA9IG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgKiBvZiBzYW1wbGVzIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBzZXQgdGhlIGxlbmdodCBvZiB0aGUgbXAzIGlucHV0IGJ1ZmZlciB0byB6ZXJvLCBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAqIGluIHRoZSBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcCB3ZSB3aWxsIGJlIHF1ZXJ5aW5nXG4gICAgICAgICAgICAgICAgICAgICAqIG1wZ2xpYiBhYm91dCBidWZmZXJlZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBtcDNfaW4gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzYW1wbGVzX291dCA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGVycm9yIGRlY29kaW5nLiBOb3QgZmF0YWwsIGJ1dCBtaWdodCBzY3JldyB1cCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFJlcGxheUdhaW4gdGFnLiBXaGF0IHNob3VsZCB3ZSBkbz8gSWdub3JlIGZvciBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlc19vdXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYW1wbGVzX291dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIHByb2Nlc3MgdGhlIFBDTSBkYXRhICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIHNob3VsZCBub3QgYmUgcG9zc2libGUsIGFuZCBpbmRpY2F0ZXMgd2UgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogb3ZlcmZsb3duIHRoZSBwY21fYnVmIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQkMTcoc2FtcGxlc19vdXQgPD0gMTE1Mik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZmMuZmluZFBlYWtTYW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlc19vdXQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGNtX2J1ZlswXVtpXSA+IGdmYy5QZWFrU2FtcGxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2ZjLlBlYWtTYW1wbGUgPSBwY21fYnVmWzBdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgtcGNtX2J1ZlswXVtpXSA+IGdmYy5QZWFrU2FtcGxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2ZjLlBlYWtTYW1wbGUgPSAtcGNtX2J1ZlswXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdmYy5jaGFubmVsc19vdXQgPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlc19vdXQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBjbV9idWZbMV1baV0gPiBnZmMuUGVha1NhbXBsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZmMuUGVha1NhbXBsZSA9IHBjbV9idWZbMV1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgtcGNtX2J1ZlsxXVtpXSA+IGdmYy5QZWFrU2FtcGxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdmYy5QZWFrU2FtcGxlID0gLXBjbV9idWZbMV1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdmYy5maW5kUmVwbGF5R2FpbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2EuQW5hbHl6ZVNhbXBsZXMoZ2ZjLnJnZGF0YSwgcGNtX2J1ZlswXSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBjbV9idWZbMV0sIDAsIHNhbXBsZXNfb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2ZjLmNoYW5uZWxzX291dCkgPT0gR2FpbkFuYWx5c2lzLkdBSU5fQU5BTFlTSVNfRVJST1IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtNjtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIGlmIChzYW1wbGVzX291dD4wKSAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiB3aGlsZSAoc2FtcGxlc19vdXQhPTApICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpZiAoZ2ZjLmRlY29kZV9vbl90aGVfZmx5KSAqL1xuXG4gICAgICAgIH1cbiAgICAgICAgLyogaWYgKG1wM2RhdGEpICovXG4gICAgICAgIHJldHVybiBtaW5pbXVtO1xuICAgIH07XG5cbiAgICB0aGlzLmluaXRfYml0X3N0cmVhbV93ID0gZnVuY3Rpb24gKGdmYykge1xuICAgICAgICBidWYgPSBuZXdfYnl0ZSQxNyhMYW1lLkxBTUVfTUFYTVAzQlVGRkVSKTtcblxuICAgICAgICBnZmMuaF9wdHIgPSBnZmMud19wdHIgPSAwO1xuICAgICAgICBnZmMuaGVhZGVyW2dmYy5oX3B0cl0ud3JpdGVfdGltaW5nID0gMDtcbiAgICAgICAgYnVmQnl0ZUlkeCA9IC0xO1xuICAgICAgICBidWZCaXRJZHggPSAwO1xuICAgICAgICB0b3RiaXQgPSAwO1xuICAgIH07XG5cbiAgICAvLyBGcm9tIG1hY2hpbmUuaFxuXG5cbn1cblxudmFyIEJpdFN0cmVhbV8xID0gQml0U3RyZWFtJDE7XG5cbnZhciBTeXN0ZW0kMiA9IGNvbW1vbi5TeXN0ZW07XG52YXIgVmJyTW9kZSQyID0gY29tbW9uLlZick1vZGU7XG52YXIgU2hvcnRCbG9jayQyID0gY29tbW9uLlNob3J0QmxvY2s7XG52YXIgbmV3X2Zsb2F0JDIgPSBjb21tb24ubmV3X2Zsb2F0O1xudmFyIG5ld19pbnRfbiQyID0gY29tbW9uLm5ld19pbnRfbjtcbnZhciBuZXdfc2hvcnRfbiQxID0gY29tbW9uLm5ld19zaG9ydF9uO1xudmFyIGFzc2VydCQyID0gY29tbW9uLmFzc2VydDtcblxuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBMYW1lJDEoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBMQU1FX01BWEFMQlVNQVJUID0gKDEyOCAqIDEwMjQpO1xuXG4gICAgTGFtZSQxLlY5ID0gNDEwO1xuICAgIExhbWUkMS5WOCA9IDQyMDtcbiAgICBMYW1lJDEuVjcgPSA0MzA7XG4gICAgTGFtZSQxLlY2ID0gNDQwO1xuICAgIExhbWUkMS5WNSA9IDQ1MDtcbiAgICBMYW1lJDEuVjQgPSA0NjA7XG4gICAgTGFtZSQxLlYzID0gNDcwO1xuICAgIExhbWUkMS5WMiA9IDQ4MDtcbiAgICBMYW1lJDEuVjEgPSA0OTA7XG4gICAgTGFtZSQxLlYwID0gNTAwO1xuXG4gICAgLyogc3RpbGwgdGhlcmUgZm9yIGNvbXBhdGliaWxpdHkgKi9cblxuICAgIExhbWUkMS5SM01JWCA9IDEwMDA7XG4gICAgTGFtZSQxLlNUQU5EQVJEID0gMTAwMTtcbiAgICBMYW1lJDEuRVhUUkVNRSA9IDEwMDI7XG4gICAgTGFtZSQxLklOU0FORSA9IDEwMDM7XG4gICAgTGFtZSQxLlNUQU5EQVJEX0ZBU1QgPSAxMDA0O1xuICAgIExhbWUkMS5FWFRSRU1FX0ZBU1QgPSAxMDA1O1xuICAgIExhbWUkMS5NRURJVU0gPSAxMDA2O1xuICAgIExhbWUkMS5NRURJVU1fRkFTVCA9IDEwMDc7XG5cbiAgICAvKipcbiAgICAgKiBtYXhpbXVtIHNpemUgb2YgbXAzYnVmZmVyIG5lZWRlZCBpZiB5b3UgZW5jb2RlIGF0IG1vc3QgMTE1MiBzYW1wbGVzIGZvclxuICAgICAqIGVhY2ggY2FsbCB0byBsYW1lX2VuY29kZV9idWZmZXIuIHNlZSBsYW1lX2VuY29kZV9idWZmZXIoKSBiZWxvd1xuICAgICAqIChMQU1FX01BWE1QM0JVRkZFUiBpcyBub3cgb2Jzb2xldGUpXG4gICAgICovXG4gICAgdmFyIExBTUVfTUFYTVAzQlVGRkVSID0gKDE2Mzg0ICsgTEFNRV9NQVhBTEJVTUFSVCk7XG4gICAgTGFtZSQxLkxBTUVfTUFYTVAzQlVGRkVSID0gTEFNRV9NQVhNUDNCVUZGRVI7XG5cbiAgICB2YXIgZ2E7XG4gICAgdmFyIGJzO1xuICAgIHZhciBwO1xuICAgIHZhciBxdXB2dDtcbiAgICB2YXIgcXU7XG4gICAgdmFyIHBzeSA9IG5ldyBQc3lNb2RlbF8xKCk7XG4gICAgdmFyIHZicjtcbiAgICB2YXIgdmVyO1xuICAgIHZhciBpZDM7XG4gICAgdmFyIG1wZ2xpYjtcbiAgICB0aGlzLmVuYyA9IG5ldyBFbmNvZGVyXzEoKTtcblxuICAgIHRoaXMuc2V0TW9kdWxlcyA9IGZ1bmN0aW9uIChfZ2EsIF9icywgX3AsIF9xdXB2dCwgX3F1LCBfdmJyLCBfdmVyLCBfaWQzLCBfbXBnbGliKSB7XG4gICAgICAgIGdhID0gX2dhO1xuICAgICAgICBicyA9IF9icztcbiAgICAgICAgcCA9IF9wO1xuICAgICAgICBxdXB2dCA9IF9xdXB2dDtcbiAgICAgICAgcXUgPSBfcXU7XG4gICAgICAgIHZiciA9IF92YnI7XG4gICAgICAgIHZlciA9IF92ZXI7XG4gICAgICAgIGlkMyA9IF9pZDM7XG4gICAgICAgIG1wZ2xpYiA9IF9tcGdsaWI7XG4gICAgICAgIHRoaXMuZW5jLnNldE1vZHVsZXMoYnMsIHBzeSwgcXVwdnQsIHZicik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBTWSBNb2RlbCByZWxhdGVkIHN0dWZmXG4gICAgICovXG4gICAgZnVuY3Rpb24gUFNZKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRiUSBzdHVmZi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFza19hZGp1c3QgPSAwLjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYlEgc3R1ZmYuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hc2tfYWRqdXN0X3Nob3J0ID0gMC47XG4gICAgICAgIC8qIGF0IHRyYW5zaXRpb24gZnJvbSBvbmUgc2NhbGVmYWN0b3IgYmFuZCB0byBuZXh0ICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYW5kIHdlaWdodCBsb25nIHNjYWxlZmFjdG9yIGJhbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib19sX3dlaWdodCA9IG5ld19mbG9hdCQyKEVuY29kZXJfMS5TQk1BWF9sKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhbmQgd2VpZ2h0IHNob3J0IHNjYWxlZmFjdG9yIGJhbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib19zX3dlaWdodCA9IG5ld19mbG9hdCQyKEVuY29kZXJfMS5TQk1BWF9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb3dQYXNzSGlnaFBhc3MoKSB7XG4gICAgICAgIHRoaXMubG93ZXJsaW1pdCA9IDAuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEJhbmRQYXNzKGJpdHJhdGUsIGxQYXNzKSB7XG4gICAgICAgIHRoaXMubG93cGFzcyA9IGxQYXNzO1xuICAgIH1cblxuICAgIHZhciBMQU1FX0lEID0gMHhGRkY4OEUzQjtcblxuICAgIGZ1bmN0aW9uIGxhbWVfaW5pdF9vbGQoZ2ZwKSB7XG4gICAgICAgIHZhciBnZmM7XG5cbiAgICAgICAgZ2ZwLmNsYXNzX2lkID0gTEFNRV9JRDtcblxuICAgICAgICBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3MgPSBuZXcgTGFtZUludGVybmFsRmxhZ3NfMSgpO1xuXG4gICAgICAgIC8qIEdsb2JhbCBmbGFncy4gc2V0IGRlZmF1bHRzIGhlcmUgZm9yIG5vbi16ZXJvIHZhbHVlcyAqL1xuICAgICAgICAvKiBzZWUgbGFtZS5oIGZvciBkZXNjcmlwdGlvbiAqL1xuICAgICAgICAvKlxuICAgICAgICAgKiBzZXQgaW50ZWdlciB2YWx1ZXMgdG8gLTEgdG8gbWVhbiB0aGF0IExBTUUgd2lsbCBjb21wdXRlIHRoZSBiZXN0XG4gICAgICAgICAqIHZhbHVlLCBVTkxFU1MgdGhlIGNhbGxpbmcgcHJvZ3JhbSBhcyBzZXQgaXQgKGFuZCB0aGUgdmFsdWUgaXMgbm9cbiAgICAgICAgICogbG9uZ2VyIC0xKVxuICAgICAgICAgKi9cblxuICAgICAgICBnZnAubW9kZSA9IE1QRUdNb2RlLk5PVF9TRVQ7XG4gICAgICAgIGdmcC5vcmlnaW5hbCA9IDE7XG4gICAgICAgIGdmcC5pbl9zYW1wbGVyYXRlID0gNDQxMDA7XG4gICAgICAgIGdmcC5udW1fY2hhbm5lbHMgPSAyO1xuICAgICAgICBnZnAubnVtX3NhbXBsZXMgPSAtMTtcblxuICAgICAgICBnZnAuYldyaXRlVmJyVGFnID0gdHJ1ZTtcbiAgICAgICAgZ2ZwLnF1YWxpdHkgPSAtMTtcbiAgICAgICAgZ2ZwLnNob3J0X2Jsb2NrcyA9IG51bGw7XG4gICAgICAgIGdmYy5zdWJibG9ja19nYWluID0gLTE7XG5cbiAgICAgICAgZ2ZwLmxvd3Bhc3NmcmVxID0gMDtcbiAgICAgICAgZ2ZwLmhpZ2hwYXNzZnJlcSA9IDA7XG4gICAgICAgIGdmcC5sb3dwYXNzd2lkdGggPSAtMTtcbiAgICAgICAgZ2ZwLmhpZ2hwYXNzd2lkdGggPSAtMTtcblxuICAgICAgICBnZnAuVkJSID0gVmJyTW9kZSQyLnZicl9vZmY7XG4gICAgICAgIGdmcC5WQlJfcSA9IDQ7XG4gICAgICAgIGdmcC5BVEhjdXJ2ZSA9IC0xO1xuICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gMTI4O1xuICAgICAgICBnZnAuVkJSX21pbl9iaXRyYXRlX2ticHMgPSAwO1xuICAgICAgICBnZnAuVkJSX21heF9iaXRyYXRlX2ticHMgPSAwO1xuICAgICAgICBnZnAuVkJSX2hhcmRfbWluID0gMDtcbiAgICAgICAgZ2ZjLlZCUl9taW5fYml0cmF0ZSA9IDE7XG4gICAgICAgIC8qIG5vdCAwID8/Pz8/ICovXG4gICAgICAgIGdmYy5WQlJfbWF4X2JpdHJhdGUgPSAxMztcbiAgICAgICAgLyogbm90IDE0ID8/Pz8/ICovXG5cbiAgICAgICAgZ2ZwLnF1YW50X2NvbXAgPSAtMTtcbiAgICAgICAgZ2ZwLnF1YW50X2NvbXBfc2hvcnQgPSAtMTtcblxuICAgICAgICBnZnAubXNmaXggPSAtMTtcblxuICAgICAgICBnZmMucmVzYW1wbGVfcmF0aW8gPSAxO1xuXG4gICAgICAgIGdmYy5PbGRWYWx1ZVswXSA9IDE4MDtcbiAgICAgICAgZ2ZjLk9sZFZhbHVlWzFdID0gMTgwO1xuICAgICAgICBnZmMuQ3VycmVudFN0ZXBbMF0gPSA0O1xuICAgICAgICBnZmMuQ3VycmVudFN0ZXBbMV0gPSA0O1xuICAgICAgICBnZmMubWFza2luZ19sb3dlciA9IDE7XG4gICAgICAgIGdmYy5uc1BzeS5hdHRhY2t0aHJlID0gLTE7XG4gICAgICAgIGdmYy5uc1BzeS5hdHRhY2t0aHJlX3MgPSAtMTtcblxuICAgICAgICBnZnAuc2NhbGUgPSAtMTtcblxuICAgICAgICBnZnAuYXRoYWFfdHlwZSA9IC0xO1xuICAgICAgICBnZnAuQVRIdHlwZSA9IC0xO1xuICAgICAgICAvKiBkZWZhdWx0ID0gLTEgPSBzZXQgaW4gbGFtZV9pbml0X3BhcmFtcyAqL1xuICAgICAgICBnZnAuYXRoYWFfbG91ZGFwcHJveCA9IC0xO1xuICAgICAgICAvKiAxID0gZmxhdCBsb3VkbmVzcyBhcHByb3guICh0b3RhbCBlbmVyZ3kpICovXG4gICAgICAgIC8qIDIgPSBlcXVhbCBsb3VkbmVzcyBjdXJ2ZSAqL1xuICAgICAgICBnZnAuYXRoYWFfc2Vuc2l0aXZpdHkgPSAwLjA7XG4gICAgICAgIC8qIG5vIG9mZnNldCAqL1xuICAgICAgICBnZnAudXNlVGVtcG9yYWwgPSBudWxsO1xuICAgICAgICBnZnAuaW50ZXJDaFJhdGlvID0gLTE7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIHJlYXNvbiBmb3IgaW50IG1mX3NhbXBsZXNfdG9fZW5jb2RlID0gRU5DREVMQVkgKyBQT1NUREVMQVk7XG4gICAgICAgICAqIEVOQ0RFTEFZID0gaW50ZXJuYWwgZW5jb2RlciBkZWxheS4gQW5kIHRoZW4gd2UgaGF2ZSB0byBhZGRcbiAgICAgICAgICogUE9TVERFTEFZPTI4OCBiZWNhdXNlIG9mIHRoZSA1MCUgTURDVCBvdmVybGFwLiBBIDU3NiBNRENUIGdyYW51bGVcbiAgICAgICAgICogZGVjb2RlcyB0byAxMTUyIHNhbXBsZXMuIFRvIHN5bnRoZXNpemUgdGhlIDU3NiBzYW1wbGVzIGNlbnRlcmVkIHVuZGVyXG4gICAgICAgICAqIHRoaXMgZ3JhbnVsZSB3ZSBuZWVkIHRoZSBwcmV2aW91cyBncmFudWxlIGZvciB0aGUgZmlyc3QgMjg4IHNhbXBsZXNcbiAgICAgICAgICogKG5vIHByb2JsZW0pLCBhbmQgdGhlIG5leHQgZ3JhbnVsZSBmb3IgdGhlIG5leHQgMjg4IHNhbXBsZXMgKG5vdFxuICAgICAgICAgKiBwb3NzaWJsZSBpZiB0aGlzIGlzIGxhc3QgZ3JhbnVsZSkuIFNvIHdlIG5lZWQgdG8gcGFkIHdpdGggMjg4IHNhbXBsZXNcbiAgICAgICAgICogdG8gbWFrZSBzdXJlIHdlIGNhbiBlbmNvZGUgdGhlIDU3NiBzYW1wbGVzIHdlIGFyZSBpbnRlcmVzdGVkIGluLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2ZjLm1mX3NhbXBsZXNfdG9fZW5jb2RlID0gRW5jb2Rlcl8xLkVOQ0RFTEFZICsgRW5jb2Rlcl8xLlBPU1RERUxBWTtcbiAgICAgICAgZ2ZwLmVuY29kZXJfcGFkZGluZyA9IDA7XG4gICAgICAgIGdmYy5tZl9zaXplID0gRW5jb2Rlcl8xLkVOQ0RFTEFZIC0gRW5jb2Rlcl8xLk1EQ1RERUxBWTtcbiAgICAgICAgLypcbiAgICAgICAgICogd2UgcGFkIGlucHV0IHdpdGggdGhpcyBtYW55IDAnc1xuICAgICAgICAgKi9cblxuICAgICAgICBnZnAuZmluZFJlcGxheUdhaW4gPSBmYWxzZTtcbiAgICAgICAgZ2ZwLmRlY29kZV9vbl90aGVfZmx5ID0gZmFsc2U7XG5cbiAgICAgICAgZ2ZjLmRlY29kZV9vbl90aGVfZmx5ID0gZmFsc2U7XG4gICAgICAgIGdmYy5maW5kUmVwbGF5R2FpbiA9IGZhbHNlO1xuICAgICAgICBnZmMuZmluZFBlYWtTYW1wbGUgPSBmYWxzZTtcblxuICAgICAgICBnZmMuUmFkaW9HYWluID0gMDtcbiAgICAgICAgZ2ZjLkF1ZGlvcGhpbGVHYWluID0gMDtcbiAgICAgICAgZ2ZjLm5vY2xpcEdhaW5DaGFuZ2UgPSAwO1xuICAgICAgICBnZmMubm9jbGlwU2NhbGUgPSAtMS4wO1xuXG4gICAgICAgIGdmcC5wcmVzZXQgPSAwO1xuXG4gICAgICAgIGdmcC53cml0ZV9pZDN0YWdfYXV0b21hdGljID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdGhpcy5sYW1lX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnZnAgPSBuZXcgTGFtZUdsb2JhbEZsYWdzXzEoKTtcblxuICAgICAgICB2YXIgcmV0ID0gbGFtZV9pbml0X29sZChnZnApO1xuICAgICAgICBpZiAocmV0ICE9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2ZwLmxhbWVfYWxsb2NhdGVkX2dmcCA9IDE7XG4gICAgICAgIHJldHVybiBnZnA7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGZpbHRlcl9jb2VmKHgpIHtcbiAgICAgICAgaWYgKHggPiAxLjApXG4gICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICBpZiAoeCA8PSAwLjApXG4gICAgICAgICAgICByZXR1cm4gMS4wO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmNvcyhNYXRoLlBJIC8gMiAqIHgpO1xuICAgIH1cblxuICAgIHRoaXMubmVhcmVzdEJpdHJhdGVGdWxsSW5kZXggPSBmdW5jdGlvbiAoYml0cmF0ZSkge1xuICAgICAgICAvKiBib3Jyb3dlZCBmcm9tIERNIGFiciBwcmVzZXRzICovXG5cbiAgICAgICAgdmFyIGZ1bGxfYml0cmF0ZV90YWJsZSA9IFs4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsXG4gICAgICAgICAgICA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwXTtcblxuICAgICAgICB2YXIgbG93ZXJfcmFuZ2UgPSAwLCBsb3dlcl9yYW5nZV9rYnBzID0gMCwgdXBwZXJfcmFuZ2UgPSAwLCB1cHBlcl9yYW5nZV9rYnBzID0gMDtcblxuICAgICAgICAvKiBXZSBhc3N1bWUgc3BlY2lmaWVkIGJpdHJhdGUgd2lsbCBiZSAzMjBrYnBzICovXG4gICAgICAgIHVwcGVyX3JhbmdlX2ticHMgPSBmdWxsX2JpdHJhdGVfdGFibGVbMTZdO1xuICAgICAgICB1cHBlcl9yYW5nZSA9IDE2O1xuICAgICAgICBsb3dlcl9yYW5nZV9rYnBzID0gZnVsbF9iaXRyYXRlX3RhYmxlWzE2XTtcbiAgICAgICAgbG93ZXJfcmFuZ2UgPSAxNjtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBEZXRlcm1pbmUgd2hpY2ggc2lnbmlmaWNhbnQgYml0cmF0ZXMgdGhlIHZhbHVlIHNwZWNpZmllZCBmYWxsc1xuICAgICAgICAgKiBiZXR3ZWVuLCBpZiBsb29wIGVuZHMgd2l0aG91dCBicmVha2luZyB0aGVuIHdlIHdlcmUgY29ycmVjdCBhYm92ZVxuICAgICAgICAgKiB0aGF0IHRoZSB2YWx1ZSB3YXMgMzIwXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IDE2OyBiKyspIHtcbiAgICAgICAgICAgIGlmICgoTWF0aC5tYXgoYml0cmF0ZSwgZnVsbF9iaXRyYXRlX3RhYmxlW2IgKyAxXSkpICE9IGJpdHJhdGUpIHtcbiAgICAgICAgICAgICAgICB1cHBlcl9yYW5nZV9rYnBzID0gZnVsbF9iaXRyYXRlX3RhYmxlW2IgKyAxXTtcbiAgICAgICAgICAgICAgICB1cHBlcl9yYW5nZSA9IGIgKyAxO1xuICAgICAgICAgICAgICAgIGxvd2VyX3JhbmdlX2ticHMgPSBmdWxsX2JpdHJhdGVfdGFibGVbYl07XG4gICAgICAgICAgICAgICAgbG93ZXJfcmFuZ2UgPSAoYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLyogV2UgZm91bmQgdXBwZXIgcmFuZ2UgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIERldGVybWluZSB3aGljaCByYW5nZSB0aGUgdmFsdWUgc3BlY2lmaWVkIGlzIGNsb3NlciB0byAqL1xuICAgICAgICBpZiAoKHVwcGVyX3JhbmdlX2ticHMgLSBiaXRyYXRlKSA+IChiaXRyYXRlIC0gbG93ZXJfcmFuZ2Vfa2JwcykpIHtcbiAgICAgICAgICAgIHJldHVybiBsb3dlcl9yYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBwZXJfcmFuZ2U7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9wdGltdW1fc2FtcGxlZnJlcShsb3dwYXNzZnJlcSwgaW5wdXRfc2FtcGxlZnJlcSkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBSdWxlczpcbiAgICAgICAgICpcbiAgICAgICAgICogLSBpZiBwb3NzaWJsZSwgc2ZiMjEgc2hvdWxkIE5PVCBiZSB1c2VkXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc3VnZ2VzdGVkX3NhbXBsZWZyZXEgPSA0NDEwMDtcblxuICAgICAgICBpZiAoaW5wdXRfc2FtcGxlZnJlcSA+PSA0ODAwMClcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gNDgwMDA7XG4gICAgICAgIGVsc2UgaWYgKGlucHV0X3NhbXBsZWZyZXEgPj0gNDQxMDApXG4gICAgICAgICAgICBzdWdnZXN0ZWRfc2FtcGxlZnJlcSA9IDQ0MTAwO1xuICAgICAgICBlbHNlIGlmIChpbnB1dF9zYW1wbGVmcmVxID49IDMyMDAwKVxuICAgICAgICAgICAgc3VnZ2VzdGVkX3NhbXBsZWZyZXEgPSAzMjAwMDtcbiAgICAgICAgZWxzZSBpZiAoaW5wdXRfc2FtcGxlZnJlcSA+PSAyNDAwMClcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gMjQwMDA7XG4gICAgICAgIGVsc2UgaWYgKGlucHV0X3NhbXBsZWZyZXEgPj0gMjIwNTApXG4gICAgICAgICAgICBzdWdnZXN0ZWRfc2FtcGxlZnJlcSA9IDIyMDUwO1xuICAgICAgICBlbHNlIGlmIChpbnB1dF9zYW1wbGVmcmVxID49IDE2MDAwKVxuICAgICAgICAgICAgc3VnZ2VzdGVkX3NhbXBsZWZyZXEgPSAxNjAwMDtcbiAgICAgICAgZWxzZSBpZiAoaW5wdXRfc2FtcGxlZnJlcSA+PSAxMjAwMClcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gMTIwMDA7XG4gICAgICAgIGVsc2UgaWYgKGlucHV0X3NhbXBsZWZyZXEgPj0gMTEwMjUpXG4gICAgICAgICAgICBzdWdnZXN0ZWRfc2FtcGxlZnJlcSA9IDExMDI1O1xuICAgICAgICBlbHNlIGlmIChpbnB1dF9zYW1wbGVmcmVxID49IDgwMDApXG4gICAgICAgICAgICBzdWdnZXN0ZWRfc2FtcGxlZnJlcSA9IDgwMDA7XG5cbiAgICAgICAgaWYgKGxvd3Bhc3NmcmVxID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHN1Z2dlc3RlZF9zYW1wbGVmcmVxO1xuXG4gICAgICAgIGlmIChsb3dwYXNzZnJlcSA8PSAxNTk2MClcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gNDQxMDA7XG4gICAgICAgIGlmIChsb3dwYXNzZnJlcSA8PSAxNTI1MClcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gMzIwMDA7XG4gICAgICAgIGlmIChsb3dwYXNzZnJlcSA8PSAxMTIyMClcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gMjQwMDA7XG4gICAgICAgIGlmIChsb3dwYXNzZnJlcSA8PSA5OTcwKVxuICAgICAgICAgICAgc3VnZ2VzdGVkX3NhbXBsZWZyZXEgPSAyMjA1MDtcbiAgICAgICAgaWYgKGxvd3Bhc3NmcmVxIDw9IDcyMzApXG4gICAgICAgICAgICBzdWdnZXN0ZWRfc2FtcGxlZnJlcSA9IDE2MDAwO1xuICAgICAgICBpZiAobG93cGFzc2ZyZXEgPD0gNTQyMClcbiAgICAgICAgICAgIHN1Z2dlc3RlZF9zYW1wbGVmcmVxID0gMTIwMDA7XG4gICAgICAgIGlmIChsb3dwYXNzZnJlcSA8PSA0NTEwKVxuICAgICAgICAgICAgc3VnZ2VzdGVkX3NhbXBsZWZyZXEgPSAxMTAyNTtcbiAgICAgICAgaWYgKGxvd3Bhc3NmcmVxIDw9IDM5NzApXG4gICAgICAgICAgICBzdWdnZXN0ZWRfc2FtcGxlZnJlcSA9IDgwMDA7XG5cbiAgICAgICAgaWYgKGlucHV0X3NhbXBsZWZyZXEgPCBzdWdnZXN0ZWRfc2FtcGxlZnJlcSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGNob29zZSBhIHZhbGlkIE1QRUcgc2FtcGxlIGZyZXF1ZW5jeSBhYm92ZSB0aGUgaW5wdXQgc2FtcGxlXG4gICAgICAgICAgICAgKiBmcmVxdWVuY3kgdG8gYXZvaWQgU0ZCMjEvMTIgYml0cmF0ZSBibG9hdCByaCAwNjExMTVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlucHV0X3NhbXBsZWZyZXEgPiA0NDEwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA0ODAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnB1dF9zYW1wbGVmcmVxID4gMzIwMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNDQxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXRfc2FtcGxlZnJlcSA+IDI0MDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDMyMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlucHV0X3NhbXBsZWZyZXEgPiAyMjA1MCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyNDAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnB1dF9zYW1wbGVmcmVxID4gMTYwMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjIwNTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXRfc2FtcGxlZnJlcSA+IDEyMDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE2MDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlucHV0X3NhbXBsZWZyZXEgPiAxMTAyNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxMjAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnB1dF9zYW1wbGVmcmVxID4gODAwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxMTAyNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiA4MDAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWdnZXN0ZWRfc2FtcGxlZnJlcTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IHNhbXAgZnJlcSBpbiBIeiB0byBpbmRleFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNtcEZycUluZGV4KHNhbXBsZV9mcmVxLCBncGYpIHtcbiAgICAgICAgc3dpdGNoIChzYW1wbGVfZnJlcSkge1xuICAgICAgICAgICAgY2FzZSA0NDEwMDpcbiAgICAgICAgICAgICAgICBncGYudmVyc2lvbiA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIDQ4MDAwOlxuICAgICAgICAgICAgICAgIGdwZi52ZXJzaW9uID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMzIwMDA6XG4gICAgICAgICAgICAgICAgZ3BmLnZlcnNpb24gPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgY2FzZSAyMjA1MDpcbiAgICAgICAgICAgICAgICBncGYudmVyc2lvbiA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIDI0MDAwOlxuICAgICAgICAgICAgICAgIGdwZi52ZXJzaW9uID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMTYwMDA6XG4gICAgICAgICAgICAgICAgZ3BmLnZlcnNpb24gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgY2FzZSAxMTAyNTpcbiAgICAgICAgICAgICAgICBncGYudmVyc2lvbiA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIDEyMDAwOlxuICAgICAgICAgICAgICAgIGdwZi52ZXJzaW9uID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgODAwMDpcbiAgICAgICAgICAgICAgICBncGYudmVyc2lvbiA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGdwZi52ZXJzaW9uID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYlJhdGVcbiAgICAgKiAgICAgICAgICAgIGxlZ2FsIHJhdGVzIGZyb20gOCB0byAzMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGaW5kTmVhcmVzdEJpdHJhdGUoYlJhdGUsIHZlcnNpb24sIHNhbXBsZXJhdGUpIHtcbiAgICAgICAgLyogTVBFRy0xIG9yIE1QRUctMiBMU0YgKi9cbiAgICAgICAgaWYgKHNhbXBsZXJhdGUgPCAxNjAwMClcbiAgICAgICAgICAgIHZlcnNpb24gPSAyO1xuXG4gICAgICAgIHZhciBiaXRyYXRlID0gVGFibGVzXzEuYml0cmF0ZV90YWJsZVt2ZXJzaW9uXVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8PSAxNDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoVGFibGVzXzEuYml0cmF0ZV90YWJsZVt2ZXJzaW9uXVtpXSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoVGFibGVzXzEuYml0cmF0ZV90YWJsZVt2ZXJzaW9uXVtpXSAtIGJSYXRlKSA8IE1hdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hYnMoYml0cmF0ZSAtIGJSYXRlKSlcbiAgICAgICAgICAgICAgICAgICAgYml0cmF0ZSA9IFRhYmxlc18xLmJpdHJhdGVfdGFibGVbdmVyc2lvbl1baV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpdHJhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGJSYXRlXG4gICAgICogICAgICAgICAgICBsZWdhbCByYXRlcyBmcm9tIDMyIHRvIDQ0OCBrYnBzXG4gICAgICogQHBhcmFtIHZlcnNpb25cbiAgICAgKiAgICAgICAgICAgIE1QRUctMSBvciBNUEVHLTIvMi41IExTRlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpdHJhdGVJbmRleChiUmF0ZSwgdmVyc2lvbiwgc2FtcGxlcmF0ZSkge1xuICAgICAgICAvKiBjb252ZXJ0IGJpdHJhdGUgaW4ga2JwcyB0byBpbmRleCAqL1xuICAgICAgICBpZiAoc2FtcGxlcmF0ZSA8IDE2MDAwKVxuICAgICAgICAgICAgdmVyc2lvbiA9IDI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDE0OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChUYWJsZXNfMS5iaXRyYXRlX3RhYmxlW3ZlcnNpb25dW2ldID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChUYWJsZXNfMS5iaXRyYXRlX3RhYmxlW3ZlcnNpb25dW2ldID09IGJSYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3B0aW11bV9iYW5kd2lkdGgobGgsIGJpdHJhdGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxQUkU+XG4gICAgICAgICAqICBJbnB1dDpcbiAgICAgICAgICogICAgICBiaXRyYXRlICAgICB0b3RhbCBiaXRyYXRlIGluIGticHNcbiAgICAgICAgICpcbiAgICAgICAgICogICBPdXRwdXQ6XG4gICAgICAgICAqICAgICAgbG93ZXJsaW1pdDogYmVzdCBsb3dwYXNzIGZyZXF1ZW5jeSBsaW1pdCBmb3IgaW5wdXQgZmlsdGVyIGluIEh6XG4gICAgICAgICAqICAgICAgdXBwZXJsaW1pdDogYmVzdCBoaWdocGFzcyBmcmVxdWVuY3kgbGltaXQgZm9yIGlucHV0IGZpbHRlciBpbiBIelxuICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBmcmVxX21hcCA9IFtuZXcgQmFuZFBhc3MoOCwgMjAwMCksXG4gICAgICAgICAgICBuZXcgQmFuZFBhc3MoMTYsIDM3MDApLCBuZXcgQmFuZFBhc3MoMjQsIDM5MDApLFxuICAgICAgICAgICAgbmV3IEJhbmRQYXNzKDMyLCA1NTAwKSwgbmV3IEJhbmRQYXNzKDQwLCA3MDAwKSxcbiAgICAgICAgICAgIG5ldyBCYW5kUGFzcyg0OCwgNzUwMCksIG5ldyBCYW5kUGFzcyg1NiwgMTAwMDApLFxuICAgICAgICAgICAgbmV3IEJhbmRQYXNzKDY0LCAxMTAwMCksIG5ldyBCYW5kUGFzcyg4MCwgMTM1MDApLFxuICAgICAgICAgICAgbmV3IEJhbmRQYXNzKDk2LCAxNTEwMCksIG5ldyBCYW5kUGFzcygxMTIsIDE1NjAwKSxcbiAgICAgICAgICAgIG5ldyBCYW5kUGFzcygxMjgsIDE3MDAwKSwgbmV3IEJhbmRQYXNzKDE2MCwgMTc1MDApLFxuICAgICAgICAgICAgbmV3IEJhbmRQYXNzKDE5MiwgMTg2MDApLCBuZXcgQmFuZFBhc3MoMjI0LCAxOTQwMCksXG4gICAgICAgICAgICBuZXcgQmFuZFBhc3MoMjU2LCAxOTcwMCksIG5ldyBCYW5kUGFzcygzMjAsIDIwNTAwKV07XG5cbiAgICAgICAgdmFyIHRhYmxlX2luZGV4ID0gc2VsZi5uZWFyZXN0Qml0cmF0ZUZ1bGxJbmRleChiaXRyYXRlKTtcbiAgICAgICAgbGgubG93ZXJsaW1pdCA9IGZyZXFfbWFwW3RhYmxlX2luZGV4XS5sb3dwYXNzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxhbWVfaW5pdF9wYXJhbXNfcHBmbHQoZ2ZwKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qIGNvbXB1dGUgaW5mbyBuZWVkZWQgZm9yIHBvbHlwaGFzZSBmaWx0ZXIgKGZpbHRlciB0eXBlPT0wLCBkZWZhdWx0KSAqL1xuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIHZhciBsb3dwYXNzX2JhbmQgPSAzMjtcbiAgICAgICAgdmFyIGhpZ2hwYXNzX2JhbmQgPSAtMTtcblxuICAgICAgICBpZiAoZ2ZjLmxvd3Bhc3MxID4gMCkge1xuICAgICAgICAgICAgdmFyIG1pbmJhbmQgPSA5OTk7XG4gICAgICAgICAgICBmb3IgKHZhciBiYW5kID0gMDsgYmFuZCA8PSAzMTsgYmFuZCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyZXEgPSAoYmFuZCAvIDMxLjApO1xuICAgICAgICAgICAgICAgIC8qIHRoaXMgYmFuZCBhbmQgYWJvdmUgd2lsbCBiZSB6ZXJvZWQ6ICovXG4gICAgICAgICAgICAgICAgaWYgKGZyZXEgPj0gZ2ZjLmxvd3Bhc3MyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd3Bhc3NfYmFuZCA9IE1hdGgubWluKGxvd3Bhc3NfYmFuZCwgYmFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZmMubG93cGFzczEgPCBmcmVxICYmIGZyZXEgPCBnZmMubG93cGFzczIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluYmFuZCA9IE1hdGgubWluKG1pbmJhbmQsIGJhbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGNvbXB1dGUgdGhlICphY3R1YWwqIHRyYW5zaXRpb24gYmFuZCBpbXBsZW1lbnRlZCBieSB0aGUgcG9seXBoYXNlXG4gICAgICAgICAgICAgKiBmaWx0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG1pbmJhbmQgPT0gOTk5KSB7XG4gICAgICAgICAgICAgICAgZ2ZjLmxvd3Bhc3MxID0gKGxvd3Bhc3NfYmFuZCAtIC43NSkgLyAzMS4wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZmMubG93cGFzczEgPSAobWluYmFuZCAtIC43NSkgLyAzMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2ZjLmxvd3Bhc3MyID0gbG93cGFzc19iYW5kIC8gMzEuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIG1ha2Ugc3VyZSBoaWdocGFzcyBmaWx0ZXIgaXMgd2l0aGluIDkwJSBvZiB3aGF0IHRoZSBlZmZlY3RpdmVcbiAgICAgICAgICogaGlnaHBhc3MgZnJlcXVlbmN5IHdpbGwgYmVcbiAgICAgICAgICovXG4gICAgICAgIGlmIChnZmMuaGlnaHBhc3MyID4gMCkge1xuICAgICAgICAgICAgaWYgKGdmYy5oaWdocGFzczIgPCAuOSAqICguNzUgLyAzMS4wKSkge1xuICAgICAgICAgICAgICAgIGdmYy5oaWdocGFzczEgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5oaWdocGFzczIgPSAwO1xuICAgICAgICAgICAgICAgIFN5c3RlbSQyLmVyci5wcmludGxuKFwiV2FybmluZzogaGlnaHBhc3MgZmlsdGVyIGRpc2FibGVkLiAgXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcImhpZ2hwYXNzIGZyZXF1ZW5jeSB0b28gc21hbGxcXG5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZjLmhpZ2hwYXNzMiA+IDApIHtcbiAgICAgICAgICAgIHZhciBtYXhiYW5kID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBiYW5kID0gMDsgYmFuZCA8PSAzMTsgYmFuZCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyZXEgPSBiYW5kIC8gMzEuMDtcbiAgICAgICAgICAgICAgICAvKiB0aGlzIGJhbmQgYW5kIGJlbG93IHdpbGwgYmUgemVyZW9kICovXG4gICAgICAgICAgICAgICAgaWYgKGZyZXEgPD0gZ2ZjLmhpZ2hwYXNzMSkge1xuICAgICAgICAgICAgICAgICAgICBoaWdocGFzc19iYW5kID0gTWF0aC5tYXgoaGlnaHBhc3NfYmFuZCwgYmFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZmMuaGlnaHBhc3MxIDwgZnJlcSAmJiBmcmVxIDwgZ2ZjLmhpZ2hwYXNzMikge1xuICAgICAgICAgICAgICAgICAgICBtYXhiYW5kID0gTWF0aC5tYXgobWF4YmFuZCwgYmFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGNvbXB1dGUgdGhlICphY3R1YWwqIHRyYW5zaXRpb24gYmFuZCBpbXBsZW1lbnRlZCBieSB0aGUgcG9seXBoYXNlXG4gICAgICAgICAgICAgKiBmaWx0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMSA9IGhpZ2hwYXNzX2JhbmQgLyAzMS4wO1xuICAgICAgICAgICAgaWYgKG1heGJhbmQgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBnZmMuaGlnaHBhc3MyID0gKGhpZ2hwYXNzX2JhbmQgKyAuNzUpIC8gMzEuMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMiA9IChtYXhiYW5kICsgLjc1KSAvIDMxLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBiYW5kID0gMDsgYmFuZCA8IDMyOyBiYW5kKyspIHtcbiAgICAgICAgICAgIHZhciBmYzEsIGZjMjtcbiAgICAgICAgICAgIHZhciBmcmVxID0gYmFuZCAvIDMxLjA7XG4gICAgICAgICAgICBpZiAoZ2ZjLmhpZ2hwYXNzMiA+IGdmYy5oaWdocGFzczEpIHtcbiAgICAgICAgICAgICAgICBmYzEgPSBmaWx0ZXJfY29lZigoZ2ZjLmhpZ2hwYXNzMiAtIGZyZXEpXG4gICAgICAgICAgICAgICAgICAgIC8gKGdmYy5oaWdocGFzczIgLSBnZmMuaGlnaHBhc3MxICsgMWUtMjApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmMxID0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdmYy5sb3dwYXNzMiA+IGdmYy5sb3dwYXNzMSkge1xuICAgICAgICAgICAgICAgIGZjMiA9IGZpbHRlcl9jb2VmKChmcmVxIC0gZ2ZjLmxvd3Bhc3MxKVxuICAgICAgICAgICAgICAgICAgICAvIChnZmMubG93cGFzczIgLSBnZmMubG93cGFzczEgKyAxZS0yMCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYzIgPSAxLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZmMuYW1wX2ZpbHRlcltiYW5kXSA9IChmYzEgKiBmYzIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFtZV9pbml0X3F2YWwoZ2ZwKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgc3dpdGNoIChnZnAucXVhbGl0eSkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhc2UgOTogLyogbm8gcHN5bW9kZWwsIG5vIG5vaXNlIHNoYXBpbmcgKi9cbiAgICAgICAgICAgICAgICBnZmMucHN5bW9kZWwgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMDtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMDtcbiAgICAgICAgICAgICAgICBnZmMuZnVsbF9vdXRlcl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGdmcC5xdWFsaXR5ID0gNztcbiAgICAgICAgICAgIC8vJEZBTEwtVEhST1VHSCRcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHVzZSBwc3ltb2RlbCAoZm9yIHNob3J0IGJsb2NrIGFuZCBtL3Mgc3dpdGNoaW5nKSwgYnV0IG5vIG5vaXNlXG4gICAgICAgICAgICAgICAgICogc2hhcHBpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBnZmMucHN5bW9kZWwgPSAxO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMDtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMDtcbiAgICAgICAgICAgICAgICBnZmMuZnVsbF9vdXRlcl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGdmYy5wc3ltb2RlbCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ub2lzZV9zaGFwaW5nID09IDApXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMTtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuc3ViYmxvY2tfZ2FpbiA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YmJsb2NrX2dhaW4gPSAxO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMDtcbiAgICAgICAgICAgICAgICBnZmMuZnVsbF9vdXRlcl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGdmYy5wc3ltb2RlbCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ub2lzZV9zaGFwaW5nID09IDApXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMTtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuc3ViYmxvY2tfZ2FpbiA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YmJsb2NrX2dhaW4gPSAxO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMDtcbiAgICAgICAgICAgICAgICBnZmMuZnVsbF9vdXRlcl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGdmYy5wc3ltb2RlbCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ub2lzZV9zaGFwaW5nID09IDApXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMTtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAwO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuc3ViYmxvY2tfZ2FpbiA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YmJsb2NrX2dhaW4gPSAxO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMTtcbiAgICAgICAgICAgICAgICBnZmMuZnVsbF9vdXRlcl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGdmYy5wc3ltb2RlbCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ub2lzZV9zaGFwaW5nID09IDApXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMTtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAxO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuc3ViYmxvY2tfZ2FpbiA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YmJsb2NrX2dhaW4gPSAxO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMTtcbiAgICAgICAgICAgICAgICBnZmMuZnVsbF9vdXRlcl9sb29wID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGdmYy5wc3ltb2RlbCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5ub2lzZV9zaGFwaW5nID09IDApXG4gICAgICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLnN1YnN0ZXBfc2hhcGluZyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBnZmMuc3Vic3RlcF9zaGFwaW5nID0gMjtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19hbXAgPSAxO1xuICAgICAgICAgICAgICAgIGdmYy5ub2lzZV9zaGFwaW5nX3N0b3AgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuc3ViYmxvY2tfZ2FpbiA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YmJsb2NrX2dhaW4gPSAxO1xuICAgICAgICAgICAgICAgIGdmYy51c2VfYmVzdF9odWZmbWFuID0gMTtcbiAgICAgICAgICAgICAgICAvKiBpbm5lciBsb29wICovXG4gICAgICAgICAgICAgICAgZ2ZjLmZ1bGxfb3V0ZXJfbG9vcCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBnZmMucHN5bW9kZWwgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChnZmMubm9pc2Vfc2hhcGluZyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZyA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5zdWJzdGVwX3NoYXBpbmcgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YnN0ZXBfc2hhcGluZyA9IDI7XG4gICAgICAgICAgICAgICAgZ2ZjLm5vaXNlX3NoYXBpbmdfYW1wID0gMjtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19zdG9wID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLnN1YmJsb2NrX2dhaW4gPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGdmYy5zdWJibG9ja19nYWluID0gMTtcbiAgICAgICAgICAgICAgICBnZmMudXNlX2Jlc3RfaHVmZm1hbiA9IDE7XG4gICAgICAgICAgICAgICAgZ2ZjLmZ1bGxfb3V0ZXJfbG9vcCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBnZmMucHN5bW9kZWwgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChnZmMubm9pc2Vfc2hhcGluZyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZyA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5zdWJzdGVwX3NoYXBpbmcgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnN1YnN0ZXBfc2hhcGluZyA9IDI7XG4gICAgICAgICAgICAgICAgZ2ZjLm5vaXNlX3NoYXBpbmdfYW1wID0gMjtcbiAgICAgICAgICAgICAgICBnZmMubm9pc2Vfc2hhcGluZ19zdG9wID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLnN1YmJsb2NrX2dhaW4gPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGdmYy5zdWJibG9ja19nYWluID0gMTtcbiAgICAgICAgICAgICAgICBnZmMudXNlX2Jlc3RfaHVmZm1hbiA9IDE7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB0eXBlIDIgZGlzYWJsZWQgYmVjYXVzZSBvZiBpdCBzbG93bmVzcywgaW4gZmF2b3Igb2YgZnVsbCBvdXRlclxuICAgICAgICAgICAgICAgICAqIGxvb3Agc2VhcmNoXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2ZjLmZ1bGxfb3V0ZXJfbG9vcCA9IDA7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBmdWxsIG91dGVyIGxvb3Agc2VhcmNoIGRpc2FibGVkIGJlY2F1c2Ugb2YgYXVkaWJsZSBkaXN0b3J0aW9ucyBpdFxuICAgICAgICAgICAgICAgICAqIG1heSBnZW5lcmF0ZSByaCAwNjA2MjlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFtZV9pbml0X2JpdHN0cmVhbShnZnApIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgZ2ZwLmZyYW1lTnVtID0gMDtcblxuICAgICAgICBpZiAoZ2ZwLndyaXRlX2lkM3RhZ19hdXRvbWF0aWMpIHtcbiAgICAgICAgICAgIGlkMy5pZDN0YWdfd3JpdGVfdjIoZ2ZwKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpbml0aWFsaXplIGhpc3RvZ3JhbSBkYXRhIG9wdGlvbmFsbHkgdXNlZCBieSBmcm9udGVuZCAqL1xuXG4gICAgICAgIGdmYy5iaXRyYXRlX3N0ZXJlb01vZGVfSGlzdCA9IG5ld19pbnRfbiQyKFsxNiwgNCArIDFdKTtcbiAgICAgICAgZ2ZjLmJpdHJhdGVfYmxvY2tUeXBlX0hpc3QgPSBuZXdfaW50X24kMihbMTYsIDQgKyAxICsgMV0pO1xuXG4gICAgICAgIGdmYy5QZWFrU2FtcGxlID0gMC4wO1xuXG4gICAgICAgIC8qIFdyaXRlIGluaXRpYWwgVkJSIEhlYWRlciB0byBiaXRzdHJlYW0gYW5kIGluaXQgVkJSIGRhdGEgKi9cbiAgICAgICAgaWYgKGdmcC5iV3JpdGVWYnJUYWcpXG4gICAgICAgICAgICB2YnIuSW5pdFZiclRhZyhnZnApO1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIGluaXRpYWxpemUgaW50ZXJuYWwgcGFyYW1zIGJhc2VkIG9uIGRhdGEgaW4gZ2YgKGdsb2JhbGZsYWdzIHN0cnVjdCBmaWxsZWRcbiAgICAgKiBpbiBieSBjYWxsaW5nIHByb2dyYW0pXG4gICAgICpcbiAgICAgKiBPVVRMSU5FOlxuICAgICAqXG4gICAgICogV2UgZmlyc3QgaGF2ZSBzb21lIGNvbXBsZXggY29kZSB0byBkZXRlcm1pbmUgYml0cmF0ZSwgb3V0cHV0IHNhbXBsZXJhdGVcbiAgICAgKiBhbmQgbW9kZS4gSXQgaXMgY29tcGxpY2F0ZWQgYnkgdGhlIGZhY3QgdGhhdCB3ZSBhbGxvdyB0aGUgdXNlciB0byBzZXRcbiAgICAgKiBzb21lIG9yIGFsbCBvZiB0aGVzZSBwYXJhbWV0ZXJzLCBhbmQgbmVlZCB0byBkZXRlcm1pbmUgYmVzdCBwb3NzaWJsZVxuICAgICAqIHZhbHVlcyBmb3IgdGhlIHJlc3Qgb2YgdGhlbTpcbiAgICAgKlxuICAgICAqIDEuIHNldCBzb21lIENQVSByZWxhdGVkIGZsYWdzIDIuIGNoZWNrIGlmIHdlIGFyZSBtb25vLm1vbm8sIHN0ZXJlby5tb25vXG4gICAgICogb3Igc3RlcmVvLnN0ZXJlbyAzLiBjb21wdXRlIGJpdHJhdGUgYW5kIG91dHB1dCBzYW1wbGVyYXRlOiB1c2VyIG1heSBoYXZlXG4gICAgICogc2V0IGNvbXByZXNzaW9uIHJhdGlvIHVzZXIgbWF5IGhhdmUgc2V0IGEgYml0cmF0ZSB1c2VyIG1heSBoYXZlIHNldCBhXG4gICAgICogb3V0cHV0IHNhbXBsZXJhdGUgNC4gc2V0IHNvbWUgb3B0aW9ucyB3aGljaCBkZXBlbmQgb24gb3V0cHV0IHNhbXBsZXJhdGVcbiAgICAgKiA1LiBjb21wdXRlIHRoZSBhY3R1YWwgY29tcHJlc3Npb24gcmF0aW8gNi4gc2V0IG1vZGUgYmFzZWQgb24gY29tcHJlc3Npb25cbiAgICAgKiByYXRpb1xuICAgICAqXG4gICAgICogVGhlIHJlbWFpbmluZyBjb2RlIGlzIG11Y2ggc2ltcGxlciAtIGl0IGp1c3Qgc2V0cyBvcHRpb25zIGJhc2VkIG9uIHRoZVxuICAgICAqIG1vZGUgJiBjb21wcmVzc2lvbiByYXRpbzpcbiAgICAgKlxuICAgICAqIHNldCBhbGxvd19kaWZmX3Nob3J0IGJhc2VkIG9uIG1vZGUgc2VsZWN0IGxvd3Bhc3MgZmlsdGVyIGJhc2VkIG9uXG4gICAgICogY29tcHJlc3Npb24gcmF0aW8gJiBtb2RlIHNldCB0aGUgYml0cmF0ZSBpbmRleCwgYW5kIG1pbi9tYXggYml0cmF0ZXMgZm9yXG4gICAgICogVkJSIG1vZGVzIGRpc2FibGUgVkJSIHRhZyBpZiBpdCBpcyBub3QgYXBwcm9wcmlhdGUgaW5pdGlhbGl6ZSB0aGVcbiAgICAgKiBiaXRzdHJlYW0gaW5pdGlhbGl6ZSBzY2FsZWZhY19iYW5kIGRhdGEgc2V0IHNpZGVpbmZvX2xlbiAoYmFzZWQgb25cbiAgICAgKiBjaGFubmVscywgQ1JDLCBvdXRfc2FtcGxlcmF0ZSkgd3JpdGUgYW4gaWQzdjIgdGFnIGludG8gdGhlIGJpdHN0cmVhbVxuICAgICAqIHdyaXRlIFZCUiB0YWcgaW50byB0aGUgYml0c3RyZWFtIHNldCBtcGVnMS8yIGZsYWcgZXN0aW1hdGUgdGhlIG51bWJlciBvZlxuICAgICAqIGZyYW1lcyAoYmFzZWQgb24gYSBsb3Qgb2YgZGF0YSlcbiAgICAgKlxuICAgICAqIG5vdyB3ZSBzZXQgbW9yZSBmbGFnczogbnNwc3l0dW5lOiBzZWUgY29kZSBWQlIgbW9kZXMgc2VlIGNvZGUgQ0JSL0FCUiBzZWVcbiAgICAgKiBjb2RlXG4gICAgICpcbiAgICAgKiBGaW5hbGx5LCB3ZSBzZXQgdGhlIGFsZ29yaXRobSBmbGFncyBiYXNlZCBvbiB0aGUgZ2ZwLnF1YWxpdHkgdmFsdWVcbiAgICAgKiBsYW1lX2luaXRfcXZhbChnZnApO1xuICAgICAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIHRoaXMubGFtZV9pbml0X3BhcmFtcyA9IGZ1bmN0aW9uIChnZnApIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblxuICAgICAgICBnZmMuQ2xhc3NfSUQgPSAwO1xuICAgICAgICBpZiAoZ2ZjLkFUSCA9PSBudWxsKVxuICAgICAgICAgICAgZ2ZjLkFUSCA9IG5ldyBBVEhfMSgpO1xuICAgICAgICBpZiAoZ2ZjLlBTWSA9PSBudWxsKVxuICAgICAgICAgICAgZ2ZjLlBTWSA9IG5ldyBQU1koKTtcbiAgICAgICAgaWYgKGdmYy5yZ2RhdGEgPT0gbnVsbClcbiAgICAgICAgICAgIGdmYy5yZ2RhdGEgPSBuZXcgUmVwbGF5R2Fpbl8xKCk7XG5cbiAgICAgICAgZ2ZjLmNoYW5uZWxzX2luID0gZ2ZwLm51bV9jaGFubmVscztcbiAgICAgICAgaWYgKGdmYy5jaGFubmVsc19pbiA9PSAxKVxuICAgICAgICAgICAgZ2ZwLm1vZGUgPSBNUEVHTW9kZS5NT05PO1xuICAgICAgICBnZmMuY2hhbm5lbHNfb3V0ID0gKGdmcC5tb2RlID09IE1QRUdNb2RlLk1PTk8pID8gMSA6IDI7XG4gICAgICAgIGdmYy5tb2RlX2V4dCA9IEVuY29kZXJfMS5NUEdfTURfTVNfTFI7XG4gICAgICAgIGlmIChnZnAubW9kZSA9PSBNUEVHTW9kZS5NT05PKVxuICAgICAgICAgICAgZ2ZwLmZvcmNlX21zID0gZmFsc2U7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGRvbid0IGFsbG93IGZvcmNlZCBtaWQvc2lkZSBzdGVyZW8gZm9yIG1vbm8gb3V0cHV0XG4gICAgICAgICAqL1xuXG4gICAgICAgIGlmIChnZnAuVkJSID09IFZick1vZGUkMi52YnJfb2ZmICYmIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMgIT0gMTI4XG4gICAgICAgICAgICAmJiBnZnAuYnJhdGUgPT0gMClcbiAgICAgICAgICAgIGdmcC5icmF0ZSA9IGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHM7XG5cbiAgICAgICAgaWYgKGdmcC5WQlIgPT0gVmJyTW9kZSQyLnZicl9vZmYgfHwgZ2ZwLlZCUiA9PSBWYnJNb2RlJDIudmJyX210cmhcbiAgICAgICAgICAgIHx8IGdmcC5WQlIgPT0gVmJyTW9kZSQyLnZicl9tdCkge1xuICAgICAgICAgICAgLyogdGhlc2UgbW9kZXMgY2FuIGhhbmRsZSBmcmVlIGZvcm1hdCBjb25kaXRpb24gKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdmcC5mcmVlX2Zvcm1hdCA9IGZhbHNlO1xuICAgICAgICAgICAgLyogbW9kZSBjYW4ndCBiZSBtaXhlZCB3aXRoIGZyZWUgZm9ybWF0ICovXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlJDIudmJyX29mZiAmJiBnZnAuYnJhdGUgPT0gMCkge1xuICAgICAgICAgICAgLyogbm8gYml0cmF0ZSBvciBjb21wcmVzc2lvbiByYXRpbyBzcGVjaWZpZWQsIHVzZSAxMS4wMjUgKi9cbiAgICAgICAgICAgIGlmIChCaXRTdHJlYW1fMS5FUShnZnAuY29tcHJlc3Npb25fcmF0aW8sIDApKVxuICAgICAgICAgICAgICAgIGdmcC5jb21wcmVzc2lvbl9yYXRpbyA9IDExLjAyNTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiByYXRlIHRvIGNvbXByZXNzIGEgQ0QgZG93biB0byBleGFjdGx5IDEyODAwMCBicHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICB9XG5cbiAgICAgICAgLyogZmluZCBiaXRyYXRlIGlmIHVzZXIgc3BlY2lmeSBhIGNvbXByZXNzaW9uIHJhdGlvICovXG4gICAgICAgIGlmIChnZnAuVkJSID09IFZick1vZGUkMi52YnJfb2ZmICYmIGdmcC5jb21wcmVzc2lvbl9yYXRpbyA+IDApIHtcblxuICAgICAgICAgICAgaWYgKGdmcC5vdXRfc2FtcGxlcmF0ZSA9PSAwKVxuICAgICAgICAgICAgICAgIGdmcC5vdXRfc2FtcGxlcmF0ZSA9IG1hcDJNUDNGcmVxdWVuY3koKGludCkoMC45NyAqIGdmcC5pbl9zYW1wbGVyYXRlKSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogcm91bmQgdXAgd2l0aCBhIG1hcmdpbiBvZiAzICVcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogY2hvb3NlIGEgYml0cmF0ZSBmb3IgdGhlIG91dHB1dCBzYW1wbGVyYXRlIHdoaWNoIGFjaGlldmVzXG4gICAgICAgICAgICAgKiBzcGVjaWZpZWQgY29tcHJlc3Npb24gcmF0aW9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2ZwLmJyYXRlID0gMCB8IChnZnAub3V0X3NhbXBsZXJhdGUgKiAxNiAqIGdmYy5jaGFubmVsc19vdXQgLyAoMS5lMyAqIGdmcC5jb21wcmVzc2lvbl9yYXRpbykpO1xuXG4gICAgICAgICAgICAvKiB3ZSBuZWVkIHRoZSB2ZXJzaW9uIGZvciB0aGUgYml0cmF0ZSB0YWJsZSBsb29rIHVwICovXG4gICAgICAgICAgICBnZmMuc2FtcGxlcmF0ZV9pbmRleCA9IFNtcEZycUluZGV4KGdmcC5vdXRfc2FtcGxlcmF0ZSwgZ2ZwKTtcblxuICAgICAgICAgICAgaWYgKCFnZnAuZnJlZV9mb3JtYXQpIC8qXG4gICAgICAgICAgICAgKiBmb3Igbm9uIEZyZWUgRm9ybWF0IGZpbmQgdGhlIG5lYXJlc3QgYWxsb3dlZFxuICAgICAgICAgICAgICogYml0cmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2ZwLmJyYXRlID0gRmluZE5lYXJlc3RCaXRyYXRlKGdmcC5icmF0ZSwgZ2ZwLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGdmcC5vdXRfc2FtcGxlcmF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZwLm91dF9zYW1wbGVyYXRlICE9IDApIHtcbiAgICAgICAgICAgIGlmIChnZnAub3V0X3NhbXBsZXJhdGUgPCAxNjAwMCkge1xuICAgICAgICAgICAgICAgIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMgPSBNYXRoLm1heChnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzLFxuICAgICAgICAgICAgICAgICAgICA4KTtcbiAgICAgICAgICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gTWF0aC5taW4oZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyxcbiAgICAgICAgICAgICAgICAgICAgNjQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnZnAub3V0X3NhbXBsZXJhdGUgPCAzMjAwMCkge1xuICAgICAgICAgICAgICAgIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMgPSBNYXRoLm1heChnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzLFxuICAgICAgICAgICAgICAgICAgICA4KTtcbiAgICAgICAgICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gTWF0aC5taW4oZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyxcbiAgICAgICAgICAgICAgICAgICAgMTYwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyA9IE1hdGgubWF4KGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMsXG4gICAgICAgICAgICAgICAgICAgIDMyKTtcbiAgICAgICAgICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gTWF0aC5taW4oZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyxcbiAgICAgICAgICAgICAgICAgICAgMzIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKiBpZiBhIGZpbHRlciBoYXMgbm90IGJlZW4gZW5hYmxlZCwgc2VlIGlmIHdlIHNob3VsZCBhZGQgb25lOiAqL1xuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKGdmcC5sb3dwYXNzZnJlcSA9PSAwKSB7XG4gICAgICAgICAgICB2YXIgbG93cGFzcyA9IDE2MDAwLjtcblxuICAgICAgICAgICAgc3dpdGNoIChnZnAuVkJSKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBWYnJNb2RlJDIudmJyX29mZjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaCA9IG5ldyBMb3dQYXNzSGlnaFBhc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW11bV9iYW5kd2lkdGgobGgsIGdmcC5icmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd3Bhc3MgPSBsaC5sb3dlcmxpbWl0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBWYnJNb2RlJDIudmJyX2FicjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaCA9IG5ldyBMb3dQYXNzSGlnaFBhc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW11bV9iYW5kd2lkdGgobGgsIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMpO1xuICAgICAgICAgICAgICAgICAgICBsb3dwYXNzID0gbGgubG93ZXJsaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgVmJyTW9kZSQyLnZicl9yaDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gWzE5NTAwLCAxOTAwMCwgMTg2MDAsIDE4MDAwLCAxNzUwMCwgMTYwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxNTYwMCwgMTQ5MDAsIDEyNTAwLCAxMDAwMCwgMzk1MF07XG4gICAgICAgICAgICAgICAgICAgIGlmICgwIDw9IGdmcC5WQlJfcSAmJiBnZnAuVkJSX3EgPD0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB4W2dmcC5WQlJfcV0sIGIgPSB4W2dmcC5WQlJfcSArIDFdLCBtID0gZ2ZwLlZCUl9xX2ZyYWM7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dwYXNzID0gbGluZWFyX2ludChhLCBiLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd3Bhc3MgPSAxOTUwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gWzE5NTAwLCAxOTAwMCwgMTg1MDAsIDE4MDAwLCAxNzUwMCwgMTY1MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxNTUwMCwgMTQ1MDAsIDEyNTAwLCA5NTAwLCAzOTUwXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPD0gZ2ZwLlZCUl9xICYmIGdmcC5WQlJfcSA8PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHhbZ2ZwLlZCUl9xXSwgYiA9IHhbZ2ZwLlZCUl9xICsgMV0sIG0gPSBnZnAuVkJSX3FfZnJhYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd3Bhc3MgPSBsaW5lYXJfaW50KGEsIGIsIG0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93cGFzcyA9IDE5NTAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdmcC5tb2RlID09IE1QRUdNb2RlLk1PTk9cbiAgICAgICAgICAgICAgICAmJiAoZ2ZwLlZCUiA9PSBWYnJNb2RlJDIudmJyX29mZiB8fCBnZnAuVkJSID09IFZick1vZGUkMi52YnJfYWJyKSlcbiAgICAgICAgICAgICAgICBsb3dwYXNzICo9IDEuNTtcblxuICAgICAgICAgICAgZ2ZwLmxvd3Bhc3NmcmVxID0gbG93cGFzcyB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZwLm91dF9zYW1wbGVyYXRlID09IDApIHtcbiAgICAgICAgICAgIGlmICgyICogZ2ZwLmxvd3Bhc3NmcmVxID4gZ2ZwLmluX3NhbXBsZXJhdGUpIHtcbiAgICAgICAgICAgICAgICBnZnAubG93cGFzc2ZyZXEgPSBnZnAuaW5fc2FtcGxlcmF0ZSAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZnAub3V0X3NhbXBsZXJhdGUgPSBvcHRpbXVtX3NhbXBsZWZyZXEoZ2ZwLmxvd3Bhc3NmcmVxIHwgMCxcbiAgICAgICAgICAgICAgICBnZnAuaW5fc2FtcGxlcmF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBnZnAubG93cGFzc2ZyZXEgPSBNYXRoLm1pbigyMDUwMCwgZ2ZwLmxvd3Bhc3NmcmVxKTtcbiAgICAgICAgZ2ZwLmxvd3Bhc3NmcmVxID0gTWF0aC5taW4oZ2ZwLm91dF9zYW1wbGVyYXRlIC8gMiwgZ2ZwLmxvd3Bhc3NmcmVxKTtcblxuICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlJDIudmJyX29mZikge1xuICAgICAgICAgICAgZ2ZwLmNvbXByZXNzaW9uX3JhdGlvID0gZ2ZwLm91dF9zYW1wbGVyYXRlICogMTYgKiBnZmMuY2hhbm5lbHNfb3V0XG4gICAgICAgICAgICAgICAgLyAoMS5lMyAqIGdmcC5icmF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdmcC5WQlIgPT0gVmJyTW9kZSQyLnZicl9hYnIpIHtcbiAgICAgICAgICAgIGdmcC5jb21wcmVzc2lvbl9yYXRpbyA9IGdmcC5vdXRfc2FtcGxlcmF0ZSAqIDE2ICogZ2ZjLmNoYW5uZWxzX291dFxuICAgICAgICAgICAgICAgIC8gKDEuZTMgKiBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGRvIG5vdCBjb21wdXRlIFJlcGxheUdhaW4gdmFsdWVzIGFuZCBkbyBub3QgZmluZCB0aGUgcGVhayBzYW1wbGUgaWZcbiAgICAgICAgICogd2UgY2FuJ3Qgc3RvcmUgdGhlbVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFnZnAuYldyaXRlVmJyVGFnKSB7XG4gICAgICAgICAgICBnZnAuZmluZFJlcGxheUdhaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGdmcC5kZWNvZGVfb25fdGhlX2ZseSA9IGZhbHNlO1xuICAgICAgICAgICAgZ2ZjLmZpbmRQZWFrU2FtcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2ZjLmZpbmRSZXBsYXlHYWluID0gZ2ZwLmZpbmRSZXBsYXlHYWluO1xuICAgICAgICBnZmMuZGVjb2RlX29uX3RoZV9mbHkgPSBnZnAuZGVjb2RlX29uX3RoZV9mbHk7XG5cbiAgICAgICAgaWYgKGdmYy5kZWNvZGVfb25fdGhlX2ZseSlcbiAgICAgICAgICAgIGdmYy5maW5kUGVha1NhbXBsZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGdmYy5maW5kUmVwbGF5R2Fpbikge1xuICAgICAgICAgICAgaWYgKGdhLkluaXRHYWluQW5hbHlzaXMoZ2ZjLnJnZGF0YSwgZ2ZwLm91dF9zYW1wbGVyYXRlKSA9PSBHYWluQW5hbHlzaXMuSU5JVF9HQUlOX0FOQUxZU0lTX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgZ2ZwLmludGVybmFsX2ZsYWdzID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZjLmRlY29kZV9vbl90aGVfZmx5ICYmICFnZnAuZGVjb2RlX29ubHkpIHtcbiAgICAgICAgICAgIGlmIChnZmMuaGlwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtcGdsaWIuaGlwX2RlY29kZV9leGl0KGdmYy5oaXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2ZjLmhpcCA9IG1wZ2xpYi5oaXBfZGVjb2RlX2luaXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdmYy5tb2RlX2dyID0gZ2ZwLm91dF9zYW1wbGVyYXRlIDw9IDI0MDAwID8gMSA6IDI7XG4gICAgICAgIC8qXG4gICAgICAgICAqIE51bWJlciBvZiBncmFudWxlcyBwZXIgZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIGdmcC5mcmFtZXNpemUgPSA1NzYgKiBnZmMubW9kZV9ncjtcbiAgICAgICAgZ2ZwLmVuY29kZXJfZGVsYXkgPSBFbmNvZGVyXzEuRU5DREVMQVk7XG5cbiAgICAgICAgZ2ZjLnJlc2FtcGxlX3JhdGlvID0gZ2ZwLmluX3NhbXBsZXJhdGUgLyBnZnAub3V0X3NhbXBsZXJhdGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxQUkU+XG4gICAgICAgICAqICBzYW1wbGUgZnJlcSAgICAgICBiaXRyYXRlICAgICBjb21wcmVzc2lvbiByYXRpb1xuICAgICAgICAgKiAgICAgW2tIel0gICAgICBba2Jwcy9jaGFubmVsXSAgIGZvciAxNiBiaXQgaW5wdXRcbiAgICAgICAgICogICAgIDQ0LjEgICAgICAgICAgICA1NiAgICAgICAgICAgICAgIDEyLjZcbiAgICAgICAgICogICAgIDQ0LjEgICAgICAgICAgICA2NCAgICAgICAgICAgICAgIDExLjAyNVxuICAgICAgICAgKiAgICAgNDQuMSAgICAgICAgICAgIDgwICAgICAgICAgICAgICAgIDguODJcbiAgICAgICAgICogICAgIDIyLjA1ICAgICAgICAgICAyNCAgICAgICAgICAgICAgIDE0LjdcbiAgICAgICAgICogICAgIDIyLjA1ICAgICAgICAgICAzMiAgICAgICAgICAgICAgIDExLjAyNVxuICAgICAgICAgKiAgICAgMjIuMDUgICAgICAgICAgIDQwICAgICAgICAgICAgICAgIDguODJcbiAgICAgICAgICogICAgIDE2ICAgICAgICAgICAgICAxNiAgICAgICAgICAgICAgIDE2LjBcbiAgICAgICAgICogICAgIDE2ICAgICAgICAgICAgICAyNCAgICAgICAgICAgICAgIDEwLjY2N1xuICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8UFJFPlxuICAgICAgICAgKiAgRm9yIFZCUiwgdGFrZSBhIGd1ZXNzIGF0IHRoZSBjb21wcmVzc2lvbl9yYXRpby5cbiAgICAgICAgICogIEZvciBleGFtcGxlOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICBWQlJfcSAgICBjb21wcmVzc2lvbiAgICAgbGlrZVxuICAgICAgICAgKiAgICAgLSAgICAgICAgNC40ICAgICAgICAgMzIwIGticHMvNDQga0h6XG4gICAgICAgICAqICAgMC4uLjEgICAgICA1LjUgICAgICAgICAyNTYga2Jwcy80NCBrSHpcbiAgICAgICAgICogICAgIDIgICAgICAgIDcuMyAgICAgICAgIDE5MiBrYnBzLzQ0IGtIelxuICAgICAgICAgKiAgICAgNCAgICAgICAgOC44ICAgICAgICAgMTYwIGticHMvNDQga0h6XG4gICAgICAgICAqICAgICA2ICAgICAgIDExICAgICAgICAgICAxMjgga2Jwcy80NCBrSHpcbiAgICAgICAgICogICAgIDkgICAgICAgMTQuNyAgICAgICAgICA5NiBrYnBzXG4gICAgICAgICAqXG4gICAgICAgICAqICBmb3IgbG93ZXIgYml0cmF0ZXMsIGRvd25zYW1wbGUgd2l0aCAtLXJlc2FtcGxlXG4gICAgICAgICAqIDwvUFJFPlxuICAgICAgICAgKi9cbiAgICAgICAgc3dpdGNoIChnZnAuVkJSKSB7XG4gICAgICAgICAgICBjYXNlIFZick1vZGUkMi52YnJfbXQ6XG4gICAgICAgICAgICBjYXNlIFZick1vZGUkMi52YnJfcmg6XG4gICAgICAgICAgICBjYXNlIFZick1vZGUkMi52YnJfbXRyaDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvKiBudW1iZXJzIGFyZSBhIGJpdCBzdHJhbmdlLCBidXQgdGhleSBkZXRlcm1pbmUgdGhlIGxvd3Bhc3MgdmFsdWUgKi9cbiAgICAgICAgICAgICAgICB2YXIgY21wID0gWzUuNywgNi41LCA3LjMsIDguMiwgMTAsIDExLjksIDEzLCAxNCxcbiAgICAgICAgICAgICAgICAgICAgMTUsIDE2LjVdO1xuICAgICAgICAgICAgICAgIGdmcC5jb21wcmVzc2lvbl9yYXRpbyA9IGNtcFtnZnAuVkJSX3FdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBWYnJNb2RlJDIudmJyX2FicjpcbiAgICAgICAgICAgICAgICBnZnAuY29tcHJlc3Npb25fcmF0aW8gPSBnZnAub3V0X3NhbXBsZXJhdGUgKiAxNiAqIGdmYy5jaGFubmVsc19vdXRcbiAgICAgICAgICAgICAgICAgICAgLyAoMS5lMyAqIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBnZnAuY29tcHJlc3Npb25fcmF0aW8gPSBnZnAub3V0X3NhbXBsZXJhdGUgKiAxNiAqIGdmYy5jaGFubmVsc19vdXRcbiAgICAgICAgICAgICAgICAgICAgLyAoMS5lMyAqIGdmcC5icmF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBtb2RlID0gLTEgKG5vdCBzZXQgYnkgdXNlcikgb3IgbW9kZSA9IE1PTk8gKGJlY2F1c2Ugb2Ygb25seSAxIGlucHV0XG4gICAgICAgICAqIGNoYW5uZWwpLiBJZiBtb2RlIGhhcyBub3QgYmVlbiBzZXQsIHRoZW4gc2VsZWN0IEotU1RFUkVPXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZ2ZwLm1vZGUgPT0gTVBFR01vZGUuTk9UX1NFVCkge1xuICAgICAgICAgICAgZ2ZwLm1vZGUgPSBNUEVHTW9kZS5KT0lOVF9TVEVSRU87XG4gICAgICAgIH1cblxuICAgICAgICAvKiBhcHBseSB1c2VyIGRyaXZlbiBoaWdoIHBhc3MgZmlsdGVyICovXG4gICAgICAgIGlmIChnZnAuaGlnaHBhc3NmcmVxID4gMCkge1xuICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMSA9IDIuICogZ2ZwLmhpZ2hwYXNzZnJlcTtcblxuICAgICAgICAgICAgaWYgKGdmcC5oaWdocGFzc3dpZHRoID49IDApXG4gICAgICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMiA9IDIuICogKGdmcC5oaWdocGFzc2ZyZXEgKyBnZnAuaGlnaHBhc3N3aWR0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAvKiAwJSBhYm92ZSBvbiBkZWZhdWx0ICovXG4gICAgICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMiA9ICgxICsgMC4wMCkgKiAyLiAqIGdmcC5oaWdocGFzc2ZyZXE7XG5cbiAgICAgICAgICAgIGdmYy5oaWdocGFzczEgLz0gZ2ZwLm91dF9zYW1wbGVyYXRlO1xuICAgICAgICAgICAgZ2ZjLmhpZ2hwYXNzMiAvPSBnZnAub3V0X3NhbXBsZXJhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZmMuaGlnaHBhc3MxID0gMDtcbiAgICAgICAgICAgIGdmYy5oaWdocGFzczIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qIGFwcGx5IHVzZXIgZHJpdmVuIGxvdyBwYXNzIGZpbHRlciAqL1xuICAgICAgICBpZiAoZ2ZwLmxvd3Bhc3NmcmVxID4gMCkge1xuICAgICAgICAgICAgZ2ZjLmxvd3Bhc3MyID0gMi4gKiBnZnAubG93cGFzc2ZyZXE7XG4gICAgICAgICAgICBpZiAoZ2ZwLmxvd3Bhc3N3aWR0aCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZ2ZjLmxvd3Bhc3MxID0gMi4gKiAoZ2ZwLmxvd3Bhc3NmcmVxIC0gZ2ZwLmxvd3Bhc3N3aWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5sb3dwYXNzMSA8IDApIC8qIGhhcyB0byBiZSA+PSAwICovXG4gICAgICAgICAgICAgICAgICAgIGdmYy5sb3dwYXNzMSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgeyAvKiAwJSBiZWxvdyBvbiBkZWZhdWx0ICovXG4gICAgICAgICAgICAgICAgZ2ZjLmxvd3Bhc3MxID0gKDEgLSAwLjAwKSAqIDIuICogZ2ZwLmxvd3Bhc3NmcmVxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2ZjLmxvd3Bhc3MxIC89IGdmcC5vdXRfc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgIGdmYy5sb3dwYXNzMiAvPSBnZnAub3V0X3NhbXBsZXJhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZmMubG93cGFzczEgPSAwO1xuICAgICAgICAgICAgZ2ZjLmxvd3Bhc3MyID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKiBjb21wdXRlIGluZm8gbmVlZGVkIGZvciBwb2x5cGhhc2UgZmlsdGVyIChmaWx0ZXIgdHlwZT09MCwgZGVmYXVsdCkgKi9cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGxhbWVfaW5pdF9wYXJhbXNfcHBmbHQoZ2ZwKTtcbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogc2FtcGxlcmF0ZSBhbmQgYml0cmF0ZSBpbmRleFxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgZ2ZjLnNhbXBsZXJhdGVfaW5kZXggPSBTbXBGcnFJbmRleChnZnAub3V0X3NhbXBsZXJhdGUsIGdmcCk7XG4gICAgICAgIGlmIChnZmMuc2FtcGxlcmF0ZV9pbmRleCA8IDApIHtcbiAgICAgICAgICAgIGdmcC5pbnRlcm5hbF9mbGFncyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlJDIudmJyX29mZikge1xuICAgICAgICAgICAgaWYgKGdmcC5mcmVlX2Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIGdmYy5iaXRyYXRlX2luZGV4ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2ZwLmJyYXRlID0gRmluZE5lYXJlc3RCaXRyYXRlKGdmcC5icmF0ZSwgZ2ZwLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGdmcC5vdXRfc2FtcGxlcmF0ZSk7XG4gICAgICAgICAgICAgICAgZ2ZjLmJpdHJhdGVfaW5kZXggPSBCaXRyYXRlSW5kZXgoZ2ZwLmJyYXRlLCBnZnAudmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgZ2ZwLm91dF9zYW1wbGVyYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLmJpdHJhdGVfaW5kZXggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZnAuaW50ZXJuYWxfZmxhZ3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2ZjLmJpdHJhdGVfaW5kZXggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogZm9yIENCUiwgd2Ugd2lsbCB3cml0ZSBhbiBcImluZm9cIiB0YWcuICovXG5cbiAgICAgICAgaWYgKGdmcC5hbmFseXNpcylcbiAgICAgICAgICAgIGdmcC5iV3JpdGVWYnJUYWcgPSBmYWxzZTtcblxuICAgICAgICAvKiBzb21lIGZpbGUgb3B0aW9ucyBub3QgYWxsb3dlZCBpZiBvdXRwdXQgaXM6IG5vdCBzcGVjaWZpZWQgb3Igc3Rkb3V0ICovXG4gICAgICAgIGlmIChnZmMucGluZm8gIT0gbnVsbClcbiAgICAgICAgICAgIGdmcC5iV3JpdGVWYnJUYWcgPSBmYWxzZTtcbiAgICAgICAgLyogZGlzYWJsZSBYaW5nIFZCUiB0YWcgKi9cblxuICAgICAgICBicy5pbml0X2JpdF9zdHJlYW1fdyhnZmMpO1xuXG4gICAgICAgIHZhciBqID0gZ2ZjLnNhbXBsZXJhdGVfaW5kZXggKyAoMyAqIGdmcC52ZXJzaW9uKSArIDZcbiAgICAgICAgICAgICogKGdmcC5vdXRfc2FtcGxlcmF0ZSA8IDE2MDAwID8gMSA6IDApO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEVuY29kZXJfMS5TQk1BWF9sICsgMTsgaSsrKVxuICAgICAgICAgICAgZ2ZjLnNjYWxlZmFjX2JhbmQubFtpXSA9IHF1cHZ0LnNmQmFuZEluZGV4W2pdLmxbaV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBFbmNvZGVyXzEuUFNGQjIxICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IChnZmMuc2NhbGVmYWNfYmFuZC5sWzIyXSAtIGdmYy5zY2FsZWZhY19iYW5kLmxbMjFdKVxuICAgICAgICAgICAgICAgIC8gRW5jb2Rlcl8xLlBTRkIyMTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGdmYy5zY2FsZWZhY19iYW5kLmxbMjFdICsgaSAqIHNpemU7XG4gICAgICAgICAgICBnZmMuc2NhbGVmYWNfYmFuZC5wc2ZiMjFbaV0gPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICBnZmMuc2NhbGVmYWNfYmFuZC5wc2ZiMjFbRW5jb2Rlcl8xLlBTRkIyMV0gPSA1NzY7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBFbmNvZGVyXzEuU0JNQVhfcyArIDE7IGkrKylcbiAgICAgICAgICAgIGdmYy5zY2FsZWZhY19iYW5kLnNbaV0gPSBxdXB2dC5zZkJhbmRJbmRleFtqXS5zW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRW5jb2Rlcl8xLlBTRkIxMiArIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNpemUgPSAoZ2ZjLnNjYWxlZmFjX2JhbmQuc1sxM10gLSBnZmMuc2NhbGVmYWNfYmFuZC5zWzEyXSlcbiAgICAgICAgICAgICAgICAvIEVuY29kZXJfMS5QU0ZCMTI7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBnZmMuc2NhbGVmYWNfYmFuZC5zWzEyXSArIGkgKiBzaXplO1xuICAgICAgICAgICAgZ2ZjLnNjYWxlZmFjX2JhbmQucHNmYjEyW2ldID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2ZjLnNjYWxlZmFjX2JhbmQucHNmYjEyW0VuY29kZXJfMS5QU0ZCMTJdID0gMTkyO1xuICAgICAgICAvKiBkZXRlcm1pbmUgdGhlIG1lYW4gYml0cmF0ZSBmb3IgbWFpbiBkYXRhICovXG4gICAgICAgIGlmIChnZnAudmVyc2lvbiA9PSAxKSAvKiBNUEVHIDEgKi9cbiAgICAgICAgICAgIGdmYy5zaWRlaW5mb19sZW4gPSAoZ2ZjLmNoYW5uZWxzX291dCA9PSAxKSA/IDQgKyAxNyA6IDQgKyAzMjtcbiAgICAgICAgZWxzZVxuICAgICAgICAvKiBNUEVHIDIgKi9cbiAgICAgICAgICAgIGdmYy5zaWRlaW5mb19sZW4gPSAoZ2ZjLmNoYW5uZWxzX291dCA9PSAxKSA/IDQgKyA5IDogNCArIDE3O1xuXG4gICAgICAgIGlmIChnZnAuZXJyb3JfcHJvdGVjdGlvbilcbiAgICAgICAgICAgIGdmYy5zaWRlaW5mb19sZW4gKz0gMjtcblxuICAgICAgICBsYW1lX2luaXRfYml0c3RyZWFtKGdmcCk7XG5cbiAgICAgICAgZ2ZjLkNsYXNzX0lEID0gTEFNRV9JRDtcblxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaztcblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDE5OyBrKyspXG4gICAgICAgICAgICAgICAgZ2ZjLm5zUHN5LnBlZmlyYnVmW2tdID0gNzAwICogZ2ZjLm1vZGVfZ3IgKiBnZmMuY2hhbm5lbHNfb3V0O1xuXG4gICAgICAgICAgICBpZiAoZ2ZwLkFUSHR5cGUgPT0gLTEpXG4gICAgICAgICAgICAgICAgZ2ZwLkFUSHR5cGUgPSA0O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCQyKGdmcC5WQlJfcSA8PSA5KTtcbiAgICAgICAgYXNzZXJ0JDIoZ2ZwLlZCUl9xID49IDApO1xuXG4gICAgICAgIHN3aXRjaCAoZ2ZwLlZCUikge1xuXG4gICAgICAgICAgICBjYXNlIFZick1vZGUkMi52YnJfbXQ6XG4gICAgICAgICAgICAgICAgZ2ZwLlZCUiA9IFZick1vZGUkMi52YnJfbXRyaDtcbiAgICAgICAgICAgIC8vJEZBTEwtVEhST1VHSCRcbiAgICAgICAgICAgIGNhc2UgVmJyTW9kZSQyLnZicl9tdHJoOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChnZnAudXNlVGVtcG9yYWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBnZnAudXNlVGVtcG9yYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLyogb2ZmIGJ5IGRlZmF1bHQgZm9yIHRoaXMgVkJSIG1vZGUgKi9cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwLmFwcGx5X3ByZXNldChnZnAsIDUwMCAtIChnZnAuVkJSX3EgKiAxMCksIDApO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIDxQUkU+XG4gICAgICAgICAgICAgICAgICogICBUaGUgbmV3ZXIgVkJSIGNvZGUgc3VwcG9ydHMgb25seSBhIGxpbWl0ZWRcbiAgICAgICAgICAgICAgICAgKiAgICAgc3Vic2V0IG9mIHF1YWxpdHkgbGV2ZWxzOlxuICAgICAgICAgICAgICAgICAqICAgICA5LTU9NSBhcmUgdGhlIHNhbWUsIHVzZXMgeF4zLzQgcXVhbnRpemF0aW9uXG4gICAgICAgICAgICAgICAgICogICA0LTA9MCBhcmUgdGhlIHNhbWUgIDUgcGx1cyBiZXN0IGh1ZmZtYW4gZGl2aWRlIGNvZGVcbiAgICAgICAgICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoZ2ZwLnF1YWxpdHkgPCAwKVxuICAgICAgICAgICAgICAgICAgICBnZnAucXVhbGl0eSA9IExBTUVfREVGQVVMVF9RVUFMSVRZO1xuICAgICAgICAgICAgICAgIGlmIChnZnAucXVhbGl0eSA8IDUpXG4gICAgICAgICAgICAgICAgICAgIGdmcC5xdWFsaXR5ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZwLnF1YWxpdHkgPiA1KVxuICAgICAgICAgICAgICAgICAgICBnZnAucXVhbGl0eSA9IDU7XG5cbiAgICAgICAgICAgICAgICBnZmMuUFNZLm1hc2tfYWRqdXN0ID0gZ2ZwLm1hc2tpbmdhZGp1c3Q7XG4gICAgICAgICAgICAgICAgZ2ZjLlBTWS5tYXNrX2FkanVzdF9zaG9ydCA9IGdmcC5tYXNraW5nYWRqdXN0X3Nob3J0O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBzZmIyMSBleHRyYSBvbmx5IHdpdGggTVBFRy0xIGF0IGhpZ2hlciBzYW1wbGluZyByYXRlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChnZnAuZXhwZXJpbWVudGFsWSlcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnNmYjIxX2V4dHJhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZmMuc2ZiMjFfZXh0cmEgPSAoZ2ZwLm91dF9zYW1wbGVyYXRlID4gNDQwMDApO1xuXG4gICAgICAgICAgICAgICAgZ2ZjLml0ZXJhdGlvbl9sb29wID0gbmV3IFZCUk5ld0l0ZXJhdGlvbkxvb3AocXUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFZick1vZGUkMi52YnJfcmg6XG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICBwLmFwcGx5X3ByZXNldChnZnAsIDUwMCAtIChnZnAuVkJSX3EgKiAxMCksIDApO1xuXG4gICAgICAgICAgICAgICAgZ2ZjLlBTWS5tYXNrX2FkanVzdCA9IGdmcC5tYXNraW5nYWRqdXN0O1xuICAgICAgICAgICAgICAgIGdmYy5QU1kubWFza19hZGp1c3Rfc2hvcnQgPSBnZnAubWFza2luZ2FkanVzdF9zaG9ydDtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogc2ZiMjEgZXh0cmEgb25seSB3aXRoIE1QRUctMSBhdCBoaWdoZXIgc2FtcGxpbmcgcmF0ZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoZ2ZwLmV4cGVyaW1lbnRhbFkpXG4gICAgICAgICAgICAgICAgICAgIGdmYy5zZmIyMV9leHRyYSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLnNmYjIxX2V4dHJhID0gKGdmcC5vdXRfc2FtcGxlcmF0ZSA+IDQ0MDAwKTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogVkJSIG5lZWRzIGF0IGxlYXN0IHRoZSBvdXRwdXQgb2YgR1BTWUNITywgc28gd2UgaGF2ZSB0byBnYXJhbnRlZVxuICAgICAgICAgICAgICAgICAqIHRoYXQgYnkgc2V0dGluZyBhIG1pbmltdW0gcXVhbGl0eSBsZXZlbCwgYWN0dWFsbHkgbGV2ZWwgNiBkb2VzXG4gICAgICAgICAgICAgICAgICogaXQuIGRvd24gdG8gbGV2ZWwgNlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChnZnAucXVhbGl0eSA+IDYpXG4gICAgICAgICAgICAgICAgICAgIGdmcC5xdWFsaXR5ID0gNjtcblxuICAgICAgICAgICAgICAgIGlmIChnZnAucXVhbGl0eSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGdmcC5xdWFsaXR5ID0gTEFNRV9ERUZBVUxUX1FVQUxJVFk7XG5cbiAgICAgICAgICAgICAgICBnZmMuaXRlcmF0aW9uX2xvb3AgPSBuZXcgVkJST2xkSXRlcmF0aW9uTG9vcChxdSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6IC8qIGNici9hYnIgKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdmJybW9kZTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogbm8gc2ZiMjEgZXh0cmEgd2l0aCBDQlIgY29kZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGdmYy5zZmIyMV9leHRyYSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGdmcC5xdWFsaXR5IDwgMClcbiAgICAgICAgICAgICAgICAgICAgZ2ZwLnF1YWxpdHkgPSBMQU1FX0RFRkFVTFRfUVVBTElUWTtcblxuICAgICAgICAgICAgICAgIHZicm1vZGUgPSBnZnAuVkJSO1xuICAgICAgICAgICAgICAgIGlmICh2YnJtb2RlID09IFZick1vZGUkMi52YnJfb2ZmKVxuICAgICAgICAgICAgICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gZ2ZwLmJyYXRlO1xuICAgICAgICAgICAgICAgIC8qIHNlY29uZCwgc2V0IHBhcmFtZXRlcnMgZGVwZW5kaW5nIG9uIGJpdHJhdGUgKi9cbiAgICAgICAgICAgICAgICBwLmFwcGx5X3ByZXNldChnZnAsIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMsIDApO1xuICAgICAgICAgICAgICAgIGdmcC5WQlIgPSB2YnJtb2RlO1xuXG4gICAgICAgICAgICAgICAgZ2ZjLlBTWS5tYXNrX2FkanVzdCA9IGdmcC5tYXNraW5nYWRqdXN0O1xuICAgICAgICAgICAgICAgIGdmYy5QU1kubWFza19hZGp1c3Rfc2hvcnQgPSBnZnAubWFza2luZ2FkanVzdF9zaG9ydDtcblxuICAgICAgICAgICAgICAgIGlmICh2YnJtb2RlID09IFZick1vZGUkMi52YnJfb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgIGdmYy5pdGVyYXRpb25fbG9vcCA9IG5ldyBDQlJOZXdJdGVyYXRpb25Mb29wXzEocXUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdmYy5pdGVyYXRpb25fbG9vcCA9IG5ldyBBQlJJdGVyYXRpb25Mb29wKHF1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0JDIoZ2ZwLnNjYWxlID49IDApO1xuICAgICAgICAvKiBpbml0aWFsaXplIGRlZmF1bHQgdmFsdWVzIGNvbW1vbiBmb3IgYWxsIG1vZGVzICovXG5cbiAgICAgICAgaWYgKGdmcC5WQlIgIT0gVmJyTW9kZSQyLnZicl9vZmYpIHsgLyogY2hvb3NlIGEgbWluL21heCBiaXRyYXRlIGZvciBWQlIgKi9cbiAgICAgICAgICAgIC8qIGlmIHRoZSB1c2VyIGRpZG4ndCBzcGVjaWZ5IFZCUl9tYXhfYml0cmF0ZTogKi9cbiAgICAgICAgICAgIGdmYy5WQlJfbWluX2JpdHJhdGUgPSAxO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGRlZmF1bHQ6IGFsbG93IDgga2JwcyAoTVBFRy0yKSBvciAzMiBrYnBzIChNUEVHLTEpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdmYy5WQlJfbWF4X2JpdHJhdGUgPSAxNDtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBkZWZhdWx0OiBhbGxvdyAxNjAga2JwcyAoTVBFRy0yKSBvciAzMjAga2JwcyAoTVBFRy0xKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZ2ZwLm91dF9zYW1wbGVyYXRlIDwgMTYwMDApXG4gICAgICAgICAgICAgICAgZ2ZjLlZCUl9tYXhfYml0cmF0ZSA9IDg7XG4gICAgICAgICAgICAvKiBkZWZhdWx0OiBhbGxvdyA2NCBrYnBzIChNUEVHLTIuNSkgKi9cbiAgICAgICAgICAgIGlmIChnZnAuVkJSX21pbl9iaXRyYXRlX2ticHMgIT0gMCkge1xuICAgICAgICAgICAgICAgIGdmcC5WQlJfbWluX2JpdHJhdGVfa2JwcyA9IEZpbmROZWFyZXN0Qml0cmF0ZShcbiAgICAgICAgICAgICAgICAgICAgZ2ZwLlZCUl9taW5fYml0cmF0ZV9rYnBzLCBnZnAudmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgZ2ZwLm91dF9zYW1wbGVyYXRlKTtcbiAgICAgICAgICAgICAgICBnZmMuVkJSX21pbl9iaXRyYXRlID0gQml0cmF0ZUluZGV4KGdmcC5WQlJfbWluX2JpdHJhdGVfa2JwcyxcbiAgICAgICAgICAgICAgICAgICAgZ2ZwLnZlcnNpb24sIGdmcC5vdXRfc2FtcGxlcmF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdmYy5WQlJfbWluX2JpdHJhdGUgPCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2ZwLlZCUl9tYXhfYml0cmF0ZV9rYnBzICE9IDApIHtcbiAgICAgICAgICAgICAgICBnZnAuVkJSX21heF9iaXRyYXRlX2ticHMgPSBGaW5kTmVhcmVzdEJpdHJhdGUoXG4gICAgICAgICAgICAgICAgICAgIGdmcC5WQlJfbWF4X2JpdHJhdGVfa2JwcywgZ2ZwLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGdmcC5vdXRfc2FtcGxlcmF0ZSk7XG4gICAgICAgICAgICAgICAgZ2ZjLlZCUl9tYXhfYml0cmF0ZSA9IEJpdHJhdGVJbmRleChnZnAuVkJSX21heF9iaXRyYXRlX2ticHMsXG4gICAgICAgICAgICAgICAgICAgIGdmcC52ZXJzaW9uLCBnZnAub3V0X3NhbXBsZXJhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChnZmMuVkJSX21heF9iaXRyYXRlIDwgMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2ZwLlZCUl9taW5fYml0cmF0ZV9rYnBzID0gVGFibGVzXzEuYml0cmF0ZV90YWJsZVtnZnAudmVyc2lvbl1bZ2ZjLlZCUl9taW5fYml0cmF0ZV07XG4gICAgICAgICAgICBnZnAuVkJSX21heF9iaXRyYXRlX2ticHMgPSBUYWJsZXNfMS5iaXRyYXRlX3RhYmxlW2dmcC52ZXJzaW9uXVtnZmMuVkJSX21heF9iaXRyYXRlXTtcbiAgICAgICAgICAgIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBUYWJsZXNfMS5iaXRyYXRlX3RhYmxlW2dmcC52ZXJzaW9uXVtnZmMuVkJSX21heF9iaXRyYXRlXSxcbiAgICAgICAgICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzKTtcbiAgICAgICAgICAgIGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBUYWJsZXNfMS5iaXRyYXRlX3RhYmxlW2dmcC52ZXJzaW9uXVtnZmMuVkJSX21pbl9iaXRyYXRlXSxcbiAgICAgICAgICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGp1c3QgYW5vdGhlciBkYWlseSBjaGFuZ2luZyBkZXZlbG9wZXIgc3dpdGNoICovXG4gICAgICAgIGlmIChnZnAudHVuZSkge1xuICAgICAgICAgICAgZ2ZjLlBTWS5tYXNrX2FkanVzdCArPSBnZnAudHVuZV92YWx1ZV9hO1xuICAgICAgICAgICAgZ2ZjLlBTWS5tYXNrX2FkanVzdF9zaG9ydCArPSBnZnAudHVuZV92YWx1ZV9hO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBpbnRlcm5hbCBxdmFsIHNldHRpbmdzICovXG4gICAgICAgIGxhbWVfaW5pdF9xdmFsKGdmcCk7XG4gICAgICAgIGFzc2VydCQyKGdmcC5zY2FsZSA+PSAwKTtcbiAgICAgICAgLypcbiAgICAgICAgICogYXV0b21hdGljIEFUSCBhZGp1c3RtZW50IG9uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZ2ZwLmF0aGFhX3R5cGUgPCAwKVxuICAgICAgICAgICAgZ2ZjLkFUSC51c2VBZGp1c3QgPSAzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBnZmMuQVRILnVzZUFkanVzdCA9IGdmcC5hdGhhYV90eXBlO1xuXG4gICAgICAgIC8qIGluaXRpYWxpemUgaW50ZXJuYWwgYWRhcHRpdmUgQVRIIHNldHRpbmdzIC1qZCAqL1xuICAgICAgICBnZmMuQVRILmFhU2Vuc2l0aXZpdHlQID0gTWF0aC5wb3coMTAuMCwgZ2ZwLmF0aGFhX3NlbnNpdGl2aXR5XG4gICAgICAgICAgICAvIC0xMC4wKTtcblxuICAgICAgICBpZiAoZ2ZwLnNob3J0X2Jsb2NrcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBnZnAuc2hvcnRfYmxvY2tzID0gU2hvcnRCbG9jayQyLnNob3J0X2Jsb2NrX2FsbG93ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBOb3RlIEphbi8yMDAzOiBNYW55IGhhcmR3YXJlIGRlY29kZXJzIGNhbm5vdCBoYW5kbGUgc2hvcnQgYmxvY2tzIGluXG4gICAgICAgICAqIHJlZ3VsYXIgc3RlcmVvIG1vZGUgdW5sZXNzIHRoZXkgYXJlIGNvdXBsZWQgKHNhbWUgdHlwZSBpbiBib3RoXG4gICAgICAgICAqIGNoYW5uZWxzKSBpdCBpcyBhIHJhcmUgZXZlbnQgKDEgZnJhbWUgcGVyIG1pbi4gb3Igc28pIHRoYXQgTEFNRSB3b3VsZFxuICAgICAgICAgKiB1c2UgdW5jb3VwbGVkIHNob3J0IGJsb2Nrcywgc28gbGV0cyB0dXJuIHRoZW0gb2ZmIHVudGlsIHdlIGRlY2lkZSBob3dcbiAgICAgICAgICogdG8gaGFuZGxlIHRoaXMuIE5vIG90aGVyIGVuY29kZXJzIGFsbG93IHVuY291cGxlZCBzaG9ydCBibG9ja3MsIGV2ZW5cbiAgICAgICAgICogdGhvdWdoIGl0IGlzIGluIHRoZSBzdGFuZGFyZC5cbiAgICAgICAgICovXG4gICAgICAgIC8qXG4gICAgICAgICAqIHJoIDIwMDQwMjE3OiBjb3VwbGluZyBtYWtlcyBubyBzZW5zZSBmb3IgbW9ubyBhbmQgZHVhbC1tb25vIHN0cmVhbXNcbiAgICAgICAgICovXG4gICAgICAgIGlmIChnZnAuc2hvcnRfYmxvY2tzID09IFNob3J0QmxvY2skMi5zaG9ydF9ibG9ja19hbGxvd2VkXG4gICAgICAgICAgICAmJiAoZ2ZwLm1vZGUgPT0gTVBFR01vZGUuSk9JTlRfU1RFUkVPIHx8IGdmcC5tb2RlID09IE1QRUdNb2RlLlNURVJFTykpIHtcbiAgICAgICAgICAgIGdmcC5zaG9ydF9ibG9ja3MgPSBTaG9ydEJsb2NrJDIuc2hvcnRfYmxvY2tfY291cGxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZnAucXVhbnRfY29tcCA8IDApXG4gICAgICAgICAgICBnZnAucXVhbnRfY29tcCA9IDE7XG4gICAgICAgIGlmIChnZnAucXVhbnRfY29tcF9zaG9ydCA8IDApXG4gICAgICAgICAgICBnZnAucXVhbnRfY29tcF9zaG9ydCA9IDA7XG5cbiAgICAgICAgaWYgKGdmcC5tc2ZpeCA8IDApXG4gICAgICAgICAgICBnZnAubXNmaXggPSAwO1xuXG4gICAgICAgIC8qIHNlbGVjdCBwc3ljaG9hY291c3RpYyBtb2RlbCAqL1xuICAgICAgICBnZnAuZXhwX25zcHN5dHVuZSA9IGdmcC5leHBfbnNwc3l0dW5lIHwgMTtcblxuICAgICAgICBpZiAoZ2ZwLmludGVybmFsX2ZsYWdzLm5zUHN5LmF0dGFja3RocmUgPCAwKVxuICAgICAgICAgICAgZ2ZwLmludGVybmFsX2ZsYWdzLm5zUHN5LmF0dGFja3RocmUgPSBQc3lNb2RlbF8xLk5TQVRUQUNLVEhSRTtcbiAgICAgICAgaWYgKGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlX3MgPCAwKVxuICAgICAgICAgICAgZ2ZwLmludGVybmFsX2ZsYWdzLm5zUHN5LmF0dGFja3RocmVfcyA9IFBzeU1vZGVsXzEuTlNBVFRBQ0tUSFJFX1M7XG5cbiAgICAgICAgYXNzZXJ0JDIoZ2ZwLnNjYWxlID49IDApO1xuXG4gICAgICAgIGlmIChnZnAuc2NhbGUgPCAwKVxuICAgICAgICAgICAgZ2ZwLnNjYWxlID0gMTtcblxuICAgICAgICBpZiAoZ2ZwLkFUSHR5cGUgPCAwKVxuICAgICAgICAgICAgZ2ZwLkFUSHR5cGUgPSA0O1xuXG4gICAgICAgIGlmIChnZnAuQVRIY3VydmUgPCAwKVxuICAgICAgICAgICAgZ2ZwLkFUSGN1cnZlID0gNDtcblxuICAgICAgICBpZiAoZ2ZwLmF0aGFhX2xvdWRhcHByb3ggPCAwKVxuICAgICAgICAgICAgZ2ZwLmF0aGFhX2xvdWRhcHByb3ggPSAyO1xuXG4gICAgICAgIGlmIChnZnAuaW50ZXJDaFJhdGlvIDwgMClcbiAgICAgICAgICAgIGdmcC5pbnRlckNoUmF0aW8gPSAwO1xuXG4gICAgICAgIGlmIChnZnAudXNlVGVtcG9yYWwgPT0gbnVsbClcbiAgICAgICAgICAgIGdmcC51c2VUZW1wb3JhbCA9IHRydWU7XG4gICAgICAgIC8qIG9uIGJ5IGRlZmF1bHQgKi9cblxuICAgICAgICAvKlxuICAgICAgICAgKiBwYWRkaW5nIG1ldGhvZCBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgICogXCJNUEVHLUxheWVyMyAvIEJpdHN0cmVhbSBTeW50YXggYW5kIERlY29kaW5nXCIgYnkgTWFydGluIFNpZWxlciwgUmFscGhcbiAgICAgICAgICogU3BlcnNjaG5laWRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBub3RlOiB0aGVyZSBpcyBubyBwYWRkaW5nIGZvciB0aGUgdmVyeSBmaXJzdCBmcmFtZVxuICAgICAgICAgKlxuICAgICAgICAgKiBSb2JlcnQgSGVnZW1hbm4gMjAwMC0wNi0yMlxuICAgICAgICAgKi9cbiAgICAgICAgZ2ZjLnNsb3RfbGFnID0gZ2ZjLmZyYWNfU3BGID0gMDtcbiAgICAgICAgaWYgKGdmcC5WQlIgPT0gVmJyTW9kZSQyLnZicl9vZmYpXG4gICAgICAgICAgICBnZmMuc2xvdF9sYWcgPSBnZmMuZnJhY19TcEYgPSAoKChnZnAudmVyc2lvbiArIDEpICogNzIwMDAgKiBnZnAuYnJhdGUpICUgZ2ZwLm91dF9zYW1wbGVyYXRlKSB8IDA7XG5cbiAgICAgICAgcXVwdnQuaXRlcmF0aW9uX2luaXQoZ2ZwKTtcbiAgICAgICAgcHN5LnBzeW1vZGVsX2luaXQoZ2ZwKTtcbiAgICAgICAgYXNzZXJ0JDIoZ2ZwLnNjYWxlID49IDApO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlX2luYnVmZmVyX3NpemUoZ2ZjLCBuc2FtcGxlcykge1xuICAgICAgICBpZiAoZ2ZjLmluX2J1ZmZlcl8wID09IG51bGwgfHwgZ2ZjLmluX2J1ZmZlcl9uc2FtcGxlcyA8IG5zYW1wbGVzKSB7XG4gICAgICAgICAgICBnZmMuaW5fYnVmZmVyXzAgPSBuZXdfZmxvYXQkMihuc2FtcGxlcyk7XG4gICAgICAgICAgICBnZmMuaW5fYnVmZmVyXzEgPSBuZXdfZmxvYXQkMihuc2FtcGxlcyk7XG4gICAgICAgICAgICBnZmMuaW5fYnVmZmVyX25zYW1wbGVzID0gbnNhbXBsZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxhbWVfZW5jb2RlX2ZsdXNoID0gZnVuY3Rpb24gKGdmcCwgbXAzYnVmZmVyLCBtcDNidWZmZXJQb3MsIG1wM2J1ZmZlcl9zaXplKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXdfc2hvcnRfbiQxKFsyLCAxMTUyXSk7XG4gICAgICAgIHZhciBpbXAzID0gMCwgbXAzY291bnQsIG1wM2J1ZmZlcl9zaXplX3JlbWFpbmluZztcblxuICAgICAgICAvKlxuICAgICAgICAgKiB3ZSBhbHdheXMgYWRkIFBPU1RERUxBWT0yODggcGFkZGluZyB0byBtYWtlIHN1cmUgZ3JhbnVsZSB3aXRoIHJlYWxcbiAgICAgICAgICogZGF0YSBjYW4gYmUgY29tcGxldHkgZGVjb2RlZCAoYmVjYXVzZSBvZiA1MCUgb3ZlcmxhcCB3aXRoIG5leHRcbiAgICAgICAgICogZ3JhbnVsZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGVuZF9wYWRkaW5nO1xuICAgICAgICB2YXIgZnJhbWVzX2xlZnQ7XG4gICAgICAgIHZhciBzYW1wbGVzX3RvX2VuY29kZSA9IGdmYy5tZl9zYW1wbGVzX3RvX2VuY29kZSAtIEVuY29kZXJfMS5QT1NUREVMQVk7XG4gICAgICAgIHZhciBtZl9uZWVkZWQgPSBjYWxjTmVlZGVkKGdmcCk7XG5cbiAgICAgICAgLyogV2FzIGZsdXNoIGFscmVhZHkgY2FsbGVkPyAqL1xuICAgICAgICBpZiAoZ2ZjLm1mX3NhbXBsZXNfdG9fZW5jb2RlIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbXAzY291bnQgPSAwO1xuXG4gICAgICAgIGlmIChnZnAuaW5fc2FtcGxlcmF0ZSAhPSBnZnAub3V0X3NhbXBsZXJhdGUpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBkZWxheSBkdWUgdG8gcmVzYW1wbGluZzsgbmVlZHMgdG8gYmUgZml4ZWQsIGlmIHJlc2FtcGxpbmcgY29kZVxuICAgICAgICAgICAgICogZ2V0cyBjaGFuZ2VkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNhbXBsZXNfdG9fZW5jb2RlICs9IDE2LiAqIGdmcC5vdXRfc2FtcGxlcmF0ZSAvIGdmcC5pbl9zYW1wbGVyYXRlO1xuICAgICAgICB9XG4gICAgICAgIGVuZF9wYWRkaW5nID0gZ2ZwLmZyYW1lc2l6ZSAtIChzYW1wbGVzX3RvX2VuY29kZSAlIGdmcC5mcmFtZXNpemUpO1xuICAgICAgICBpZiAoZW5kX3BhZGRpbmcgPCA1NzYpXG4gICAgICAgICAgICBlbmRfcGFkZGluZyArPSBnZnAuZnJhbWVzaXplO1xuICAgICAgICBnZnAuZW5jb2Rlcl9wYWRkaW5nID0gZW5kX3BhZGRpbmc7XG5cbiAgICAgICAgZnJhbWVzX2xlZnQgPSAoc2FtcGxlc190b19lbmNvZGUgKyBlbmRfcGFkZGluZykgLyBnZnAuZnJhbWVzaXplO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHNlbmQgaW4gYSBmcmFtZSBvZiAwIHBhZGRpbmcgdW50aWwgYWxsIGludGVybmFsIHNhbXBsZSBidWZmZXJzIGFyZVxuICAgICAgICAgKiBmbHVzaGVkXG4gICAgICAgICAqL1xuICAgICAgICB3aGlsZSAoZnJhbWVzX2xlZnQgPiAwICYmIGltcDMgPj0gMCkge1xuICAgICAgICAgICAgdmFyIGJ1bmNoID0gbWZfbmVlZGVkIC0gZ2ZjLm1mX3NpemU7XG4gICAgICAgICAgICB2YXIgZnJhbWVfbnVtID0gZ2ZwLmZyYW1lTnVtO1xuXG4gICAgICAgICAgICBidW5jaCAqPSBnZnAuaW5fc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgIGJ1bmNoIC89IGdmcC5vdXRfc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgIGlmIChidW5jaCA+IDExNTIpXG4gICAgICAgICAgICAgICAgYnVuY2ggPSAxMTUyO1xuICAgICAgICAgICAgaWYgKGJ1bmNoIDwgMSlcbiAgICAgICAgICAgICAgICBidW5jaCA9IDE7XG5cbiAgICAgICAgICAgIG1wM2J1ZmZlcl9zaXplX3JlbWFpbmluZyA9IG1wM2J1ZmZlcl9zaXplIC0gbXAzY291bnQ7XG5cbiAgICAgICAgICAgIC8qIGlmIHVzZXIgc3BlY2lmZWQgYnVmZmVyIHNpemUgPSAwLCBkb250IGNoZWNrIHNpemUgKi9cbiAgICAgICAgICAgIGlmIChtcDNidWZmZXJfc2l6ZSA9PSAwKVxuICAgICAgICAgICAgICAgIG1wM2J1ZmZlcl9zaXplX3JlbWFpbmluZyA9IDA7XG5cbiAgICAgICAgICAgIGltcDMgPSB0aGlzLmxhbWVfZW5jb2RlX2J1ZmZlcihnZnAsIGJ1ZmZlclswXSwgYnVmZmVyWzFdLCBidW5jaCxcbiAgICAgICAgICAgICAgICBtcDNidWZmZXIsIG1wM2J1ZmZlclBvcywgbXAzYnVmZmVyX3NpemVfcmVtYWluaW5nKTtcblxuICAgICAgICAgICAgbXAzYnVmZmVyUG9zICs9IGltcDM7XG4gICAgICAgICAgICBtcDNjb3VudCArPSBpbXAzO1xuICAgICAgICAgICAgZnJhbWVzX2xlZnQgLT0gKGZyYW1lX251bSAhPSBnZnAuZnJhbWVOdW0pID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogU2V0IGdmYy5tZl9zYW1wbGVzX3RvX2VuY29kZSB0byAwLCBzbyB3ZSBtYXkgZGV0ZWN0IGFuZCBicmVhayBsb29wc1xuICAgICAgICAgKiBjYWxsaW5nIGl0IG1vcmUgdGhhbiBvbmNlIGluIGEgcm93LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2ZjLm1mX3NhbXBsZXNfdG9fZW5jb2RlID0gMDtcblxuICAgICAgICBpZiAoaW1wMyA8IDApIHtcbiAgICAgICAgICAgIC8qIHNvbWUgdHlwZSBvZiBmYXRhbCBlcnJvciAqL1xuICAgICAgICAgICAgcmV0dXJuIGltcDM7XG4gICAgICAgIH1cblxuICAgICAgICBtcDNidWZmZXJfc2l6ZV9yZW1haW5pbmcgPSBtcDNidWZmZXJfc2l6ZSAtIG1wM2NvdW50O1xuICAgICAgICAvKiBpZiB1c2VyIHNwZWNpZmVkIGJ1ZmZlciBzaXplID0gMCwgZG9udCBjaGVjayBzaXplICovXG4gICAgICAgIGlmIChtcDNidWZmZXJfc2l6ZSA9PSAwKVxuICAgICAgICAgICAgbXAzYnVmZmVyX3NpemVfcmVtYWluaW5nID0gMDtcblxuICAgICAgICAvKiBtcDMgcmVsYXRlZCBzdHVmZi4gYml0IGJ1ZmZlciBtaWdodCBzdGlsbCBjb250YWluIHNvbWUgbXAzIGRhdGEgKi9cbiAgICAgICAgYnMuZmx1c2hfYml0c3RyZWFtKGdmcCk7XG4gICAgICAgIGltcDMgPSBicy5jb3B5X2J1ZmZlcihnZmMsIG1wM2J1ZmZlciwgbXAzYnVmZmVyUG9zLFxuICAgICAgICAgICAgbXAzYnVmZmVyX3NpemVfcmVtYWluaW5nLCAxKTtcbiAgICAgICAgaWYgKGltcDMgPCAwKSB7XG4gICAgICAgICAgICAvKiBzb21lIHR5cGUgb2YgZmF0YWwgZXJyb3IgKi9cbiAgICAgICAgICAgIHJldHVybiBpbXAzO1xuICAgICAgICB9XG4gICAgICAgIG1wM2J1ZmZlclBvcyArPSBpbXAzO1xuICAgICAgICBtcDNjb3VudCArPSBpbXAzO1xuICAgICAgICBtcDNidWZmZXJfc2l6ZV9yZW1haW5pbmcgPSBtcDNidWZmZXJfc2l6ZSAtIG1wM2NvdW50O1xuICAgICAgICAvKiBpZiB1c2VyIHNwZWNpZmVkIGJ1ZmZlciBzaXplID0gMCwgZG9udCBjaGVjayBzaXplICovXG4gICAgICAgIGlmIChtcDNidWZmZXJfc2l6ZSA9PSAwKVxuICAgICAgICAgICAgbXAzYnVmZmVyX3NpemVfcmVtYWluaW5nID0gMDtcblxuICAgICAgICBpZiAoZ2ZwLndyaXRlX2lkM3RhZ19hdXRvbWF0aWMpIHtcbiAgICAgICAgICAgIC8qIHdyaXRlIGEgaWQzIHRhZyB0byB0aGUgYml0c3RyZWFtICovXG4gICAgICAgICAgICBpZDMuaWQzdGFnX3dyaXRlX3YxKGdmcCk7XG5cbiAgICAgICAgICAgIGltcDMgPSBicy5jb3B5X2J1ZmZlcihnZmMsIG1wM2J1ZmZlciwgbXAzYnVmZmVyUG9zLFxuICAgICAgICAgICAgICAgIG1wM2J1ZmZlcl9zaXplX3JlbWFpbmluZywgMCk7XG5cbiAgICAgICAgICAgIGlmIChpbXAzIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbXAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXAzY291bnQgKz0gaW1wMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXAzY291bnQ7XG4gICAgfTtcblxuICAgIHRoaXMubGFtZV9lbmNvZGVfYnVmZmVyID0gZnVuY3Rpb24gKGdmcCwgYnVmZmVyX2wsIGJ1ZmZlcl9yLCBuc2FtcGxlcywgbXAzYnVmLCBtcDNidWZQb3MsIG1wM2J1Zl9zaXplKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBpbl9idWZmZXIgPSBbbnVsbCwgbnVsbF07XG5cbiAgICAgICAgaWYgKGdmYy5DbGFzc19JRCAhPSBMQU1FX0lEKVxuICAgICAgICAgICAgcmV0dXJuIC0zO1xuXG4gICAgICAgIGlmIChuc2FtcGxlcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgdXBkYXRlX2luYnVmZmVyX3NpemUoZ2ZjLCBuc2FtcGxlcyk7XG5cbiAgICAgICAgaW5fYnVmZmVyWzBdID0gZ2ZjLmluX2J1ZmZlcl8wO1xuICAgICAgICBpbl9idWZmZXJbMV0gPSBnZmMuaW5fYnVmZmVyXzE7XG5cbiAgICAgICAgLyogbWFrZSBhIGNvcHkgb2YgaW5wdXQgYnVmZmVyLCBjaGFuZ2luZyB0eXBlIHRvIHNhbXBsZV90ICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnNhbXBsZXM7IGkrKykge1xuICAgICAgICAgICAgaW5fYnVmZmVyWzBdW2ldID0gYnVmZmVyX2xbaV07XG4gICAgICAgICAgICBpZiAoZ2ZjLmNoYW5uZWxzX2luID4gMSlcbiAgICAgICAgICAgICAgICBpbl9idWZmZXJbMV1baV0gPSBidWZmZXJfcltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYW1lX2VuY29kZV9idWZmZXJfc2FtcGxlKGdmcCwgaW5fYnVmZmVyWzBdLCBpbl9idWZmZXJbMV0sXG4gICAgICAgICAgICBuc2FtcGxlcywgbXAzYnVmLCBtcDNidWZQb3MsIG1wM2J1Zl9zaXplKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsY05lZWRlZChnZnApIHtcbiAgICAgICAgdmFyIG1mX25lZWRlZCA9IEVuY29kZXJfMS5CTEtTSVpFICsgZ2ZwLmZyYW1lc2l6ZSAtIEVuY29kZXJfMS5GRlRPRkZTRVQ7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGFtb3VudCBuZWVkZWQgZm9yIEZGVFxuICAgICAgICAgKi9cbiAgICAgICAgbWZfbmVlZGVkID0gTWF0aC5tYXgobWZfbmVlZGVkLCA1MTIgKyBnZnAuZnJhbWVzaXplIC0gMzIpO1xuICAgICAgICBhc3NlcnQkMihMYW1lSW50ZXJuYWxGbGFnc18xLk1GU0laRSA+PSBtZl9uZWVkZWQpO1xuXG4gICAgICAgIHJldHVybiBtZl9uZWVkZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFtZV9lbmNvZGVfYnVmZmVyX3NhbXBsZShnZnAsIGJ1ZmZlcl9sLCBidWZmZXJfciwgbnNhbXBsZXMsIG1wM2J1ZiwgbXAzYnVmUG9zLCBtcDNidWZfc2l6ZSkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgbXAzc2l6ZSA9IDAsIHJldCwgaSwgY2gsIG1mX25lZWRlZDtcbiAgICAgICAgdmFyIG1wM291dDtcbiAgICAgICAgdmFyIG1mYnVmID0gW251bGwsIG51bGxdO1xuICAgICAgICB2YXIgaW5fYnVmZmVyID0gW251bGwsIG51bGxdO1xuXG4gICAgICAgIGlmIChnZmMuQ2xhc3NfSUQgIT0gTEFNRV9JRClcbiAgICAgICAgICAgIHJldHVybiAtMztcblxuICAgICAgICBpZiAobnNhbXBsZXMgPT0gMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIC8qIGNvcHkgb3V0IGFueSB0YWdzIHRoYXQgbWF5IGhhdmUgYmVlbiB3cml0dGVuIGludG8gYml0c3RyZWFtICovXG4gICAgICAgIG1wM291dCA9IGJzLmNvcHlfYnVmZmVyKGdmYywgbXAzYnVmLCBtcDNidWZQb3MsIG1wM2J1Zl9zaXplLCAwKTtcbiAgICAgICAgaWYgKG1wM291dCA8IDApXG4gICAgICAgICAgICByZXR1cm4gbXAzb3V0O1xuICAgICAgICAvKiBub3QgZW5vdWdoIGJ1ZmZlciBzcGFjZSAqL1xuICAgICAgICBtcDNidWZQb3MgKz0gbXAzb3V0O1xuICAgICAgICBtcDNzaXplICs9IG1wM291dDtcblxuICAgICAgICBpbl9idWZmZXJbMF0gPSBidWZmZXJfbDtcbiAgICAgICAgaW5fYnVmZmVyWzFdID0gYnVmZmVyX3I7XG5cbiAgICAgICAgLyogQXBwbHkgdXNlciBkZWZpbmVkIHJlLXNjYWxpbmcgKi9cblxuICAgICAgICAvKiB1c2VyIHNlbGVjdGVkIHNjYWxpbmcgb2YgdGhlIHNhbXBsZXMgKi9cbiAgICAgICAgaWYgKEJpdFN0cmVhbV8xLk5FUShnZnAuc2NhbGUsIDApICYmIEJpdFN0cmVhbV8xLk5FUShnZnAuc2NhbGUsIDEuMCkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuc2FtcGxlczsgKytpKSB7XG4gICAgICAgICAgICAgICAgaW5fYnVmZmVyWzBdW2ldICo9IGdmcC5zY2FsZTtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLmNoYW5uZWxzX291dCA9PSAyKVxuICAgICAgICAgICAgICAgICAgICBpbl9idWZmZXJbMV1baV0gKj0gZ2ZwLnNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogdXNlciBzZWxlY3RlZCBzY2FsaW5nIG9mIHRoZSBjaGFubmVsIDAgKGxlZnQpIHNhbXBsZXMgKi9cbiAgICAgICAgaWYgKEJpdFN0cmVhbV8xLk5FUShnZnAuc2NhbGVfbGVmdCwgMClcbiAgICAgICAgICAgICYmIEJpdFN0cmVhbV8xLk5FUShnZnAuc2NhbGVfbGVmdCwgMS4wKSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5zYW1wbGVzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpbl9idWZmZXJbMF1baV0gKj0gZ2ZwLnNjYWxlX2xlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiB1c2VyIHNlbGVjdGVkIHNjYWxpbmcgb2YgdGhlIGNoYW5uZWwgMSAocmlnaHQpIHNhbXBsZXMgKi9cbiAgICAgICAgaWYgKEJpdFN0cmVhbV8xLk5FUShnZnAuc2NhbGVfcmlnaHQsIDApXG4gICAgICAgICAgICAmJiBCaXRTdHJlYW1fMS5ORVEoZ2ZwLnNjYWxlX3JpZ2h0LCAxLjApKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnNhbXBsZXM7ICsraSkge1xuICAgICAgICAgICAgICAgIGluX2J1ZmZlclsxXVtpXSAqPSBnZnAuc2NhbGVfcmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBEb3duc2FtcGxlIHRvIE1vbm8gaWYgMiBjaGFubmVscyBpbiBhbmQgMSBjaGFubmVsIG91dCAqL1xuICAgICAgICBpZiAoZ2ZwLm51bV9jaGFubmVscyA9PSAyICYmIGdmYy5jaGFubmVsc19vdXQgPT0gMSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5zYW1wbGVzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpbl9idWZmZXJbMF1baV0gPSAwLjUgKiAoIGluX2J1ZmZlclswXVtpXSArIGluX2J1ZmZlclsxXVtpXSk7XG4gICAgICAgICAgICAgICAgaW5fYnVmZmVyWzFdW2ldID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWZfbmVlZGVkID0gY2FsY05lZWRlZChnZnApO1xuXG4gICAgICAgIG1mYnVmWzBdID0gZ2ZjLm1mYnVmWzBdO1xuICAgICAgICBtZmJ1ZlsxXSA9IGdmYy5tZmJ1ZlsxXTtcblxuICAgICAgICB2YXIgaW5fYnVmZmVyUG9zID0gMDtcbiAgICAgICAgd2hpbGUgKG5zYW1wbGVzID4gMCkge1xuICAgICAgICAgICAgdmFyIGluX2J1ZmZlcl9wdHIgPSBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgICB2YXIgbl9pbiA9IDA7XG4gICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5wdXQgc2FtcGxlcyBwcm9jZXNzZWQgd2l0aCBmaWxsX2J1ZmZlciAqL1xuICAgICAgICAgICAgdmFyIG5fb3V0ID0gMDtcbiAgICAgICAgICAgIC8qIG51bWJlciBvZiBzYW1wbGVzIG91dHB1dCB3aXRoIGZpbGxfYnVmZmVyICovXG4gICAgICAgICAgICAvKiBuX2luIDw+IG5fb3V0IGlmIHdlIGFyZSByZXNhbXBsaW5nICovXG5cbiAgICAgICAgICAgIGluX2J1ZmZlcl9wdHJbMF0gPSBpbl9idWZmZXJbMF07XG4gICAgICAgICAgICBpbl9idWZmZXJfcHRyWzFdID0gaW5fYnVmZmVyWzFdO1xuICAgICAgICAgICAgLyogY29weSBpbiBuZXcgc2FtcGxlcyBpbnRvIG1mYnVmLCB3aXRoIHJlc2FtcGxpbmcgKi9cbiAgICAgICAgICAgIHZhciBpbk91dCA9IG5ldyBJbk91dCgpO1xuICAgICAgICAgICAgZmlsbF9idWZmZXIoZ2ZwLCBtZmJ1ZiwgaW5fYnVmZmVyX3B0ciwgaW5fYnVmZmVyUG9zLCBuc2FtcGxlcyxcbiAgICAgICAgICAgICAgICBpbk91dCk7XG4gICAgICAgICAgICBuX2luID0gaW5PdXQubl9pbjtcbiAgICAgICAgICAgIG5fb3V0ID0gaW5PdXQubl9vdXQ7XG5cbiAgICAgICAgICAgIC8qIGNvbXB1dGUgUmVwbGF5R2FpbiBvZiByZXNhbXBsZWQgaW5wdXQgaWYgcmVxdWVzdGVkICovXG4gICAgICAgICAgICBpZiAoZ2ZjLmZpbmRSZXBsYXlHYWluICYmICFnZmMuZGVjb2RlX29uX3RoZV9mbHkpXG4gICAgICAgICAgICAgICAgaWYgKGdhLkFuYWx5emVTYW1wbGVzKGdmYy5yZ2RhdGEsIG1mYnVmWzBdLCBnZmMubWZfc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1mYnVmWzFdLCBnZmMubWZfc2l6ZSwgbl9vdXQsIGdmYy5jaGFubmVsc19vdXQpID09IEdhaW5BbmFseXNpcy5HQUlOX0FOQUxZU0lTX0VSUk9SKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTY7XG5cbiAgICAgICAgICAgIC8qIHVwZGF0ZSBpbl9idWZmZXIgY291bnRlcnMgKi9cbiAgICAgICAgICAgIG5zYW1wbGVzIC09IG5faW47XG4gICAgICAgICAgICBpbl9idWZmZXJQb3MgKz0gbl9pbjtcbiAgICAgICAgICAgIGlmIChnZmMuY2hhbm5lbHNfb3V0ID09IDIpXG4gICAgICAgICAgICAgICAgOy8vIGluX2J1ZmZlclBvcyArPSBuX2luO1xuXG4gICAgICAgICAgICAvKiB1cGRhdGUgbWZidWZbXSBjb3VudGVycyAqL1xuICAgICAgICAgICAgZ2ZjLm1mX3NpemUgKz0gbl9vdXQ7XG4gICAgICAgICAgICBhc3NlcnQkMihnZmMubWZfc2l6ZSA8PSBMYW1lSW50ZXJuYWxGbGFnc18xLk1GU0laRSk7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBsYW1lX2VuY29kZV9mbHVzaCBtYXkgaGF2ZSBzZXQgZ2ZjLm1mX3NhbXBsZV90b19lbmNvZGUgdG8gMCBzbyB3ZVxuICAgICAgICAgICAgICogaGF2ZSB0byByZWluaXRpYWxpemUgaXQgaGVyZSB3aGVuIHRoYXQgaGFwcGVuZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChnZmMubWZfc2FtcGxlc190b19lbmNvZGUgPCAxKSB7XG4gICAgICAgICAgICAgICAgZ2ZjLm1mX3NhbXBsZXNfdG9fZW5jb2RlID0gRW5jb2Rlcl8xLkVOQ0RFTEFZICsgRW5jb2Rlcl8xLlBPU1RERUxBWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdmYy5tZl9zYW1wbGVzX3RvX2VuY29kZSArPSBuX291dDtcblxuICAgICAgICAgICAgaWYgKGdmYy5tZl9zaXplID49IG1mX25lZWRlZCkge1xuICAgICAgICAgICAgICAgIC8qIGVuY29kZSB0aGUgZnJhbWUuICovXG4gICAgICAgICAgICAgICAgLyogbXAzYnVmID0gcG9pbnRlciB0byBjdXJyZW50IGxvY2F0aW9uIGluIGJ1ZmZlciAqL1xuICAgICAgICAgICAgICAgIC8qIG1wM2J1Zl9zaXplID0gc2l6ZSBvZiBvcmlnaW5hbCBtcDMgb3V0cHV0IGJ1ZmZlciAqL1xuICAgICAgICAgICAgICAgIC8qID0gMCBpZiB3ZSBzaG91bGQgbm90IHdvcnJ5IGFib3V0IHRoZSAqL1xuICAgICAgICAgICAgICAgIC8qIGJ1ZmZlciBzaXplIGJlY2F1c2UgY2FsbGluZyBwcm9ncmFtIGlzICovXG4gICAgICAgICAgICAgICAgLyogdG8gbGF6eSB0byBjb21wdXRlIGl0ICovXG4gICAgICAgICAgICAgICAgLyogbXAzc2l6ZSA9IHNpemUgb2YgZGF0YSB3cml0dGVuIHRvIGJ1ZmZlciBzbyBmYXIgKi9cbiAgICAgICAgICAgICAgICAvKiBtcDNidWZfc2l6ZS1tcDNzaXplID0gYW1vdW50IG9mIHNwYWNlIGF2YWxhYmxlICovXG5cbiAgICAgICAgICAgICAgICB2YXIgYnVmX3NpemUgPSBtcDNidWZfc2l6ZSAtIG1wM3NpemU7XG4gICAgICAgICAgICAgICAgaWYgKG1wM2J1Zl9zaXplID09IDApXG4gICAgICAgICAgICAgICAgICAgIGJ1Zl9zaXplID0gMDtcblxuICAgICAgICAgICAgICAgIHJldCA9IGxhbWVfZW5jb2RlX2ZyYW1lKGdmcCwgbWZidWZbMF0sIG1mYnVmWzFdLCBtcDNidWYsXG4gICAgICAgICAgICAgICAgICAgIG1wM2J1ZlBvcywgYnVmX3NpemUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJldCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgbXAzYnVmUG9zICs9IHJldDtcbiAgICAgICAgICAgICAgICBtcDNzaXplICs9IHJldDtcblxuICAgICAgICAgICAgICAgIC8qIHNoaWZ0IG91dCBvbGQgc2FtcGxlcyAqL1xuICAgICAgICAgICAgICAgIGdmYy5tZl9zaXplIC09IGdmcC5mcmFtZXNpemU7XG4gICAgICAgICAgICAgICAgZ2ZjLm1mX3NhbXBsZXNfdG9fZW5jb2RlIC09IGdmcC5mcmFtZXNpemU7XG4gICAgICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGdmYy5tZl9zaXplOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBtZmJ1ZltjaF1baV0gPSBtZmJ1ZltjaF1baSArIGdmcC5mcmFtZXNpemVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydCQyKG5zYW1wbGVzID09IDApO1xuXG4gICAgICAgIHJldHVybiBtcDNzaXplO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxhbWVfZW5jb2RlX2ZyYW1lKGdmcCwgaW5idWZfbCwgaW5idWZfciwgbXAzYnVmLCBtcDNidWZQb3MsIG1wM2J1Zl9zaXplKSB7XG4gICAgICAgIHZhciByZXQgPSBzZWxmLmVuYy5sYW1lX2VuY29kZV9tcDNfZnJhbWUoZ2ZwLCBpbmJ1Zl9sLCBpbmJ1Zl9yLCBtcDNidWYsXG4gICAgICAgICAgICBtcDNidWZQb3MsIG1wM2J1Zl9zaXplKTtcbiAgICAgICAgZ2ZwLmZyYW1lTnVtKys7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSW5PdXQoKSB7XG4gICAgICAgIHRoaXMubl9pbiA9IDA7XG4gICAgICAgIHRoaXMubl9vdXQgPSAwO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gTnVtVXNlZCgpIHtcbiAgICAgICAgdGhpcy5udW1fdXNlZCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JlYXRlc3QgY29tbW9uIGRpdmlzb3IuXG4gICAgICogPHA+XG4gICAgICogSm9pbnQgd29yayBvZiBFdWNsaWQgYW5kIE0uIEhlbmRyeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdjZChpLCBqKSB7XG4gICAgICAgIHJldHVybiBqICE9IDAgPyBnY2QoaiwgaSAlIGopIDogaTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNhbXBsaW5nIHZpYSBGSVIgZmlsdGVyLCBibGFja21hbiB3aW5kb3cuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmxhY2ttYW4oeCwgZmNuLCBsKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoaXMgYWxnb3JpdGhtIGZyb206IFNJR05BTCBQUk9DRVNTSU5HIEFMR09SSVRITVMgSU4gRk9SVFJBTiBBTkQgQ1xuICAgICAgICAgKiBTLkQuIFN0ZWFybnMgYW5kIFIuQS4gRGF2aWQsIFByZW50aWNlLUhhbGwsIDE5OTJcbiAgICAgICAgICovXG4gICAgICAgIHZhciB3Y24gPSAoTWF0aC5QSSAqIGZjbik7XG5cbiAgICAgICAgeCAvPSBsO1xuICAgICAgICBpZiAoeCA8IDApXG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgaWYgKHggPiAxKVxuICAgICAgICAgICAgeCA9IDE7XG4gICAgICAgIHZhciB4MiA9IHggLSAuNTtcblxuICAgICAgICB2YXIgYmt3biA9IDAuNDIgLSAwLjUgKiBNYXRoLmNvcygyICogeCAqIE1hdGguUEkpICsgMC4wOCAqIE1hdGguY29zKDQgKiB4ICogTWF0aC5QSSk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4MikgPCAxZS05KVxuICAgICAgICAgICAgcmV0dXJuICh3Y24gLyBNYXRoLlBJKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIChia3duICogTWF0aC5zaW4obCAqIHdjbiAqIHgyKSAvIChNYXRoLlBJICogbCAqIHgyKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsbF9idWZmZXJfcmVzYW1wbGUoZ2ZwLCBvdXRidWYsIG91dGJ1ZlBvcywgZGVzaXJlZF9sZW4sIGluYnVmLCBpbl9idWZmZXJQb3MsIGxlbiwgbnVtX3VzZWQsIGNoKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBpLCBqID0gMCwgaztcbiAgICAgICAgLyogbnVtYmVyIG9mIGNvbnZvbHV0aW9uIGZ1bmN0aW9ucyB0byBwcmUtY29tcHV0ZSAqL1xuICAgICAgICB2YXIgYnBjID0gZ2ZwLm91dF9zYW1wbGVyYXRlXG4gICAgICAgICAgICAvIGdjZChnZnAub3V0X3NhbXBsZXJhdGUsIGdmcC5pbl9zYW1wbGVyYXRlKTtcbiAgICAgICAgaWYgKGJwYyA+IExhbWVJbnRlcm5hbEZsYWdzXzEuQlBDKVxuICAgICAgICAgICAgYnBjID0gTGFtZUludGVybmFsRmxhZ3NfMS5CUEM7XG5cbiAgICAgICAgdmFyIGludHJhdGlvID0gKE1hdGguYWJzKGdmYy5yZXNhbXBsZV9yYXRpb1xuICAgICAgICAgICAgLSBNYXRoLmZsb29yKC41ICsgZ2ZjLnJlc2FtcGxlX3JhdGlvKSkgPCAuMDAwMSkgPyAxIDogMDtcbiAgICAgICAgdmFyIGZjbiA9IDEuMDAgLyBnZmMucmVzYW1wbGVfcmF0aW87XG4gICAgICAgIGlmIChmY24gPiAxLjAwKVxuICAgICAgICAgICAgZmNuID0gMS4wMDtcbiAgICAgICAgdmFyIGZpbHRlcl9sID0gMzE7XG4gICAgICAgIGlmICgwID09IGZpbHRlcl9sICUgMilcbiAgICAgICAgICAgIC0tZmlsdGVyX2w7XG4gICAgICAgIC8qIG11c3QgYmUgb2RkICovXG4gICAgICAgIGZpbHRlcl9sICs9IGludHJhdGlvO1xuICAgICAgICAvKiB1bmxlc3MgcmVzYW1wbGVfcmF0aW89aW50LCBpdCBtdXN0IGJlIGV2ZW4gKi9cblxuICAgICAgICB2YXIgQkxBQ0tTSVpFID0gZmlsdGVyX2wgKyAxO1xuICAgICAgICAvKiBzaXplIG9mIGRhdGEgbmVlZGVkIGZvciBGSVIgKi9cblxuICAgICAgICBpZiAoZ2ZjLmZpbGxfYnVmZmVyX3Jlc2FtcGxlX2luaXQgPT0gMCkge1xuICAgICAgICAgICAgZ2ZjLmluYnVmX29sZFswXSA9IG5ld19mbG9hdCQyKEJMQUNLU0laRSk7XG4gICAgICAgICAgICBnZmMuaW5idWZfb2xkWzFdID0gbmV3X2Zsb2F0JDIoQkxBQ0tTSVpFKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gMiAqIGJwYzsgKytpKVxuICAgICAgICAgICAgICAgIGdmYy5ibGFja2ZpbHRbaV0gPSBuZXdfZmxvYXQkMihCTEFDS1NJWkUpO1xuXG4gICAgICAgICAgICBnZmMuaXRpbWVbMF0gPSAwO1xuICAgICAgICAgICAgZ2ZjLml0aW1lWzFdID0gMDtcblxuICAgICAgICAgICAgLyogcHJlY29tcHV0ZSBibGFja21hbiBmaWx0ZXIgY29lZmZpY2llbnRzICovXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDw9IDIgKiBicGM7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBzdW0gPSAwLjtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKGogLSBicGMpIC8gKDIuICogYnBjKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGZpbHRlcl9sOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBnZmMuYmxhY2tmaWx0W2pdW2ldID0gYmxhY2ttYW4oaSAtIG9mZnNldCwgZmNuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyX2wpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gZmlsdGVyX2w7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgZ2ZjLmJsYWNrZmlsdFtqXVtpXSAvPSBzdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZmMuZmlsbF9idWZmZXJfcmVzYW1wbGVfaW5pdCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5idWZfb2xkID0gZ2ZjLmluYnVmX29sZFtjaF07XG5cbiAgICAgICAgLyogdGltZSBvZiBqJ3RoIGVsZW1lbnQgaW4gaW5idWYgPSBpdGltZSArIGovaWZyZXE7ICovXG4gICAgICAgIC8qIHRpbWUgb2Ygayd0aCBlbGVtZW50IGluIG91dGJ1ZiA9IGovb2ZyZXEgKi9cbiAgICAgICAgZm9yIChrID0gMDsgayA8IGRlc2lyZWRfbGVuOyBrKyspIHtcbiAgICAgICAgICAgIHZhciB0aW1lMDtcbiAgICAgICAgICAgIHZhciBqb2ZmO1xuXG4gICAgICAgICAgICB0aW1lMCA9IGsgKiBnZmMucmVzYW1wbGVfcmF0aW87XG4gICAgICAgICAgICAvKiB0aW1lIG9mIGsndGggb3V0cHV0IHNhbXBsZSAqL1xuICAgICAgICAgICAgaiA9IDAgfCBNYXRoLmZsb29yKHRpbWUwIC0gZ2ZjLml0aW1lW2NoXSk7XG5cbiAgICAgICAgICAgIC8qIGNoZWNrIGlmIHdlIG5lZWQgbW9yZSBpbnB1dCBkYXRhICovXG4gICAgICAgICAgICBpZiAoKGZpbHRlcl9sICsgaiAtIGZpbHRlcl9sIC8gMikgPj0gbGVuKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvKiBibGFja21hbiBmaWx0ZXIuIGJ5IGRlZmF1bHQsIHdpbmRvdyBjZW50ZXJlZCBhdCBqKy41KGZpbHRlcl9sJTIpICovXG4gICAgICAgICAgICAvKiBidXQgd2Ugd2FudCBhIHdpbmRvdyBjZW50ZXJlZCBhdCB0aW1lMC4gKi9cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAodGltZTAgLSBnZmMuaXRpbWVbY2hdIC0gKGogKyAuNSAqIChmaWx0ZXJfbCAlIDIpKSk7XG4gICAgICAgICAgICBhc3NlcnQkMihNYXRoLmFicyhvZmZzZXQpIDw9IC41MDEpO1xuXG4gICAgICAgICAgICAvKiBmaW5kIHRoZSBjbG9zZXN0IHByZWNvbXB1dGVkIHdpbmRvdyBmb3IgdGhpcyBvZmZzZXQ6ICovXG4gICAgICAgICAgICBqb2ZmID0gMCB8IE1hdGguZmxvb3IoKG9mZnNldCAqIDIgKiBicGMpICsgYnBjICsgLjUpO1xuICAgICAgICAgICAgdmFyIHh2YWx1ZSA9IDAuO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBmaWx0ZXJfbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGoyID0gaSArIGogLSBmaWx0ZXJfbCAvIDI7XG4gICAgICAgICAgICAgICAgdmFyIHk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0JDIoajIgPCBsZW4pO1xuICAgICAgICAgICAgICAgIGFzc2VydCQyKGoyICsgQkxBQ0tTSVpFID49IDApO1xuICAgICAgICAgICAgICAgIHkgPSAoajIgPCAwKSA/IGluYnVmX29sZFtCTEFDS1NJWkUgKyBqMl0gOiBpbmJ1Zltpbl9idWZmZXJQb3NcbiAgICAgICAgICAgICAgICArIGoyXTtcbiAgICAgICAgICAgICAgICB4dmFsdWUgKz0geSAqIGdmYy5ibGFja2ZpbHRbam9mZl1baV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRidWZbb3V0YnVmUG9zICsga10gPSB4dmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBrID0gbnVtYmVyIG9mIHNhbXBsZXMgYWRkZWQgdG8gb3V0YnVmICovXG4gICAgICAgIC8qIGxhc3QgayBzYW1wbGUgdXNlZCBkYXRhIGZyb20gW2otZmlsdGVyX2wvMixqK2ZpbHRlcl9sLWZpbHRlcl9sLzJdICovXG5cbiAgICAgICAgLyogaG93IG1hbnkgc2FtcGxlcyBvZiBpbnB1dCBkYXRhIHdlcmUgdXNlZDogKi9cbiAgICAgICAgbnVtX3VzZWQubnVtX3VzZWQgPSBNYXRoLm1pbihsZW4sIGZpbHRlcl9sICsgaiAtIGZpbHRlcl9sIC8gMik7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogYWRqdXN0IG91ciBpbnB1dCB0aW1lIGNvdW50ZXIuIEluY3JpbWVudCBieSB0aGUgbnVtYmVyIG9mIHNhbXBsZXNcbiAgICAgICAgICogdXNlZCwgdGhlbiBub3JtYWxpemUgc28gdGhhdCBuZXh0IG91dHB1dCBzYW1wbGUgaXMgYXQgdGltZSAwLCBuZXh0XG4gICAgICAgICAqIGlucHV0IGJ1ZmZlciBpcyBhdCB0aW1lIGl0aW1lW2NoXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2ZjLml0aW1lW2NoXSArPSBudW1fdXNlZC5udW1fdXNlZCAtIGsgKiBnZmMucmVzYW1wbGVfcmF0aW87XG5cbiAgICAgICAgLyogc2F2ZSB0aGUgbGFzdCBCTEFDS1NJWkUgc2FtcGxlcyBpbnRvIHRoZSBpbmJ1Zl9vbGQgYnVmZmVyICovXG4gICAgICAgIGlmIChudW1fdXNlZC5udW1fdXNlZCA+PSBCTEFDS1NJWkUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBCTEFDS1NJWkU7IGkrKylcbiAgICAgICAgICAgICAgICBpbmJ1Zl9vbGRbaV0gPSBpbmJ1Zltpbl9idWZmZXJQb3MgKyBudW1fdXNlZC5udW1fdXNlZCArIGlcbiAgICAgICAgICAgICAgICAtIEJMQUNLU0laRV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBzaGlmdCBpbiBudW1fdXNlZC5udW1fdXNlZCBzYW1wbGVzIGludG8gaW5idWZfb2xkICovXG4gICAgICAgICAgICB2YXIgbl9zaGlmdCA9IEJMQUNLU0laRSAtIG51bV91c2VkLm51bV91c2VkO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIG51bWJlciBvZiBzYW1wbGVzIHRvXG4gICAgICAgICAgICAgKiBzaGlmdFxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBzaGlmdCBuX3NoaWZ0IHNhbXBsZXMgYnkgbnVtX3VzZWQubnVtX3VzZWQsIHRvIG1ha2Ugcm9vbSBmb3IgdGhlXG4gICAgICAgICAgICAgKiBudW1fdXNlZCBuZXcgc2FtcGxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbl9zaGlmdDsgKytpKVxuICAgICAgICAgICAgICAgIGluYnVmX29sZFtpXSA9IGluYnVmX29sZFtpICsgbnVtX3VzZWQubnVtX3VzZWRdO1xuXG4gICAgICAgICAgICAvKiBzaGlmdCBpbiB0aGUgbnVtX3VzZWQubnVtX3VzZWQgc2FtcGxlcyAqL1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaSA8IEJMQUNLU0laRTsgKytpLCArK2opXG4gICAgICAgICAgICAgICAgaW5idWZfb2xkW2ldID0gaW5idWZbaW5fYnVmZmVyUG9zICsgal07XG5cbiAgICAgICAgICAgIGFzc2VydCQyKGogPT0gbnVtX3VzZWQubnVtX3VzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrO1xuICAgICAgICAvKiByZXR1cm4gdGhlIG51bWJlciBzYW1wbGVzIGNyZWF0ZWQgYXQgdGhlIG5ldyBzYW1wbGVyYXRlICovXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsbF9idWZmZXIoZ2ZwLCBtZmJ1ZiwgaW5fYnVmZmVyLCBpbl9idWZmZXJQb3MsIG5zYW1wbGVzLCBpbykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXG4gICAgICAgIC8qIGNvcHkgaW4gbmV3IHNhbXBsZXMgaW50byBtZmJ1Ziwgd2l0aCByZXNhbXBsaW5nIGlmIG5lY2Vzc2FyeSAqL1xuICAgICAgICBpZiAoKGdmYy5yZXNhbXBsZV9yYXRpbyA8IC45OTk5KSB8fCAoZ2ZjLnJlc2FtcGxlX3JhdGlvID4gMS4wMDAxKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtVXNlZCA9IG5ldyBOdW1Vc2VkKCk7XG4gICAgICAgICAgICAgICAgaW8ubl9vdXQgPSBmaWxsX2J1ZmZlcl9yZXNhbXBsZShnZnAsIG1mYnVmW2NoXSwgZ2ZjLm1mX3NpemUsXG4gICAgICAgICAgICAgICAgICAgIGdmcC5mcmFtZXNpemUsIGluX2J1ZmZlcltjaF0sIGluX2J1ZmZlclBvcywgbnNhbXBsZXMsXG4gICAgICAgICAgICAgICAgICAgIG51bVVzZWQsIGNoKTtcbiAgICAgICAgICAgICAgICBpby5uX2luID0gbnVtVXNlZC5udW1fdXNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlvLm5fb3V0ID0gTWF0aC5taW4oZ2ZwLmZyYW1lc2l6ZSwgbnNhbXBsZXMpO1xuICAgICAgICAgICAgaW8ubl9pbiA9IGlvLm5fb3V0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpby5uX291dDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbWZidWZbMF1bZ2ZjLm1mX3NpemUgKyBpXSA9IGluX2J1ZmZlclswXVtpbl9idWZmZXJQb3MgKyBpXTtcbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLmNoYW5uZWxzX291dCA9PSAyKVxuICAgICAgICAgICAgICAgICAgICBtZmJ1ZlsxXVtnZmMubWZfc2l6ZSArIGldID0gaW5fYnVmZmVyWzFdW2luX2J1ZmZlclBvcyArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbnZhciBMYW1lXzEgPSBMYW1lJDE7XG5cbnZhciBWYnJNb2RlJDIwID0gY29tbW9uLlZick1vZGU7XG5mdW5jdGlvbiBQcmVzZXRzJDEoKSB7XG4gICAgZnVuY3Rpb24gVkJSUHJlc2V0cyhxdWFsLCBjb21wLCBjb21wUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksIHNoVGhyZXNob2xkLCBzaFRocmVzaG9sZFMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGosIGFkalNob3J0LCBsb3dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlLCBzZW5zLCBpbnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW50LCBtb2QsIGZpeCkge1xuICAgICAgICB0aGlzLnZicl9xID0gcXVhbDtcbiAgICAgICAgdGhpcy5xdWFudF9jb21wID0gY29tcDtcbiAgICAgICAgdGhpcy5xdWFudF9jb21wX3MgPSBjb21wUztcbiAgICAgICAgdGhpcy5leHBZID0geTtcbiAgICAgICAgdGhpcy5zdF9scm0gPSBzaFRocmVzaG9sZDtcbiAgICAgICAgdGhpcy5zdF9zID0gc2hUaHJlc2hvbGRTO1xuICAgICAgICB0aGlzLm1hc2tpbmdfYWRqID0gYWRqO1xuICAgICAgICB0aGlzLm1hc2tpbmdfYWRqX3Nob3J0ID0gYWRqU2hvcnQ7XG4gICAgICAgIHRoaXMuYXRoX2xvd2VyID0gbG93ZXI7XG4gICAgICAgIHRoaXMuYXRoX2N1cnZlID0gY3VydmU7XG4gICAgICAgIHRoaXMuYXRoX3NlbnNpdGl2aXR5ID0gc2VucztcbiAgICAgICAgdGhpcy5pbnRlcmNoID0gaW50ZXI7XG4gICAgICAgIHRoaXMuc2FmZWpvaW50ID0gam9pbnQ7XG4gICAgICAgIHRoaXMuc2ZiMjFtb2QgPSBtb2Q7XG4gICAgICAgIHRoaXMubXNmaXggPSBmaXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQUJSUHJlc2V0cyhrYnBzLCBjb21wLCBjb21wUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW50LCBmaXgsIHNoVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hUaHJlc2hvbGRTLCBiYXNzLCBzYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2ssIGxvd2VyLCBjdXJ2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyQ2gsIHNmU2NhbGUpIHtcbiAgICAgICAgdGhpcy5xdWFudF9jb21wID0gY29tcDtcbiAgICAgICAgdGhpcy5xdWFudF9jb21wX3MgPSBjb21wUztcbiAgICAgICAgdGhpcy5zYWZlam9pbnQgPSBqb2ludDtcbiAgICAgICAgdGhpcy5uc21zZml4ID0gZml4O1xuICAgICAgICB0aGlzLnN0X2xybSA9IHNoVGhyZXNob2xkO1xuICAgICAgICB0aGlzLnN0X3MgPSBzaFRocmVzaG9sZFM7XG4gICAgICAgIHRoaXMubnNiYXNzID0gYmFzcztcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjO1xuICAgICAgICB0aGlzLm1hc2tpbmdfYWRqID0gbWFzaztcbiAgICAgICAgdGhpcy5hdGhfbG93ZXIgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5hdGhfY3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgdGhpcy5pbnRlcmNoID0gaW50ZXJDaDtcbiAgICAgICAgdGhpcy5zZnNjYWxlID0gc2ZTY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgbGFtZTtcblxuICAgIHRoaXMuc2V0TW9kdWxlcyA9IGZ1bmN0aW9uIChfbGFtZSkge1xuICAgICAgICBsYW1lID0gX2xhbWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIDxQUkU+XG4gICAgICogU3dpdGNoIG1hcHBpbmdzIGZvciBWQlIgbW9kZSBWQlJfUkhcbiAgICAgKiAgICAgICAgICAgICB2YnJfcSAgcWNvbXBfbCAgcWNvbXBfcyAgZXhwWSAgc3RfbHJtICAgc3RfcyAgbWFzayBhZGpfbCAgYWRqX3MgIGF0aF9sb3dlciAgYXRoX2N1cnZlICBhdGhfc2VucyAgaW50ZXJDaFIgIHNhZmVqb2ludCBzZmIyMW1vZCAgbXNmaXhcbiAgICAgKiA8L1BSRT5cbiAgICAgKi9cbiAgICB2YXIgdmJyX29sZF9zd2l0Y2hfbWFwID0gW1xuICAgICAgICBuZXcgVkJSUHJlc2V0cygwLCA5LCA5LCAwLCA1LjIwLCAxMjUuMCwgLTQuMiwgLTYuMywgNC44LCAxLCAwLCAwLCAyLCAyMSwgMC45NyksXG4gICAgICAgIG5ldyBWQlJQcmVzZXRzKDEsIDksIDksIDAsIDUuMzAsIDEyNS4wLCAtMy42LCAtNS42LCA0LjUsIDEuNSwgMCwgMCwgMiwgMjEsIDEuMzUpLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cygyLCA5LCA5LCAwLCA1LjYwLCAxMjUuMCwgLTIuMiwgLTMuNSwgMi44LCAyLCAwLCAwLCAyLCAyMSwgMS40OSksXG4gICAgICAgIG5ldyBWQlJQcmVzZXRzKDMsIDksIDksIDEsIDUuODAsIDEzMC4wLCAtMS44LCAtMi44LCAyLjYsIDMsIC00LCAwLCAyLCAyMCwgMS42NCksXG4gICAgICAgIG5ldyBWQlJQcmVzZXRzKDQsIDksIDksIDEsIDYuMDAsIDEzNS4wLCAtMC43LCAtMS4xLCAxLjEsIDMuNSwgLTgsIDAsIDIsIDAsIDEuNzkpLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cyg1LCA5LCA5LCAxLCA2LjQwLCAxNDAuMCwgMC41LCAwLjQsIC03LjUsIDQsIC0xMiwgMC4wMDAyLCAwLCAwLCAxLjk1KSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoNiwgOSwgOSwgMSwgNi42MCwgMTQ1LjAsIDAuNjcsIDAuNjUsIC0xNC43LCA2LjUsIC0xOSwgMC4wMDA0LCAwLCAwLCAyLjMwKSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoNywgOSwgOSwgMSwgNi42MCwgMTQ1LjAsIDAuOCwgMC43NSwgLTE5LjcsIDgsIC0yMiwgMC4wMDA2LCAwLCAwLCAyLjcwKSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoOCwgOSwgOSwgMSwgNi42MCwgMTQ1LjAsIDEuMiwgMS4xNSwgLTI3LjUsIDEwLCAtMjMsIDAuMDAwNywgMCwgMCwgMCksXG4gICAgICAgIG5ldyBWQlJQcmVzZXRzKDksIDksIDksIDEsIDYuNjAsIDE0NS4wLCAxLjYsIDEuNiwgLTM2LCAxMSwgLTI1LCAwLjAwMDgsIDAsIDAsIDApLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cygxMCwgOSwgOSwgMSwgNi42MCwgMTQ1LjAsIDIuMCwgMi4wLCAtMzYsIDEyLCAtMjUsIDAuMDAwOCwgMCwgMCwgMClcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiAgICAgICAgICAgICAgICAgdmJyX3EgIHFjb21wX2wgIHFjb21wX3MgIGV4cFkgIHN0X2xybSAgIHN0X3MgIG1hc2sgYWRqX2wgIGFkal9zICBhdGhfbG93ZXIgIGF0aF9jdXJ2ZSAgYXRoX3NlbnMgIGludGVyQ2hSICBzYWZlam9pbnQgc2ZiMjFtb2QgIG1zZml4XG4gICAgICogPC9QUkU+XG4gICAgICovXG4gICAgdmFyIHZicl9wc3lfc3dpdGNoX21hcCA9IFtcbiAgICAgICAgbmV3IFZCUlByZXNldHMoMCwgOSwgOSwgMCwgNC4yMCwgMjUuMCwgLTcuMCwgLTQuMCwgNy41LCAxLCAwLCAwLCAyLCAyNiwgMC45NyksXG4gICAgICAgIG5ldyBWQlJQcmVzZXRzKDEsIDksIDksIDAsIDQuMjAsIDI1LjAsIC01LjYsIC0zLjYsIDQuNSwgMS41LCAwLCAwLCAyLCAyMSwgMS4zNSksXG4gICAgICAgIG5ldyBWQlJQcmVzZXRzKDIsIDksIDksIDAsIDQuMjAsIDI1LjAsIC00LjQsIC0xLjgsIDIsIDIsIDAsIDAsIDIsIDE4LCAxLjQ5KSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoMywgOSwgOSwgMSwgNC4yMCwgMjUuMCwgLTMuNCwgLTEuMjUsIDEuMSwgMywgLTQsIDAsIDIsIDE1LCAxLjY0KSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoNCwgOSwgOSwgMSwgNC4yMCwgMjUuMCwgLTIuMiwgMC4xLCAwLCAzLjUsIC04LCAwLCAyLCAwLCAxLjc5KSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoNSwgOSwgOSwgMSwgNC4yMCwgMjUuMCwgLTEuMCwgMS42NSwgLTcuNywgNCwgLTEyLCAwLjAwMDIsIDAsIDAsIDEuOTUpLFxuICAgICAgICBuZXcgVkJSUHJlc2V0cyg2LCA5LCA5LCAxLCA0LjIwLCAyNS4wLCAtMC4wLCAyLjQ3LCAtNy43LCA2LjUsIC0xOSwgMC4wMDA0LCAwLCAwLCAyKSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoNywgOSwgOSwgMSwgNC4yMCwgMjUuMCwgMC41LCAyLjAsIC0xNC41LCA4LCAtMjIsIDAuMDAwNiwgMCwgMCwgMiksXG4gICAgICAgIG5ldyBWQlJQcmVzZXRzKDgsIDksIDksIDEsIDQuMjAsIDI1LjAsIDEuMCwgMi40LCAtMjIuMCwgMTAsIC0yMywgMC4wMDA3LCAwLCAwLCAyKSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoOSwgOSwgOSwgMSwgNC4yMCwgMjUuMCwgMS41LCAyLjk1LCAtMzAuMCwgMTEsIC0yNSwgMC4wMDA4LCAwLCAwLCAyKSxcbiAgICAgICAgbmV3IFZCUlByZXNldHMoMTAsIDksIDksIDEsIDQuMjAsIDI1LjAsIDIuMCwgMi45NSwgLTM2LjAsIDEyLCAtMzAsIDAuMDAwOCwgMCwgMCwgMilcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gYXBwbHlfdmJyX3ByZXNldChnZnAsIGEsIGVuZm9yY2UpIHtcbiAgICAgICAgdmFyIHZicl9wcmVzZXQgPSBnZnAuVkJSID09IFZick1vZGUkMjAudmJyX3JoID8gdmJyX29sZF9zd2l0Y2hfbWFwXG4gICAgICAgICAgICA6IHZicl9wc3lfc3dpdGNoX21hcDtcblxuICAgICAgICB2YXIgeCA9IGdmcC5WQlJfcV9mcmFjO1xuICAgICAgICB2YXIgcCA9IHZicl9wcmVzZXRbYV07XG4gICAgICAgIHZhciBxID0gdmJyX3ByZXNldFthICsgMV07XG4gICAgICAgIHZhciBzZXQgPSBwO1xuXG4gICAgICAgIC8vIE5PT1AodmJyX3EpO1xuICAgICAgICAvLyBOT09QKHF1YW50X2NvbXApO1xuICAgICAgICAvLyBOT09QKHF1YW50X2NvbXBfcyk7XG4gICAgICAgIC8vIE5PT1AoZXhwWSk7XG4gICAgICAgIHAuc3RfbHJtID0gcC5zdF9scm0gKyB4ICogKHEuc3RfbHJtIC0gcC5zdF9scm0pO1xuICAgICAgICAvLyBMRVJQKHN0X2xybSk7XG4gICAgICAgIHAuc3RfcyA9IHAuc3RfcyArIHggKiAocS5zdF9zIC0gcC5zdF9zKTtcbiAgICAgICAgLy8gTEVSUChzdF9zKTtcbiAgICAgICAgcC5tYXNraW5nX2FkaiA9IHAubWFza2luZ19hZGogKyB4ICogKHEubWFza2luZ19hZGogLSBwLm1hc2tpbmdfYWRqKTtcbiAgICAgICAgLy8gTEVSUChtYXNraW5nX2Fkaik7XG4gICAgICAgIHAubWFza2luZ19hZGpfc2hvcnQgPSBwLm1hc2tpbmdfYWRqX3Nob3J0ICsgeFxuICAgICAgICAgICAgKiAocS5tYXNraW5nX2Fkal9zaG9ydCAtIHAubWFza2luZ19hZGpfc2hvcnQpO1xuICAgICAgICAvLyBMRVJQKG1hc2tpbmdfYWRqX3Nob3J0KTtcbiAgICAgICAgcC5hdGhfbG93ZXIgPSBwLmF0aF9sb3dlciArIHggKiAocS5hdGhfbG93ZXIgLSBwLmF0aF9sb3dlcik7XG4gICAgICAgIC8vIExFUlAoYXRoX2xvd2VyKTtcbiAgICAgICAgcC5hdGhfY3VydmUgPSBwLmF0aF9jdXJ2ZSArIHggKiAocS5hdGhfY3VydmUgLSBwLmF0aF9jdXJ2ZSk7XG4gICAgICAgIC8vIExFUlAoYXRoX2N1cnZlKTtcbiAgICAgICAgcC5hdGhfc2Vuc2l0aXZpdHkgPSBwLmF0aF9zZW5zaXRpdml0eSArIHhcbiAgICAgICAgICAgICogKHEuYXRoX3NlbnNpdGl2aXR5IC0gcC5hdGhfc2Vuc2l0aXZpdHkpO1xuICAgICAgICAvLyBMRVJQKGF0aF9zZW5zaXRpdml0eSk7XG4gICAgICAgIHAuaW50ZXJjaCA9IHAuaW50ZXJjaCArIHggKiAocS5pbnRlcmNoIC0gcC5pbnRlcmNoKTtcbiAgICAgICAgLy8gTEVSUChpbnRlcmNoKTtcbiAgICAgICAgLy8gTk9PUChzYWZlam9pbnQpO1xuICAgICAgICAvLyBOT09QKHNmYjIxbW9kKTtcbiAgICAgICAgcC5tc2ZpeCA9IHAubXNmaXggKyB4ICogKHEubXNmaXggLSBwLm1zZml4KTtcbiAgICAgICAgLy8gTEVSUChtc2ZpeCk7XG5cbiAgICAgICAgbGFtZV9zZXRfVkJSX3EoZ2ZwLCBzZXQudmJyX3EpO1xuXG4gICAgICAgIGlmIChlbmZvcmNlICE9IDApXG4gICAgICAgICAgICBnZnAucXVhbnRfY29tcCA9IHNldC5xdWFudF9jb21wO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5xdWFudF9jb21wIC0gLTEpID4gMCkpXG4gICAgICAgICAgICBnZnAucXVhbnRfY29tcCA9IHNldC5xdWFudF9jb21wO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKHF1YW50X2NvbXAsIHNldC5xdWFudF9jb21wLCAtMSk7XG4gICAgICAgIGlmIChlbmZvcmNlICE9IDApXG4gICAgICAgICAgICBnZnAucXVhbnRfY29tcF9zaG9ydCA9IHNldC5xdWFudF9jb21wX3M7XG4gICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLnF1YW50X2NvbXBfc2hvcnQgLSAtMSkgPiAwKSlcbiAgICAgICAgICAgIGdmcC5xdWFudF9jb21wX3Nob3J0ID0gc2V0LnF1YW50X2NvbXBfcztcbiAgICAgICAgLy8gU0VUX09QVElPTihxdWFudF9jb21wX3Nob3J0LCBzZXQucXVhbnRfY29tcF9zLCAtMSk7XG4gICAgICAgIGlmIChzZXQuZXhwWSAhPSAwKSB7XG4gICAgICAgICAgICBnZnAuZXhwZXJpbWVudGFsWSA9IHNldC5leHBZICE9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlID0gc2V0LnN0X2xybTtcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicyhnZnAuaW50ZXJuYWxfZmxhZ3MubnNQc3kuYXR0YWNrdGhyZSAtIC0xKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLmludGVybmFsX2ZsYWdzLm5zUHN5LmF0dGFja3RocmUgPSBzZXQuc3RfbHJtO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKHNob3J0X3RocmVzaG9sZF9scm0sIHNldC5zdF9scm0sIC0xKTtcbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlX3MgPSBzZXQuc3RfcztcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicyhnZnAuaW50ZXJuYWxfZmxhZ3MubnNQc3kuYXR0YWNrdGhyZV9zIC0gLTEpID4gMCkpXG4gICAgICAgICAgICBnZnAuaW50ZXJuYWxfZmxhZ3MubnNQc3kuYXR0YWNrdGhyZV9zID0gc2V0LnN0X3M7XG4gICAgICAgIC8vIFNFVF9PUFRJT04oc2hvcnRfdGhyZXNob2xkX3MsIHNldC5zdF9zLCAtMSk7XG4gICAgICAgIGlmIChlbmZvcmNlICE9IDApXG4gICAgICAgICAgICBnZnAubWFza2luZ2FkanVzdCA9IHNldC5tYXNraW5nX2FkajtcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicyhnZnAubWFza2luZ2FkanVzdCAtIDApID4gMCkpXG4gICAgICAgICAgICBnZnAubWFza2luZ2FkanVzdCA9IHNldC5tYXNraW5nX2FkajtcbiAgICAgICAgLy8gU0VUX09QVElPTihtYXNraW5nYWRqdXN0LCBzZXQubWFza2luZ19hZGosIDApO1xuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLm1hc2tpbmdhZGp1c3Rfc2hvcnQgPSBzZXQubWFza2luZ19hZGpfc2hvcnQ7XG4gICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLm1hc2tpbmdhZGp1c3Rfc2hvcnQgLSAwKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLm1hc2tpbmdhZGp1c3Rfc2hvcnQgPSBzZXQubWFza2luZ19hZGpfc2hvcnQ7XG4gICAgICAgIC8vIFNFVF9PUFRJT04obWFza2luZ2FkanVzdF9zaG9ydCwgc2V0Lm1hc2tpbmdfYWRqX3Nob3J0LCAwKTtcbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5BVEhsb3dlciA9IC1zZXQuYXRoX2xvd2VyIC8gMTAuMDtcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicygoLWdmcC5BVEhsb3dlciAqIDEwLjApIC0gMCkgPiAwKSlcbiAgICAgICAgICAgIGdmcC5BVEhsb3dlciA9IC1zZXQuYXRoX2xvd2VyIC8gMTAuMDtcbiAgICAgICAgLy8gU0VUX09QVElPTihBVEhsb3dlciwgc2V0LmF0aF9sb3dlciwgMCk7XG4gICAgICAgIGlmIChlbmZvcmNlICE9IDApXG4gICAgICAgICAgICBnZnAuQVRIY3VydmUgPSBzZXQuYXRoX2N1cnZlO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5BVEhjdXJ2ZSAtIC0xKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLkFUSGN1cnZlID0gc2V0LmF0aF9jdXJ2ZTtcbiAgICAgICAgLy8gU0VUX09QVElPTihBVEhjdXJ2ZSwgc2V0LmF0aF9jdXJ2ZSwgLTEpO1xuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLmF0aGFhX3NlbnNpdGl2aXR5ID0gc2V0LmF0aF9zZW5zaXRpdml0eTtcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicyhnZnAuYXRoYWFfc2Vuc2l0aXZpdHkgLSAtMSkgPiAwKSlcbiAgICAgICAgICAgIGdmcC5hdGhhYV9zZW5zaXRpdml0eSA9IHNldC5hdGhfc2Vuc2l0aXZpdHk7XG4gICAgICAgIC8vIFNFVF9PUFRJT04oYXRoYWFfc2Vuc2l0aXZpdHksIHNldC5hdGhfc2Vuc2l0aXZpdHksIDApO1xuICAgICAgICBpZiAoc2V0LmludGVyY2ggPiAwKSB7XG4gICAgICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgICAgIGdmcC5pbnRlckNoUmF0aW8gPSBzZXQuaW50ZXJjaDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLmludGVyQ2hSYXRpbyAtIC0xKSA+IDApKVxuICAgICAgICAgICAgICAgIGdmcC5pbnRlckNoUmF0aW8gPSBzZXQuaW50ZXJjaDtcbiAgICAgICAgICAgIC8vIFNFVF9PUFRJT04oaW50ZXJDaFJhdGlvLCBzZXQuaW50ZXJjaCwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogcGFyYW1ldGVycyBmb3Igd2hpY2ggdGhlcmUgaXMgbm8gcHJvcGVyIHNldC9nZXQgaW50ZXJmYWNlICovXG4gICAgICAgIGlmIChzZXQuc2FmZWpvaW50ID4gMCkge1xuICAgICAgICAgICAgZ2ZwLmV4cF9uc3BzeXR1bmUgPSBnZnAuZXhwX25zcHN5dHVuZSB8IHNldC5zYWZlam9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldC5zZmIyMW1vZCA+IDApIHtcbiAgICAgICAgICAgIGdmcC5leHBfbnNwc3l0dW5lID0gZ2ZwLmV4cF9uc3BzeXR1bmUgfCAoc2V0LnNmYjIxbW9kIDw8IDIwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLm1zZml4ID0gc2V0Lm1zZml4O1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5tc2ZpeCAtIC0xKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLm1zZml4ID0gc2V0Lm1zZml4O1xuICAgICAgICAvLyBTRVRfT1BUSU9OKG1zZml4LCBzZXQubXNmaXgsIC0xKTtcblxuICAgICAgICBpZiAoZW5mb3JjZSA9PSAwKSB7XG4gICAgICAgICAgICBnZnAuVkJSX3EgPSBhO1xuICAgICAgICAgICAgZ2ZwLlZCUl9xX2ZyYWMgPSB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiAgU3dpdGNoIG1hcHBpbmdzIGZvciBBQlIgbW9kZVxuICAgICAqXG4gICAgICogICAgICAgICAgICAgIGticHMgIHF1YW50IHFfcyBzYWZlam9pbnQgbnNtc2ZpeCBzdF9scm0gIHN0X3MgIG5zLWJhc3Mgc2NhbGUgICBtc2sgYXRoX2x3ciBhdGhfY3VydmUgIGludGVyY2ggLCBzZnNjYWxlXG4gICAgICogPC9QUkU+XG4gICAgICovXG4gICAgdmFyIGFicl9zd2l0Y2hfbWFwID0gW1xuICAgICAgICBuZXcgQUJSUHJlc2V0cyg4LCA5LCA5LCAwLCAwLCA2LjYwLCAxNDUsIDAsIDAuOTUsIDAsIC0zMC4wLCAxMSwgMC4wMDEyLCAxKSwgLyogICA4LCBpbXBvc3NpYmxlIHRvIHVzZSBpbiBzdGVyZW8gKi9cbiAgICAgICAgbmV3IEFCUlByZXNldHMoMTYsIDksIDksIDAsIDAsIDYuNjAsIDE0NSwgMCwgMC45NSwgMCwgLTI1LjAsIDExLCAwLjAwMTAsIDEpLCAvKiAgMTYgKi9cbiAgICAgICAgbmV3IEFCUlByZXNldHMoMjQsIDksIDksIDAsIDAsIDYuNjAsIDE0NSwgMCwgMC45NSwgMCwgLTIwLjAsIDExLCAwLjAwMTAsIDEpLCAvKiAgMjQgKi9cbiAgICAgICAgbmV3IEFCUlByZXNldHMoMzIsIDksIDksIDAsIDAsIDYuNjAsIDE0NSwgMCwgMC45NSwgMCwgLTE1LjAsIDExLCAwLjAwMTAsIDEpLCAvKiAgMzIgKi9cbiAgICAgICAgbmV3IEFCUlByZXNldHMoNDAsIDksIDksIDAsIDAsIDYuNjAsIDE0NSwgMCwgMC45NSwgMCwgLTEwLjAsIDExLCAwLjAwMDksIDEpLCAvKiAgNDAgKi9cbiAgICAgICAgbmV3IEFCUlByZXNldHMoNDgsIDksIDksIDAsIDAsIDYuNjAsIDE0NSwgMCwgMC45NSwgMCwgLTEwLjAsIDExLCAwLjAwMDksIDEpLCAvKiAgNDggKi9cbiAgICAgICAgbmV3IEFCUlByZXNldHMoNTYsIDksIDksIDAsIDAsIDYuNjAsIDE0NSwgMCwgMC45NSwgMCwgLTYuMCwgMTEsIDAuMDAwOCwgMSksIC8qICA1NiAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cyg2NCwgOSwgOSwgMCwgMCwgNi42MCwgMTQ1LCAwLCAwLjk1LCAwLCAtMi4wLCAxMSwgMC4wMDA4LCAxKSwgLyogIDY0ICovXG4gICAgICAgIG5ldyBBQlJQcmVzZXRzKDgwLCA5LCA5LCAwLCAwLCA2LjYwLCAxNDUsIDAsIDAuOTUsIDAsIC4wLCA4LCAwLjAwMDcsIDEpLCAvKiAgODAgKi9cbiAgICAgICAgbmV3IEFCUlByZXNldHMoOTYsIDksIDksIDAsIDIuNTAsIDYuNjAsIDE0NSwgMCwgMC45NSwgMCwgMS4wLCA1LjUsIDAuMDAwNiwgMSksIC8qICA5NiAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cygxMTIsIDksIDksIDAsIDIuMjUsIDYuNjAsIDE0NSwgMCwgMC45NSwgMCwgMi4wLCA0LjUsIDAuMDAwNSwgMSksIC8qIDExMiAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cygxMjgsIDksIDksIDAsIDEuOTUsIDYuNDAsIDE0MCwgMCwgMC45NSwgMCwgMy4wLCA0LCAwLjAwMDIsIDEpLCAvKiAxMjggKi9cbiAgICAgICAgbmV3IEFCUlByZXNldHMoMTYwLCA5LCA5LCAxLCAxLjc5LCA2LjAwLCAxMzUsIDAsIDAuOTUsIC0yLCA1LjAsIDMuNSwgMCwgMSksIC8qIDE2MCAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cygxOTIsIDksIDksIDEsIDEuNDksIDUuNjAsIDEyNSwgMCwgMC45NywgLTQsIDcuMCwgMywgMCwgMCksIC8qIDE5MiAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cygyMjQsIDksIDksIDEsIDEuMjUsIDUuMjAsIDEyNSwgMCwgMC45OCwgLTYsIDkuMCwgMiwgMCwgMCksIC8qIDIyNCAqL1xuICAgICAgICBuZXcgQUJSUHJlc2V0cygyNTYsIDksIDksIDEsIDAuOTcsIDUuMjAsIDEyNSwgMCwgMS4wMCwgLTgsIDEwLjAsIDEsIDAsIDApLCAvKiAyNTYgKi9cbiAgICAgICAgbmV3IEFCUlByZXNldHMoMzIwLCA5LCA5LCAxLCAwLjkwLCA1LjIwLCAxMjUsIDAsIDEuMDAsIC0xMCwgMTIuMCwgMCwgMCwgMCkgIC8qIDMyMCAqL1xuICAgIF07XG5cbiAgICBmdW5jdGlvbiBhcHBseV9hYnJfcHJlc2V0KGdmcCwgcHJlc2V0LCBlbmZvcmNlKSB7XG4gICAgICAgIC8qIFZhcmlhYmxlcyBmb3IgdGhlIEFCUiBzdHVmZiAqL1xuICAgICAgICB2YXIgYWN0dWFsX2JpdHJhdGUgPSBwcmVzZXQ7XG5cbiAgICAgICAgdmFyIHIgPSBsYW1lLm5lYXJlc3RCaXRyYXRlRnVsbEluZGV4KHByZXNldCk7XG5cbiAgICAgICAgZ2ZwLlZCUiA9IFZick1vZGUkMjAudmJyX2FicjtcbiAgICAgICAgZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyA9IGFjdHVhbF9iaXRyYXRlO1xuICAgICAgICBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzID0gTWF0aC5taW4oZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcywgMzIwKTtcbiAgICAgICAgZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyA9IE1hdGgubWF4KGdmcC5WQlJfbWVhbl9iaXRyYXRlX2ticHMsIDgpO1xuICAgICAgICBnZnAuYnJhdGUgPSBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzO1xuICAgICAgICBpZiAoZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyA+IDMyMCkge1xuICAgICAgICAgICAgZ2ZwLmRpc2FibGVfcmVzZXJ2b2lyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIHBhcmFtZXRlcnMgZm9yIHdoaWNoIHRoZXJlIGlzIG5vIHByb3BlciBzZXQvZ2V0IGludGVyZmFjZSAqL1xuICAgICAgICBpZiAoYWJyX3N3aXRjaF9tYXBbcl0uc2FmZWpvaW50ID4gMClcbiAgICAgICAgICAgIGdmcC5leHBfbnNwc3l0dW5lID0gZ2ZwLmV4cF9uc3BzeXR1bmUgfCAyO1xuICAgICAgICAvKiBzYWZlam9pbnQgKi9cblxuICAgICAgICBpZiAoYWJyX3N3aXRjaF9tYXBbcl0uc2ZzY2FsZSA+IDApIHtcbiAgICAgICAgICAgIGdmcC5pbnRlcm5hbF9mbGFncy5ub2lzZV9zaGFwaW5nID0gMjtcbiAgICAgICAgfVxuICAgICAgICAvKiBucy1iYXNzIHR3ZWFrcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnMoYWJyX3N3aXRjaF9tYXBbcl0ubnNiYXNzKSA+IDApIHtcbiAgICAgICAgICAgIHZhciBrID0gKGludCkoYWJyX3N3aXRjaF9tYXBbcl0ubnNiYXNzICogNCk7XG4gICAgICAgICAgICBpZiAoayA8IDApXG4gICAgICAgICAgICAgICAgayArPSA2NDtcbiAgICAgICAgICAgIGdmcC5leHBfbnNwc3l0dW5lID0gZ2ZwLmV4cF9uc3BzeXR1bmUgfCAoayA8PCAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmZvcmNlICE9IDApXG4gICAgICAgICAgICBnZnAucXVhbnRfY29tcCA9IGFicl9zd2l0Y2hfbWFwW3JdLnF1YW50X2NvbXA7XG4gICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLnF1YW50X2NvbXAgLSAtMSkgPiAwKSlcbiAgICAgICAgICAgIGdmcC5xdWFudF9jb21wID0gYWJyX3N3aXRjaF9tYXBbcl0ucXVhbnRfY29tcDtcbiAgICAgICAgLy8gU0VUX09QVElPTihxdWFudF9jb21wLCBhYnJfc3dpdGNoX21hcFtyXS5xdWFudF9jb21wLCAtMSk7XG4gICAgICAgIGlmIChlbmZvcmNlICE9IDApXG4gICAgICAgICAgICBnZnAucXVhbnRfY29tcF9zaG9ydCA9IGFicl9zd2l0Y2hfbWFwW3JdLnF1YW50X2NvbXBfcztcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicyhnZnAucXVhbnRfY29tcF9zaG9ydCAtIC0xKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLnF1YW50X2NvbXBfc2hvcnQgPSBhYnJfc3dpdGNoX21hcFtyXS5xdWFudF9jb21wX3M7XG4gICAgICAgIC8vIFNFVF9PUFRJT04ocXVhbnRfY29tcF9zaG9ydCwgYWJyX3N3aXRjaF9tYXBbcl0ucXVhbnRfY29tcF9zLCAtMSk7XG5cbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5tc2ZpeCA9IGFicl9zd2l0Y2hfbWFwW3JdLm5zbXNmaXg7XG4gICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLm1zZml4IC0gLTEpID4gMCkpXG4gICAgICAgICAgICBnZnAubXNmaXggPSBhYnJfc3dpdGNoX21hcFtyXS5uc21zZml4O1xuICAgICAgICAvLyBTRVRfT1BUSU9OKG1zZml4LCBhYnJfc3dpdGNoX21hcFtyXS5uc21zZml4LCAtMSk7XG5cbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlID0gYWJyX3N3aXRjaF9tYXBbcl0uc3RfbHJtO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlIC0gLTEpID4gMCkpXG4gICAgICAgICAgICBnZnAuaW50ZXJuYWxfZmxhZ3MubnNQc3kuYXR0YWNrdGhyZSA9IGFicl9zd2l0Y2hfbWFwW3JdLnN0X2xybTtcbiAgICAgICAgLy8gU0VUX09QVElPTihzaG9ydF90aHJlc2hvbGRfbHJtLCBhYnJfc3dpdGNoX21hcFtyXS5zdF9scm0sIC0xKTtcbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlX3MgPSBhYnJfc3dpdGNoX21hcFtyXS5zdF9zO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlX3MgLSAtMSkgPiAwKSlcbiAgICAgICAgICAgIGdmcC5pbnRlcm5hbF9mbGFncy5uc1BzeS5hdHRhY2t0aHJlX3MgPSBhYnJfc3dpdGNoX21hcFtyXS5zdF9zO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKHNob3J0X3RocmVzaG9sZF9zLCBhYnJfc3dpdGNoX21hcFtyXS5zdF9zLCAtMSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogQUJSIHNlZW1zIHRvIGhhdmUgYmlnIHByb2JsZW1zIHdpdGggY2xpcHBpbmcsIGVzcGVjaWFsbHkgYXQgbG93XG4gICAgICAgICAqIGJpdHJhdGVzXG4gICAgICAgICAqL1xuICAgICAgICAvKlxuICAgICAgICAgKiBzbyB3ZSBjb21wZW5zYXRlIGZvciB0aGF0IGhlcmUgYnkgdXNpbmcgYSBzY2FsZSB2YWx1ZSBkZXBlbmRpbmcgb25cbiAgICAgICAgICogYml0cmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5zY2FsZSA9IGFicl9zd2l0Y2hfbWFwW3JdLnNjYWxlO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5zY2FsZSAtIC0xKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLnNjYWxlID0gYWJyX3N3aXRjaF9tYXBbcl0uc2NhbGU7XG4gICAgICAgIC8vIFNFVF9PUFRJT04oc2NhbGUsIGFicl9zd2l0Y2hfbWFwW3JdLnNjYWxlLCAtMSk7XG5cbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5tYXNraW5nYWRqdXN0ID0gYWJyX3N3aXRjaF9tYXBbcl0ubWFza2luZ19hZGo7XG4gICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoZ2ZwLm1hc2tpbmdhZGp1c3QgLSAwKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLm1hc2tpbmdhZGp1c3QgPSBhYnJfc3dpdGNoX21hcFtyXS5tYXNraW5nX2FkajtcbiAgICAgICAgLy8gU0VUX09QVElPTihtYXNraW5nYWRqdXN0LCBhYnJfc3dpdGNoX21hcFtyXS5tYXNraW5nX2FkaiwgMCk7XG4gICAgICAgIGlmIChhYnJfc3dpdGNoX21hcFtyXS5tYXNraW5nX2FkaiA+IDApIHtcbiAgICAgICAgICAgIGlmIChlbmZvcmNlICE9IDApXG4gICAgICAgICAgICAgICAgZ2ZwLm1hc2tpbmdhZGp1c3Rfc2hvcnQgPSAoYWJyX3N3aXRjaF9tYXBbcl0ubWFza2luZ19hZGogKiAuOSk7XG4gICAgICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5tYXNraW5nYWRqdXN0X3Nob3J0IC0gMCkgPiAwKSlcbiAgICAgICAgICAgICAgICBnZnAubWFza2luZ2FkanVzdF9zaG9ydCA9IChhYnJfc3dpdGNoX21hcFtyXS5tYXNraW5nX2FkaiAqIC45KTtcbiAgICAgICAgICAgIC8vIFNFVF9PUFRJT04obWFza2luZ2FkanVzdF9zaG9ydCwgYWJyX3N3aXRjaF9tYXBbcl0ubWFza2luZ19hZGogKlxuICAgICAgICAgICAgLy8gLjksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgICAgICBnZnAubWFza2luZ2FkanVzdF9zaG9ydCA9IChhYnJfc3dpdGNoX21hcFtyXS5tYXNraW5nX2FkaiAqIDEuMSk7XG4gICAgICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5tYXNraW5nYWRqdXN0X3Nob3J0IC0gMCkgPiAwKSlcbiAgICAgICAgICAgICAgICBnZnAubWFza2luZ2FkanVzdF9zaG9ydCA9IChhYnJfc3dpdGNoX21hcFtyXS5tYXNraW5nX2FkaiAqIDEuMSk7XG4gICAgICAgICAgICAvLyBTRVRfT1BUSU9OKG1hc2tpbmdhZGp1c3Rfc2hvcnQsIGFicl9zd2l0Y2hfbWFwW3JdLm1hc2tpbmdfYWRqICpcbiAgICAgICAgICAgIC8vIDEuMSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5mb3JjZSAhPSAwKVxuICAgICAgICAgICAgZ2ZwLkFUSGxvd2VyID0gLWFicl9zd2l0Y2hfbWFwW3JdLmF0aF9sb3dlciAvIDEwLjtcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicygoLWdmcC5BVEhsb3dlciAqIDEwLikgLSAwKSA+IDApKVxuICAgICAgICAgICAgZ2ZwLkFUSGxvd2VyID0gLWFicl9zd2l0Y2hfbWFwW3JdLmF0aF9sb3dlciAvIDEwLjtcbiAgICAgICAgLy8gU0VUX09QVElPTihBVEhsb3dlciwgYWJyX3N3aXRjaF9tYXBbcl0uYXRoX2xvd2VyLCAwKTtcbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5BVEhjdXJ2ZSA9IGFicl9zd2l0Y2hfbWFwW3JdLmF0aF9jdXJ2ZTtcbiAgICAgICAgZWxzZSBpZiAoIShNYXRoLmFicyhnZnAuQVRIY3VydmUgLSAtMSkgPiAwKSlcbiAgICAgICAgICAgIGdmcC5BVEhjdXJ2ZSA9IGFicl9zd2l0Y2hfbWFwW3JdLmF0aF9jdXJ2ZTtcbiAgICAgICAgLy8gU0VUX09QVElPTihBVEhjdXJ2ZSwgYWJyX3N3aXRjaF9tYXBbcl0uYXRoX2N1cnZlLCAtMSk7XG5cbiAgICAgICAgaWYgKGVuZm9yY2UgIT0gMClcbiAgICAgICAgICAgIGdmcC5pbnRlckNoUmF0aW8gPSBhYnJfc3dpdGNoX21hcFtyXS5pbnRlcmNoO1xuICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKGdmcC5pbnRlckNoUmF0aW8gLSAtMSkgPiAwKSlcbiAgICAgICAgICAgIGdmcC5pbnRlckNoUmF0aW8gPSBhYnJfc3dpdGNoX21hcFtyXS5pbnRlcmNoO1xuICAgICAgICAvLyBTRVRfT1BUSU9OKGludGVyQ2hSYXRpbywgYWJyX3N3aXRjaF9tYXBbcl0uaW50ZXJjaCwgLTEpO1xuXG4gICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBseV9wcmVzZXQgPSBmdW5jdGlvbihnZnAsIHByZXNldCwgZW5mb3JjZSkge1xuICAgICAgICAvKiB0cmFuc2xhdGUgbGVnYWN5IHByZXNldHMgKi9cbiAgICAgICAgc3dpdGNoIChwcmVzZXQpIHtcbiAgICAgICAgICAgIGNhc2UgTGFtZS5SM01JWDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcmVzZXQgPSBMYW1lLlYzO1xuICAgICAgICAgICAgICAgIGdmcC5WQlIgPSBWYnJNb2RlJDIwLnZicl9tdHJoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBMYW1lLk1FRElVTTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcmVzZXQgPSBMYW1lLlY0O1xuICAgICAgICAgICAgICAgIGdmcC5WQlIgPSBWYnJNb2RlJDIwLnZicl9yaDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTGFtZS5NRURJVU1fRkFTVDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcmVzZXQgPSBMYW1lLlY0O1xuICAgICAgICAgICAgICAgIGdmcC5WQlIgPSBWYnJNb2RlJDIwLnZicl9tdHJoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBMYW1lLlNUQU5EQVJEOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZXNldCA9IExhbWUuVjI7XG4gICAgICAgICAgICAgICAgZ2ZwLlZCUiA9IFZick1vZGUkMjAudmJyX3JoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBMYW1lLlNUQU5EQVJEX0ZBU1Q6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJlc2V0ID0gTGFtZS5WMjtcbiAgICAgICAgICAgICAgICBnZnAuVkJSID0gVmJyTW9kZSQyMC52YnJfbXRyaDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTGFtZS5FWFRSRU1FOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZXNldCA9IExhbWUuVjA7XG4gICAgICAgICAgICAgICAgZ2ZwLlZCUiA9IFZick1vZGUkMjAudmJyX3JoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBMYW1lLkVYVFJFTUVfRkFTVDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcmVzZXQgPSBMYW1lLlYwO1xuICAgICAgICAgICAgICAgIGdmcC5WQlIgPSBWYnJNb2RlJDIwLnZicl9tdHJoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBMYW1lLklOU0FORTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcmVzZXQgPSAzMjA7XG4gICAgICAgICAgICAgICAgZ2ZwLnByZXNldCA9IHByZXNldDtcbiAgICAgICAgICAgICAgICBhcHBseV9hYnJfcHJlc2V0KGdmcCwgcHJlc2V0LCBlbmZvcmNlKTtcbiAgICAgICAgICAgICAgICBnZnAuVkJSID0gVmJyTW9kZSQyMC52YnJfb2ZmO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZnAucHJlc2V0ID0gcHJlc2V0O1xuICAgICAgICB7XG4gICAgICAgICAgICBzd2l0Y2ggKHByZXNldCkge1xuICAgICAgICAgICAgICAgIGNhc2UgTGFtZS5WOTpcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlfdmJyX3ByZXNldChnZnAsIDksIGVuZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2V0O1xuICAgICAgICAgICAgICAgIGNhc2UgTGFtZS5WODpcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlfdmJyX3ByZXNldChnZnAsIDgsIGVuZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2V0O1xuICAgICAgICAgICAgICAgIGNhc2UgTGFtZS5WNzpcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlfdmJyX3ByZXNldChnZnAsIDcsIGVuZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2V0O1xuICAgICAgICAgICAgICAgIGNhc2UgTGFtZS5WNjpcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlfdmJyX3ByZXNldChnZnAsIDYsIGVuZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2V0O1xuICAgICAgICAgICAgICAgIGNhc2UgTGFtZS5WNTpcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlfdmJyX3ByZXNldChnZnAsIDUsIGVuZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2V0O1xuICAgICAgICAgICAgICAgIGNhc2UgTGFtZS5WNDpcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlfdmJyX3ByZXNldChnZnAsIDQsIGVuZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2V0O1xuICAgICAgICAgICAgICAgIGNhc2UgTGFtZS5WMzpcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlfdmJyX3ByZXNldChnZnAsIDMsIGVuZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2V0O1xuICAgICAgICAgICAgICAgIGNhc2UgTGFtZS5WMjpcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlfdmJyX3ByZXNldChnZnAsIDIsIGVuZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2V0O1xuICAgICAgICAgICAgICAgIGNhc2UgTGFtZS5WMTpcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlfdmJyX3ByZXNldChnZnAsIDEsIGVuZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2V0O1xuICAgICAgICAgICAgICAgIGNhc2UgTGFtZS5WMDpcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlfdmJyX3ByZXNldChnZnAsIDAsIGVuZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2V0O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICg4IDw9IHByZXNldCAmJiBwcmVzZXQgPD0gMzIwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHlfYWJyX3ByZXNldChnZnAsIHByZXNldCwgZW5mb3JjZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBubyBjb3JyZXNwb25kaW5nIHByZXNldCBmb3VuZCAqL1xuICAgICAgICBnZnAucHJlc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHByZXNldDtcbiAgICB9O1xuXG4gICAgLy8gUmVzdCBmcm9tIGdldHNldC5jOlxuXG4gICAgLyoqXG4gICAgICogVkJSIHF1YWxpdHkgbGV2ZWwuPEJSPlxuICAgICAqIDAgPSBoaWdoZXN0PEJSPlxuICAgICAqIDkgPSBsb3dlc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYW1lX3NldF9WQlJfcShnZnAsIFZCUl9xKSB7XG4gICAgICAgIHZhciByZXQgPSAwO1xuXG4gICAgICAgIGlmICgwID4gVkJSX3EpIHtcbiAgICAgICAgICAgIC8qIFVua25vd24gVkJSIHF1YWxpdHkgbGV2ZWwhICovXG4gICAgICAgICAgICByZXQgPSAtMTtcbiAgICAgICAgICAgIFZCUl9xID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoOSA8IFZCUl9xKSB7XG4gICAgICAgICAgICByZXQgPSAtMTtcbiAgICAgICAgICAgIFZCUl9xID0gOTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdmcC5WQlJfcSA9IFZCUl9xO1xuICAgICAgICBnZnAuVkJSX3FfZnJhYyA9IDA7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG59XG5cbnZhciBQcmVzZXRzXzEgPSBQcmVzZXRzJDE7XG5cbmZ1bmN0aW9uIFZCUlF1YW50aXplKCkge1xuICAgIHZhciBxdXB2dDtcbiAgICB2YXIgdGFrO1xuXG4gICAgdGhpcy5zZXRNb2R1bGVzID0gZnVuY3Rpb24gKF9xdXB2dCwgX3RrKSB7XG4gICAgICAgIHF1cHZ0ID0gX3F1cHZ0O1xuICAgICAgICB0YWsgPSBfdGs7XG4gICAgfTtcbiAgICAvL1RPRE9cblxufVxuXG52YXIgVkJSUXVhbnRpemVfMSA9IFZCUlF1YW50aXplO1xuXG4vL3BhY2thZ2UgbXAzO1xuXG5mdW5jdGlvbiBDYWxjTm9pc2VSZXN1bHQkMSgpIHtcbiAgICAvKipcbiAgICAgKiBzdW0gb2YgcXVhbnRpemF0aW9uIG5vaXNlID4gbWFza2luZ1xuICAgICAqL1xuICAgIHRoaXMub3Zlcl9ub2lzZSA9IDAuO1xuICAgIC8qKlxuICAgICAqIHN1bSBvZiBhbGwgcXVhbnRpemF0aW9uIG5vaXNlXG4gICAgICovXG4gICAgdGhpcy50b3Rfbm9pc2UgPSAwLjtcbiAgICAvKipcbiAgICAgKiBtYXggcXVhbnRpemF0aW9uIG5vaXNlXG4gICAgICovXG4gICAgdGhpcy5tYXhfbm9pc2UgPSAwLjtcbiAgICAvKipcbiAgICAgKiBudW1iZXIgb2YgcXVhbnRpemF0aW9uIG5vaXNlID4gbWFza2luZ1xuICAgICAqL1xuICAgIHRoaXMub3Zlcl9jb3VudCA9IDA7XG4gICAgLyoqXG4gICAgICogU1NELWxpa2UgY29zdCBvZiBkaXN0b3J0ZWQgYmFuZHNcbiAgICAgKi9cbiAgICB0aGlzLm92ZXJfU1NEID0gMDtcbiAgICB0aGlzLmJpdHMgPSAwO1xufVxuXG52YXIgQ2FsY05vaXNlUmVzdWx0XzEgPSBDYWxjTm9pc2VSZXN1bHQkMTtcblxudmFyIG5ld19mbG9hdCQyMiA9IGNvbW1vbi5uZXdfZmxvYXQ7XG52YXIgbmV3X2ludCQyMiA9IGNvbW1vbi5uZXdfaW50O1xuZnVuY3Rpb24gQ2FsY05vaXNlRGF0YSgpIHtcbiAgICB0aGlzLmdsb2JhbF9nYWluID0gMDtcbiAgICB0aGlzLnNmYl9jb3VudDEgPSAwO1xuICAgIHRoaXMuc3RlcCA9IG5ld19pbnQkMjIoMzkpO1xuICAgIHRoaXMubm9pc2UgPSBuZXdfZmxvYXQkMjIoMzkpO1xuICAgIHRoaXMubm9pc2VfbG9nID0gbmV3X2Zsb2F0JDIyKDM5KTtcbn1cblxudmFyIENhbGNOb2lzZURhdGFfMSA9IENhbGNOb2lzZURhdGE7XG5cbi8qXG4gKiBNUDMgcXVhbnRpemF0aW9uXG4gKlxuICogICAgICBDb3B5cmlnaHQgKGMpIDE5OTktMjAwMCBNYXJrIFRheWxvclxuICogICAgICBDb3B5cmlnaHQgKGMpIDE5OTktMjAwMyBUYWtlaGlybyBUb21pbmFnYVxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMDAtMjAwNyBSb2JlcnQgSGVnZW1hbm5cbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDAxLTIwMDUgR2FicmllbCBCb3V2aWduZVxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAqIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlclxuICogdmVyc2lvbiAyIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gICAgIFNlZSB0aGUgR05VXG4gKiBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZVxuICogRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsXG4gKiBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqL1xuXG4vKiAkSWQ6IFF1YW50aXplLmphdmEsdiAxLjI0IDIwMTEvMDUvMjQgMjA6NDg6MDYga2VuY2hpcyBFeHAgJCAqL1xuXG4vL3BhY2thZ2UgbXAzO1xuXG4vL2ltcG9ydCBqYXZhLnV0aWwuQXJyYXlzO1xuXG52YXIgU3lzdGVtJDIxID0gY29tbW9uLlN5c3RlbTtcbnZhciBWYnJNb2RlJDIxID0gY29tbW9uLlZick1vZGU7XG52YXIgVXRpbCQyMSA9IGNvbW1vbi5VdGlsO1xudmFyIEFycmF5cyQyMSA9IGNvbW1vbi5BcnJheXM7XG52YXIgbmV3X2Zsb2F0JDIxID0gY29tbW9uLm5ld19mbG9hdDtcbnZhciBhc3NlcnQkMjEgPSBjb21tb24uYXNzZXJ0O1xuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIFF1YW50aXplJDEoKSB7XG4gICAgdmFyIGJzO1xuICAgIHRoaXMucnYgPSBudWxsO1xuICAgIHZhciBydjtcbiAgICB0aGlzLnF1cHZ0ID0gbnVsbDtcbiAgICB2YXIgcXVwdnQ7XG5cbiAgICB2YXIgdmJyID0gbmV3IFZCUlF1YW50aXplXzEoKTtcbiAgICB2YXIgdGs7XG5cbiAgICB0aGlzLnNldE1vZHVsZXMgPSBmdW5jdGlvbiAoX2JzLCBfcnYsIF9xdXB2dCwgX3RrKSB7XG4gICAgICAgIGJzID0gX2JzO1xuICAgICAgICBydiA9IF9ydjtcbiAgICAgICAgdGhpcy5ydiA9IF9ydjtcbiAgICAgICAgcXVwdnQgPSBfcXVwdnQ7XG4gICAgICAgIHRoaXMucXVwdnQgPSBfcXVwdnQ7XG4gICAgICAgIHRrID0gX3RrO1xuICAgICAgICB2YnIuc2V0TW9kdWxlcyhxdXB2dCwgdGspO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGZyb20gTC9SIDwuIE1pZC9TaWRlXG4gICAgICovXG4gICAgdGhpcy5tc19jb252ZXJ0ID0gZnVuY3Rpb24gKGwzX3NpZGUsIGdyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTc2OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsID0gbDNfc2lkZS50dFtncl1bMF0ueHJbaV07XG4gICAgICAgICAgICB2YXIgciA9IGwzX3NpZGUudHRbZ3JdWzFdLnhyW2ldO1xuICAgICAgICAgICAgbDNfc2lkZS50dFtncl1bMF0ueHJbaV0gPSAobCArIHIpICogKFV0aWwkMjEuU1FSVDIgKiAwLjUpO1xuICAgICAgICAgICAgbDNfc2lkZS50dFtncl1bMV0ueHJbaV0gPSAobCAtIHIpICogKFV0aWwkMjEuU1FSVDIgKiAwLjUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG10IDYvOTlcbiAgICAgKlxuICAgICAqIGluaXRpYWxpemVzIGNvZF9pbmZvLCBzY2FsZWZhYyBhbmQgeHJwb3dcbiAgICAgKlxuICAgICAqIHJldHVybnMgMCBpZiBhbGwgZW5lcmdpZXMgaW4geHIgYXJlIHplcm8sIGVsc2UgMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRfeHJwb3dfY29yZShjb2RfaW5mbywgeHJwb3csIHVwcGVyLCBzdW0pIHtcbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdXBwZXI7ICsraSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IE1hdGguYWJzKGNvZF9pbmZvLnhyW2ldKTtcbiAgICAgICAgICAgIHN1bSArPSB0bXA7XG4gICAgICAgICAgICB4cnBvd1tpXSA9IE1hdGguc3FydCh0bXAgKiBNYXRoLnNxcnQodG1wKSk7XG5cbiAgICAgICAgICAgIGlmICh4cnBvd1tpXSA+IGNvZF9pbmZvLnhycG93X21heClcbiAgICAgICAgICAgICAgICBjb2RfaW5mby54cnBvd19tYXggPSB4cnBvd1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdF94cnBvdyA9IGZ1bmN0aW9uIChnZmMsIGNvZF9pbmZvLCB4cnBvdykge1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIHVwcGVyID0gMCB8IGNvZF9pbmZvLm1heF9ub256ZXJvX2NvZWZmO1xuXG4gICAgICAgIGFzc2VydCQyMSh4cnBvdyAhPSBudWxsKTtcbiAgICAgICAgY29kX2luZm8ueHJwb3dfbWF4ID0gMDtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBjaGVjayBpZiB0aGVyZSBpcyBzb21lIGVuZXJneSB3ZSBoYXZlIHRvIHF1YW50aXplIGFuZCBjYWxjdWxhdGUgeHJwb3dcbiAgICAgICAgICogbWF0Y2hpbmcgb3VyIGZyZXNoIHNjYWxlZmFjdG9yc1xuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXJ0JDIxKDAgPD0gdXBwZXIgJiYgdXBwZXIgPD0gNTc1KTtcblxuICAgICAgICBBcnJheXMkMjEuZmlsbCh4cnBvdywgdXBwZXIsIDU3NiwgMCk7XG5cbiAgICAgICAgc3VtID0gaW5pdF94cnBvd19jb3JlKGNvZF9pbmZvLCB4cnBvdywgdXBwZXIsIHN1bSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogcmV0dXJuIDEgaWYgd2UgaGF2ZSBzb21ldGhpbmcgdG8gcXVhbnRpemUsIGVsc2UgMFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHN1bSA+IDFFLTIwKSB7XG4gICAgICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgICAgICBpZiAoKGdmYy5zdWJzdGVwX3NoYXBpbmcgJiAyKSAhPSAwKVxuICAgICAgICAgICAgICAgIGogPSAxO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZF9pbmZvLnBzeW1heDsgaSsrKVxuICAgICAgICAgICAgICAgIGdmYy5wc2V1ZG9oYWxmW2ldID0gajtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBBcnJheXMkMjEuZmlsbChjb2RfaW5mby5sM19lbmMsIDAsIDU3NiwgMCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2FicmllbCBCb3V2aWduZSBmZWIvYXByIDIwMDM8QlI+XG4gICAgICogQW5hbG9nIHNpbGVuY2UgZGV0ZWN0aW9uIGluIHBhcnRpdGlvbm5lZCBzZmIyMSBvciBzZmIxMiBmb3Igc2hvcnQgYmxvY2tzXG4gICAgICpcbiAgICAgKiBGcm9tIHRvcCB0byBib3R0b20gb2Ygc2ZiLCBjaGFuZ2VzIHRvIDAgY29lZmZzIHdoaWNoIGFyZSBiZWxvdyBhdGguIEl0XG4gICAgICogc3RvcHMgb24gdGhlIGZpcnN0IGNvZWZmIGhpZ2hlciB0aGFuIGF0aC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwc2ZiMjFfYW5hbG9nc2lsZW5jZShnZmMsIGNvZF9pbmZvKSB7XG4gICAgICAgIHZhciBhdGggPSBnZmMuQVRIO1xuICAgICAgICB2YXIgeHIgPSBjb2RfaW5mby54cjtcblxuICAgICAgICBpZiAoY29kX2luZm8uYmxvY2tfdHlwZSAhPSBFbmNvZGVyXzEuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgLyogTk9STSwgU1RBUlQgb3IgU1RPUCB0eXBlLCBidXQgbm90IFNIT1JUIGJsb2NrcyAqL1xuICAgICAgICAgICAgdmFyIHN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGdzZmIgPSBFbmNvZGVyXzEuUFNGQjIxIC0gMTsgZ3NmYiA+PSAwICYmICFzdG9wOyBnc2ZiLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBnZmMuc2NhbGVmYWNfYmFuZC5wc2ZiMjFbZ3NmYl07XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGdmYy5zY2FsZWZhY19iYW5kLnBzZmIyMVtnc2ZiICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIGF0aDIxID0gcXVwdnQuYXRoQWRqdXN0KGF0aC5hZGp1c3QsIGF0aC5wc2ZiMjFbZ3NmYl0sXG4gICAgICAgICAgICAgICAgICAgIGF0aC5mbG9vcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2ZjLm5zUHN5LmxvbmdmYWN0WzIxXSA+IDFlLTEyKVxuICAgICAgICAgICAgICAgICAgICBhdGgyMSAqPSBnZmMubnNQc3kubG9uZ2ZhY3RbMjFdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGVuZCAtIDE7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeHJbal0pIDwgYXRoMjEpXG4gICAgICAgICAgICAgICAgICAgICAgICB4cltqXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIG5vdGU6IHNob3J0IGJsb2NrcyBjb2VmZnMgYXJlIHJlb3JkZXJlZCAqL1xuICAgICAgICAgICAgZm9yICh2YXIgYmxvY2sgPSAwOyBibG9jayA8IDM7IGJsb2NrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGdzZmIgPSBFbmNvZGVyXzEuUFNGQjEyIC0gMTsgZ3NmYiA+PSAwICYmICFzdG9wOyBnc2ZiLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ2ZjLnNjYWxlZmFjX2JhbmQuc1sxMl1cbiAgICAgICAgICAgICAgICAgICAgICAgICogM1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAoZ2ZjLnNjYWxlZmFjX2JhbmQuc1sxM10gLSBnZmMuc2NhbGVmYWNfYmFuZC5zWzEyXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICogYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGdmYy5zY2FsZWZhY19iYW5kLnBzZmIxMltnc2ZiXSAtIGdmYy5zY2FsZWZhY19iYW5kLnBzZmIxMlswXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoZ2ZjLnNjYWxlZmFjX2JhbmQucHNmYjEyW2dzZmIgKyAxXSAtIGdmYy5zY2FsZWZhY19iYW5kLnBzZmIxMltnc2ZiXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdGgxMiA9IHF1cHZ0LmF0aEFkanVzdChhdGguYWRqdXN0LCBhdGgucHNmYjEyW2dzZmJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXRoLmZsb29yKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2ZjLm5zUHN5LnNob3J0ZmFjdFsxMl0gPiAxZS0xMilcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0aDEyICo9IGdmYy5uc1BzeS5zaG9ydGZhY3RbMTJdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBlbmQgLSAxOyBqID49IHN0YXJ0OyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh4cltqXSkgPCBhdGgxMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4cltqXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5pbml0X291dGVyX2xvb3AgPSBmdW5jdGlvbiAoZ2ZjLCBjb2RfaW5mbykge1xuICAgICAgICAvKlxuICAgICAgICAgKiBpbml0aWFsaXplIGZyZXNoIGNvZF9pbmZvXG4gICAgICAgICAqL1xuICAgICAgICBjb2RfaW5mby5wYXJ0Ml8zX2xlbmd0aCA9IDA7XG4gICAgICAgIGNvZF9pbmZvLmJpZ192YWx1ZXMgPSAwO1xuICAgICAgICBjb2RfaW5mby5jb3VudDEgPSAwO1xuICAgICAgICBjb2RfaW5mby5nbG9iYWxfZ2FpbiA9IDIxMDtcbiAgICAgICAgY29kX2luZm8uc2NhbGVmYWNfY29tcHJlc3MgPSAwO1xuICAgICAgICAvKiBtaXhlZF9ibG9ja19mbGFnLCBibG9ja190eXBlIHdhcyBzZXQgaW4gcHN5bW9kZWwuYyAqL1xuICAgICAgICBjb2RfaW5mby50YWJsZV9zZWxlY3RbMF0gPSAwO1xuICAgICAgICBjb2RfaW5mby50YWJsZV9zZWxlY3RbMV0gPSAwO1xuICAgICAgICBjb2RfaW5mby50YWJsZV9zZWxlY3RbMl0gPSAwO1xuICAgICAgICBjb2RfaW5mby5zdWJibG9ja19nYWluWzBdID0gMDtcbiAgICAgICAgY29kX2luZm8uc3ViYmxvY2tfZ2FpblsxXSA9IDA7XG4gICAgICAgIGNvZF9pbmZvLnN1YmJsb2NrX2dhaW5bMl0gPSAwO1xuICAgICAgICBjb2RfaW5mby5zdWJibG9ja19nYWluWzNdID0gMDtcbiAgICAgICAgLyogdGhpcyBvbmUgaXMgYWx3YXlzIDAgKi9cbiAgICAgICAgY29kX2luZm8ucmVnaW9uMF9jb3VudCA9IDA7XG4gICAgICAgIGNvZF9pbmZvLnJlZ2lvbjFfY291bnQgPSAwO1xuICAgICAgICBjb2RfaW5mby5wcmVmbGFnID0gMDtcbiAgICAgICAgY29kX2luZm8uc2NhbGVmYWNfc2NhbGUgPSAwO1xuICAgICAgICBjb2RfaW5mby5jb3VudDF0YWJsZV9zZWxlY3QgPSAwO1xuICAgICAgICBjb2RfaW5mby5wYXJ0Ml9sZW5ndGggPSAwO1xuICAgICAgICBjb2RfaW5mby5zZmJfbG1heCA9IEVuY29kZXJfMS5TQlBTWV9sO1xuICAgICAgICBjb2RfaW5mby5zZmJfc21pbiA9IEVuY29kZXJfMS5TQlBTWV9zO1xuICAgICAgICBjb2RfaW5mby5wc3lfbG1heCA9IGdmYy5zZmIyMV9leHRyYSA/IEVuY29kZXJfMS5TQk1BWF9sIDogRW5jb2Rlcl8xLlNCUFNZX2w7XG4gICAgICAgIGNvZF9pbmZvLnBzeW1heCA9IGNvZF9pbmZvLnBzeV9sbWF4O1xuICAgICAgICBjb2RfaW5mby5zZmJtYXggPSBjb2RfaW5mby5zZmJfbG1heDtcbiAgICAgICAgY29kX2luZm8uc2ZiZGl2aWRlID0gMTE7XG4gICAgICAgIGZvciAodmFyIHNmYiA9IDA7IHNmYiA8IEVuY29kZXJfMS5TQk1BWF9sOyBzZmIrKykge1xuICAgICAgICAgICAgY29kX2luZm8ud2lkdGhbc2ZiXSA9IGdmYy5zY2FsZWZhY19iYW5kLmxbc2ZiICsgMV1cbiAgICAgICAgICAgICAgICAtIGdmYy5zY2FsZWZhY19iYW5kLmxbc2ZiXTtcbiAgICAgICAgICAgIC8qIHdoaWNoIGlzIGFsd2F5cyAwLiAqL1xuICAgICAgICAgICAgY29kX2luZm8ud2luZG93W3NmYl0gPSAzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlID09IEVuY29kZXJfMS5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICB2YXIgaXh3b3JrID0gbmV3X2Zsb2F0JDIxKDU3Nik7XG5cbiAgICAgICAgICAgIGNvZF9pbmZvLnNmYl9zbWluID0gMDtcbiAgICAgICAgICAgIGNvZF9pbmZvLnNmYl9sbWF4ID0gMDtcbiAgICAgICAgICAgIGlmIChjb2RfaW5mby5taXhlZF9ibG9ja19mbGFnICE9IDApIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIE1QRUctMTogc2ZicyAwLTcgbG9uZyBibG9jaywgMy0xMiBzaG9ydCBibG9ja3MgTVBFRy0yKC41KTpcbiAgICAgICAgICAgICAgICAgKiBzZmJzIDAtNSBsb25nIGJsb2NrLCAzLTEyIHNob3J0IGJsb2Nrc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvZF9pbmZvLnNmYl9zbWluID0gMztcbiAgICAgICAgICAgICAgICBjb2RfaW5mby5zZmJfbG1heCA9IGdmYy5tb2RlX2dyICogMiArIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RfaW5mby5wc3ltYXggPSBjb2RfaW5mby5zZmJfbG1heFxuICAgICAgICAgICAgICAgICsgM1xuICAgICAgICAgICAgICAgICogKChnZmMuc2ZiMjFfZXh0cmEgPyBFbmNvZGVyXzEuU0JNQVhfcyA6IEVuY29kZXJfMS5TQlBTWV9zKSAtIGNvZF9pbmZvLnNmYl9zbWluKTtcbiAgICAgICAgICAgIGNvZF9pbmZvLnNmYm1heCA9IGNvZF9pbmZvLnNmYl9sbWF4ICsgM1xuICAgICAgICAgICAgICAgICogKEVuY29kZXJfMS5TQlBTWV9zIC0gY29kX2luZm8uc2ZiX3NtaW4pO1xuICAgICAgICAgICAgY29kX2luZm8uc2ZiZGl2aWRlID0gY29kX2luZm8uc2ZibWF4IC0gMTg7XG4gICAgICAgICAgICBjb2RfaW5mby5wc3lfbG1heCA9IGNvZF9pbmZvLnNmYl9sbWF4O1xuICAgICAgICAgICAgLyogcmUtb3JkZXIgdGhlIHNob3J0IGJsb2NrcywgZm9yIG1vcmUgZWZmaWNpZW50IGVuY29kaW5nIGJlbG93ICovXG4gICAgICAgICAgICAvKiBCeSBUYWtlaGlybyBUT01JTkFHQSAqL1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFdpdGhpbiBlYWNoIHNjYWxlZmFjdG9yIGJhbmQsIGRhdGEgaXMgZ2l2ZW4gZm9yIHN1Y2Nlc3NpdmUgdGltZVxuICAgICAgICAgICAgICogd2luZG93cywgYmVnaW5uaW5nIHdpdGggd2luZG93IDAgYW5kIGVuZGluZyB3aXRoIHdpbmRvdyAyLiBXaXRoaW5cbiAgICAgICAgICAgICAqIGVhY2ggd2luZG93LCB0aGUgcXVhbnRpemVkIHZhbHVlcyBhcmUgdGhlbiBhcnJhbmdlZCBpbiBvcmRlciBvZlxuICAgICAgICAgICAgICogaW5jcmVhc2luZyBmcmVxdWVuY3kuLi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGl4ID0gZ2ZjLnNjYWxlZmFjX2JhbmQubFtjb2RfaW5mby5zZmJfbG1heF07XG4gICAgICAgICAgICBTeXN0ZW0kMjEuYXJyYXljb3B5KGNvZF9pbmZvLnhyLCAwLCBpeHdvcmssIDAsIDU3Nik7XG4gICAgICAgICAgICBmb3IgKHZhciBzZmIgPSBjb2RfaW5mby5zZmJfc21pbjsgc2ZiIDwgRW5jb2Rlcl8xLlNCTUFYX3M7IHNmYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ2ZjLnNjYWxlZmFjX2JhbmQuc1tzZmJdO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBnZmMuc2NhbGVmYWNfYmFuZC5zW3NmYiArIDFdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHdpbmRvdyA9IDA7IHdpbmRvdyA8IDM7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSBzdGFydDsgbCA8IGVuZDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RfaW5mby54cltpeCsrXSA9IGl4d29ya1szICogbCArIHdpbmRvd107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBqID0gY29kX2luZm8uc2ZiX2xtYXg7XG4gICAgICAgICAgICBmb3IgKHZhciBzZmIgPSBjb2RfaW5mby5zZmJfc21pbjsgc2ZiIDwgRW5jb2Rlcl8xLlNCTUFYX3M7IHNmYisrKSB7XG4gICAgICAgICAgICAgICAgY29kX2luZm8ud2lkdGhbal0gPSBjb2RfaW5mby53aWR0aFtqICsgMV0gPSBjb2RfaW5mby53aWR0aFtqICsgMl0gPSBnZmMuc2NhbGVmYWNfYmFuZC5zW3NmYiArIDFdXG4gICAgICAgICAgICAgICAgICAgIC0gZ2ZjLnNjYWxlZmFjX2JhbmQuc1tzZmJdO1xuICAgICAgICAgICAgICAgIGNvZF9pbmZvLndpbmRvd1tqXSA9IDA7XG4gICAgICAgICAgICAgICAgY29kX2luZm8ud2luZG93W2ogKyAxXSA9IDE7XG4gICAgICAgICAgICAgICAgY29kX2luZm8ud2luZG93W2ogKyAyXSA9IDI7XG4gICAgICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29kX2luZm8uY291bnQxYml0cyA9IDA7XG4gICAgICAgIGNvZF9pbmZvLnNmYl9wYXJ0aXRpb25fdGFibGUgPSBxdXB2dC5ucl9vZl9zZmJfYmxvY2tbMF1bMF07XG4gICAgICAgIGNvZF9pbmZvLnNsZW5bMF0gPSAwO1xuICAgICAgICBjb2RfaW5mby5zbGVuWzFdID0gMDtcbiAgICAgICAgY29kX2luZm8uc2xlblsyXSA9IDA7XG4gICAgICAgIGNvZF9pbmZvLnNsZW5bM10gPSAwO1xuXG4gICAgICAgIGNvZF9pbmZvLm1heF9ub256ZXJvX2NvZWZmID0gNTc1O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGZyZXNoIHNjYWxlZmFjdG9ycyBhcmUgYWxsIHplcm9cbiAgICAgICAgICovXG4gICAgICAgIEFycmF5cyQyMS5maWxsKGNvZF9pbmZvLnNjYWxlZmFjLCAwKTtcblxuICAgICAgICBwc2ZiMjFfYW5hbG9nc2lsZW5jZShnZmMsIGNvZF9pbmZvKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQmluU2VhcmNoRGlyZWN0aW9uKG9yZGluYWwpIHtcbiAgICAgICAgdGhpcy5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICB9XG5cbiAgICBCaW5TZWFyY2hEaXJlY3Rpb24uQklOU0VBUkNIX05PTkUgPSBuZXcgQmluU2VhcmNoRGlyZWN0aW9uKDApO1xuICAgIEJpblNlYXJjaERpcmVjdGlvbi5CSU5TRUFSQ0hfVVAgPSBuZXcgQmluU2VhcmNoRGlyZWN0aW9uKDEpO1xuICAgIEJpblNlYXJjaERpcmVjdGlvbi5CSU5TRUFSQ0hfRE9XTiA9IG5ldyBCaW5TZWFyY2hEaXJlY3Rpb24oMik7XG5cbiAgICAvKipcbiAgICAgKiBhdXRob3IvZGF0ZT8/XG4gICAgICpcbiAgICAgKiBiaW5hcnkgc3RlcCBzaXplIHNlYXJjaCB1c2VkIGJ5IG91dGVyX2xvb3AgdG8gZ2V0IGEgcXVhbnRpemVyIHN0ZXAgc2l6ZVxuICAgICAqIHRvIHN0YXJ0IHdpdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5fc2VhcmNoX1N0ZXBTaXplKGdmYywgY29kX2luZm8sIGRlc2lyZWRfcmF0ZSwgY2gsIHhycG93KSB7XG4gICAgICAgIHZhciBuQml0cztcbiAgICAgICAgdmFyIEN1cnJlbnRTdGVwID0gZ2ZjLkN1cnJlbnRTdGVwW2NoXTtcbiAgICAgICAgdmFyIGZsYWdHb25lT3ZlciA9IGZhbHNlO1xuICAgICAgICB2YXIgc3RhcnQgPSBnZmMuT2xkVmFsdWVbY2hdO1xuICAgICAgICB2YXIgRGlyZWN0aW9uID0gQmluU2VhcmNoRGlyZWN0aW9uLkJJTlNFQVJDSF9OT05FO1xuICAgICAgICBjb2RfaW5mby5nbG9iYWxfZ2FpbiA9IHN0YXJ0O1xuICAgICAgICBkZXNpcmVkX3JhdGUgLT0gY29kX2luZm8ucGFydDJfbGVuZ3RoO1xuXG4gICAgICAgIGFzc2VydCQyMShDdXJyZW50U3RlcCAhPSAwKTtcbiAgICAgICAgZm9yICg7IDspIHtcbiAgICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgICAgbkJpdHMgPSB0ay5jb3VudF9iaXRzKGdmYywgeHJwb3csIGNvZF9pbmZvLCBudWxsKTtcblxuICAgICAgICAgICAgaWYgKEN1cnJlbnRTdGVwID09IDEgfHwgbkJpdHMgPT0gZGVzaXJlZF9yYXRlKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogbm90aGluZyB0byBhZGp1c3QgYW55bW9yZSAqL1xuXG4gICAgICAgICAgICBpZiAobkJpdHMgPiBkZXNpcmVkX3JhdGUpIHtcbiAgICAgICAgICAgICAgICAvKiBpbmNyZWFzZSBRdWFudGl6ZV9TdGVwU2l6ZSAqL1xuICAgICAgICAgICAgICAgIGlmIChEaXJlY3Rpb24gPT0gQmluU2VhcmNoRGlyZWN0aW9uLkJJTlNFQVJDSF9ET1dOKVxuICAgICAgICAgICAgICAgICAgICBmbGFnR29uZU92ZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZsYWdHb25lT3ZlcilcbiAgICAgICAgICAgICAgICAgICAgQ3VycmVudFN0ZXAgLz0gMjtcbiAgICAgICAgICAgICAgICBEaXJlY3Rpb24gPSBCaW5TZWFyY2hEaXJlY3Rpb24uQklOU0VBUkNIX1VQO1xuICAgICAgICAgICAgICAgIHN0ZXAgPSBDdXJyZW50U3RlcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogZGVjcmVhc2UgUXVhbnRpemVfU3RlcFNpemUgKi9cbiAgICAgICAgICAgICAgICBpZiAoRGlyZWN0aW9uID09IEJpblNlYXJjaERpcmVjdGlvbi5CSU5TRUFSQ0hfVVApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdHb25lT3ZlciA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ0dvbmVPdmVyKVxuICAgICAgICAgICAgICAgICAgICBDdXJyZW50U3RlcCAvPSAyO1xuICAgICAgICAgICAgICAgIERpcmVjdGlvbiA9IEJpblNlYXJjaERpcmVjdGlvbi5CSU5TRUFSQ0hfRE9XTjtcbiAgICAgICAgICAgICAgICBzdGVwID0gLUN1cnJlbnRTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kX2luZm8uZ2xvYmFsX2dhaW4gKz0gc3RlcDtcbiAgICAgICAgICAgIGlmIChjb2RfaW5mby5nbG9iYWxfZ2FpbiA8IDApIHtcbiAgICAgICAgICAgICAgICBjb2RfaW5mby5nbG9iYWxfZ2FpbiA9IDA7XG4gICAgICAgICAgICAgICAgZmxhZ0dvbmVPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RfaW5mby5nbG9iYWxfZ2FpbiA+IDI1NSkge1xuICAgICAgICAgICAgICAgIGNvZF9pbmZvLmdsb2JhbF9nYWluID0gMjU1O1xuICAgICAgICAgICAgICAgIGZsYWdHb25lT3ZlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQkMjEoY29kX2luZm8uZ2xvYmFsX2dhaW4gPj0gMCk7XG4gICAgICAgIGFzc2VydCQyMShjb2RfaW5mby5nbG9iYWxfZ2FpbiA8IDI1Nik7XG5cbiAgICAgICAgd2hpbGUgKG5CaXRzID4gZGVzaXJlZF9yYXRlICYmIGNvZF9pbmZvLmdsb2JhbF9nYWluIDwgMjU1KSB7XG4gICAgICAgICAgICBjb2RfaW5mby5nbG9iYWxfZ2FpbisrO1xuICAgICAgICAgICAgbkJpdHMgPSB0ay5jb3VudF9iaXRzKGdmYywgeHJwb3csIGNvZF9pbmZvLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBnZmMuQ3VycmVudFN0ZXBbY2hdID0gKHN0YXJ0IC0gY29kX2luZm8uZ2xvYmFsX2dhaW4gPj0gNCkgPyA0IDogMjtcbiAgICAgICAgZ2ZjLk9sZFZhbHVlW2NoXSA9IGNvZF9pbmZvLmdsb2JhbF9nYWluO1xuICAgICAgICBjb2RfaW5mby5wYXJ0Ml8zX2xlbmd0aCA9IG5CaXRzO1xuICAgICAgICByZXR1cm4gbkJpdHM7XG4gICAgfVxuXG4gICAgdGhpcy50cmFuY2F0ZV9zbWFsbHNwZWN0cnVtcyA9IGZ1bmN0aW9uIChnZmMsIGdpLCBsM194bWluLCB3b3JrKSB7XG4gICAgICAgIHZhciBkaXN0b3J0ID0gbmV3X2Zsb2F0JDIxKEwzU2lkZV8xLlNGQk1BWCk7XG5cbiAgICAgICAgaWYgKCgwID09IChnZmMuc3Vic3RlcF9zaGFwaW5nICYgNCkgJiYgZ2kuYmxvY2tfdHlwZSA9PSBFbmNvZGVyXzEuU0hPUlRfVFlQRSlcbiAgICAgICAgICAgIHx8IChnZmMuc3Vic3RlcF9zaGFwaW5nICYgMHg4MCkgIT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcXVwdnQuY2FsY19ub2lzZShnaSwgbDNfeG1pbiwgZGlzdG9ydCwgbmV3IENhbGNOb2lzZVJlc3VsdF8xKCksIG51bGwpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDU3NjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgeHIgPSAwLjA7XG4gICAgICAgICAgICBpZiAoZ2kubDNfZW5jW2pdICE9IDApXG4gICAgICAgICAgICAgICAgeHIgPSBNYXRoLmFicyhnaS54cltqXSk7XG4gICAgICAgICAgICB3b3JrW2pdID0geHI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgIHZhciBzZmIgPSA4O1xuICAgICAgICBpZiAoZ2kuYmxvY2tfdHlwZSA9PSBFbmNvZGVyXzEuU0hPUlRfVFlQRSlcbiAgICAgICAgICAgIHNmYiA9IDY7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBhbGxvd2VkTm9pc2UsIHRyYW5jYXRlVGhyZXNob2xkO1xuICAgICAgICAgICAgdmFyIG5zYW1lLCBzdGFydDtcblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gZ2kud2lkdGhbc2ZiXTtcbiAgICAgICAgICAgIGogKz0gd2lkdGg7XG4gICAgICAgICAgICBpZiAoZGlzdG9ydFtzZmJdID49IDEuMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgQXJyYXlzJDIxLnNvcnQod29yaywgaiAtIHdpZHRoLCB3aWR0aCk7XG4gICAgICAgICAgICBpZiAoQml0U3RyZWFtLkVRKHdvcmtbaiAtIDFdLCAwLjApKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLyogYWxsIHplcm8gc2ZiICovXG5cbiAgICAgICAgICAgIGFsbG93ZWROb2lzZSA9ICgxLjAgLSBkaXN0b3J0W3NmYl0pICogbDNfeG1pbltzZmJdO1xuICAgICAgICAgICAgdHJhbmNhdGVUaHJlc2hvbGQgPSAwLjA7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIG5vaXNlO1xuICAgICAgICAgICAgICAgIGZvciAobnNhbWUgPSAxOyBzdGFydCArIG5zYW1lIDwgd2lkdGg7IG5zYW1lKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChCaXRTdHJlYW0uTkVRKHdvcmtbc3RhcnQgKyBqIC0gd2lkdGhdLCB3b3JrW3N0YXJ0ICsgalxuICAgICAgICAgICAgICAgICAgICAgICAgKyBuc2FtZSAtIHdpZHRoXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIG5vaXNlID0gd29ya1tzdGFydCArIGogLSB3aWR0aF0gKiB3b3JrW3N0YXJ0ICsgaiAtIHdpZHRoXVxuICAgICAgICAgICAgICAgICAgICAqIG5zYW1lO1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd2VkTm9pc2UgPCBub2lzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgIT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5jYXRlVGhyZXNob2xkID0gd29ya1tzdGFydCArIGogLSB3aWR0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWxsb3dlZE5vaXNlIC09IG5vaXNlO1xuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IG5zYW1lO1xuICAgICAgICAgICAgfSB3aGlsZSAoc3RhcnQgPCB3aWR0aCk7XG4gICAgICAgICAgICBpZiAoQml0U3RyZWFtLkVRKHRyYW5jYXRlVGhyZXNob2xkLCAwLjApKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGdpLnhyW2ogLSB3aWR0aF0pIDw9IHRyYW5jYXRlVGhyZXNob2xkKVxuICAgICAgICAgICAgICAgICAgICBnaS5sM19lbmNbaiAtIHdpZHRoXSA9IDA7XG4gICAgICAgICAgICB9IHdoaWxlICgtLXdpZHRoID4gMCk7XG4gICAgICAgIH0gd2hpbGUgKCsrc2ZiIDwgZ2kucHN5bWF4KTtcblxuICAgICAgICBnaS5wYXJ0Ml8zX2xlbmd0aCA9IHRrLm5vcXVhbnRfY291bnRfYml0cyhnZmMsIGdpLCBudWxsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXV0aG9yL2RhdGU/P1xuICAgICAqXG4gICAgICogRnVuY3Rpb246IFJldHVybnMgemVybyBpZiB0aGVyZSBpcyBhIHNjYWxlZmFjIHdoaWNoIGhhcyBub3QgYmVlblxuICAgICAqIGFtcGxpZmllZC4gT3RoZXJ3aXNlIGl0IHJldHVybnMgb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvb3BfYnJlYWsoY29kX2luZm8pIHtcbiAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgY29kX2luZm8uc2ZibWF4OyBzZmIrKylcbiAgICAgICAgICAgIGlmIChjb2RfaW5mby5zY2FsZWZhY1tzZmJdXG4gICAgICAgICAgICAgICAgKyBjb2RfaW5mby5zdWJibG9ja19nYWluW2NvZF9pbmZvLndpbmRvd1tzZmJdXSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBtdCA1Lzk5OiBGdW5jdGlvbjogSW1wcm92ZWQgY2FsY19ub2lzZSBmb3IgYSBzaW5nbGUgY2hhbm5lbCAqL1xuXG4gICAgZnVuY3Rpb24gcGVuYWx0aWVzKG5vaXNlKSB7XG4gICAgICAgIHJldHVybiBVdGlsJDIxLkZBU1RfTE9HMTAoKDAuMzY4ICsgMC42MzIgKiBub2lzZSAqIG5vaXNlICogbm9pc2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhdXRob3IvZGF0ZT8/XG4gICAgICpcbiAgICAgKiBzZXZlcmFsIGRpZmZlcmVudCBjb2RlcyB0byBkZWNpZGUgd2hpY2ggcXVhbnRpemF0aW9uIGlzIGJldHRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldF9rbGVtbV9ub2lzZShkaXN0b3J0LCBnaSkge1xuICAgICAgICB2YXIga2xlbW1fbm9pc2UgPSAxRS0zNztcbiAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgZ2kucHN5bWF4OyBzZmIrKylcbiAgICAgICAgICAgIGtsZW1tX25vaXNlICs9IHBlbmFsdGllcyhkaXN0b3J0W3NmYl0pO1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCgxZS0yMCwga2xlbW1fbm9pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHF1YW50X2NvbXBhcmUocXVhbnRfY29tcCwgYmVzdCwgY2FsYywgZ2ksIGRpc3RvcnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5vaXNlIGlzIGdpdmVuIGluIGRlY2liZWxzIChkQikgcmVsYXRpdmUgdG8gbWFza2luZyB0aGVzaG9sZHMuPEJSPlxuICAgICAgICAgKlxuICAgICAgICAgKiBvdmVyX25vaXNlOiA/Pz8gKHRoZSBwcmV2aW91cyBjb21tZW50IGlzIGZ1bGx5IHdyb25nKTxCUj5cbiAgICAgICAgICogdG90X25vaXNlOiA/Pz8gKHRoZSBwcmV2aW91cyBjb21tZW50IGlzIGZ1bGx5IHdyb25nKTxCUj5cbiAgICAgICAgICogbWF4X25vaXNlOiBtYXggcXVhbnRpemF0aW9uIG5vaXNlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYmV0dGVyO1xuXG4gICAgICAgIHN3aXRjaCAocXVhbnRfY29tcCkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVzdC5vdmVyX2NvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvKiB0aGVyZSBhcmUgZGlzdG9ydGVkIHNmYiAqL1xuICAgICAgICAgICAgICAgICAgICBiZXR0ZXIgPSBjYWxjLm92ZXJfU1NEIDw9IGJlc3Qub3Zlcl9TU0Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxjLm92ZXJfU1NEID09IGJlc3Qub3Zlcl9TU0QpXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXR0ZXIgPSBjYWxjLmJpdHMgPCBiZXN0LmJpdHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogbm8gZGlzdG9ydGVkIHNmYiAqL1xuICAgICAgICAgICAgICAgICAgICBiZXR0ZXIgPSAoKGNhbGMubWF4X25vaXNlIDwgMCkgJiYgKChjYWxjLm1heF9ub2lzZSAqIDEwICsgY2FsYy5iaXRzKSA8PSAoYmVzdC5tYXhfbm9pc2UgKiAxMCArIGJlc3QuYml0cykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBiZXR0ZXIgPSBjYWxjLm92ZXJfY291bnQgPCBiZXN0Lm92ZXJfY291bnRcbiAgICAgICAgICAgICAgICAgICAgfHwgKGNhbGMub3Zlcl9jb3VudCA9PSBiZXN0Lm92ZXJfY291bnQgJiYgY2FsYy5vdmVyX25vaXNlIDwgYmVzdC5vdmVyX25vaXNlKVxuICAgICAgICAgICAgICAgICAgICB8fCAoY2FsYy5vdmVyX2NvdW50ID09IGJlc3Qub3Zlcl9jb3VudFxuICAgICAgICAgICAgICAgICAgICAmJiBCaXRTdHJlYW0uRVEoY2FsYy5vdmVyX25vaXNlLCBiZXN0Lm92ZXJfbm9pc2UpICYmIGNhbGMudG90X25vaXNlIDwgYmVzdC50b3Rfbm9pc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgY2FsYy5tYXhfbm9pc2UgPSBnZXRfa2xlbW1fbm9pc2UoZGlzdG9ydCwgZ2kpO1xuICAgICAgICAgICAgLy8kRkFMTC1USFJPVUdIJFxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJldHRlciA9IGNhbGMubWF4X25vaXNlIDwgYmVzdC5tYXhfbm9pc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgYmV0dGVyID0gY2FsYy50b3Rfbm9pc2UgPCBiZXN0LnRvdF9ub2lzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBiZXR0ZXIgPSAoY2FsYy50b3Rfbm9pc2UgPCBiZXN0LnRvdF9ub2lzZSlcbiAgICAgICAgICAgICAgICAgICAgJiYgKGNhbGMubWF4X25vaXNlIDwgYmVzdC5tYXhfbm9pc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGJldHRlciA9IChjYWxjLm1heF9ub2lzZSA8PSAwLjAgJiYgYmVzdC5tYXhfbm9pc2UgPiAwLjIpXG4gICAgICAgICAgICAgICAgICAgIHx8IChjYWxjLm1heF9ub2lzZSA8PSAwLjAgJiYgYmVzdC5tYXhfbm9pc2UgPCAwLjBcbiAgICAgICAgICAgICAgICAgICAgJiYgYmVzdC5tYXhfbm9pc2UgPiBjYWxjLm1heF9ub2lzZSAtIDAuMiAmJiBjYWxjLnRvdF9ub2lzZSA8IGJlc3QudG90X25vaXNlKVxuICAgICAgICAgICAgICAgICAgICB8fCAoY2FsYy5tYXhfbm9pc2UgPD0gMC4wICYmIGJlc3QubWF4X25vaXNlID4gMC4wXG4gICAgICAgICAgICAgICAgICAgICYmIGJlc3QubWF4X25vaXNlID4gY2FsYy5tYXhfbm9pc2UgLSAwLjIgJiYgY2FsYy50b3Rfbm9pc2UgPCBiZXN0LnRvdF9ub2lzZVxuICAgICAgICAgICAgICAgICAgICArIGJlc3Qub3Zlcl9ub2lzZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgKGNhbGMubWF4X25vaXNlID4gMC4wICYmIGJlc3QubWF4X25vaXNlID4gLTAuMDVcbiAgICAgICAgICAgICAgICAgICAgJiYgYmVzdC5tYXhfbm9pc2UgPiBjYWxjLm1heF9ub2lzZSAtIDAuMSAmJiBjYWxjLnRvdF9ub2lzZVxuICAgICAgICAgICAgICAgICAgICArIGNhbGMub3Zlcl9ub2lzZSA8IGJlc3QudG90X25vaXNlXG4gICAgICAgICAgICAgICAgICAgICsgYmVzdC5vdmVyX25vaXNlKVxuICAgICAgICAgICAgICAgICAgICB8fCAoY2FsYy5tYXhfbm9pc2UgPiAwLjAgJiYgYmVzdC5tYXhfbm9pc2UgPiAtMC4xXG4gICAgICAgICAgICAgICAgICAgICYmIGJlc3QubWF4X25vaXNlID4gY2FsYy5tYXhfbm9pc2UgLSAwLjE1ICYmIGNhbGMudG90X25vaXNlXG4gICAgICAgICAgICAgICAgICAgICsgY2FsYy5vdmVyX25vaXNlICsgY2FsYy5vdmVyX25vaXNlIDwgYmVzdC50b3Rfbm9pc2VcbiAgICAgICAgICAgICAgICAgICAgKyBiZXN0Lm92ZXJfbm9pc2UgKyBiZXN0Lm92ZXJfbm9pc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGJldHRlciA9IGNhbGMub3Zlcl9ub2lzZSA8IGJlc3Qub3Zlcl9ub2lzZVxuICAgICAgICAgICAgICAgICAgICB8fCAoQml0U3RyZWFtLkVRKGNhbGMub3Zlcl9ub2lzZSwgYmVzdC5vdmVyX25vaXNlKSAmJiBjYWxjLnRvdF9ub2lzZSA8IGJlc3QudG90X25vaXNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBiZXR0ZXIgPSBjYWxjLm92ZXJfbm9pc2UgPCBiZXN0Lm92ZXJfbm9pc2VcbiAgICAgICAgICAgICAgICAgICAgfHwgKEJpdFN0cmVhbS5FUShjYWxjLm92ZXJfbm9pc2UsIGJlc3Qub3Zlcl9ub2lzZSkgJiYgKGNhbGMubWF4X25vaXNlIDwgYmVzdC5tYXhfbm9pc2UgfHwgKEJpdFN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgLkVRKGNhbGMubWF4X25vaXNlLCBiZXN0Lm1heF9ub2lzZSkgJiYgY2FsYy50b3Rfbm9pc2UgPD0gYmVzdC50b3Rfbm9pc2UpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgYmV0dGVyID0gY2FsYy5vdmVyX2NvdW50IDwgYmVzdC5vdmVyX2NvdW50XG4gICAgICAgICAgICAgICAgICAgIHx8IGNhbGMub3Zlcl9ub2lzZSA8IGJlc3Qub3Zlcl9ub2lzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiZXN0Lm92ZXJfY291bnQgPT0gMCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIElmIG5vIGRpc3RvcnRlZCBiYW5kcywgb25seSB1c2UgdGhpcyBxdWFudGl6YXRpb24gaWYgaXQgaXNcbiAgICAgICAgICAgICAqIGJldHRlciwgYW5kIGlmIGl0IHVzZXMgbGVzcyBiaXRzLiBVbmZvcnR1bmF0ZWx5LCBwYXJ0Ml8zX2xlbmd0aFxuICAgICAgICAgICAgICogaXMgc29tZXRpbWVzIGEgcG9vciBlc3RpbWF0b3Igb2YgdGhlIGZpbmFsIHNpemUgYXQgbG93IGJpdHJhdGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBiZXR0ZXIgPSBiZXR0ZXIgJiYgY2FsYy5iaXRzIDwgYmVzdC5iaXRzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJldHRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhdXRob3IvZGF0ZT8/XG4gICAgICpcbiAgICAgKiA8UFJFPlxuICAgICAqICBBbXBsaWZ5IHRoZSBzY2FsZWZhY3RvciBiYW5kcyB0aGF0IHZpb2xhdGUgdGhlIG1hc2tpbmcgdGhyZXNob2xkLlxuICAgICAqICBTZWUgSVNPIDExMTcyLTMgU2VjdGlvbiBDLjEuNS40LjMuNVxuICAgICAqXG4gICAgICogIGRpc3RvcnRbXSA9IG5vaXNlL21hc2tpbmdcbiAgICAgKiAgZGlzdG9ydFtdID4gMSAgID09PiBub2lzZSBpcyBub3QgbWFza2VkXG4gICAgICogIGRpc3RvcnRbXSA8IDEgICA9PT4gbm9pc2UgaXMgbWFza2VkXG4gICAgICogIG1heF9kaXN0ID0gbWF4aW11bSB2YWx1ZSBvZiBkaXN0b3J0W11cbiAgICAgKlxuICAgICAqICBUaHJlZSBhbGdvcml0aG1zOlxuICAgICAqICBub2lzZV9zaGFwaW5nX2FtcFxuICAgICAqICAgICAgICAwICAgICAgICAgICAgIEFtcGxpZnkgYWxsIGJhbmRzIHdpdGggZGlzdG9ydFtdPjEuXG4gICAgICpcbiAgICAgKiAgICAgICAgMSAgICAgICAgICAgICBBbXBsaWZ5IGFsbCBiYW5kcyB3aXRoIGRpc3RvcnRbXSA+PSBtYXhfZGlzdF4oLjUpO1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgKCA1MCUgaW4gdGhlIGRiIHNjYWxlKVxuICAgICAqXG4gICAgICogICAgICAgIDIgICAgICAgICAgICAgQW1wbGlmeSBmaXJzdCBiYW5kIHdpdGggZGlzdG9ydFtdID49IG1heF9kaXN0O1xuICAgICAqXG4gICAgICpcbiAgICAgKiAgRm9yIGFsZ29yaXRobXMgMCBhbmQgMSwgaWYgbWF4X2Rpc3QgPCAxLCB0aGVuIGFtcGxpZnkgYWxsIGJhbmRzXG4gICAgICogIHdpdGggZGlzdG9ydFtdID49IC45NSptYXhfZGlzdC4gIFRoaXMgaXMgdG8gbWFrZSBzdXJlIHdlIGFsd2F5c1xuICAgICAqICBhbXBsaWZ5IGF0IGxlYXN0IG9uZSBiYW5kLlxuICAgICAqIDwvUFJFPlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFtcF9zY2FsZWZhY19iYW5kcyhnZnAsIGNvZF9pbmZvLCBkaXN0b3J0LCB4cnBvdywgYlJlZmluZSkge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuICAgICAgICB2YXIgaWZxc3RlcDM0O1xuXG4gICAgICAgIGlmIChjb2RfaW5mby5zY2FsZWZhY19zY2FsZSA9PSAwKSB7XG4gICAgICAgICAgICBpZnFzdGVwMzQgPSAxLjI5NjgzOTU1NDY1MTAwOTY0MDU1O1xuICAgICAgICAgICAgLyogMioqKC43NSouNSkgKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmcXN0ZXAzNCA9IDEuNjgxNzkyODMwNTA3NDI5MjI2MTI7XG4gICAgICAgICAgICAvKiAyKiooLjc1KjEpICovXG4gICAgICAgIH1cblxuICAgICAgICAvKiBjb21wdXRlIG1heGltdW0gdmFsdWUgb2YgZGlzdG9ydFtdICovXG4gICAgICAgIHZhciB0cmlnZ2VyID0gMDtcbiAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgY29kX2luZm8uc2ZibWF4OyBzZmIrKykge1xuICAgICAgICAgICAgaWYgKHRyaWdnZXIgPCBkaXN0b3J0W3NmYl0pXG4gICAgICAgICAgICAgICAgdHJpZ2dlciA9IGRpc3RvcnRbc2ZiXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2lzZV9zaGFwaW5nX2FtcCA9IGdmYy5ub2lzZV9zaGFwaW5nX2FtcDtcbiAgICAgICAgaWYgKG5vaXNlX3NoYXBpbmdfYW1wID09IDMpIHtcbiAgICAgICAgICAgIGlmIChiUmVmaW5lKVxuICAgICAgICAgICAgICAgIG5vaXNlX3NoYXBpbmdfYW1wID0gMjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2lzZV9zaGFwaW5nX2FtcCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChub2lzZV9zaGFwaW5nX2FtcCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIC8qIGFtcGxpZnkgZXhhY3RseSAxIGJhbmQgKi9cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8qIGFtcGxpZnkgYmFuZHMgd2l0aGluIDUwJSBvZiBtYXggKG9uIGRiIHNjYWxlKSAqL1xuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyID4gMS4wKVxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyID0gTWF0aC5wb3codHJpZ2dlciwgLjUpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlciAqPSAuOTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLyogSVNPIGFsZ29yaXRobS4gYW1wbGlmeSBhbGwgYmFuZHMgd2l0aCBkaXN0b3J0PjEgKi9cbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlciA+IDEuMClcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlciA9IDEuMDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIgKj0gLjk1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICBmb3IgKHZhciBzZmIgPSAwOyBzZmIgPCBjb2RfaW5mby5zZmJtYXg7IHNmYisrKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBjb2RfaW5mby53aWR0aFtzZmJdO1xuICAgICAgICAgICAgdmFyIGw7XG4gICAgICAgICAgICBqICs9IHdpZHRoO1xuICAgICAgICAgICAgaWYgKGRpc3RvcnRbc2ZiXSA8IHRyaWdnZXIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmICgoZ2ZjLnN1YnN0ZXBfc2hhcGluZyAmIDIpICE9IDApIHtcbiAgICAgICAgICAgICAgICBnZmMucHNldWRvaGFsZltzZmJdID0gKDAgPT0gZ2ZjLnBzZXVkb2hhbGZbc2ZiXSkgPyAxIDogMDtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PSBnZmMucHNldWRvaGFsZltzZmJdICYmIGdmYy5ub2lzZV9zaGFwaW5nX2FtcCA9PSAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RfaW5mby5zY2FsZWZhY1tzZmJdKys7XG4gICAgICAgICAgICBmb3IgKGwgPSAtd2lkdGg7IGwgPCAwOyBsKyspIHtcbiAgICAgICAgICAgICAgICB4cnBvd1tqICsgbF0gKj0gaWZxc3RlcDM0O1xuICAgICAgICAgICAgICAgIGlmICh4cnBvd1tqICsgbF0gPiBjb2RfaW5mby54cnBvd19tYXgpXG4gICAgICAgICAgICAgICAgICAgIGNvZF9pbmZvLnhycG93X21heCA9IHhycG93W2ogKyBsXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdmYy5ub2lzZV9zaGFwaW5nX2FtcCA9PSAyKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRha2VoaXJvIFRvbWluYWdhIDIwMDAteHgteHhcbiAgICAgKlxuICAgICAqIHR1cm5zIG9uIHNjYWxlZmFjIHNjYWxlIGFuZCBhZGp1c3RzIHNjYWxlZmFjdG9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY19zY2FsZWZhY19zY2FsZShjb2RfaW5mbywgeHJwb3cpIHtcbiAgICAgICAgdmFyIGlmcXN0ZXAzNCA9IDEuMjk2ODM5NTU0NjUxMDA5NjQwNTU7XG5cbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICBmb3IgKHZhciBzZmIgPSAwOyBzZmIgPCBjb2RfaW5mby5zZmJtYXg7IHNmYisrKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBjb2RfaW5mby53aWR0aFtzZmJdO1xuICAgICAgICAgICAgdmFyIHMgPSBjb2RfaW5mby5zY2FsZWZhY1tzZmJdO1xuICAgICAgICAgICAgaWYgKGNvZF9pbmZvLnByZWZsYWcgIT0gMClcbiAgICAgICAgICAgICAgICBzICs9IHF1cHZ0LnByZXRhYltzZmJdO1xuICAgICAgICAgICAgaiArPSB3aWR0aDtcbiAgICAgICAgICAgIGlmICgocyAmIDEpICE9IDApIHtcbiAgICAgICAgICAgICAgICBzKys7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IC13aWR0aDsgbCA8IDA7IGwrKykge1xuICAgICAgICAgICAgICAgICAgICB4cnBvd1tqICsgbF0gKj0gaWZxc3RlcDM0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoeHJwb3dbaiArIGxdID4gY29kX2luZm8ueHJwb3dfbWF4KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29kX2luZm8ueHJwb3dfbWF4ID0geHJwb3dbaiArIGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZF9pbmZvLnNjYWxlZmFjW3NmYl0gPSBzID4+IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29kX2luZm8ucHJlZmxhZyA9IDA7XG4gICAgICAgIGNvZF9pbmZvLnNjYWxlZmFjX3NjYWxlID0gMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlaGlybyBUb21pbmFnYSAyMDAwLXh4LXh4XG4gICAgICpcbiAgICAgKiBpbmNyZWFzZXMgdGhlIHN1YmJsb2NrIGdhaW4gYW5kIGFkanVzdHMgc2NhbGVmYWN0b3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jX3N1YmJsb2NrX2dhaW4oZ2ZjLCBjb2RfaW5mbywgeHJwb3cpIHtcbiAgICAgICAgdmFyIHNmYjtcbiAgICAgICAgdmFyIHNjYWxlZmFjID0gY29kX2luZm8uc2NhbGVmYWM7XG5cbiAgICAgICAgLyogc3ViYmxvY19nYWluIGNhbid0IGRvIGFueXRoaW5nIGluIHRoZSBsb25nIGJsb2NrIHJlZ2lvbiAqL1xuICAgICAgICBmb3IgKHNmYiA9IDA7IHNmYiA8IGNvZF9pbmZvLnNmYl9sbWF4OyBzZmIrKykge1xuICAgICAgICAgICAgaWYgKHNjYWxlZmFjW3NmYl0gPj0gMTYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciB3aW5kb3cgPSAwOyB3aW5kb3cgPCAzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgdmFyIHMxID0gMDtcbiAgICAgICAgICAgIHZhciBzMiA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoc2ZiID0gY29kX2luZm8uc2ZiX2xtYXggKyB3aW5kb3c7IHNmYiA8IGNvZF9pbmZvLnNmYmRpdmlkZTsgc2ZiICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoczEgPCBzY2FsZWZhY1tzZmJdKVxuICAgICAgICAgICAgICAgICAgICBzMSA9IHNjYWxlZmFjW3NmYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgc2ZiIDwgY29kX2luZm8uc2ZibWF4OyBzZmIgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmIChzMiA8IHNjYWxlZmFjW3NmYl0pXG4gICAgICAgICAgICAgICAgICAgIHMyID0gc2NhbGVmYWNbc2ZiXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHMxIDwgMTYgJiYgczIgPCA4KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoY29kX2luZm8uc3ViYmxvY2tfZ2Fpblt3aW5kb3ddID49IDcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBldmVuIHRob3VnaCB0aGVyZSBpcyBubyBzY2FsZWZhY3RvciBmb3Igc2ZiMTIgc3ViYmxvY2sgZ2FpblxuICAgICAgICAgICAgICogYWZmZWN0cyB1cHBlciBmcmVxdWVuY2llcyB0b28sIHRoYXQncyB3aHkgd2UgaGF2ZSB0byBnbyB1cCB0b1xuICAgICAgICAgICAgICogU0JNQVhfc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb2RfaW5mby5zdWJibG9ja19nYWluW3dpbmRvd10rKztcbiAgICAgICAgICAgIHZhciBqID0gZ2ZjLnNjYWxlZmFjX2JhbmQubFtjb2RfaW5mby5zZmJfbG1heF07XG4gICAgICAgICAgICBmb3IgKHNmYiA9IGNvZF9pbmZvLnNmYl9sbWF4ICsgd2luZG93OyBzZmIgPCBjb2RfaW5mby5zZmJtYXg7IHNmYiArPSAzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFtcDtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBjb2RfaW5mby53aWR0aFtzZmJdO1xuICAgICAgICAgICAgICAgIHZhciBzID0gc2NhbGVmYWNbc2ZiXTtcbiAgICAgICAgICAgICAgICBhc3NlcnQkMjEocyA+PSAwKTtcbiAgICAgICAgICAgICAgICBzID0gcyAtICg0ID4+IGNvZF9pbmZvLnNjYWxlZmFjX3NjYWxlKTtcbiAgICAgICAgICAgICAgICBpZiAocyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlZmFjW3NmYl0gPSBzO1xuICAgICAgICAgICAgICAgICAgICBqICs9IHdpZHRoICogMztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2NhbGVmYWNbc2ZiXSA9IDA7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2FpbiA9IDIxMCArIChzIDw8IChjb2RfaW5mby5zY2FsZWZhY19zY2FsZSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYW1wID0gcXVwdnQuSVBPVzIwKGdhaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqICs9IHdpZHRoICogKHdpbmRvdyArIDEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAtd2lkdGg7IGwgPCAwOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeHJwb3dbaiArIGxdICo9IGFtcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhycG93W2ogKyBsXSA+IGNvZF9pbmZvLnhycG93X21heClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZF9pbmZvLnhycG93X21heCA9IHhycG93W2ogKyBsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaiArPSB3aWR0aCAqICgzIC0gd2luZG93IC0gMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgYW1wID0gcXVwdnQuSVBPVzIwKDIwMik7XG4gICAgICAgICAgICAgICAgaiArPSBjb2RfaW5mby53aWR0aFtzZmJdICogKHdpbmRvdyArIDEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAtY29kX2luZm8ud2lkdGhbc2ZiXTsgbCA8IDA7IGwrKykge1xuICAgICAgICAgICAgICAgICAgICB4cnBvd1tqICsgbF0gKj0gYW1wO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeHJwb3dbaiArIGxdID4gY29kX2luZm8ueHJwb3dfbWF4KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29kX2luZm8ueHJwb3dfbWF4ID0geHJwb3dbaiArIGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiAgVGFrZWhpcm8gVG9taW5hZ2EgL2RhdGU/P1xuICAgICAqICBSb2JlcnQgSGVnZW1hbm4gMjAwMC0wOS0wNjogbWFkZSBhIGZ1bmN0aW9uIG9mIGl0XG4gICAgICpcbiAgICAgKiAgYW1wbGlmaWVzIHNjYWxlZmFjdG9yIGJhbmRzLFxuICAgICAqICAgLSBpZiBhbGwgYXJlIGFscmVhZHkgYW1wbGlmaWVkIHJldHVybnMgMFxuICAgICAqICAgLSBpZiBzb21lIGJhbmRzIGFyZSBhbXBsaWZpZWQgdG9vIG11Y2g6XG4gICAgICogICAgICAqIHRyeSB0byBpbmNyZWFzZSBzY2FsZWZhY19zY2FsZVxuICAgICAqICAgICAgKiBpZiBhbHJlYWR5IHNjYWxlZmFjX3NjYWxlIHdhcyBzZXRcbiAgICAgKiAgICAgICAgICB0cnkgb24gc2hvcnQgYmxvY2tzIHRvIGluY3JlYXNlIHN1YmJsb2NrIGdhaW5cbiAgICAgKiA8L1BSRT5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYWxhbmNlX25vaXNlKGdmcCwgY29kX2luZm8sIGRpc3RvcnQsIHhycG93LCBiUmVmaW5lKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgYW1wX3NjYWxlZmFjX2JhbmRzKGdmcCwgY29kX2luZm8sIGRpc3RvcnQsIHhycG93LCBiUmVmaW5lKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBjaGVjayB0byBtYWtlIHN1cmUgd2UgaGF2ZSBub3QgYW1wbGlmaWVkIHRvbyBtdWNoIGxvb3BfYnJlYWsgcmV0dXJuc1xuICAgICAgICAgKiAwIGlmIHRoZXJlIGlzIGFuIHVuYW1wbGlmaWVkIHNjYWxlZmFjIHNjYWxlX2JpdGNvdW50IHJldHVybnMgMCBpZiBub1xuICAgICAgICAgKiBzY2FsZWZhY3RvcnMgYXJlIHRvbyBsYXJnZVxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgc3RhdHVzID0gbG9vcF9icmVhayhjb2RfaW5mbyk7XG5cbiAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLyogYWxsIGJhbmRzIGFtcGxpZmllZCAqL1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIG5vdCBhbGwgc2NhbGVmYWN0b3JzIGhhdmUgYmVlbiBhbXBsaWZpZWQuIHNvIHRoZXNlIHNjYWxlZmFjcyBhcmVcbiAgICAgICAgICogcG9zc2libHkgdmFsaWQuIGVuY29kZSB0aGVtOlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGdmYy5tb2RlX2dyID09IDIpXG4gICAgICAgICAgICBzdGF0dXMgPSB0ay5zY2FsZV9iaXRjb3VudChjb2RfaW5mbyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0YXR1cyA9IHRrLnNjYWxlX2JpdGNvdW50X2xzZihnZmMsIGNvZF9pbmZvKTtcblxuICAgICAgICBpZiAoIXN0YXR1cylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvKiBhbXBsaWZpZWQgc29tZSBiYW5kcyBub3QgZXhjZWVkaW5nIGxpbWl0cyAqL1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHNvbWUgc2NhbGVmYWN0b3JzIGFyZSB0b28gbGFyZ2UuIGxldHMgdHJ5IHNldHRpbmcgc2NhbGVmYWNfc2NhbGU9MVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGdmYy5ub2lzZV9zaGFwaW5nID4gMSkge1xuICAgICAgICAgICAgQXJyYXlzJDIxLmZpbGwoZ2ZjLnBzZXVkb2hhbGYsIDApO1xuICAgICAgICAgICAgaWYgKDAgPT0gY29kX2luZm8uc2NhbGVmYWNfc2NhbGUpIHtcbiAgICAgICAgICAgICAgICBpbmNfc2NhbGVmYWNfc2NhbGUoY29kX2luZm8sIHhycG93KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZF9pbmZvLmJsb2NrX3R5cGUgPT0gRW5jb2Rlcl8xLlNIT1JUX1RZUEVcbiAgICAgICAgICAgICAgICAgICAgJiYgZ2ZjLnN1YmJsb2NrX2dhaW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IChpbmNfc3ViYmxvY2tfZ2FpbihnZmMsIGNvZF9pbmZvLCB4cnBvdykgfHwgbG9vcF9icmVhayhjb2RfaW5mbykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhdHVzKSB7XG4gICAgICAgICAgICBpZiAoZ2ZjLm1vZGVfZ3IgPT0gMilcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSB0ay5zY2FsZV9iaXRjb3VudChjb2RfaW5mbyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gdGsuc2NhbGVfYml0Y291bnRfbHNmKGdmYywgY29kX2luZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhc3RhdHVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxQUkU+XG4gICAgICogIEZ1bmN0aW9uOiBUaGUgb3V0ZXIgaXRlcmF0aW9uIGxvb3AgY29udHJvbHMgdGhlIG1hc2tpbmcgY29uZGl0aW9uc1xuICAgICAqICBvZiBhbGwgc2NhbGVmYWN0b3JiYW5kcy4gSXQgY29tcHV0ZXMgdGhlIGJlc3Qgc2NhbGVmYWMgYW5kXG4gICAgICogIGdsb2JhbCBnYWluLiBUaGlzIG1vZHVsZSBjYWxscyB0aGUgaW5uZXIgaXRlcmF0aW9uIGxvb3BcbiAgICAgKlxuICAgICAqICBtdCA1Lzk5IGNvbXBsZXRlbHkgcmV3cml0dGVuIHRvIGFsbG93IGZvciBiaXQgcmVzZXJ2b2lyIGNvbnRyb2wsXG4gICAgICogIG1pZC9zaWRlIGNoYW5uZWxzIHdpdGggTC9SIG9yIG1pZC9zaWRlIG1hc2tpbmcgdGhyZXNob2xkcyxcbiAgICAgKiAgYW5kIGNob29zZXMgYmVzdCBxdWFudGl6YXRpb24gaW5zdGVhZCBvZiBsYXN0IHF1YW50aXphdGlvbiB3aGVuXG4gICAgICogIG5vIGRpc3RvcnRpb24gZnJlZSBxdWFudGl6YXRpb24gY2FuIGJlIGZvdW5kLlxuICAgICAqXG4gICAgICogIGFkZGVkIFZCUiBzdXBwb3J0IG10IDUvOTlcbiAgICAgKlxuICAgICAqICBzb21lIGNvZGUgc2h1ZmZsZSByaCA5LzAwXG4gICAgICogPC9QUkU+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbDNfeG1pblxuICAgICAqICAgICAgICAgICAgYWxsb3dlZCBkaXN0b3J0aW9uXG4gICAgICogQHBhcmFtIHhycG93XG4gICAgICogICAgICAgICAgICBjb2xvdXJlZCBtYWduaXR1ZGVzIG9mIHNwZWN0cmFsXG4gICAgICogQHBhcmFtIHRhcmdfYml0c1xuICAgICAqICAgICAgICAgICAgbWF4aW11bSBhbGxvd2VkIGJpdHNcbiAgICAgKi9cbiAgICB0aGlzLm91dGVyX2xvb3AgPSBmdW5jdGlvbiAoZ2ZwLCBjb2RfaW5mbywgbDNfeG1pbiwgeHJwb3csIGNoLCB0YXJnX2JpdHMpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGNvZF9pbmZvX3cgPSBuZXcgR3JJbmZvXzEoKTtcbiAgICAgICAgdmFyIHNhdmVfeHJwb3cgPSBuZXdfZmxvYXQkMjEoNTc2KTtcbiAgICAgICAgdmFyIGRpc3RvcnQgPSBuZXdfZmxvYXQkMjEoTDNTaWRlXzEuU0ZCTUFYKTtcbiAgICAgICAgdmFyIGJlc3Rfbm9pc2VfaW5mbyA9IG5ldyBDYWxjTm9pc2VSZXN1bHRfMSgpO1xuICAgICAgICB2YXIgYmV0dGVyO1xuICAgICAgICB2YXIgcHJldl9ub2lzZSA9IG5ldyBDYWxjTm9pc2VEYXRhXzEoKTtcbiAgICAgICAgdmFyIGJlc3RfcGFydDJfM19sZW5ndGggPSA5OTk5OTk5O1xuICAgICAgICB2YXIgYkVuZE9mU2VhcmNoID0gZmFsc2U7XG4gICAgICAgIHZhciBiUmVmaW5lID0gZmFsc2U7XG4gICAgICAgIHZhciBiZXN0X2dnYWluX3Bhc3MxID0gMDtcblxuICAgICAgICBiaW5fc2VhcmNoX1N0ZXBTaXplKGdmYywgY29kX2luZm8sIHRhcmdfYml0cywgY2gsIHhycG93KTtcblxuICAgICAgICBpZiAoMCA9PSBnZmMubm9pc2Vfc2hhcGluZylcbiAgICAgICAgLyogZmFzdCBtb2RlLCBubyBub2lzZSBzaGFwaW5nLCB3ZSBhcmUgcmVhZHkgKi9cbiAgICAgICAgICAgIHJldHVybiAxMDA7XG4gICAgICAgIC8qIGRlZmF1bHQgbm9pc2VfaW5mby5vdmVyX2NvdW50ICovXG5cbiAgICAgICAgLyogY29tcHV0ZSB0aGUgZGlzdG9ydGlvbiBpbiB0aGlzIHF1YW50aXphdGlvbiAqL1xuICAgICAgICAvKiBjb2VmZmljaWVudHMgYW5kIHRocmVzaG9sZHMgYm90aCBsL3IgKG9yIGJvdGggbWlkL3NpZGUpICovXG4gICAgICAgIHF1cHZ0LmNhbGNfbm9pc2UoY29kX2luZm8sIGwzX3htaW4sIGRpc3RvcnQsIGJlc3Rfbm9pc2VfaW5mbyxcbiAgICAgICAgICAgIHByZXZfbm9pc2UpO1xuICAgICAgICBiZXN0X25vaXNlX2luZm8uYml0cyA9IGNvZF9pbmZvLnBhcnQyXzNfbGVuZ3RoO1xuXG4gICAgICAgIGNvZF9pbmZvX3cuYXNzaWduKGNvZF9pbmZvKTtcbiAgICAgICAgdmFyIGFnZSA9IDA7XG4gICAgICAgIFN5c3RlbSQyMS5hcnJheWNvcHkoeHJwb3csIDAsIHNhdmVfeHJwb3csIDAsIDU3Nik7XG5cbiAgICAgICAgd2hpbGUgKCFiRW5kT2ZTZWFyY2gpIHtcbiAgICAgICAgICAgIC8qIEJFR0lOIE1BSU4gTE9PUCAqL1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBub2lzZV9pbmZvID0gbmV3IENhbGNOb2lzZVJlc3VsdF8xKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNlYXJjaF9saW1pdDtcbiAgICAgICAgICAgICAgICB2YXIgbWF4Z2dhaW4gPSAyNTU7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFdoZW4gcXVhbnRpemF0aW9uIHdpdGggbm8gZGlzdG9ydGVkIGJhbmRzIGlzIGZvdW5kLCBhbGxvdyB1cFxuICAgICAgICAgICAgICAgICAqIHRvIFggbmV3IHVuc3VjY2VzZnVsIHRyaWVzIGluIHNlcmlhbC4gVGhpcyBnaXZlcyB1cyBtb3JlXG4gICAgICAgICAgICAgICAgICogcG9zc2liaWxpdGllcyBmb3IgZGlmZmVyZW50IHF1YW50X2NvbXBhcmUgbW9kZXMuIE11Y2ggbW9yZVxuICAgICAgICAgICAgICAgICAqIHRoYW4gMyBtYWtlcyBub3QgYSBiaWcgZGlmZmVyZW5jZSwgaXQgaXMgb25seSBzbG93ZXIuXG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICBpZiAoKGdmYy5zdWJzdGVwX3NoYXBpbmcgJiAyKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaF9saW1pdCA9IDIwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaF9saW1pdCA9IDM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBDaGVjayBpZiB0aGUgbGFzdCBzY2FsZWZhY3RvciBiYW5kIGlzIGRpc3RvcnRlZC4gaW4gVkJSIG1vZGVcbiAgICAgICAgICAgICAgICAgKiB3ZSBjYW4ndCBnZXQgcmlkIG9mIHRoZSBkaXN0b3J0aW9uLCBzbyBxdWl0IG5vdyBhbmQgVkJSIG1vZGVcbiAgICAgICAgICAgICAgICAgKiB3aWxsIHRyeSBhZ2FpbiB3aXRoIG1vcmUgYml0cy4gKG1ha2VzIGEgMTAlIHNwZWVkIGluY3JlYXNlLFxuICAgICAgICAgICAgICAgICAqIHRoZSBmaWxlcyBJIHRlc3RlZCB3ZXJlIGJpbmFyeSBpZGVudGljYWwsIDIwMDAvMDUvMjAgUm9iZXJ0XG4gICAgICAgICAgICAgICAgICogSGVnZW1hbm4pIGRpc3RvcnRbXSA+IDEgbWVhbnMgbm9pc2UgPiBhbGxvd2VkIG5vaXNlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGdmYy5zZmIyMV9leHRyYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdG9ydFtjb2RfaW5mb193LnNmYm1heF0gPiAxLjApXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZF9pbmZvX3cuYmxvY2tfdHlwZSA9PSBFbmNvZGVyXzEuU0hPUlRfVFlQRVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGRpc3RvcnRbY29kX2luZm9fdy5zZmJtYXggKyAxXSA+IDEuMCB8fCBkaXN0b3J0W2NvZF9pbmZvX3cuc2ZibWF4ICsgMl0gPiAxLjApKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogdHJ5IGEgbmV3IHNjYWxlZmFjdG9yIGNvbmJpbmF0aW9uIG9uIGNvZF9pbmZvX3cgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWJhbGFuY2Vfbm9pc2UoZ2ZwLCBjb2RfaW5mb193LCBkaXN0b3J0LCB4cnBvdywgYlJlZmluZSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChjb2RfaW5mb193LnNjYWxlZmFjX3NjYWxlICE9IDApXG4gICAgICAgICAgICAgICAgICAgIG1heGdnYWluID0gMjU0O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBpbm5lcl9sb29wIHN0YXJ0cyB3aXRoIHRoZSBpbml0aWFsIHF1YW50aXphdGlvbiBzdGVwIGNvbXB1dGVkXG4gICAgICAgICAgICAgICAgICogYWJvdmUgYW5kIHNsb3dseSBpbmNyZWFzZXMgdW50aWwgdGhlIGJpdHMgPCBodWZmX2JpdHMuIFRodXNcbiAgICAgICAgICAgICAgICAgKiBpdCBpcyBpbXBvcnRhbnQgbm90IHRvIHN0YXJ0IHdpdGggdG9vIGxhcmdlIG9mIGFuIGluaXRhbFxuICAgICAgICAgICAgICAgICAqIHF1YW50aXphdGlvbiBzdGVwLiBUb28gc21hbGwgaXMgb2ssIGJ1dCBpbm5lcl9sb29wIHdpbGwgdGFrZVxuICAgICAgICAgICAgICAgICAqIGxvbmdlclxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBodWZmX2JpdHMgPSB0YXJnX2JpdHMgLSBjb2RfaW5mb193LnBhcnQyX2xlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoaHVmZl9iaXRzIDw9IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBpbmNyZWFzZSBxdWFudGl6ZXIgc3RlcHNpemUgdW50aWwgbmVlZGVkIGJpdHMgYXJlIGJlbG93XG4gICAgICAgICAgICAgICAgICogbWF4aW11bVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHdoaWxlICgoY29kX2luZm9fdy5wYXJ0Ml8zX2xlbmd0aCA9IHRrLmNvdW50X2JpdHMoZ2ZjLCB4cnBvdyxcbiAgICAgICAgICAgICAgICAgICAgY29kX2luZm9fdywgcHJldl9ub2lzZSkpID4gaHVmZl9iaXRzXG4gICAgICAgICAgICAgICAgJiYgY29kX2luZm9fdy5nbG9iYWxfZ2FpbiA8PSBtYXhnZ2FpbilcbiAgICAgICAgICAgICAgICAgICAgY29kX2luZm9fdy5nbG9iYWxfZ2FpbisrO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvZF9pbmZvX3cuZ2xvYmFsX2dhaW4gPiBtYXhnZ2FpbilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmVzdF9ub2lzZV9pbmZvLm92ZXJfY291bnQgPT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY29kX2luZm9fdy5wYXJ0Ml8zX2xlbmd0aCA9IHRrLmNvdW50X2JpdHMoZ2ZjLFxuICAgICAgICAgICAgICAgICAgICAgICAgeHJwb3csIGNvZF9pbmZvX3csIHByZXZfbm9pc2UpKSA+IGJlc3RfcGFydDJfM19sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgJiYgY29kX2luZm9fdy5nbG9iYWxfZ2FpbiA8PSBtYXhnZ2FpbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZF9pbmZvX3cuZ2xvYmFsX2dhaW4rKztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kX2luZm9fdy5nbG9iYWxfZ2FpbiA+IG1heGdnYWluKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogY29tcHV0ZSB0aGUgZGlzdG9ydGlvbiBpbiB0aGlzIHF1YW50aXphdGlvbiAqL1xuICAgICAgICAgICAgICAgIHF1cHZ0LmNhbGNfbm9pc2UoY29kX2luZm9fdywgbDNfeG1pbiwgZGlzdG9ydCwgbm9pc2VfaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcHJldl9ub2lzZSk7XG4gICAgICAgICAgICAgICAgbm9pc2VfaW5mby5iaXRzID0gY29kX2luZm9fdy5wYXJ0Ml8zX2xlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogY2hlY2sgaWYgdGhpcyBxdWFudGl6YXRpb24gaXMgYmV0dGVyIHRoYW4gb3VyIHNhdmVkXG4gICAgICAgICAgICAgICAgICogcXVhbnRpemF0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGNvZF9pbmZvLmJsb2NrX3R5cGUgIT0gRW5jb2Rlcl8xLlNIT1JUX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9STSwgU1RBUlQgb3IgU1RPUCB0eXBlXG4gICAgICAgICAgICAgICAgICAgIGJldHRlciA9IGdmcC5xdWFudF9jb21wO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBiZXR0ZXIgPSBnZnAucXVhbnRfY29tcF9zaG9ydDtcblxuICAgICAgICAgICAgICAgIGJldHRlciA9IHF1YW50X2NvbXBhcmUoYmV0dGVyLCBiZXN0X25vaXNlX2luZm8sIG5vaXNlX2luZm8sXG4gICAgICAgICAgICAgICAgICAgIGNvZF9pbmZvX3csIGRpc3RvcnQpID8gMSA6IDA7XG5cbiAgICAgICAgICAgICAgICAvKiBzYXZlIGRhdGEgc28gd2UgY2FuIHJlc3RvcmUgdGhpcyBxdWFudGl6YXRpb24gbGF0ZXIgKi9cbiAgICAgICAgICAgICAgICBpZiAoYmV0dGVyICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdF9wYXJ0Ml8zX2xlbmd0aCA9IGNvZF9pbmZvLnBhcnQyXzNfbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBiZXN0X25vaXNlX2luZm8gPSBub2lzZV9pbmZvO1xuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mby5hc3NpZ24oY29kX2luZm9fdyk7XG4gICAgICAgICAgICAgICAgICAgIGFnZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8qIHNhdmUgZGF0YSBzbyB3ZSBjYW4gcmVzdG9yZSB0aGlzIHF1YW50aXphdGlvbiBsYXRlciAqL1xuICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZSBmb3IgbGF0ZXIgcmV1c2UgKi9cbiAgICAgICAgICAgICAgICAgICAgU3lzdGVtJDIxLmFycmF5Y29weSh4cnBvdywgMCwgc2F2ZV94cnBvdywgMCwgNTc2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBlYXJseSBzdG9wPyAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2ZjLmZ1bGxfb3V0ZXJfbG9vcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKythZ2UgPiBzZWFyY2hfbGltaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBiZXN0X25vaXNlX2luZm8ub3Zlcl9jb3VudCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChnZmMubm9pc2Vfc2hhcGluZ19hbXAgPT0gMykgJiYgYlJlZmluZSAmJiBhZ2UgPiAzMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZ2ZjLm5vaXNlX3NoYXBpbmdfYW1wID09IDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYlJlZmluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChjb2RfaW5mb193Lmdsb2JhbF9nYWluIC0gYmVzdF9nZ2Fpbl9wYXNzMSkgPiAxNSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKChjb2RfaW5mb193Lmdsb2JhbF9nYWluICsgY29kX2luZm9fdy5zY2FsZWZhY19zY2FsZSkgPCAyNTUpO1xuXG4gICAgICAgICAgICBpZiAoZ2ZjLm5vaXNlX3NoYXBpbmdfYW1wID09IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJSZWZpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogcmVmaW5lIHNlYXJjaCAqL1xuICAgICAgICAgICAgICAgICAgICBjb2RfaW5mb193LmFzc2lnbihjb2RfaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIFN5c3RlbSQyMS5hcnJheWNvcHkoc2F2ZV94cnBvdywgMCwgeHJwb3csIDAsIDU3Nik7XG4gICAgICAgICAgICAgICAgICAgIGFnZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RfZ2dhaW5fcGFzczEgPSBjb2RfaW5mb193Lmdsb2JhbF9nYWluO1xuXG4gICAgICAgICAgICAgICAgICAgIGJSZWZpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHNlYXJjaCBhbHJlYWR5IHJlZmluZWQsIHN0b3AgKi9cbiAgICAgICAgICAgICAgICAgICAgYkVuZE9mU2VhcmNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYkVuZE9mU2VhcmNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFzc2VydCQyMSgoY29kX2luZm8uZ2xvYmFsX2dhaW4gKyBjb2RfaW5mby5zY2FsZWZhY19zY2FsZSkgPD0gMjU1KTtcbiAgICAgICAgLypcbiAgICAgICAgICogZmluaXNoIHVwXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZ2ZwLlZCUiA9PSBWYnJNb2RlJDIxLnZicl9yaCB8fCBnZnAuVkJSID09IFZick1vZGUkMjEudmJyX210cmgpXG4gICAgICAgIC8qIHJlc3RvcmUgZm9yIHJldXNlIG9uIG5leHQgdHJ5ICovXG4gICAgICAgICAgICBTeXN0ZW0kMjEuYXJyYXljb3B5KHNhdmVfeHJwb3csIDAsIHhycG93LCAwLCA1NzYpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBkbyB0aGUgJ3N1YnN0ZXAgc2hhcGluZydcbiAgICAgICAgICovXG4gICAgICAgIGVsc2UgaWYgKChnZmMuc3Vic3RlcF9zaGFwaW5nICYgMSkgIT0gMClcbiAgICAgICAgICAgIHRyYW5jYXRlX3NtYWxsc3BlY3RydW1zKGdmYywgY29kX2luZm8sIGwzX3htaW4sIHhycG93KTtcblxuICAgICAgICByZXR1cm4gYmVzdF9ub2lzZV9pbmZvLm92ZXJfY291bnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJvYmVydCBIZWdlbWFubiAyMDAwLTA5LTA2XG4gICAgICpcbiAgICAgKiB1cGRhdGUgcmVzZXJ2b2lyIHN0YXR1cyBhZnRlciBGSU5BTCBxdWFudGl6YXRpb24vYml0cmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXRlcmF0aW9uX2ZpbmlzaF9vbmUgPSBmdW5jdGlvbiAoZ2ZjLCBnciwgY2gpIHtcbiAgICAgICAgdmFyIGwzX3NpZGUgPSBnZmMubDNfc2lkZTtcbiAgICAgICAgdmFyIGNvZF9pbmZvID0gbDNfc2lkZS50dFtncl1bY2hdO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHRyeSBzb21lIGJldHRlciBzY2FsZWZhYyBzdG9yYWdlXG4gICAgICAgICAqL1xuICAgICAgICB0ay5iZXN0X3NjYWxlZmFjX3N0b3JlKGdmYywgZ3IsIGNoLCBsM19zaWRlKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBiZXN0IGh1ZmZtYW5fZGl2aWRlIG1heSBzYXZlIHNvbWUgYml0cyB0b29cbiAgICAgICAgICovXG4gICAgICAgIGlmIChnZmMudXNlX2Jlc3RfaHVmZm1hbiA9PSAxKVxuICAgICAgICAgICAgdGsuYmVzdF9odWZmbWFuX2RpdmlkZShnZmMsIGNvZF9pbmZvKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiB1cGRhdGUgcmVzZXJ2b2lyIHN0YXR1cyBhZnRlciBGSU5BTCBxdWFudGl6YXRpb24vYml0cmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcnYuUmVzdkFkanVzdChnZmMsIGNvZF9pbmZvKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiAyMDAwLTA5LTA0IFJvYmVydCBIZWdlbWFublxuICAgICAqXG4gICAgICogQHBhcmFtIGwzX3htaW5cbiAgICAgKiAgICAgICAgICAgIGFsbG93ZWQgZGlzdG9ydGlvbiBvZiB0aGUgc2NhbGVmYWN0b3JcbiAgICAgKiBAcGFyYW0geHJwb3dcbiAgICAgKiAgICAgICAgICAgIGNvbG91cmVkIG1hZ25pdHVkZXMgb2Ygc3BlY3RyYWwgdmFsdWVzXG4gICAgICovXG4gICAgdGhpcy5WQlJfZW5jb2RlX2dyYW51bGUgPSBmdW5jdGlvbiAoZ2ZwLCBjb2RfaW5mbywgbDNfeG1pbiwgeHJwb3csIGNoLCBtaW5fYml0cywgbWF4X2JpdHMpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGJzdF9jb2RfaW5mbyA9IG5ldyBHckluZm9fMSgpO1xuICAgICAgICB2YXIgYnN0X3hycG93ID0gbmV3X2Zsb2F0JDIxKDU3Nik7XG4gICAgICAgIHZhciBNYXhfYml0cyA9IG1heF9iaXRzO1xuICAgICAgICB2YXIgcmVhbF9iaXRzID0gbWF4X2JpdHMgKyAxO1xuICAgICAgICB2YXIgdGhpc19iaXRzID0gKG1heF9iaXRzICsgbWluX2JpdHMpIC8gMjtcbiAgICAgICAgdmFyIGRiaXRzLCBvdmVyLCBmb3VuZCA9IDA7XG4gICAgICAgIHZhciBzZmIyMV9leHRyYSA9IGdmYy5zZmIyMV9leHRyYTtcblxuICAgICAgICBhc3NlcnQkMjEoTWF4X2JpdHMgPD0gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0NIQU5ORUwpO1xuICAgICAgICBBcnJheXMkMjEuZmlsbChic3RfY29kX2luZm8ubDNfZW5jLCAwKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBzZWFyY2ggd2l0aGluIHJvdW5kIGFib3V0IDQwIGJpdHMgb2Ygb3B0aW1hbFxuICAgICAgICAgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgYXNzZXJ0JDIxKHRoaXNfYml0cyA+PSBtaW5fYml0cyk7XG4gICAgICAgICAgICBhc3NlcnQkMjEodGhpc19iaXRzIDw9IG1heF9iaXRzKTtcbiAgICAgICAgICAgIGFzc2VydCQyMShtaW5fYml0cyA8PSBtYXhfYml0cyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzX2JpdHMgPiBNYXhfYml0cyAtIDQyKVxuICAgICAgICAgICAgICAgIGdmYy5zZmIyMV9leHRyYSA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGdmYy5zZmIyMV9leHRyYSA9IHNmYjIxX2V4dHJhO1xuXG4gICAgICAgICAgICBvdmVyID0gb3V0ZXJfbG9vcChnZnAsIGNvZF9pbmZvLCBsM194bWluLCB4cnBvdywgY2gsIHRoaXNfYml0cyk7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpcyBxdWFudGl6YXRpb24gYXMgZ29vZCBhcyB3ZSBhcmUgbG9va2luZyBmb3IgPyBpbiB0aGlzIGNhc2U6IGlzXG4gICAgICAgICAgICAgKiBubyBzY2FsZWZhY3RvciBiYW5kIGRpc3RvcnRlZD9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG92ZXIgPD0gMCkge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gMTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIG5vdyB3ZSBrbm93IGl0IGNhbiBiZSBkb25lIHdpdGggXCJyZWFsX2JpdHNcIiBhbmQgbWF5YmUgd2UgY2FuXG4gICAgICAgICAgICAgICAgICogc2tpcCBzb21lIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZWFsX2JpdHMgPSBjb2RfaW5mby5wYXJ0Ml8zX2xlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogc3RvcmUgYmVzdCBxdWFudGl6YXRpb24gc28gZmFyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYnN0X2NvZF9pbmZvLmFzc2lnbihjb2RfaW5mbyk7XG4gICAgICAgICAgICAgICAgU3lzdGVtJDIxLmFycmF5Y29weSh4cnBvdywgMCwgYnN0X3hycG93LCAwLCA1NzYpO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB0cnkgd2l0aCBmZXdlciBiaXRzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbWF4X2JpdHMgPSByZWFsX2JpdHMgLSAzMjtcbiAgICAgICAgICAgICAgICBkYml0cyA9IG1heF9iaXRzIC0gbWluX2JpdHM7XG4gICAgICAgICAgICAgICAgdGhpc19iaXRzID0gKG1heF9iaXRzICsgbWluX2JpdHMpIC8gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB0cnkgd2l0aCBtb3JlIGJpdHNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBtaW5fYml0cyA9IHRoaXNfYml0cyArIDMyO1xuICAgICAgICAgICAgICAgIGRiaXRzID0gbWF4X2JpdHMgLSBtaW5fYml0cztcbiAgICAgICAgICAgICAgICB0aGlzX2JpdHMgPSAobWF4X2JpdHMgKyBtaW5fYml0cykgLyAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBzdGFydCBhZ2FpbiB3aXRoIGJlc3QgcXVhbnRpemF0aW9uIHNvIGZhclxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29kX2luZm8uYXNzaWduKGJzdF9jb2RfaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIFN5c3RlbSQyMS5hcnJheWNvcHkoYnN0X3hycG93LCAwLCB4cnBvdywgMCwgNTc2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRiaXRzID4gMTIpO1xuXG4gICAgICAgIGdmYy5zZmIyMV9leHRyYSA9IHNmYjIxX2V4dHJhO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGZvdW5kPTAgPT4gbm90aGluZyBmb3VuZCwgdXNlIGxhc3Qgb25lIGZvdW5kPTEgPT4gd2UganVzdCBmb3VuZCB0aGVcbiAgICAgICAgICogYmVzdCBhbmQgbGVmdCB0aGUgbG9vcCBmb3VuZD0yID0+IHdlIHJlc3RvcmVkIGEgZ29vZCBvbmUgYW5kIGhhdmUgbm93XG4gICAgICAgICAqIGwzX2VuYyB0byByZXN0b3JlIHRvb1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZvdW5kID09IDIpIHtcbiAgICAgICAgICAgIFN5c3RlbSQyMS5hcnJheWNvcHkoYnN0X2NvZF9pbmZvLmwzX2VuYywgMCwgY29kX2luZm8ubDNfZW5jLCAwLCA1NzYpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCQyMShjb2RfaW5mby5wYXJ0Ml8zX2xlbmd0aCA8PSBNYXhfYml0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJvYmVydCBIZWdlbWFubiAyMDAwLTA5LTA1XG4gICAgICpcbiAgICAgKiBjYWxjdWxhdGVzICogaG93IG1hbnkgYml0cyBhcmUgYXZhaWxhYmxlIGZvciBhbmFsb2cgc2lsZW50IGdyYW51bGVzICogaG93XG4gICAgICogbWFueSBiaXRzIHRvIHVzZSBmb3IgdGhlIGxvd2VzdCBhbGxvd2VkIGJpdHJhdGUgKiBob3cgbWFueSBiaXRzIGVhY2hcbiAgICAgKiBiaXRyYXRlIHdvdWxkIHByb3ZpZGVcbiAgICAgKi9cbiAgICB0aGlzLmdldF9mcmFtZWJpdHMgPSBmdW5jdGlvbiAoZ2ZwLCBmcmFtZUJpdHMpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblxuICAgICAgICAvKlxuICAgICAgICAgKiBhbHdheXMgdXNlIGF0IGxlYXN0IHRoaXMgbWFueSBiaXRzIHBlciBncmFudWxlIHBlciBjaGFubmVsIHVubGVzcyB3ZVxuICAgICAgICAgKiBkZXRlY3QgYW5hbG9nIHNpbGVuY2UsIHNlZSBiZWxvd1xuICAgICAgICAgKi9cbiAgICAgICAgZ2ZjLmJpdHJhdGVfaW5kZXggPSBnZmMuVkJSX21pbl9iaXRyYXRlO1xuICAgICAgICB2YXIgYml0c1BlckZyYW1lID0gYnMuZ2V0ZnJhbWViaXRzKGdmcCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogYml0cyBmb3IgYW5hbG9nIHNpbGVuY2VcbiAgICAgICAgICovXG4gICAgICAgIGdmYy5iaXRyYXRlX2luZGV4ID0gMTtcbiAgICAgICAgYml0c1BlckZyYW1lID0gYnMuZ2V0ZnJhbWViaXRzKGdmcCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZ2ZjLlZCUl9tYXhfYml0cmF0ZTsgaSsrKSB7XG4gICAgICAgICAgICBnZmMuYml0cmF0ZV9pbmRleCA9IGk7XG4gICAgICAgICAgICB2YXIgbWIgPSBuZXcgTWVhbkJpdHMoYml0c1BlckZyYW1lKTtcbiAgICAgICAgICAgIGZyYW1lQml0c1tpXSA9IHJ2LlJlc3ZGcmFtZUJlZ2luKGdmcCwgbWIpO1xuICAgICAgICAgICAgYml0c1BlckZyYW1lID0gbWIuYml0cztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKiBSSDogdGhpcyBvbmUgbmVlZHMgdG8gYmUgb3ZlcmhhdWxlZCBzb21ldGltZSAqL1xuXG4gICAgLyoqXG4gICAgICogPFBSRT5cbiAgICAgKiAgMjAwMC0wOS0wNCBSb2JlcnQgSGVnZW1hbm5cbiAgICAgKlxuICAgICAqICAqIGNvbnZlcnRzIExSIHRvIE1TIGNvZGluZyB3aGVuIG5lY2Vzc2FyeVxuICAgICAqICAqIGNhbGN1bGF0ZXMgYWxsb3dlZC9hZGp1c3RlZCBxdWFudGl6YXRpb24gbm9pc2UgYW1vdW50c1xuICAgICAqICAqIGRldGVjdHMgYW5hbG9nIHNpbGVudCBmcmFtZXNcbiAgICAgKlxuICAgICAqICBzb21lIHJlbWFya3M6XG4gICAgICogIC0gbG93ZXIgbWFza2luZyBkZXBlbmRpbmcgb24gUXVhbGl0eSBzZXR0aW5nXG4gICAgICogIC0gcXVhbGl0eSBjb250cm9sIHRvZ2V0aGVyIHdpdGggYWRqdXN0ZWQgQVRIIE1EQ1Qgc2NhbGluZ1xuICAgICAqICAgIG9uIGxvd2VyIHF1YWxpdHkgc2V0dGluZyBhbGxvY2F0ZSBtb3JlIG5vaXNlIGZyb21cbiAgICAgKiAgICBBVEggbWFza2luZywgYW5kIG9uIGhpZ2hlciBxdWFsaXR5IHNldHRpbmcgYWxsb2NhdGVcbiAgICAgKiAgICBsZXNzIG5vaXNlIGZyb20gQVRIIG1hc2tpbmcuXG4gICAgICogIC0gZXhwZXJpbWVudHMgc2hvdyB0aGF0IGdvaW5nIG1vcmUgdGhhbiAyZEIgb3ZlciBHUFNZQ0hPJ3NcbiAgICAgKiAgICBsaW1pdHMgZW5kcyB1cCBpbiB2ZXJ5IGFubm95aW5nIGFydGVmYWN0c1xuICAgICAqIDwvUFJFPlxuICAgICAqL1xuICAgIHRoaXMuVkJSX29sZF9wcmVwYXJlID0gZnVuY3Rpb24gKGdmcCwgcGUsIG1zX2VuZXJfcmF0aW8sIHJhdGlvLCBsM194bWluLCBmcmFtZUJpdHMsIG1pbl9iaXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heF9iaXRzLCBiYW5kcykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXG4gICAgICAgIHZhciBtYXNraW5nX2xvd2VyX2RiLCBhZGp1c3QgPSAwLjA7XG4gICAgICAgIHZhciBhbmFsb2dfc2lsZW5jZSA9IDE7XG4gICAgICAgIHZhciBiaXRzID0gMDtcblxuICAgICAgICBnZmMuYml0cmF0ZV9pbmRleCA9IGdmYy5WQlJfbWF4X2JpdHJhdGU7XG4gICAgICAgIHZhciBhdmcgPSBydi5SZXN2RnJhbWVCZWdpbihnZnAsIG5ldyBNZWFuQml0cygwKSkgLyBnZmMubW9kZV9ncjtcblxuICAgICAgICBnZXRfZnJhbWViaXRzKGdmcCwgZnJhbWVCaXRzKTtcblxuICAgICAgICBmb3IgKHZhciBnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcbiAgICAgICAgICAgIHZhciBteGIgPSBxdXB2dC5vbl9wZShnZnAsIHBlLCBtYXhfYml0c1tncl0sIGF2ZywgZ3IsIDApO1xuICAgICAgICAgICAgaWYgKGdmYy5tb2RlX2V4dCA9PSBFbmNvZGVyXzEuTVBHX01EX01TX0xSKSB7XG4gICAgICAgICAgICAgICAgbXNfY29udmVydChnZmMubDNfc2lkZSwgZ3IpO1xuICAgICAgICAgICAgICAgIHF1cHZ0LnJlZHVjZV9zaWRlKG1heF9iaXRzW2dyXSwgbXNfZW5lcl9yYXRpb1tncl0sIGF2ZywgbXhiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyArK2NoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZF9pbmZvID0gZ2ZjLmwzX3NpZGUudHRbZ3JdW2NoXTtcblxuICAgICAgICAgICAgICAgIGlmIChjb2RfaW5mby5ibG9ja190eXBlICE9IEVuY29kZXJfMS5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PUk0sIFNUQVJUIG9yIFNUT1AgdHlwZVxuICAgICAgICAgICAgICAgICAgICBhZGp1c3QgPSAxLjI4IC8gKDEgKyBNYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmV4cCgzLjUgLSBwZVtncl1bY2hdIC8gMzAwLikpIC0gMC4wNTtcbiAgICAgICAgICAgICAgICAgICAgbWFza2luZ19sb3dlcl9kYiA9IGdmYy5QU1kubWFza19hZGp1c3QgLSBhZGp1c3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0ID0gMi41NiAvICgxICsgTWF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5leHAoMy41IC0gcGVbZ3JdW2NoXSAvIDMwMC4pKSAtIDAuMTQ7XG4gICAgICAgICAgICAgICAgICAgIG1hc2tpbmdfbG93ZXJfZGIgPSBnZmMuUFNZLm1hc2tfYWRqdXN0X3Nob3J0IC0gYWRqdXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZmMubWFza2luZ19sb3dlciA9IE1hdGgucG93KDEwLjAsXG4gICAgICAgICAgICAgICAgICAgIG1hc2tpbmdfbG93ZXJfZGIgKiAwLjEpO1xuXG4gICAgICAgICAgICAgICAgaW5pdF9vdXRlcl9sb29wKGdmYywgY29kX2luZm8pO1xuICAgICAgICAgICAgICAgIGJhbmRzW2dyXVtjaF0gPSBxdXB2dC5jYWxjX3htaW4oZ2ZwLCByYXRpb1tncl1bY2hdLCBjb2RfaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgbDNfeG1pbltncl1bY2hdKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFuZHNbZ3JdW2NoXSAhPSAwKVxuICAgICAgICAgICAgICAgICAgICBhbmFsb2dfc2lsZW5jZSA9IDA7XG5cbiAgICAgICAgICAgICAgICBtaW5fYml0c1tncl1bY2hdID0gMTI2O1xuXG4gICAgICAgICAgICAgICAgYml0cyArPSBtYXhfYml0c1tncl1bY2hdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYml0cyA+IGZyYW1lQml0c1tnZmMuVkJSX21heF9iaXRyYXRlXSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhfYml0c1tncl1bY2hdICo9IGZyYW1lQml0c1tnZmMuVkJSX21heF9iaXRyYXRlXTtcbiAgICAgICAgICAgICAgICAgICAgbWF4X2JpdHNbZ3JdW2NoXSAvPSBiaXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWluX2JpdHNbZ3JdW2NoXSA+IG1heF9iaXRzW2dyXVtjaF0pXG4gICAgICAgICAgICAgICAgICAgIG1pbl9iaXRzW2dyXVtjaF0gPSBtYXhfYml0c1tncl1bY2hdO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmb3IgY2ggKi9cbiAgICAgICAgfVxuICAgICAgICAvKiBmb3IgZ3IgKi9cblxuICAgICAgICByZXR1cm4gYW5hbG9nX3NpbGVuY2U7XG4gICAgfTtcblxuICAgIHRoaXMuYml0cHJlc3N1cmVfc3RyYXRlZ3kgPSBmdW5jdGlvbiAoZ2ZjLCBsM194bWluLCBtaW5fYml0cywgbWF4X2JpdHMpIHtcbiAgICAgICAgZm9yICh2YXIgZ3IgPSAwOyBnciA8IGdmYy5tb2RlX2dyOyBncisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgIHZhciBnaSA9IGdmYy5sM19zaWRlLnR0W2dyXVtjaF07XG4gICAgICAgICAgICAgICAgdmFyIHB4bWluID0gbDNfeG1pbltncl1bY2hdO1xuICAgICAgICAgICAgICAgIHZhciBweG1pblBvcyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2ZiID0gMDsgc2ZiIDwgZ2kucHN5X2xtYXg7IHNmYisrKVxuICAgICAgICAgICAgICAgICAgICBweG1pbltweG1pblBvcysrXSAqPSAxLiArIC4wMjkgKiBzZmIgKiBzZmJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8gRW5jb2Rlcl8xLlNCTUFYX2wgLyBFbmNvZGVyXzEuU0JNQVhfbDtcblxuICAgICAgICAgICAgICAgIGlmIChnaS5ibG9ja190eXBlID09IEVuY29kZXJfMS5TSE9SVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHNmYiA9IGdpLnNmYl9zbWluOyBzZmIgPCBFbmNvZGVyXzEuU0JNQVhfczsgc2ZiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB4bWluW3B4bWluUG9zKytdICo9IDEuICsgLjAyOSAqIHNmYiAqIHNmYlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gRW5jb2Rlcl8xLlNCTUFYX3MgLyBFbmNvZGVyXzEuU0JNQVhfcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHB4bWluW3B4bWluUG9zKytdICo9IDEuICsgLjAyOSAqIHNmYiAqIHNmYlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gRW5jb2Rlcl8xLlNCTUFYX3MgLyBFbmNvZGVyXzEuU0JNQVhfcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHB4bWluW3B4bWluUG9zKytdICo9IDEuICsgLjAyOSAqIHNmYiAqIHNmYlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gRW5jb2Rlcl8xLlNCTUFYX3MgLyBFbmNvZGVyXzEuU0JNQVhfcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXhfYml0c1tncl1bY2hdID0gMCB8IE1hdGgubWF4KG1pbl9iaXRzW2dyXVtjaF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjkgKiBtYXhfYml0c1tncl1bY2hdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLlZCUl9uZXdfcHJlcGFyZSA9IGZ1bmN0aW9uIChnZnAsIHBlLCByYXRpbywgbDNfeG1pbiwgZnJhbWVCaXRzLCBtYXhfYml0cykge1xuICAgICAgICB2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXG4gICAgICAgIHZhciBhbmFsb2dfc2lsZW5jZSA9IDE7XG4gICAgICAgIHZhciBhdmcgPSAwLCBiaXRzID0gMDtcbiAgICAgICAgdmFyIG1heGltdW1fZnJhbWViaXRzO1xuXG4gICAgICAgIGlmICghZ2ZwLmZyZWVfZm9ybWF0KSB7XG4gICAgICAgICAgICBnZmMuYml0cmF0ZV9pbmRleCA9IGdmYy5WQlJfbWF4X2JpdHJhdGU7XG5cbiAgICAgICAgICAgIHZhciBtYiA9IG5ldyBNZWFuQml0cyhhdmcpO1xuICAgICAgICAgICAgcnYuUmVzdkZyYW1lQmVnaW4oZ2ZwLCBtYik7XG4gICAgICAgICAgICBhdmcgPSBtYi5iaXRzO1xuXG4gICAgICAgICAgICBnZXRfZnJhbWViaXRzKGdmcCwgZnJhbWVCaXRzKTtcbiAgICAgICAgICAgIG1heGltdW1fZnJhbWViaXRzID0gZnJhbWVCaXRzW2dmYy5WQlJfbWF4X2JpdHJhdGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2ZjLmJpdHJhdGVfaW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIG1iID0gbmV3IE1lYW5CaXRzKGF2Zyk7XG4gICAgICAgICAgICBtYXhpbXVtX2ZyYW1lYml0cyA9IHJ2LlJlc3ZGcmFtZUJlZ2luKGdmcCwgbWIpO1xuICAgICAgICAgICAgYXZnID0gbWIuYml0cztcbiAgICAgICAgICAgIGZyYW1lQml0c1swXSA9IG1heGltdW1fZnJhbWViaXRzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgZ3IgPSAwOyBnciA8IGdmYy5tb2RlX2dyOyBncisrKSB7XG4gICAgICAgICAgICBxdXB2dC5vbl9wZShnZnAsIHBlLCBtYXhfYml0c1tncl0sIGF2ZywgZ3IsIDApO1xuICAgICAgICAgICAgaWYgKGdmYy5tb2RlX2V4dCA9PSBFbmNvZGVyXzEuTVBHX01EX01TX0xSKSB7XG4gICAgICAgICAgICAgICAgbXNfY29udmVydChnZmMubDNfc2lkZSwgZ3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7ICsrY2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kX2luZm8gPSBnZmMubDNfc2lkZS50dFtncl1bY2hdO1xuXG4gICAgICAgICAgICAgICAgZ2ZjLm1hc2tpbmdfbG93ZXIgPSBNYXRoLnBvdygxMC4wLFxuICAgICAgICAgICAgICAgICAgICBnZmMuUFNZLm1hc2tfYWRqdXN0ICogMC4xKTtcblxuICAgICAgICAgICAgICAgIGluaXRfb3V0ZXJfbG9vcChnZmMsIGNvZF9pbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAoMCAhPSBxdXB2dC5jYWxjX3htaW4oZ2ZwLCByYXRpb1tncl1bY2hdLCBjb2RfaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGwzX3htaW5bZ3JdW2NoXSkpXG4gICAgICAgICAgICAgICAgICAgIGFuYWxvZ19zaWxlbmNlID0gMDtcblxuICAgICAgICAgICAgICAgIGJpdHMgKz0gbWF4X2JpdHNbZ3JdW2NoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpdHMgPiBtYXhpbXVtX2ZyYW1lYml0cykge1xuICAgICAgICAgICAgICAgICAgICBtYXhfYml0c1tncl1bY2hdICo9IG1heGltdW1fZnJhbWViaXRzO1xuICAgICAgICAgICAgICAgICAgICBtYXhfYml0c1tncl1bY2hdIC89IGJpdHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmb3IgY2ggKi9cbiAgICAgICAgfVxuICAgICAgICAvKiBmb3IgZ3IgKi9cblxuICAgICAgICByZXR1cm4gYW5hbG9nX3NpbGVuY2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZXMgdGFyZ2V0IGJpdHMgZm9yIEFCUiBlbmNvZGluZ1xuICAgICAqXG4gICAgICogbXQgMjAwMC8wNS8zMVxuICAgICAqL1xuICAgIHRoaXMuY2FsY190YXJnZXRfYml0cyA9IGZ1bmN0aW9uIChnZnAsIHBlLCBtc19lbmVyX3JhdGlvLCB0YXJnX2JpdHMsIGFuYWxvZ19zaWxlbmNlX2JpdHMsIG1heF9mcmFtZV9iaXRzKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG4gICAgICAgIHZhciBsM19zaWRlID0gZ2ZjLmwzX3NpZGU7XG4gICAgICAgIHZhciByZXNfZmFjdG9yO1xuICAgICAgICB2YXIgZ3IsIGNoLCB0b3RiaXRzLCBtZWFuX2JpdHMgPSAwO1xuXG4gICAgICAgIGdmYy5iaXRyYXRlX2luZGV4ID0gZ2ZjLlZCUl9tYXhfYml0cmF0ZTtcbiAgICAgICAgdmFyIG1iID0gbmV3IE1lYW5CaXRzKG1lYW5fYml0cyk7XG4gICAgICAgIG1heF9mcmFtZV9iaXRzWzBdID0gcnYuUmVzdkZyYW1lQmVnaW4oZ2ZwLCBtYik7XG4gICAgICAgIG1lYW5fYml0cyA9IG1iLmJpdHM7XG5cbiAgICAgICAgZ2ZjLmJpdHJhdGVfaW5kZXggPSAxO1xuICAgICAgICBtZWFuX2JpdHMgPSBicy5nZXRmcmFtZWJpdHMoZ2ZwKSAtIGdmYy5zaWRlaW5mb19sZW4gKiA4O1xuICAgICAgICBhbmFsb2dfc2lsZW5jZV9iaXRzWzBdID0gbWVhbl9iaXRzIC8gKGdmYy5tb2RlX2dyICogZ2ZjLmNoYW5uZWxzX291dCk7XG5cbiAgICAgICAgbWVhbl9iaXRzID0gZ2ZwLlZCUl9tZWFuX2JpdHJhdGVfa2JwcyAqIGdmcC5mcmFtZXNpemUgKiAxMDAwO1xuICAgICAgICBpZiAoKGdmYy5zdWJzdGVwX3NoYXBpbmcgJiAxKSAhPSAwKVxuICAgICAgICAgICAgbWVhbl9iaXRzICo9IDEuMDk7XG4gICAgICAgIG1lYW5fYml0cyAvPSBnZnAub3V0X3NhbXBsZXJhdGU7XG4gICAgICAgIG1lYW5fYml0cyAtPSBnZmMuc2lkZWluZm9fbGVuICogODtcbiAgICAgICAgbWVhbl9iaXRzIC89IChnZmMubW9kZV9nciAqIGdmYy5jaGFubmVsc19vdXQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8UFJFPlxuICAgICAgICAgKiAgICAgICAgICAgcmVzX2ZhY3RvciBpcyB0aGUgcGVyY2VudGFnZSBvZiB0aGUgdGFyZ2V0IGJpdHJhdGUgdGhhdCBzaG91bGRcbiAgICAgICAgICogICAgICAgICAgIGJlIHVzZWQgb24gYXZlcmFnZS4gIHRoZSByZW1haW5pbmcgYml0cyBhcmUgYWRkZWQgdG8gdGhlXG4gICAgICAgICAqICAgICAgICAgICBiaXRyZXNlcnZvaXIgYW5kIHVzZWQgZm9yIGRpZmZpY3VsdCB0byBlbmNvZGUgZnJhbWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgICAgU2luY2Ugd2UgYXJlIHRyYWNraW5nIHRoZSBhdmVyYWdlIGJpdHJhdGUsIHdlIHNob3VsZCBhZGp1c3RcbiAgICAgICAgICogICAgICAgICAgIHJlc19mYWN0b3IgXCJvbiB0aGUgZmx5XCIsIGluY3JlYXNpbmcgaXQgaWYgdGhlIGF2ZXJhZ2UgYml0cmF0ZVxuICAgICAgICAgKiAgICAgICAgICAgaXMgZ3JlYXRlciB0aGFuIHRoZSByZXF1ZXN0ZWQgYml0cmF0ZSwgYW5kIGRlY3JlYXNpbmcgaXRcbiAgICAgICAgICogICAgICAgICAgIG90aGVyd2lzZS4gIFJlYXNvbmFibGUgcmFuZ2VzIGFyZSBmcm9tIC45IHRvIDEuMFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgICAgVW50aWwgd2UgZ2V0IHRoZSBhYm92ZSBzdWdnZXN0aW9uIHdvcmtpbmcsIHdlIHVzZSB0aGUgZm9sbG93aW5nXG4gICAgICAgICAqICAgICAgICAgICB0dW5pbmc6XG4gICAgICAgICAqICAgICAgICAgICBjb21wcmVzc2lvbiByYXRpbyAgICByZXNfZmFjdG9yXG4gICAgICAgICAqICAgICAgICAgICA1LjUgICgyNTZrYnBzKSAgICAgICAgIDEuMCAgICAgIG5vIG5lZWQgZm9yIGJpdHJlc2Vydm9pclxuICAgICAgICAgKiAgICAgICAgICAgMTEgICAoMTI4a2JwcykgICAgICAgICAuOTMgICAgICA3JSBoZWxkIGZvciByZXNlcnZvaXJcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICAgIHdpdGggbGluZWFyIGludGVycG9sYXRpb24gZm9yIG90aGVyIHZhbHVlcy5cbiAgICAgICAgICogPC9QUkU+XG4gICAgICAgICAqL1xuICAgICAgICByZXNfZmFjdG9yID0gLjkzICsgLjA3ICogKDExLjAgLSBnZnAuY29tcHJlc3Npb25fcmF0aW8pXG4gICAgICAgICAgICAvICgxMS4wIC0gNS41KTtcbiAgICAgICAgaWYgKHJlc19mYWN0b3IgPCAuOTApXG4gICAgICAgICAgICByZXNfZmFjdG9yID0gLjkwO1xuICAgICAgICBpZiAocmVzX2ZhY3RvciA+IDEuMDApXG4gICAgICAgICAgICByZXNfZmFjdG9yID0gMS4wMDtcblxuICAgICAgICBmb3IgKGdyID0gMDsgZ3IgPCBnZmMubW9kZV9ncjsgZ3IrKykge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ19iaXRzW2dyXVtjaF0gPSAoaW50KShyZXNfZmFjdG9yICogbWVhbl9iaXRzKTtcblxuICAgICAgICAgICAgICAgIGlmIChwZVtncl1bY2hdID4gNzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRfYml0cyA9IChpbnQpKChwZVtncl1bY2hdIC0gNzAwKSAvIDEuNCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZF9pbmZvID0gbDNfc2lkZS50dFtncl1bY2hdO1xuICAgICAgICAgICAgICAgICAgICB0YXJnX2JpdHNbZ3JdW2NoXSA9IChpbnQpKHJlc19mYWN0b3IgKiBtZWFuX2JpdHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIHNob3J0IGJsb2NrcyB1c2UgYSBsaXR0bGUgZXh0cmEsIG5vIG1hdHRlciB3aGF0IHRoZSBwZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kX2luZm8uYmxvY2tfdHlwZSA9PSBFbmNvZGVyXzEuU0hPUlRfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZF9iaXRzIDwgbWVhbl9iaXRzIC8gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfYml0cyA9IG1lYW5fYml0cyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyogYXQgbW9zdCBpbmNyZWFzZSBiaXRzIGJ5IDEuNSphdmVyYWdlICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRfYml0cyA+IG1lYW5fYml0cyAqIDMgLyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkX2JpdHMgPSBtZWFuX2JpdHMgKiAzIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWRkX2JpdHMgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkX2JpdHMgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdfYml0c1tncl1bY2hdICs9IGFkZF9iaXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGFyZ19iaXRzW2dyXVtjaF0gPiBMYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfQ0hBTk5FTCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnX2JpdHNbZ3JdW2NoXSA9IExhbWVJbnRlcm5hbEZsYWdzLk1BWF9CSVRTX1BFUl9DSEFOTkVMO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdW0gKz0gdGFyZ19iaXRzW2dyXVtjaF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmb3IgY2ggKi9cbiAgICAgICAgICAgIGlmIChzdW0gPiBMYW1lSW50ZXJuYWxGbGFncy5NQVhfQklUU19QRVJfR1JBTlVMRSkge1xuICAgICAgICAgICAgICAgIGZvciAoY2ggPSAwOyBjaCA8IGdmYy5jaGFubmVsc19vdXQ7ICsrY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ19iaXRzW2dyXVtjaF0gKj0gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0dSQU5VTEU7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdfYml0c1tncl1bY2hdIC89IHN1bTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogZm9yIGdyICovXG5cbiAgICAgICAgaWYgKGdmYy5tb2RlX2V4dCA9PSBFbmNvZGVyXzEuTVBHX01EX01TX0xSKVxuICAgICAgICAgICAgZm9yIChnciA9IDA7IGdyIDwgZ2ZjLm1vZGVfZ3I7IGdyKyspIHtcbiAgICAgICAgICAgICAgICBxdXB2dC5yZWR1Y2Vfc2lkZSh0YXJnX2JpdHNbZ3JdLCBtc19lbmVyX3JhdGlvW2dyXSwgbWVhbl9iaXRzXG4gICAgICAgICAgICAgICAgICAgICogZ2ZjLmNoYW5uZWxzX291dCxcbiAgICAgICAgICAgICAgICAgICAgTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0dSQU5VTEUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHN1bSB0YXJnZXQgYml0c1xuICAgICAgICAgKi9cbiAgICAgICAgdG90Yml0cyA9IDA7XG4gICAgICAgIGZvciAoZ3IgPSAwOyBnciA8IGdmYy5tb2RlX2dyOyBncisrKSB7XG4gICAgICAgICAgICBmb3IgKGNoID0gMDsgY2ggPCBnZmMuY2hhbm5lbHNfb3V0OyBjaCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdfYml0c1tncl1bY2hdID4gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0NIQU5ORUwpXG4gICAgICAgICAgICAgICAgICAgIHRhcmdfYml0c1tncl1bY2hdID0gTGFtZUludGVybmFsRmxhZ3MuTUFYX0JJVFNfUEVSX0NIQU5ORUw7XG4gICAgICAgICAgICAgICAgdG90Yml0cyArPSB0YXJnX2JpdHNbZ3JdW2NoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHJlcGFydGlvbiB0YXJnZXQgYml0cyBpZiBuZWVkZWRcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0b3RiaXRzID4gbWF4X2ZyYW1lX2JpdHNbMF0pIHtcbiAgICAgICAgICAgIGZvciAoZ3IgPSAwOyBnciA8IGdmYy5tb2RlX2dyOyBncisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjaCA9IDA7IGNoIDwgZ2ZjLmNoYW5uZWxzX291dDsgY2grKykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnX2JpdHNbZ3JdW2NoXSAqPSBtYXhfZnJhbWVfYml0c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ19iaXRzW2dyXVtjaF0gLz0gdG90Yml0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG59XG5cbnZhciBRdWFudGl6ZV8xID0gUXVhbnRpemUkMTtcblxuLypcbiAqICAgICAgYml0IHJlc2Vydm9pciBzb3VyY2UgZmlsZVxuICpcbiAqICAgICAgQ29weXJpZ2h0IChjKSAxOTk5LTIwMDAgTWFyayBUYXlsb3JcbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gKiBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gKiBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBlaXRoZXJcbiAqIHZlcnNpb24gMiBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuICogTGlicmFyeSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICogTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGVcbiAqIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLFxuICogQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4gKi9cblxuLyogJElkOiBSZXNlcnZvaXIuamF2YSx2IDEuOSAyMDExLzA1LzI0IDIwOjQ4OjA2IGtlbmNoaXMgRXhwICQgKi9cblxuLy9wYWNrYWdlIG1wMztcblxuLyoqXG4gKiBSZXN2RnJhbWVCZWdpbjo8QlI+XG4gKiBDYWxsZWQgKHJlcGVhdGVkbHkpIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBmcmFtZS4gVXBkYXRlcyB0aGUgbWF4aW11bSBzaXplIG9mXG4gKiB0aGUgcmVzZXJ2b2lyLCBhbmQgY2hlY2tzIHRvIG1ha2Ugc3VyZSBtYWluX2RhdGFfYmVnaW4gd2FzIHNldCBwcm9wZXJseSBieVxuICogdGhlIGZvcm1hdHRlcjxCUj5cbiAqIEJhY2tncm91bmQgaW5mb3JtYXRpb246XG4gKiBcbiAqIFRoaXMgaXMgdGhlIG9yaWdpbmFsIHRleHQgZnJvbSB0aGUgSVNPIHN0YW5kYXJkLiBCZWNhdXNlIG9mIHNvb28gbWFueSBidWdzXG4gKiBhbmQgaXJyaXRhdGlvbnMgY29ycmVjdGluZyBjb21tZW50cyBhcmUgYWRkZWQgaW4gYnJhY2tldHMgW10uIEEgJ15XJyBtZWFuc1xuICogeW91IHNob3VsZCByZW1vdmUgdGhlIGxhc3Qgd29yZC5cbiAqIFxuICogPFBSRT5cbiAqICAxLiBUaGUgZm9sbG93aW5nIHJ1bGUgY2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBtYXhpbXVtXG4gKiAgICAgbnVtYmVyIG9mIGJpdHMgdXNlZCBmb3Igb25lIGdyYW51bGUgW15XIGZyYW1lXTo8QlI+XG4gKiAgICAgQXQgdGhlIGhpZ2hlc3QgcG9zc2libGUgYml0cmF0ZSBvZiBMYXllciBJSUkgKDMyMCBrYnBzXG4gKiAgICAgcGVyIHN0ZXJlbyBzaWduYWwgW15XXldeV10sIDQ4IGtIeikgdGhlIGZyYW1lcyBtdXN0IGJlIG9mXG4gKiAgICAgW15XXldeVyBhcmUgZGVzaWduZWQgdG8gaGF2ZV0gY29uc3RhbnQgbGVuZ3RoLCBpLmUuXG4gKiAgICAgb25lIGJ1ZmZlciBbXldeVyB0aGUgZnJhbWVdIGxlbmd0aCBpczo8QlI+XG4gKiBcbiAqICAgICAgICAgMzIwIGticHMgKiAxMTUyLzQ4IGtIeiA9IDc2ODAgYml0ID0gOTYwIGJ5dGVcbiAqIFxuICogICAgIFRoaXMgdmFsdWUgaXMgdXNlZCBhcyB0aGUgbWF4aW11bSBidWZmZXIgcGVyIGNoYW5uZWwgW15XXlddIGF0XG4gKiAgICAgbG93ZXIgYml0cmF0ZXMgW3RoYW4gMzIwIGticHNdLiBBdCA2NCBrYnBzIG1vbm8gb3IgMTI4IGticHNcbiAqICAgICBzdGVyZW8gdGhlIG1haW4gZ3JhbnVsZSBsZW5ndGggaXMgNjQga2JwcyAqIDU3Ni80OCBrSHogPSA3NjggYml0XG4gKiAgICAgW3BlciBncmFudWxlIGFuZCBjaGFubmVsXSBhdCA0OCBrSHogc2FtcGxpbmcgZnJlcXVlbmN5LlxuICogICAgIFRoaXMgbWVhbnMgdGhhdCB0aGVyZSBpcyBhIG1heGltdW0gZGV2aWF0aW9uIChzaG9ydCB0aW1lIGJ1ZmZlclxuICogICAgIFs9IHJlc2Vydm9pcl0pIG9mIDc2ODAgLSAyKjIqNzY4ID0gNDYwOCBiaXRzIGlzIGFsbG93ZWQgYXQgNjQga2Jwcy5cbiAqICAgICBUaGUgYWN0dWFsIGRldmlhdGlvbiBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzIFt3aXRoIHRoZVxuICogICAgIG1lYW5pbmcgb2Ygb2N0ZXRzXSBkZW5vdGVkIGJ5IHRoZSBtYWluX2RhdGFfZW5kIG9mZnNldCBwb2ludGVyLlxuICogICAgIFRoZSBhY3R1YWwgbWF4aW11bSBkZXZpYXRpb24gaXMgKDJeOS0xKSo4IGJpdCA9IDQwODggYml0c1xuICogICAgIFtmb3IgTVBFRy0xIGFuZCAoMl44LTEpKjggYml0IGZvciBNUEVHLTIsIGJvdGggYXJlIGhhcmQgbGltaXRzXS5cbiAqICAgICAuLi4gVGhlIHhjaGFuZ2Ugb2YgYnVmZmVyIGJpdHMgYmV0d2VlbiB0aGUgbGVmdCBhbmQgcmlnaHQgY2hhbm5lbFxuICogICAgIGlzIGFsbG93ZWQgd2l0aG91dCByZXN0cmljdGlvbnMgW2V4Y2VwdGlvbjogZHVhbCBjaGFubmVsXS5cbiAqICAgICBCZWNhdXNlIG9mIHRoZSBbY29uc3RydWN0ZWRdIGNvbnN0cmFpbnQgb24gdGhlIGJ1ZmZlciBzaXplXG4gKiAgICAgbWFpbl9kYXRhX2VuZCBpcyBhbHdheXMgc2V0IHRvIDAgaW4gdGhlIGNhc2Ugb2YgYml0X3JhdGVfaW5kZXg9PTE0LFxuICogICAgIGkuZS4gZGF0YSByYXRlIDMyMCBrYnBzIHBlciBzdGVyZW8gc2lnbmFsIFteV15XXlddLiBJbiB0aGlzIGNhc2VcbiAqICAgICBhbGwgZGF0YSBhcmUgYWxsb2NhdGVkIGJldHdlZW4gYWRqYWNlbnQgaGVhZGVyIFteVyBzeW5jXSB3b3Jkc1xuICogICAgIFssIGkuZS4gdGhlcmUgaXMgbm8gYnVmZmVyaW5nIGF0IGFsbF0uXG4gKiA8L1BSRT5cbiAqL1xuXG5cbnZhciBhc3NlcnQkMjMgPSBjb21tb24uYXNzZXJ0O1xuXG5mdW5jdGlvbiBSZXNlcnZvaXIkMSgpIHtcblx0dmFyIGJzO1xuXG5cdHRoaXMuc2V0TW9kdWxlcyAgPSBmdW5jdGlvbihfYnMpIHtcblx0XHRicyA9IF9icztcblx0fTtcblxuXHR0aGlzLlJlc3ZGcmFtZUJlZ2luID0gZnVuY3Rpb24oZ2ZwLCBtZWFuX2JpdHMpIHtcblx0XHR2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXHRcdHZhciBtYXhtcDNidWY7XG5cdFx0dmFyIGwzX3NpZGUgPSBnZmMubDNfc2lkZTtcblxuXHRcdHZhciBmcmFtZUxlbmd0aCA9IGJzLmdldGZyYW1lYml0cyhnZnApO1xuXHRcdG1lYW5fYml0cy5iaXRzID0gKGZyYW1lTGVuZ3RoIC0gZ2ZjLnNpZGVpbmZvX2xlbiAqIDgpIC8gZ2ZjLm1vZGVfZ3I7XG5cblx0XHQvKipcblx0XHQgKiA8UFJFPlxuXHRcdCAqICBNZWFuaW5nIG9mIHRoZSB2YXJpYWJsZXM6XG5cdFx0ICogICAgICByZXN2TGltaXQ6ICgwLCA4LCAuLi4sIDgqMjU1IChNUEVHLTIpLCA4KjUxMSAoTVBFRy0xKSlcblx0XHQgKiAgICAgICAgICBOdW1iZXIgb2YgYml0cyBjYW4gYmUgc3RvcmVkIGluIHByZXZpb3VzIGZyYW1lKHMpIGR1ZSB0b1xuXHRcdCAqICAgICAgICAgIGNvdW50ZXIgc2l6ZSBjb25zdGFpbnRzXG5cdFx0ICogICAgICBtYXhtcDNidWY6ICggPz8/IC4uLiA4KjE5NTEgKE1QRUctMSBhbmQgMiksIDgqMjA0NyAoTVBFRy0yLjUpKVxuXHRcdCAqICAgICAgICAgIE51bWJlciBvZiBiaXRzIGFsbG93ZWQgdG8gZW5jb2RlIG9uZSBmcmFtZSAoeW91IGNhbiB0YWtlIDgqNTExIGJpdFxuXHRcdCAqICAgICAgICAgIGZyb20gdGhlIGJpdCByZXNlcnZvaXIgYW5kIGF0IG1vc3QgOCoxNDQwIGJpdCBmcm9tIHRoZSBjdXJyZW50XG5cdFx0ICogICAgICAgICAgZnJhbWUgKDMyMCBrYnBzLCAzMiBrSHopLCBzbyA4KjE5NTEgYml0IGlzIHRoZSBsYXJnZXN0IHBvc3NpYmxlXG5cdFx0ICogICAgICAgICAgdmFsdWUgZm9yIE1QRUctMSBhbmQgLTIpXG5cdFx0ICogXG5cdFx0ICogICAgICAgICAgbWF4aW11bSBhbGxvd2VkIGdyYW51bGUvY2hhbm5lbCBzaXplIHRpbWVzIDQgPSA4KjIwNDcgYml0cy4sXG5cdFx0ICogICAgICAgICAgc28gdGhpcyBpcyB0aGUgYWJzb2x1dGUgbWF4aW11bSBzdXBwb3J0ZWQgYnkgdGhlIGZvcm1hdC5cblx0XHQgKiBcblx0XHQgKiBcblx0XHQgKiAgICAgIGZ1bGxGcmFtZUJpdHM6ICBtYXhpbXVtIG51bWJlciBvZiBiaXRzIGF2YWlsYWJsZSBmb3IgZW5jb2Rpbmdcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICB0aGUgY3VycmVudCBmcmFtZS5cblx0XHQgKiBcblx0XHQgKiAgICAgIG1lYW5fYml0czogICAgICB0YXJnZXQgbnVtYmVyIG9mIGJpdHMgcGVyIGdyYW51bGUuXG5cdFx0ICogXG5cdFx0ICogICAgICBmcmFtZUxlbmd0aDpcblx0XHQgKiBcblx0XHQgKiAgICAgIGdmYy5SZXN2TWF4OiAgIG1heGltdW0gYWxsb3dlZCByZXNlcnZvaXJcblx0XHQgKiBcblx0XHQgKiAgICAgIGdmYy5SZXN2U2l6ZTogIGN1cnJlbnQgcmVzZXJ2b2lyIHNpemVcblx0XHQgKiBcblx0XHQgKiAgICAgIGwzX3NpZGUucmVzdkRyYWluX3ByZTpcblx0XHQgKiAgICAgICAgIGFuY2lsbGFyeSBkYXRhIHRvIGJlIGFkZGVkIHRvIHByZXZpb3VzIGZyYW1lOlxuXHRcdCAqICAgICAgICAgKG9ubHkgdXNlZnVsbCBpbiBWQlIgbW9kZXMgaWYgaXQgaXMgcG9zc2libGUgdG8gaGF2ZVxuXHRcdCAqICAgICAgICAgbWF4bXAzYnVmIDwgZnVsbEZyYW1lQml0cykpLiAgQ3VycmVudGx5IGRpc2FibGVkLFxuXHRcdCAqICAgICAgICAgc2VlICNkZWZpbmUgTkVXX0RSQUlOXG5cdFx0ICogICAgICAgICAyMDEwLTAyLTEzOiBSSCBub3cgZW5hYmxlZCwgaXQgc2VlbXMgdG8gYmUgbmVlZGVkIGZvciBDQlIgdG9vLFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgYXMgdGhlcmUgZXhpc3RzIG9uZSBleGFtcGxlLCB3aGVyZSB0aGUgRmhHIGRlY29kZXJcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgIGNhbid0IGRlY29kZSBhIC1iMzIwIENCUiBmaWxlIGFueW1vcmUuXG5cdFx0ICogXG5cdFx0ICogICAgICBsM19zaWRlLnJlc3ZEcmFpbl9wb3N0OlxuXHRcdCAqICAgICAgICAgYW5jaWxsYXJ5IGRhdGEgdG8gYmUgYWRkZWQgdG8gdGhpcyBmcmFtZTpcblx0XHQgKiBcblx0XHQgKiA8L1BSRT5cblx0XHQgKi9cblxuXHRcdC8qIG1haW5fZGF0YV9iZWdpbiBoYXMgOSBiaXRzIGluIE1QRUctMSwgOCBiaXRzIE1QRUctMiAqL1xuXHRcdHZhciByZXN2TGltaXQgPSAoOCAqIDI1NikgKiBnZmMubW9kZV9nciAtIDg7XG5cblx0XHQvKlxuXHRcdCAqIG1heGltdW0gYWxsb3dlZCBmcmFtZSBzaXplLiBkb250IHVzZSBtb3JlIHRoYW4gdGhpcyBudW1iZXIgb2YgYml0cyxcblx0XHQgKiBldmVuIGlmIHRoZSBmcmFtZSBoYXMgdGhlIHNwYWNlIGZvciB0aGVtOlxuXHRcdCAqL1xuXHRcdGlmIChnZnAuYnJhdGUgPiAzMjApIHtcblx0XHRcdC8qIGluIGZyZWVmb3JtYXQgdGhlIGJ1ZmZlciBpcyBjb25zdGFudCAqL1xuXHRcdFx0bWF4bXAzYnVmID0gOCAqICgoaW50KSAoKGdmcC5icmF0ZSAqIDEwMDApXG5cdFx0XHRcdFx0LyAoZ2ZwLm91dF9zYW1wbGVyYXRlIC8gMTE1MikgLyA4ICsgLjUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Lypcblx0XHRcdCAqIGFsbCBtcDMgZGVjb2RlcnMgc2hvdWxkIGhhdmUgZW5vdWdoIGJ1ZmZlciB0byBoYW5kbGUgdGhpcyB2YWx1ZTpcblx0XHRcdCAqIHNpemUgb2YgYSAzMjBrYnBzIDMya0h6IGZyYW1lXG5cdFx0XHQgKi9cblx0XHRcdG1heG1wM2J1ZiA9IDggKiAxNDQwO1xuXG5cdFx0XHQvKlxuXHRcdFx0ICogQm91dmlnbmUgc3VnZ2VzdHMgdGhpcyBtb3JlIGxheCBpbnRlcnByZXRhdGlvbiBvZiB0aGUgSVNPIGRvY1xuXHRcdFx0ICogaW5zdGVhZCBvZiB1c2luZyA4Kjk2MC5cblx0XHRcdCAqL1xuXG5cdFx0XHRpZiAoZ2ZwLnN0cmljdF9JU08pIHtcblx0XHRcdFx0bWF4bXAzYnVmID0gOCAqICgoaW50KSAoMzIwMDAwIC8gKGdmcC5vdXRfc2FtcGxlcmF0ZSAvIDExNTIpIC8gOCArIC41KSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Z2ZjLlJlc3ZNYXggPSBtYXhtcDNidWYgLSBmcmFtZUxlbmd0aDtcblx0XHRpZiAoZ2ZjLlJlc3ZNYXggPiByZXN2TGltaXQpXG5cdFx0XHRnZmMuUmVzdk1heCA9IHJlc3ZMaW1pdDtcblx0XHRpZiAoZ2ZjLlJlc3ZNYXggPCAwIHx8IGdmcC5kaXNhYmxlX3Jlc2Vydm9pcilcblx0XHRcdGdmYy5SZXN2TWF4ID0gMDtcblxuXHRcdHZhciBmdWxsRnJhbWVCaXRzID0gbWVhbl9iaXRzLmJpdHMgKiBnZmMubW9kZV9nclxuXHRcdFx0XHQrIE1hdGgubWluKGdmYy5SZXN2U2l6ZSwgZ2ZjLlJlc3ZNYXgpO1xuXG5cdFx0aWYgKGZ1bGxGcmFtZUJpdHMgPiBtYXhtcDNidWYpXG5cdFx0XHRmdWxsRnJhbWVCaXRzID0gbWF4bXAzYnVmO1xuXG5cdFx0YXNzZXJ0JDIzICgwID09IGdmYy5SZXN2TWF4ICUgOCk7XG5cdFx0YXNzZXJ0JDIzIChnZmMuUmVzdk1heCA+PSAwKTtcblxuXHRcdGwzX3NpZGUucmVzdkRyYWluX3ByZSA9IDA7XG5cblx0XHQvLyBmcmFtZSBhbmFseXplciBjb2RlXG5cdFx0aWYgKGdmYy5waW5mbyAhPSBudWxsKSB7XG5cdFx0XHQvKlxuXHRcdFx0ICogZXhwZWN0ZWQgYml0cyBwZXIgY2hhbm5lbCBwZXIgZ3JhbnVsZSBbaXMgdGhpcyBhbHNvIHJpZ2h0IGZvclxuXHRcdFx0ICogbW9uby9zdGVyZW8sIE1QRUctMS8yID9dXG5cdFx0XHQgKi9cblx0XHRcdGdmYy5waW5mby5tZWFuX2JpdHMgPSBtZWFuX2JpdHMuYml0cyAvIDI7XG5cdFx0XHRnZmMucGluZm8ucmVzdnNpemUgPSBnZmMuUmVzdlNpemU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bGxGcmFtZUJpdHM7XG5cdH07XG5cblx0LyoqXG5cdCAqIHJldHVybnMgdGFyZ19iaXRzOiB0YXJnZXQgbnVtYmVyIG9mIGJpdHMgdG8gdXNlIGZvciAxIGdyYW51bGU8QlI+XG5cdCAqIGV4dHJhX2JpdHM6IGFtb3VudCBleHRyYSBhdmFpbGFibGUgZnJvbSByZXNlcnZvaXI8QlI+XG5cdCAqIE1hcmsgVGF5bG9yIDQvOTlcblx0ICovXG5cdHRoaXMuUmVzdk1heEJpdHMgPSBmdW5jdGlvbihnZnAsIG1lYW5fYml0cywgdGFyZ19iaXRzLCBjYnIpIHtcblx0XHR2YXIgZ2ZjID0gZ2ZwLmludGVybmFsX2ZsYWdzO1xuXHRcdHZhciBhZGRfYml0cztcbiAgICAgICAgdmFyIFJlc3ZTaXplID0gZ2ZjLlJlc3ZTaXplLCBSZXN2TWF4ID0gZ2ZjLlJlc3ZNYXg7XG5cblx0XHQvKiBjb21wZW5zYXRlIHRoZSBzYXZlZCBiaXRzIHVzZWQgaW4gdGhlIDFzdCBncmFudWxlICovXG5cdFx0aWYgKGNiciAhPSAwKVxuXHRcdFx0UmVzdlNpemUgKz0gbWVhbl9iaXRzO1xuXG5cdFx0aWYgKChnZmMuc3Vic3RlcF9zaGFwaW5nICYgMSkgIT0gMClcblx0XHRcdFJlc3ZNYXggKj0gMC45O1xuXG5cdFx0dGFyZ19iaXRzLmJpdHMgPSBtZWFuX2JpdHM7XG5cblx0XHQvKiBleHRyYSBiaXRzIGlmIHRoZSByZXNlcnZvaXIgaXMgYWxtb3N0IGZ1bGwgKi9cblx0XHRpZiAoUmVzdlNpemUgKiAxMCA+IFJlc3ZNYXggKiA5KSB7XG5cdFx0XHRhZGRfYml0cyA9IFJlc3ZTaXplIC0gKFJlc3ZNYXggKiA5KSAvIDEwO1xuXHRcdFx0dGFyZ19iaXRzLmJpdHMgKz0gYWRkX2JpdHM7XG5cdFx0XHRnZmMuc3Vic3RlcF9zaGFwaW5nIHw9IDB4ODA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFkZF9iaXRzID0gMDtcblx0XHRcdGdmYy5zdWJzdGVwX3NoYXBpbmcgJj0gMHg3Zjtcblx0XHRcdC8qXG5cdFx0XHQgKiBidWlsZCB1cCByZXNlcnZvaXIuIHRoaXMgYnVpbGRzIHRoZSByZXNlcnZvaXIgYSBsaXR0bGUgc2xvd2VyXG5cdFx0XHQgKiB0aGFuIEZoRy4gSXQgY291bGQgc2ltcGxlIGJlIG1lYW5fYml0cy8xNSwgYnV0IHRoaXMgd2FzIHJpZ2dlZCB0b1xuXHRcdFx0ICogYWx3YXlzIHByb2R1Y2UgMTAwICh0aGUgb2xkIHZhbHVlKSBhdCAxMjhrYnNcblx0XHRcdCAqL1xuXHRcdFx0aWYgKCFnZnAuZGlzYWJsZV9yZXNlcnZvaXIgJiYgMCA9PSAoZ2ZjLnN1YnN0ZXBfc2hhcGluZyAmIDEpKVxuXHRcdFx0XHR0YXJnX2JpdHMuYml0cyAtPSAuMSAqIG1lYW5fYml0cztcblx0XHR9XG5cblx0XHQvKiBhbW91bnQgZnJvbSB0aGUgcmVzZXJ2b2lyIHdlIGFyZSBhbGxvd2VkIHRvIHVzZS4gSVNPIHNheXMgNi8xMCAqL1xuXHRcdHZhciBleHRyYV9iaXRzID0gKFJlc3ZTaXplIDwgKGdmYy5SZXN2TWF4ICogNikgLyAxMCA/IFJlc3ZTaXplXG5cdFx0XHRcdDogKGdmYy5SZXN2TWF4ICogNikgLyAxMCk7XG5cdFx0ZXh0cmFfYml0cyAtPSBhZGRfYml0cztcblxuXHRcdGlmIChleHRyYV9iaXRzIDwgMClcblx0XHRcdGV4dHJhX2JpdHMgPSAwO1xuXHRcdHJldHVybiBleHRyYV9iaXRzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgYWZ0ZXIgYSBncmFudWxlJ3MgYml0IGFsbG9jYXRpb24uIFJlYWRqdXN0cyB0aGUgc2l6ZSBvZiB0aGVcblx0ICogcmVzZXJ2b2lyIHRvIHJlZmxlY3QgdGhlIGdyYW51bGUncyB1c2FnZS5cblx0ICovXG5cdHRoaXMuUmVzdkFkanVzdCA9IGZ1bmN0aW9uKGdmYywgZ2kpIHtcblx0XHRnZmMuUmVzdlNpemUgLT0gZ2kucGFydDJfM19sZW5ndGggKyBnaS5wYXJ0Ml9sZW5ndGg7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCBhZnRlciBhbGwgZ3JhbnVsZXMgaW4gYSBmcmFtZSBoYXZlIGJlZW4gYWxsb2NhdGVkLiBNYWtlcyBzdXJlIHRoYXRcblx0ICogdGhlIHJlc2Vydm9pciBzaXplIGlzIHdpdGhpbiBsaW1pdHMsIHBvc3NpYmx5IGJ5IGFkZGluZyBzdHVmZmluZyBiaXRzLlxuXHQgKi9cblx0dGhpcy5SZXN2RnJhbWVFbmQgPSBmdW5jdGlvbihnZmMsIG1lYW5fYml0cykge1xuXHRcdHZhciBvdmVyX2JpdHM7XG5cdFx0dmFyIGwzX3NpZGUgPSBnZmMubDNfc2lkZTtcblxuXHRcdGdmYy5SZXN2U2l6ZSArPSBtZWFuX2JpdHMgKiBnZmMubW9kZV9ncjtcblx0XHR2YXIgc3R1ZmZpbmdCaXRzID0gMDtcblx0XHRsM19zaWRlLnJlc3ZEcmFpbl9wb3N0ID0gMDtcblx0XHRsM19zaWRlLnJlc3ZEcmFpbl9wcmUgPSAwO1xuXG5cdFx0Lyogd2UgbXVzdCBiZSBieXRlIGFsaWduZWQgKi9cblx0XHRpZiAoKG92ZXJfYml0cyA9IGdmYy5SZXN2U2l6ZSAlIDgpICE9IDApXG5cdFx0XHRzdHVmZmluZ0JpdHMgKz0gb3Zlcl9iaXRzO1xuXG5cdFx0b3Zlcl9iaXRzID0gKGdmYy5SZXN2U2l6ZSAtIHN0dWZmaW5nQml0cykgLSBnZmMuUmVzdk1heDtcblx0XHRpZiAob3Zlcl9iaXRzID4gMCkge1xuXHRcdFx0YXNzZXJ0JDIzICgwID09IG92ZXJfYml0cyAlIDgpO1xuXHRcdFx0YXNzZXJ0JDIzIChvdmVyX2JpdHMgPj0gMCk7XG5cdFx0XHRzdHVmZmluZ0JpdHMgKz0gb3Zlcl9iaXRzO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0ICogTk9URTogZW5hYmxpbmcgdGhlIE5FV19EUkFJTiBjb2RlIGZpeGVzIHNvbWUgcHJvYmxlbXMgd2l0aCBGaEdcblx0XHQgKiBkZWNvZGVyIHNoaXBwZWQgd2l0aCBNUyBXaW5kb3dzIG9wZXJhdGluZyBzeXN0ZW1zLiBVc2luZyB0aGlzLCBpdCBpc1xuXHRcdCAqIGV2ZW4gcG9zc2libGUgdG8gdXNlIEdhYnJpZWwncyBsYXggYnVmZmVyIGNvbnNpZGVyYXRpb24gYWdhaW4sIHdoaWNoXG5cdFx0ICogYXNzdW1lcywgYW55IGRlY29kZXIgc2hvdWxkIGhhdmUgYSBidWZmZXIgbGFyZ2UgZW5vdWdoIGZvciBhIDMyMCBrYnBzXG5cdFx0ICogZnJhbWUgYXQgMzIga0h6IHNhbXBsZSByYXRlLlxuXHRcdCAqIFxuXHRcdCAqIG9sZCBkcmFpbiBjb2RlOiBsYW1lIC1iMzIwIEJsYWNrQmlyZC53YXYgLS0uIGRvZXMgbm90IHBsYXkgd2l0aFxuXHRcdCAqIEdyYXBoRWRpdC5leGUgdXNpbmcgRmhHIGRlY29kZXIgVjEuNSBCdWlsZCA1MFxuXHRcdCAqIFxuXHRcdCAqIG5ldyBkcmFpbiBjb2RlOiBsYW1lIC1iMzIwIEJsYWNrQmlyZC53YXYgLS0uIHBsYXlzIGZpbmUgd2l0aFxuXHRcdCAqIEdyYXBoRWRpdC5leGUgdXNpbmcgRmhHIGRlY29kZXIgVjEuNSBCdWlsZCA1MFxuXHRcdCAqIFxuXHRcdCAqIFJvYmVydCBIZWdlbWFubiwgMjAxMC0wMi0xMy5cblx0XHQgKi9cblx0XHQvKlxuXHRcdCAqIGRyYWluIGFzIG1hbnkgYml0cyBhcyBwb3NzaWJsZSBpbnRvIHByZXZpb3VzIGZyYW1lIGFuY2lsbGFyeSBkYXRhIEluXG5cdFx0ICogcGFydGljdWxhciwgaW4gVkJSIG1vZGUgUmVzdk1heCBtYXkgaGF2ZSBjaGFuZ2VkLCBhbmQgd2UgaGF2ZSB0byBtYWtlXG5cdFx0ICogc3VyZSBtYWluX2RhdGFfYmVnaW4gZG9lcyBub3QgY3JlYXRlIGEgcmVzZXJ2b2lyIGJpZ2dlciB0aGFuIFJlc3ZNYXhcblx0XHQgKiBtdCA0LzAwXG5cdFx0ICovXG5cdFx0e1xuXHRcdFx0dmFyIG1kYl9ieXRlcyA9IE1hdGgubWluKGwzX3NpZGUubWFpbl9kYXRhX2JlZ2luICogOCwgc3R1ZmZpbmdCaXRzKSAvIDg7XG5cdFx0XHRsM19zaWRlLnJlc3ZEcmFpbl9wcmUgKz0gOCAqIG1kYl9ieXRlcztcblx0XHRcdHN0dWZmaW5nQml0cyAtPSA4ICogbWRiX2J5dGVzO1xuXHRcdFx0Z2ZjLlJlc3ZTaXplIC09IDggKiBtZGJfYnl0ZXM7XG5cdFx0XHRsM19zaWRlLm1haW5fZGF0YV9iZWdpbiAtPSBtZGJfYnl0ZXM7XG5cdFx0fVxuXHRcdC8qIGRyYWluIHRoZSByZXN0IGludG8gdGhpcyBmcmFtZXMgYW5jaWxsYXJ5IGRhdGEgKi9cblx0XHRsM19zaWRlLnJlc3ZEcmFpbl9wb3N0ICs9IHN0dWZmaW5nQml0cztcblx0XHRnZmMuUmVzdlNpemUgLT0gc3R1ZmZpbmdCaXRzO1xuXHR9O1xufVxuXG52YXIgUmVzZXJ2b2lyXzEgPSBSZXNlcnZvaXIkMTtcblxuZnVuY3Rpb24gVmVyc2lvbigpIHtcblxuICAgIC8qKlxuICAgICAqIFVSTCBmb3IgdGhlIExBTUUgd2Vic2l0ZS5cbiAgICAgKi9cbiAgICB2YXIgTEFNRV9VUkwgPSBcImh0dHA6Ly93d3cubXAzZGV2Lm9yZy9cIjtcblxuICAgIC8qKlxuICAgICAqIE1ham9yIHZlcnNpb24gbnVtYmVyLlxuICAgICAqL1xuICAgIHZhciBMQU1FX01BSk9SX1ZFUlNJT04gPSAzO1xuICAgIC8qKlxuICAgICAqIE1pbm9yIHZlcnNpb24gbnVtYmVyLlxuICAgICAqL1xuICAgIHZhciBMQU1FX01JTk9SX1ZFUlNJT04gPSA5ODtcbiAgICAvKipcbiAgICAgKiBQYXRjaCBsZXZlbC5cbiAgICAgKi9cbiAgICB2YXIgTEFNRV9QQVRDSF9WRVJTSU9OID0gNDtcblxuICAgIC8qKlxuICAgICAqIE1ham9yIHZlcnNpb24gbnVtYmVyLlxuICAgICAqL1xuICAgIHZhciBQU1lfTUFKT1JfVkVSU0lPTiA9IDA7XG4gICAgLyoqXG4gICAgICogTWlub3IgdmVyc2lvbiBudW1iZXIuXG4gICAgICovXG4gICAgdmFyIFBTWV9NSU5PUl9WRVJTSU9OID0gOTM7XG5cbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyB3aGljaCBkZXNjcmliZXMgdGhlIHZlcnNpb24gb2YgTEFNRS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc3RyaW5nIHdoaWNoIGRlc2NyaWJlcyB0aGUgdmVyc2lvbiBvZiBMQU1FXG4gICAgICovXG4gICAgdGhpcy5nZXRMYW1lVmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcHJpbWFyeSB0byB3cml0ZSBzY3JlZW4gcmVwb3J0c1xuICAgICAgICByZXR1cm4gKExBTUVfTUFKT1JfVkVSU0lPTiArIFwiLlwiICsgTEFNRV9NSU5PUl9WRVJTSU9OICsgXCIuXCIgKyBMQU1FX1BBVENIX1ZFUlNJT04pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hvcnQgdmVyc2lvbiBvZiB0aGUgTEFNRSB2ZXJzaW9uIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2hvcnQgdmVyc2lvbiBvZiB0aGUgTEFNRSB2ZXJzaW9uIHN0cmluZ1xuICAgICAqL1xuICAgIHRoaXMuZ2V0TGFtZVNob3J0VmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQWRkaW5nIGRhdGUgYW5kIHRpbWUgdG8gdmVyc2lvbiBzdHJpbmcgbWFrZXMgaXQgaGFyZGVyIGZvciBvdXRwdXRcbiAgICAgICAgLy8gdmFsaWRhdGlvblxuICAgICAgICByZXR1cm4gKExBTUVfTUFKT1JfVkVSU0lPTiArIFwiLlwiICsgTEFNRV9NSU5PUl9WRVJTSU9OICsgXCIuXCIgKyBMQU1FX1BBVENIX1ZFUlNJT04pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hvcnRlc3QgdmVyc2lvbiBvZiB0aGUgTEFNRSB2ZXJzaW9uIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2hvcnRlc3QgdmVyc2lvbiBvZiB0aGUgTEFNRSB2ZXJzaW9uIHN0cmluZ1xuICAgICAqL1xuICAgIHRoaXMuZ2V0TGFtZVZlcnlTaG9ydFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEFkZGluZyBkYXRlIGFuZCB0aW1lIHRvIHZlcnNpb24gc3RyaW5nIG1ha2VzIGl0IGhhcmRlciBmb3Igb3V0cHV0XG4gICAgICAgIHJldHVybiAoXCJMQU1FXCIgKyBMQU1FX01BSk9SX1ZFUlNJT04gKyBcIi5cIiArIExBTUVfTUlOT1JfVkVSU0lPTiArIFwiclwiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RyaW5nIHdoaWNoIGRlc2NyaWJlcyB0aGUgdmVyc2lvbiBvZiBHUFNZQ0hPXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHN0cmluZyB3aGljaCBkZXNjcmliZXMgdGhlIHZlcnNpb24gb2YgR1BTWUNIT1xuICAgICAqL1xuICAgIHRoaXMuZ2V0UHN5VmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChQU1lfTUFKT1JfVkVSU0lPTiArIFwiLlwiICsgUFNZX01JTk9SX1ZFUlNJT04pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgd2hpY2ggaXMgYSBVUkwgZm9yIHRoZSBMQU1FIHdlYnNpdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHN0cmluZyB3aGljaCBpcyBhIFVSTCBmb3IgdGhlIExBTUUgd2Vic2l0ZVxuICAgICAqL1xuICAgIHRoaXMuZ2V0TGFtZVVybCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIExBTUVfVVJMO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBRdWl0ZSB1c2VsZXNzIGZvciBhIGphdmEgdmVyc2lvbiwgaG93ZXZlciB3ZSBhcmUgY29tcGF0aWJsZSA7LSlcbiAgICAgKlxuICAgICAqIEByZXR1cm4gXCIzMmJpdHNcIlxuICAgICAqL1xuICAgIHRoaXMuZ2V0TGFtZU9zQml0bmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiMzJiaXRzXCI7XG4gICAgfTtcblxufVxuXG52YXIgVmVyc2lvbl8xID0gVmVyc2lvbjtcblxudmFyIFN5c3RlbSQyMiA9IGNvbW1vbi5TeXN0ZW07XG52YXIgVmJyTW9kZSQyMiA9IGNvbW1vbi5WYnJNb2RlO1xudmFyIFNob3J0QmxvY2skMjIgPSBjb21tb24uU2hvcnRCbG9jaztcbnZhciBBcnJheXMkMjIgPSBjb21tb24uQXJyYXlzO1xudmFyIG5ld19ieXRlJDIyID0gY29tbW9uLm5ld19ieXRlO1xudmFyIGFzc2VydCQyNCA9IGNvbW1vbi5hc3NlcnQ7XG5cbi8qKlxuICogQSBWYnIgaGVhZGVyIG1heSBiZSBwcmVzZW50IGluIHRoZSBhbmNpbGxhcnkgZGF0YSBmaWVsZCBvZiB0aGUgZmlyc3QgZnJhbWUgb2ZcbiAqIGFuIG1wMyBiaXRzdHJlYW08QlI+XG4gKiBUaGUgVmJyIGhlYWRlciAob3B0aW9uYWxseSkgY29udGFpbnNcbiAqIDxVTD5cbiAqIDxMST5mcmFtZXMgdG90YWwgbnVtYmVyIG9mIGF1ZGlvIGZyYW1lcyBpbiB0aGUgYml0c3RyZWFtXG4gKiA8TEk+Ynl0ZXMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBiaXRzdHJlYW1cbiAqIDxMST50b2MgdGFibGUgb2YgY29udGVudHNcbiAqIDwvVUw+XG4gKlxuICogdG9jICh0YWJsZSBvZiBjb250ZW50cykgZ2l2ZXMgc2VlayBwb2ludHMgZm9yIHJhbmRvbSBhY2Nlc3MuPEJSPlxuICogVGhlIGl0aCBlbnRyeSBkZXRlcm1pbmVzIHRoZSBzZWVrIHBvaW50IGZvciBpLXBlcmNlbnQgZHVyYXRpb24uPEJSPlxuICogc2VlayBwb2ludCBpbiBieXRlcyA9ICh0b2NbaV0vMjU2LjApICogdG90YWxfYml0c3RyZWFtX2J5dGVzPEJSPlxuICogZS5nLiBoYWxmIGR1cmF0aW9uIHNlZWsgcG9pbnQgPSAodG9jWzUwXS8yNTYuMCkgKiB0b3RhbF9iaXRzdHJlYW1fYnl0ZXNcbiAqL1xuVkJSVGFnLk5VTVRPQ0VOVFJJRVMgPSAxMDA7XG5WQlJUYWcuTUFYRlJBTUVTSVpFID0gMjg4MDtcblxuZnVuY3Rpb24gVkJSVGFnKCkge1xuXG4gICAgdmFyIGxhbWU7XG4gICAgdmFyIGJzO1xuICAgIHZhciB2O1xuXG4gICAgdGhpcy5zZXRNb2R1bGVzID0gZnVuY3Rpb24gKF9sYW1lLCBfYnMsIF92KSB7XG4gICAgICAgIGxhbWUgPSBfbGFtZTtcbiAgICAgICAgYnMgPSBfYnM7XG4gICAgICAgIHYgPSBfdjtcbiAgICB9O1xuXG4gICAgdmFyIEZSQU1FU19GTEFHID0gMHgwMDAxO1xuICAgIHZhciBCWVRFU19GTEFHID0gMHgwMDAyO1xuICAgIHZhciBUT0NfRkxBRyA9IDB4MDAwNDtcbiAgICB2YXIgVkJSX1NDQUxFX0ZMQUcgPSAweDAwMDg7XG5cbiAgICB2YXIgTlVNVE9DRU5UUklFUyA9IFZCUlRhZy5OVU1UT0NFTlRSSUVTO1xuXG4gICAgLyoqXG4gICAgICogKDB4QjQwKSB0aGUgbWF4IGZyZWVmb3JtYXQgNjQwIDMya0h6IGZyYW1lc2l6ZS5cbiAgICAgKi9cbiAgICB2YXIgTUFYRlJBTUVTSVpFID0gVkJSVGFnLk1BWEZSQU1FU0laRTtcblxuICAgIC8qKlxuICAgICAqIDxQUkU+XG4gICAgICogICAgNCBieXRlcyBmb3IgSGVhZGVyIFRhZ1xuICAgICAqICAgIDQgYnl0ZXMgZm9yIEhlYWRlciBGbGFnc1xuICAgICAqICAxMDAgYnl0ZXMgZm9yIGVudHJ5ICh0b2MpXG4gICAgICogICAgNCBieXRlcyBmb3IgZnJhbWUgc2l6ZVxuICAgICAqICAgIDQgYnl0ZXMgZm9yIHN0cmVhbSBzaXplXG4gICAgICogICAgNCBieXRlcyBmb3IgVkJSIHNjYWxlLiBhIFZCUiBxdWFsaXR5IGluZGljYXRvcjogMD1iZXN0IDEwMD13b3JzdFxuICAgICAqICAgMjAgYnl0ZXMgZm9yIExBTUUgdGFnLiAgZm9yIGV4YW1wbGUsIFwiTEFNRTMuMTIgKGJldGEgNilcIlxuICAgICAqIF9fX19fX19fX19fXG4gICAgICogIDE0MCBieXRlc1xuICAgICAqIDwvUFJFPlxuICAgICAqL1xuICAgIHZhciBWQlJIRUFERVJTSVpFID0gKE5VTVRPQ0VOVFJJRVMgKyA0ICsgNCArIDQgKyA0ICsgNCk7XG5cbiAgICB2YXIgTEFNRUhFQURFUlNJWkUgPSAoVkJSSEVBREVSU0laRSArIDkgKyAxICsgMSArIDhcbiAgICArIDEgKyAxICsgMyArIDEgKyAxICsgMiArIDQgKyAyICsgMik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgWGluZyBoZWFkZXIgTVBFRy0xLCBiaXQgcmF0ZSBpbiBrYnBzLlxuICAgICAqL1xuICAgIHZhciBYSU5HX0JJVFJBVEUxID0gMTI4O1xuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSBYaW5nIGhlYWRlciBNUEVHLTIsIGJpdCByYXRlIGluIGticHMuXG4gICAgICovXG4gICAgdmFyIFhJTkdfQklUUkFURTIgPSA2NDtcbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgWGluZyBoZWFkZXIgTVBFRy0yLjUsIGJpdCByYXRlIGluIGticHMuXG4gICAgICovXG4gICAgdmFyIFhJTkdfQklUUkFURTI1ID0gMzI7XG5cbiAgICAvKipcbiAgICAgKiBJU08tODg1OS0xIGNoYXJzZXQgZm9yIGJ5dGUgdG8gc3RyaW5nIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgdmFyIElTT184ODU5XzEgPSBudWxsOyAvL0NoYXJzZXQuZm9yTmFtZShcIklTTy04ODU5LTFcIik7XG5cbiAgICAvKipcbiAgICAgKiBWQlIgaGVhZGVyIG1hZ2ljIHN0cmluZy5cbiAgICAgKi9cbiAgICB2YXIgVkJSVGFnMCA9IFwiWGluZ1wiO1xuICAgIC8qKlxuICAgICAqIFZCUiBoZWFkZXIgbWFnaWMgc3RyaW5nIChWQlIgPT0gVkJSTW9kZS52YnJfb2ZmKS5cbiAgICAgKi9cbiAgICB2YXIgVkJSVGFnMSA9IFwiSW5mb1wiO1xuXG4gICAgLyoqXG4gICAgICogTG9va3VwIHRhYmxlIGZvciBmYXN0IENSQy0xNiBjb21wdXRhdGlvbi4gVXNlcyB0aGUgcG9seW5vbWlhbFxuICAgICAqIHheMTYreF4xNSt4XjIrMVxuICAgICAqL1xuICAgIHZhciBjcmMxNkxvb2t1cCA9IFsweDAwMDAsIDB4QzBDMSwgMHhDMTgxLCAweDAxNDAsXG4gICAgICAgIDB4QzMwMSwgMHgwM0MwLCAweDAyODAsIDB4QzI0MSwgMHhDNjAxLCAweDA2QzAsIDB4MDc4MCwgMHhDNzQxLFxuICAgICAgICAweDA1MDAsIDB4QzVDMSwgMHhDNDgxLCAweDA0NDAsIDB4Q0MwMSwgMHgwQ0MwLCAweDBEODAsIDB4Q0Q0MSxcbiAgICAgICAgMHgwRjAwLCAweENGQzEsIDB4Q0U4MSwgMHgwRTQwLCAweDBBMDAsIDB4Q0FDMSwgMHhDQjgxLCAweDBCNDAsXG4gICAgICAgIDB4QzkwMSwgMHgwOUMwLCAweDA4ODAsIDB4Qzg0MSwgMHhEODAxLCAweDE4QzAsIDB4MTk4MCwgMHhEOTQxLFxuICAgICAgICAweDFCMDAsIDB4REJDMSwgMHhEQTgxLCAweDFBNDAsIDB4MUUwMCwgMHhERUMxLCAweERGODEsIDB4MUY0MCxcbiAgICAgICAgMHhERDAxLCAweDFEQzAsIDB4MUM4MCwgMHhEQzQxLCAweDE0MDAsIDB4RDRDMSwgMHhENTgxLCAweDE1NDAsXG4gICAgICAgIDB4RDcwMSwgMHgxN0MwLCAweDE2ODAsIDB4RDY0MSwgMHhEMjAxLCAweDEyQzAsIDB4MTM4MCwgMHhEMzQxLFxuICAgICAgICAweDExMDAsIDB4RDFDMSwgMHhEMDgxLCAweDEwNDAsIDB4RjAwMSwgMHgzMEMwLCAweDMxODAsIDB4RjE0MSxcbiAgICAgICAgMHgzMzAwLCAweEYzQzEsIDB4RjI4MSwgMHgzMjQwLCAweDM2MDAsIDB4RjZDMSwgMHhGNzgxLCAweDM3NDAsXG4gICAgICAgIDB4RjUwMSwgMHgzNUMwLCAweDM0ODAsIDB4RjQ0MSwgMHgzQzAwLCAweEZDQzEsIDB4RkQ4MSwgMHgzRDQwLFxuICAgICAgICAweEZGMDEsIDB4M0ZDMCwgMHgzRTgwLCAweEZFNDEsIDB4RkEwMSwgMHgzQUMwLCAweDNCODAsIDB4RkI0MSxcbiAgICAgICAgMHgzOTAwLCAweEY5QzEsIDB4Rjg4MSwgMHgzODQwLCAweDI4MDAsIDB4RThDMSwgMHhFOTgxLCAweDI5NDAsXG4gICAgICAgIDB4RUIwMSwgMHgyQkMwLCAweDJBODAsIDB4RUE0MSwgMHhFRTAxLCAweDJFQzAsIDB4MkY4MCwgMHhFRjQxLFxuICAgICAgICAweDJEMDAsIDB4RURDMSwgMHhFQzgxLCAweDJDNDAsIDB4RTQwMSwgMHgyNEMwLCAweDI1ODAsIDB4RTU0MSxcbiAgICAgICAgMHgyNzAwLCAweEU3QzEsIDB4RTY4MSwgMHgyNjQwLCAweDIyMDAsIDB4RTJDMSwgMHhFMzgxLCAweDIzNDAsXG4gICAgICAgIDB4RTEwMSwgMHgyMUMwLCAweDIwODAsIDB4RTA0MSwgMHhBMDAxLCAweDYwQzAsIDB4NjE4MCwgMHhBMTQxLFxuICAgICAgICAweDYzMDAsIDB4QTNDMSwgMHhBMjgxLCAweDYyNDAsIDB4NjYwMCwgMHhBNkMxLCAweEE3ODEsIDB4Njc0MCxcbiAgICAgICAgMHhBNTAxLCAweDY1QzAsIDB4NjQ4MCwgMHhBNDQxLCAweDZDMDAsIDB4QUNDMSwgMHhBRDgxLCAweDZENDAsXG4gICAgICAgIDB4QUYwMSwgMHg2RkMwLCAweDZFODAsIDB4QUU0MSwgMHhBQTAxLCAweDZBQzAsIDB4NkI4MCwgMHhBQjQxLFxuICAgICAgICAweDY5MDAsIDB4QTlDMSwgMHhBODgxLCAweDY4NDAsIDB4NzgwMCwgMHhCOEMxLCAweEI5ODEsIDB4Nzk0MCxcbiAgICAgICAgMHhCQjAxLCAweDdCQzAsIDB4N0E4MCwgMHhCQTQxLCAweEJFMDEsIDB4N0VDMCwgMHg3RjgwLCAweEJGNDEsXG4gICAgICAgIDB4N0QwMCwgMHhCREMxLCAweEJDODEsIDB4N0M0MCwgMHhCNDAxLCAweDc0QzAsIDB4NzU4MCwgMHhCNTQxLFxuICAgICAgICAweDc3MDAsIDB4QjdDMSwgMHhCNjgxLCAweDc2NDAsIDB4NzIwMCwgMHhCMkMxLCAweEIzODEsIDB4NzM0MCxcbiAgICAgICAgMHhCMTAxLCAweDcxQzAsIDB4NzA4MCwgMHhCMDQxLCAweDUwMDAsIDB4OTBDMSwgMHg5MTgxLCAweDUxNDAsXG4gICAgICAgIDB4OTMwMSwgMHg1M0MwLCAweDUyODAsIDB4OTI0MSwgMHg5NjAxLCAweDU2QzAsIDB4NTc4MCwgMHg5NzQxLFxuICAgICAgICAweDU1MDAsIDB4OTVDMSwgMHg5NDgxLCAweDU0NDAsIDB4OUMwMSwgMHg1Q0MwLCAweDVEODAsIDB4OUQ0MSxcbiAgICAgICAgMHg1RjAwLCAweDlGQzEsIDB4OUU4MSwgMHg1RTQwLCAweDVBMDAsIDB4OUFDMSwgMHg5QjgxLCAweDVCNDAsXG4gICAgICAgIDB4OTkwMSwgMHg1OUMwLCAweDU4ODAsIDB4OTg0MSwgMHg4ODAxLCAweDQ4QzAsIDB4NDk4MCwgMHg4OTQxLFxuICAgICAgICAweDRCMDAsIDB4OEJDMSwgMHg4QTgxLCAweDRBNDAsIDB4NEUwMCwgMHg4RUMxLCAweDhGODEsIDB4NEY0MCxcbiAgICAgICAgMHg4RDAxLCAweDREQzAsIDB4NEM4MCwgMHg4QzQxLCAweDQ0MDAsIDB4ODRDMSwgMHg4NTgxLCAweDQ1NDAsXG4gICAgICAgIDB4ODcwMSwgMHg0N0MwLCAweDQ2ODAsIDB4ODY0MSwgMHg4MjAxLCAweDQyQzAsIDB4NDM4MCwgMHg4MzQxLFxuICAgICAgICAweDQxMDAsIDB4ODFDMSwgMHg4MDgxLCAweDQwNDBdO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogUm9iZXJ0IEhlZ2VtYW5uIDIwMDEtMDEtMTdcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBhZGRWYnIodiwgYml0cmF0ZSkge1xuICAgICAgICB2Lm5WYnJOdW1GcmFtZXMrKztcbiAgICAgICAgdi5zdW0gKz0gYml0cmF0ZTtcbiAgICAgICAgdi5zZWVuKys7XG5cbiAgICAgICAgaWYgKHYuc2VlbiA8IHYud2FudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYucG9zIDwgdi5zaXplKSB7XG4gICAgICAgICAgICB2LmJhZ1t2LnBvc10gPSB2LnN1bTtcbiAgICAgICAgICAgIHYucG9zKys7XG4gICAgICAgICAgICB2LnNlZW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2LnBvcyA9PSB2LnNpemUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdi5zaXplOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2LmJhZ1tpIC8gMl0gPSB2LmJhZ1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYud2FudCAqPSAyO1xuICAgICAgICAgICAgdi5wb3MgLz0gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHhpbmdTZWVrVGFibGUodiwgdCkge1xuICAgICAgICBpZiAodi5wb3MgPD0gMClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IE5VTVRPQ0VOVFJJRVM7ICsraSkge1xuICAgICAgICAgICAgdmFyIGogPSBpIC8gTlVNVE9DRU5UUklFUywgYWN0LCBzdW07XG4gICAgICAgICAgICB2YXIgaW5keCA9IDAgfCAoTWF0aC5mbG9vcihqICogdi5wb3MpKTtcbiAgICAgICAgICAgIGlmIChpbmR4ID4gdi5wb3MgLSAxKVxuICAgICAgICAgICAgICAgIGluZHggPSB2LnBvcyAtIDE7XG4gICAgICAgICAgICBhY3QgPSB2LmJhZ1tpbmR4XTtcbiAgICAgICAgICAgIHN1bSA9IHYuc3VtO1xuICAgICAgICAgICAgdmFyIHNlZWtfcG9pbnQgPSAwIHwgKDI1Ni4gKiBhY3QgLyBzdW0pO1xuICAgICAgICAgICAgaWYgKHNlZWtfcG9pbnQgPiAyNTUpXG4gICAgICAgICAgICAgICAgc2Vla19wb2ludCA9IDI1NTtcbiAgICAgICAgICAgIHRbaV0gPSAweGZmICYgc2Vla19wb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBWQlIgZW50cnksIHVzZWQgdG8gZmlsbCB0aGUgVkJSIFRPQyBlbnRyaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdmcFxuICAgICAqICAgICAgICAgICAgZ2xvYmFsIGZsYWdzXG4gICAgICovXG4gICAgdGhpcy5hZGRWYnJGcmFtZSA9IGZ1bmN0aW9uIChnZnApIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGticHMgPSBUYWJsZXMuYml0cmF0ZV90YWJsZVtnZnAudmVyc2lvbl1bZ2ZjLmJpdHJhdGVfaW5kZXhdO1xuICAgICAgICBhc3NlcnQkMjQoZ2ZjLlZCUl9zZWVrX3RhYmxlLmJhZyAhPSBudWxsKTtcbiAgICAgICAgYWRkVmJyKGdmYy5WQlJfc2Vla190YWJsZSwga2Jwcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYmlnIGVuZGlhbiBpbnRlZ2VyICg0LWJ5dGVzKSBmcm9tIGhlYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBidWZcbiAgICAgKiAgICAgICAgICAgIGhlYWRlciBjb250YWluaW5nIHRoZSBpbnRlZ2VyXG4gICAgICogQHBhcmFtIGJ1ZlBvc1xuICAgICAqICAgICAgICAgICAgb2Zmc2V0IGludG8gdGhlIGhlYWRlclxuICAgICAqIEByZXR1cm4gZXh0cmFjdGVkIGludGVnZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleHRyYWN0SW50ZWdlcihidWYsIGJ1ZlBvcykge1xuICAgICAgICB2YXIgeCA9IGJ1ZltidWZQb3MgKyAwXSAmIDB4ZmY7XG4gICAgICAgIHggPDw9IDg7XG4gICAgICAgIHggfD0gYnVmW2J1ZlBvcyArIDFdICYgMHhmZjtcbiAgICAgICAgeCA8PD0gODtcbiAgICAgICAgeCB8PSBidWZbYnVmUG9zICsgMl0gJiAweGZmO1xuICAgICAgICB4IDw8PSA4O1xuICAgICAgICB4IHw9IGJ1ZltidWZQb3MgKyAzXSAmIDB4ZmY7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyaXRlIGJpZyBlbmRpYW4gaW50ZWdlciAoNC1ieXRlcykgaW4gdGhlIGhlYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBidWZcbiAgICAgKiAgICAgICAgICAgIGhlYWRlciB0byB3cml0ZSB0aGUgaW50ZWdlciBpbnRvXG4gICAgICogQHBhcmFtIGJ1ZlBvc1xuICAgICAqICAgICAgICAgICAgb2Zmc2V0IGludG8gdGhlIGhlYWRlclxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqICAgICAgICAgICAgaW50ZWdlciB2YWx1ZSB0byB3cml0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludGVnZXIoYnVmLCBidWZQb3MsIHZhbHVlKSB7XG4gICAgICAgIGJ1ZltidWZQb3MgKyAwXSA9IDB4ZmYgJiAoKHZhbHVlID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBidWZbYnVmUG9zICsgMV0gPSAweGZmICYgKCh2YWx1ZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgYnVmW2J1ZlBvcyArIDJdID0gMHhmZiAmICgodmFsdWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgYnVmW2J1ZlBvcyArIDNdID0gMHhmZiAmICh2YWx1ZSAmIDB4ZmYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyaXRlIGJpZyBlbmRpYW4gc2hvcnQgKDItYnl0ZXMpIGluIHRoZSBoZWFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVmXG4gICAgICogICAgICAgICAgICBoZWFkZXIgdG8gd3JpdGUgdGhlIGludGVnZXIgaW50b1xuICAgICAqIEBwYXJhbSBidWZQb3NcbiAgICAgKiAgICAgICAgICAgIG9mZnNldCBpbnRvIHRoZSBoZWFkZXJcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiAgICAgICAgICAgIGludGVnZXIgdmFsdWUgdG8gd3JpdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVTaG9ydChidWYsIGJ1ZlBvcywgdmFsdWUpIHtcbiAgICAgICAgYnVmW2J1ZlBvcyArIDBdID0gMHhmZiAmICgodmFsdWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgYnVmW2J1ZlBvcyArIDFdID0gMHhmZiAmICh2YWx1ZSAmIDB4ZmYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBtYWdpYyBzdHJpbmdzIChYaW5nL0luZm8pLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1ZlxuICAgICAqICAgICAgICAgICAgaGVhZGVyIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIGJ1ZlBvc1xuICAgICAqICAgICAgICAgICAgaGVhZGVyIG9mZnNldCB0byBjaGVja1xuICAgICAqIEByZXR1cm4gbWFnaWMgc3RyaW5nIGZvdW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNWYnJUYWcoYnVmLCBidWZQb3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmcoYnVmLCBidWZQb3MsIFZCUlRhZzAubGVuZ3RoKCksIElTT184ODU5XzEpXG4gICAgICAgICAgICAgICAgLmVxdWFscyhWQlJUYWcwKVxuICAgICAgICAgICAgfHwgbmV3IFN0cmluZyhidWYsIGJ1ZlBvcywgVkJSVGFnMS5sZW5ndGgoKSwgSVNPXzg4NTlfMSlcbiAgICAgICAgICAgICAgICAuZXF1YWxzKFZCUlRhZzEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoaWZ0SW5CaXRzVmFsdWUoeCwgbiwgdikge1xuICAgICAgICByZXR1cm4gMHhmZiAmICgoeCA8PCBuKSB8ICh2ICYgfigtMSA8PCBuKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCB0aGUgTVAzIGhlYWRlciB1c2luZyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdsb2JhbCBmbGFncy5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiMTAwMHB4LU1wM2ZpbGVzdHJ1Y3R1cmUuc3ZnLnBuZ1wiPlxuICAgICAqXG4gICAgICogQHBhcmFtIGdmcFxuICAgICAqICAgICAgICAgICAgZ2xvYmFsIGZsYWdzXG4gICAgICogQHBhcmFtIGJ1ZmZlclxuICAgICAqICAgICAgICAgICAgaGVhZGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0TGFtZVRhZ0ZyYW1lSGVhZGVyKGdmcCwgYnVmZmVyKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgLy8gTVAzIFN5bmMgV29yZFxuICAgICAgICBidWZmZXJbMF0gPSBzaGlmdEluQml0c1ZhbHVlKGJ1ZmZlclswXSwgOCwgMHhmZik7XG5cbiAgICAgICAgYnVmZmVyWzFdID0gc2hpZnRJbkJpdHNWYWx1ZShidWZmZXJbMV0sIDMsIDcpO1xuICAgICAgICBidWZmZXJbMV0gPSBzaGlmdEluQml0c1ZhbHVlKGJ1ZmZlclsxXSwgMSxcbiAgICAgICAgICAgIChnZnAub3V0X3NhbXBsZXJhdGUgPCAxNjAwMCkgPyAwIDogMSk7XG4gICAgICAgIC8vIFZlcnNpb25cbiAgICAgICAgYnVmZmVyWzFdID0gc2hpZnRJbkJpdHNWYWx1ZShidWZmZXJbMV0sIDEsIGdmcC52ZXJzaW9uKTtcbiAgICAgICAgLy8gMDEgPT0gTGF5ZXIgM1xuICAgICAgICBidWZmZXJbMV0gPSBzaGlmdEluQml0c1ZhbHVlKGJ1ZmZlclsxXSwgMiwgNCAtIDMpO1xuICAgICAgICAvLyBFcnJvciBwcm90ZWN0aW9uXG4gICAgICAgIGJ1ZmZlclsxXSA9IHNoaWZ0SW5CaXRzVmFsdWUoYnVmZmVyWzFdLCAxLCAoIWdmcC5lcnJvcl9wcm90ZWN0aW9uKSA/IDFcbiAgICAgICAgICAgIDogMCk7XG5cbiAgICAgICAgLy8gQml0IHJhdGVcbiAgICAgICAgYnVmZmVyWzJdID0gc2hpZnRJbkJpdHNWYWx1ZShidWZmZXJbMl0sIDQsIGdmYy5iaXRyYXRlX2luZGV4KTtcbiAgICAgICAgLy8gRnJlcXVlbmN5XG4gICAgICAgIGJ1ZmZlclsyXSA9IHNoaWZ0SW5CaXRzVmFsdWUoYnVmZmVyWzJdLCAyLCBnZmMuc2FtcGxlcmF0ZV9pbmRleCk7XG4gICAgICAgIC8vIFBhZC4gQml0XG4gICAgICAgIGJ1ZmZlclsyXSA9IHNoaWZ0SW5CaXRzVmFsdWUoYnVmZmVyWzJdLCAxLCAwKTtcbiAgICAgICAgLy8gUHJpdi4gQml0XG4gICAgICAgIGJ1ZmZlclsyXSA9IHNoaWZ0SW5CaXRzVmFsdWUoYnVmZmVyWzJdLCAxLCBnZnAuZXh0ZW5zaW9uKTtcblxuICAgICAgICAvLyBNb2RlXG4gICAgICAgIGJ1ZmZlclszXSA9IHNoaWZ0SW5CaXRzVmFsdWUoYnVmZmVyWzNdLCAyLCBnZnAubW9kZS5vcmRpbmFsKCkpO1xuICAgICAgICAvLyBNb2RlIGV4dGVuc2lvbiAoVXNlZCB3aXRoIEpvaW50IFN0ZXJlbylcbiAgICAgICAgYnVmZmVyWzNdID0gc2hpZnRJbkJpdHNWYWx1ZShidWZmZXJbM10sIDIsIGdmYy5tb2RlX2V4dCk7XG4gICAgICAgIC8vIENvcHlcbiAgICAgICAgYnVmZmVyWzNdID0gc2hpZnRJbkJpdHNWYWx1ZShidWZmZXJbM10sIDEsIGdmcC5jb3B5cmlnaHQpO1xuICAgICAgICAvLyBPcmlnaW5hbFxuICAgICAgICBidWZmZXJbM10gPSBzaGlmdEluQml0c1ZhbHVlKGJ1ZmZlclszXSwgMSwgZ2ZwLm9yaWdpbmFsKTtcbiAgICAgICAgLy8gRW1waGFzaXNcbiAgICAgICAgYnVmZmVyWzNdID0gc2hpZnRJbkJpdHNWYWx1ZShidWZmZXJbM10sIDIsIGdmcC5lbXBoYXNpcyk7XG5cbiAgICAgICAgLyogdGhlIGRlZmF1bHQgVkJSIGhlYWRlci4gNDgga2JwcyBsYXllciBJSUksIG5vIHBhZGRpbmcsIG5vIGNyYyAqL1xuICAgICAgICAvKiBidXQgc2FtcGxpbmcgZnJlcSwgbW9kZSBhbmQgY29weXJpZ2h0L2NvcHkgcHJvdGVjdGlvbiB0YWtlbiAqL1xuICAgICAgICAvKiBmcm9tIGZpcnN0IHZhbGlkIGZyYW1lICovXG4gICAgICAgIGJ1ZmZlclswXSA9IDB4ZmY7XG4gICAgICAgIHZhciBhYnl0ZSA9IDB4ZmYgJiAoYnVmZmVyWzFdICYgMHhmMSk7XG4gICAgICAgIHZhciBiaXRyYXRlO1xuICAgICAgICBpZiAoMSA9PSBnZnAudmVyc2lvbikge1xuICAgICAgICAgICAgYml0cmF0ZSA9IFhJTkdfQklUUkFURTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZ2ZwLm91dF9zYW1wbGVyYXRlIDwgMTYwMDApXG4gICAgICAgICAgICAgICAgYml0cmF0ZSA9IFhJTkdfQklUUkFURTI1O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJpdHJhdGUgPSBYSU5HX0JJVFJBVEUyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdmcC5WQlIgPT0gVmJyTW9kZSQyMi52YnJfb2ZmKVxuICAgICAgICAgICAgYml0cmF0ZSA9IGdmcC5icmF0ZTtcblxuICAgICAgICB2YXIgYmJ5dGU7XG4gICAgICAgIGlmIChnZnAuZnJlZV9mb3JtYXQpXG4gICAgICAgICAgICBiYnl0ZSA9IDB4MDA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJieXRlID0gMHhmZiAmICgxNiAqIGxhbWUuQml0cmF0ZUluZGV4KGJpdHJhdGUsIGdmcC52ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICBnZnAub3V0X3NhbXBsZXJhdGUpKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBVc2UgYXMgbXVjaCBvZiB0aGUgaW5mbyBmcm9tIHRoZSByZWFsIGZyYW1lcyBpbiB0aGUgWGluZyBoZWFkZXI6XG4gICAgICAgICAqIHNhbXBsZXJhdGUsIGNoYW5uZWxzLCBjcmMsIGV0Yy4uLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGdmcC52ZXJzaW9uID09IDEpIHtcbiAgICAgICAgICAgIC8qIE1QRUcxICovXG4gICAgICAgICAgICBidWZmZXJbMV0gPSAweGZmICYgKGFieXRlIHwgMHgwYSk7XG4gICAgICAgICAgICAvKiB3YXMgMHgwYjsgKi9cbiAgICAgICAgICAgIGFieXRlID0gMHhmZiAmIChidWZmZXJbMl0gJiAweDBkKTtcbiAgICAgICAgICAgIC8qIEFGIGtlZXAgYWxzbyBwcml2YXRlIGJpdCAqL1xuICAgICAgICAgICAgYnVmZmVyWzJdID0gMHhmZiAmIChiYnl0ZSB8IGFieXRlKTtcbiAgICAgICAgICAgIC8qIDY0a2JzIE1QRUcxIGZyYW1lICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBNUEVHMiAqL1xuICAgICAgICAgICAgYnVmZmVyWzFdID0gMHhmZiAmIChhYnl0ZSB8IDB4MDIpO1xuICAgICAgICAgICAgLyogd2FzIDB4MDM7ICovXG4gICAgICAgICAgICBhYnl0ZSA9IDB4ZmYgJiAoYnVmZmVyWzJdICYgMHgwZCk7XG4gICAgICAgICAgICAvKiBBRiBrZWVwIGFsc28gcHJpdmF0ZSBiaXQgKi9cbiAgICAgICAgICAgIGJ1ZmZlclsyXSA9IDB4ZmYgJiAoYmJ5dGUgfCBhYnl0ZSk7XG4gICAgICAgICAgICAvKiA2NGticyBNUEVHMiBmcmFtZSAqL1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IFZCUiB0YWcgaW5mb3JtYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBidWZcbiAgICAgKiAgICAgICAgICAgIGhlYWRlciB0byBhbmFseXplXG4gICAgICogQHBhcmFtIGJ1ZlBvc1xuICAgICAqICAgICAgICAgICAgb2Zmc2V0IGludG8gdGhlIGhlYWRlclxuICAgICAqIEByZXR1cm4gVkJSIHRhZyBkYXRhXG4gICAgICovXG4gICAgdGhpcy5nZXRWYnJUYWcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAgIHZhciBwVGFnRGF0YSA9IG5ldyBWQlJUYWdEYXRhKCk7XG4gICAgICAgIHZhciBidWZQb3MgPSAwO1xuXG4gICAgICAgIC8qIGdldCBWYnIgaGVhZGVyIGRhdGEgKi9cbiAgICAgICAgcFRhZ0RhdGEuZmxhZ3MgPSAwO1xuXG4gICAgICAgIC8qIGdldCBzZWxlY3RlZCBNUEVHIGhlYWRlciBkYXRhICovXG4gICAgICAgIHZhciBoSWQgPSAoYnVmW2J1ZlBvcyArIDFdID4+IDMpICYgMTtcbiAgICAgICAgdmFyIGhTckluZGV4ID0gKGJ1ZltidWZQb3MgKyAyXSA+PiAyKSAmIDM7XG4gICAgICAgIHZhciBoTW9kZSA9IChidWZbYnVmUG9zICsgM10gPj4gNikgJiAzO1xuICAgICAgICB2YXIgaEJpdHJhdGUgPSAoKGJ1ZltidWZQb3MgKyAyXSA+PiA0KSAmIDB4Zik7XG4gICAgICAgIGhCaXRyYXRlID0gVGFibGVzLmJpdHJhdGVfdGFibGVbaElkXVtoQml0cmF0ZV07XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIEZGRSBzeW5jd29yZCAqL1xuICAgICAgICBpZiAoKGJ1ZltidWZQb3MgKyAxXSA+PiA0KSA9PSAweEUpXG4gICAgICAgICAgICBwVGFnRGF0YS5zYW1wcmF0ZSA9IFRhYmxlcy5zYW1wbGVyYXRlX3RhYmxlWzJdW2hTckluZGV4XTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcFRhZ0RhdGEuc2FtcHJhdGUgPSBUYWJsZXMuc2FtcGxlcmF0ZV90YWJsZVtoSWRdW2hTckluZGV4XTtcblxuICAgICAgICAvKiBkZXRlcm1pbmUgb2Zmc2V0IG9mIGhlYWRlciAqL1xuICAgICAgICBpZiAoaElkICE9IDApIHtcbiAgICAgICAgICAgIC8qIG1wZWcxICovXG4gICAgICAgICAgICBpZiAoaE1vZGUgIT0gMylcbiAgICAgICAgICAgICAgICBidWZQb3MgKz0gKDMyICsgNCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnVmUG9zICs9ICgxNyArIDQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogbXBlZzIgKi9cbiAgICAgICAgICAgIGlmIChoTW9kZSAhPSAzKVxuICAgICAgICAgICAgICAgIGJ1ZlBvcyArPSAoMTcgKyA0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBidWZQb3MgKz0gKDkgKyA0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYnJUYWcoYnVmLCBidWZQb3MpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgYnVmUG9zICs9IDQ7XG5cbiAgICAgICAgcFRhZ0RhdGEuaElkID0gaElkO1xuXG4gICAgICAgIC8qIGdldCBmbGFncyAqL1xuICAgICAgICB2YXIgaGVhZF9mbGFncyA9IHBUYWdEYXRhLmZsYWdzID0gZXh0cmFjdEludGVnZXIoYnVmLCBidWZQb3MpO1xuICAgICAgICBidWZQb3MgKz0gNDtcblxuICAgICAgICBpZiAoKGhlYWRfZmxhZ3MgJiBGUkFNRVNfRkxBRykgIT0gMCkge1xuICAgICAgICAgICAgcFRhZ0RhdGEuZnJhbWVzID0gZXh0cmFjdEludGVnZXIoYnVmLCBidWZQb3MpO1xuICAgICAgICAgICAgYnVmUG9zICs9IDQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGhlYWRfZmxhZ3MgJiBCWVRFU19GTEFHKSAhPSAwKSB7XG4gICAgICAgICAgICBwVGFnRGF0YS5ieXRlcyA9IGV4dHJhY3RJbnRlZ2VyKGJ1ZiwgYnVmUG9zKTtcbiAgICAgICAgICAgIGJ1ZlBvcyArPSA0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChoZWFkX2ZsYWdzICYgVE9DX0ZMQUcpICE9IDApIHtcbiAgICAgICAgICAgIGlmIChwVGFnRGF0YS50b2MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlVNVE9DRU5UUklFUzsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBwVGFnRGF0YS50b2NbaV0gPSBidWZbYnVmUG9zICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZQb3MgKz0gTlVNVE9DRU5UUklFUztcbiAgICAgICAgfVxuXG4gICAgICAgIHBUYWdEYXRhLnZiclNjYWxlID0gLTE7XG5cbiAgICAgICAgaWYgKChoZWFkX2ZsYWdzICYgVkJSX1NDQUxFX0ZMQUcpICE9IDApIHtcbiAgICAgICAgICAgIHBUYWdEYXRhLnZiclNjYWxlID0gZXh0cmFjdEludGVnZXIoYnVmLCBidWZQb3MpO1xuICAgICAgICAgICAgYnVmUG9zICs9IDQ7XG4gICAgICAgIH1cblxuICAgICAgICBwVGFnRGF0YS5oZWFkZXJzaXplID0gKChoSWQgKyAxKSAqIDcyMDAwICogaEJpdHJhdGUpXG4gICAgICAgICAgICAvIHBUYWdEYXRhLnNhbXByYXRlO1xuXG4gICAgICAgIGJ1ZlBvcyArPSAyMTtcbiAgICAgICAgdmFyIGVuY0RlbGF5ID0gYnVmW2J1ZlBvcyArIDBdIDw8IDQ7XG4gICAgICAgIGVuY0RlbGF5ICs9IGJ1ZltidWZQb3MgKyAxXSA+PiA0O1xuICAgICAgICB2YXIgZW5jUGFkZGluZyA9IChidWZbYnVmUG9zICsgMV0gJiAweDBGKSA8PCA4O1xuICAgICAgICBlbmNQYWRkaW5nICs9IGJ1ZltidWZQb3MgKyAyXSAmIDB4ZmY7XG4gICAgICAgIC8qIGNoZWNrIGZvciByZWFzb25hYmxlIHZhbHVlcyAodGhpcyBtYXkgYmUgYW4gb2xkIFhpbmcgaGVhZGVyLCAqL1xuICAgICAgICAvKiBub3QgYSBJTkZPIHRhZykgKi9cbiAgICAgICAgaWYgKGVuY0RlbGF5IDwgMCB8fCBlbmNEZWxheSA+IDMwMDApXG4gICAgICAgICAgICBlbmNEZWxheSA9IC0xO1xuICAgICAgICBpZiAoZW5jUGFkZGluZyA8IDAgfHwgZW5jUGFkZGluZyA+IDMwMDApXG4gICAgICAgICAgICBlbmNQYWRkaW5nID0gLTE7XG5cbiAgICAgICAgcFRhZ0RhdGEuZW5jRGVsYXkgPSBlbmNEZWxheTtcbiAgICAgICAgcFRhZ0RhdGEuZW5jUGFkZGluZyA9IGVuY1BhZGRpbmc7XG5cbiAgICAgICAgLyogc3VjY2VzcyAqL1xuICAgICAgICByZXR1cm4gcFRhZ0RhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBoZWFkZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBnZnBcbiAgICAgKiAgICAgICAgICAgIGdsb2JhbCBmbGFnc1xuICAgICAqL1xuICAgIHRoaXMuSW5pdFZiclRhZyA9IGZ1bmN0aW9uIChnZnApIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcblxuICAgICAgICAvKipcbiAgICAgICAgICogPFBSRT5cbiAgICAgICAgICogWGluZyBWQlIgcHJldGVuZHMgdG8gYmUgYSA0OGticyBsYXllciBJSUkgZnJhbWUuICAoYXQgNDQuMWtIeikuXG4gICAgICAgICAqIChhdCA0OGtIeiB0aGV5IHVzZSA1NmticyBzaW5jZSA0OGticyBmcmFtZSBub3QgYmlnIGVub3VnaCBmb3JcbiAgICAgICAgICogdGFibGUgb2YgY29udGVudHMpXG4gICAgICAgICAqIGxldCdzIGFsd2F5cyBlbWJlZCBYaW5nIGhlYWRlciBpbnNpZGUgYSA2NGticyBsYXllciBJSUkgZnJhbWUuXG4gICAgICAgICAqIHRoaXMgZ2l2ZXMgdXMgZW5vdWdoIHJvb20gZm9yIGEgTEFNRSB2ZXJzaW9uIHN0cmluZyB0b28uXG4gICAgICAgICAqIHNpemUgZGV0ZXJtaW5lZCBieSBzYW1wbGluZyBmcmVxdWVuY3kgKE1QRUcxKVxuICAgICAgICAgKiAzMmtIejogICAgMjE2IGJ5dGVzQDQ4a2JzICAgIDI4OGJ5dGVzQCA2NGtic1xuICAgICAgICAgKiA0NC4xa0h6OiAgMTU2IGJ5dGVzICAgICAgICAgIDIwOGJ5dGVzQDY0a2JzICAgICAoKzEgaWYgcGFkZGluZyA9IDEpXG4gICAgICAgICAqIDQ4a0h6OiAgICAxNDQgYnl0ZXMgICAgICAgICAgMTkyXG4gICAgICAgICAqXG4gICAgICAgICAqIE1QRUcgMiB2YWx1ZXMgYXJlIHRoZSBzYW1lIHNpbmNlIHRoZSBmcmFtZXNpemUgYW5kIHNhbXBsZXJhdGVcbiAgICAgICAgICogYXJlIGVhY2ggcmVkdWNlZCBieSBhIGZhY3RvciBvZiAyLlxuICAgICAgICAgKiA8L1BSRT5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBrYnBzX2hlYWRlcjtcbiAgICAgICAgaWYgKDEgPT0gZ2ZwLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGticHNfaGVhZGVyID0gWElOR19CSVRSQVRFMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnZnAub3V0X3NhbXBsZXJhdGUgPCAxNjAwMClcbiAgICAgICAgICAgICAgICBrYnBzX2hlYWRlciA9IFhJTkdfQklUUkFURTI1O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGticHNfaGVhZGVyID0gWElOR19CSVRSQVRFMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZnAuVkJSID09IFZick1vZGUkMjIudmJyX29mZilcbiAgICAgICAgICAgIGticHNfaGVhZGVyID0gZ2ZwLmJyYXRlO1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBMQU1FIEhlYWRlciBmaXRzIGludG8gRnJhbWVcbiAgICAgICAgdmFyIHRvdGFsRnJhbWVTaXplID0gKChnZnAudmVyc2lvbiArIDEpICogNzIwMDAgKiBrYnBzX2hlYWRlcilcbiAgICAgICAgICAgIC8gZ2ZwLm91dF9zYW1wbGVyYXRlO1xuICAgICAgICB2YXIgaGVhZGVyU2l6ZSA9IChnZmMuc2lkZWluZm9fbGVuICsgTEFNRUhFQURFUlNJWkUpO1xuICAgICAgICBnZmMuVkJSX3NlZWtfdGFibGUuVG90YWxGcmFtZVNpemUgPSB0b3RhbEZyYW1lU2l6ZTtcbiAgICAgICAgaWYgKHRvdGFsRnJhbWVTaXplIDwgaGVhZGVyU2l6ZSB8fCB0b3RhbEZyYW1lU2l6ZSA+IE1BWEZSQU1FU0laRSkge1xuICAgICAgICAgICAgLyogZGlzYWJsZSB0YWcsIGl0IHdvbnQgZml0ICovXG4gICAgICAgICAgICBnZnAuYldyaXRlVmJyVGFnID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnZmMuVkJSX3NlZWtfdGFibGUublZick51bUZyYW1lcyA9IDA7XG4gICAgICAgIGdmYy5WQlJfc2Vla190YWJsZS5uQnl0ZXNXcml0dGVuID0gMDtcbiAgICAgICAgZ2ZjLlZCUl9zZWVrX3RhYmxlLnN1bSA9IDA7XG5cbiAgICAgICAgZ2ZjLlZCUl9zZWVrX3RhYmxlLnNlZW4gPSAwO1xuICAgICAgICBnZmMuVkJSX3NlZWtfdGFibGUud2FudCA9IDE7XG4gICAgICAgIGdmYy5WQlJfc2Vla190YWJsZS5wb3MgPSAwO1xuXG4gICAgICAgIGlmIChnZmMuVkJSX3NlZWtfdGFibGUuYmFnID09IG51bGwpIHtcbiAgICAgICAgICAgIGdmYy5WQlJfc2Vla190YWJsZS5iYWcgPSBuZXcgaW50WzQwMF07XG4gICAgICAgICAgICBnZmMuVkJSX3NlZWtfdGFibGUuc2l6ZSA9IDQwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdyaXRlIGR1bW15IFZCUiB0YWcgb2YgYWxsIDAncyBpbnRvIGJpdHN0cmVhbVxuICAgICAgICB2YXIgYnVmZmVyID0gbmV3X2J5dGUkMjIoTUFYRlJBTUVTSVpFKTtcblxuICAgICAgICBzZXRMYW1lVGFnRnJhbWVIZWFkZXIoZ2ZwLCBidWZmZXIpO1xuICAgICAgICB2YXIgbiA9IGdmYy5WQlJfc2Vla190YWJsZS5Ub3RhbEZyYW1lU2l6ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGJzLmFkZF9kdW1teV9ieXRlKGdmcCwgYnVmZmVyW2ldICYgMHhmZiwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmFzdCBDUkMtMTYgY29tcHV0YXRpb24gKHVzZXMgdGFibGUgY3JjMTZMb29rdXApLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIGNyY1xuICAgICAqIEByZXR1cm5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmNVcGRhdGVMb29rdXAodmFsdWUsIGNyYykge1xuICAgICAgICB2YXIgdG1wID0gY3JjIF4gdmFsdWU7XG4gICAgICAgIGNyYyA9IChjcmMgPj4gOCkgXiBjcmMxNkxvb2t1cFt0bXAgJiAweGZmXTtcbiAgICAgICAgcmV0dXJuIGNyYztcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZU11c2ljQ1JDID0gZnVuY3Rpb24gKGNyYywgYnVmZmVyLCBidWZmZXJQb3MsIHNpemUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpXG4gICAgICAgICAgICBjcmNbMF0gPSBjcmNVcGRhdGVMb29rdXAoYnVmZmVyW2J1ZmZlclBvcyArIGldLCBjcmNbMF0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSBMQU1FIGluZm86IG1pbmkgdmVyc2lvbiArIGluZm8gb24gdmFyaW91cyBzd2l0Y2hlcyB1c2VkIChKb25hdGhhblxuICAgICAqIERlZSAyMDAxLzA4LzMxKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBnZnBcbiAgICAgKiAgICAgICAgICAgIGdsb2JhbCBmbGFnc1xuICAgICAqIEBwYXJhbSBtdXNpY0xlbmd0aFxuICAgICAqICAgICAgICAgICAgbXVzaWMgbGVuZ3RoXG4gICAgICogQHBhcmFtIHN0cmVhbUJ1ZmZlclxuICAgICAqICAgICAgICAgICAgcG9pbnRlciB0byBvdXRwdXQgYnVmZmVyXG4gICAgICogQHBhcmFtIHN0cmVhbUJ1ZmZlclBvc1xuICAgICAqICAgICAgICAgICAgb2Zmc2V0IGludG8gdGhlIG91dHB1dCBidWZmZXJcbiAgICAgKiBAcGFyYW0gY3JjXG4gICAgICogICAgICAgICAgICBjb21wdXRhdGlvbiBvZiBDUkMtMTYgb2YgTGFtZSBUYWcgc28gZmFyIChzdGFydGluZyBhdCBmcmFtZVxuICAgICAqICAgICAgICAgICAgc3luYylcbiAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBieXRlcyB3cml0dGVuIHRvIHRoZSBzdHJlYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdXRMYW1lVkJSKGdmcCwgbXVzaWNMZW5ndGgsIHN0cmVhbUJ1ZmZlciwgc3RyZWFtQnVmZmVyUG9zLCBjcmMpIHtcbiAgICAgICAgdmFyIGdmYyA9IGdmcC5pbnRlcm5hbF9mbGFncztcbiAgICAgICAgdmFyIGJ5dGVzV3JpdHRlbiA9IDA7XG5cbiAgICAgICAgLyogZW5jb2RlciBkZWxheSAqL1xuICAgICAgICB2YXIgZW5jRGVsYXkgPSBnZnAuZW5jb2Rlcl9kZWxheTtcbiAgICAgICAgLyogZW5jb2RlciBwYWRkaW5nICovXG4gICAgICAgIHZhciBlbmNQYWRkaW5nID0gZ2ZwLmVuY29kZXJfcGFkZGluZztcblxuICAgICAgICAvKiByZWNhbGw6IGdmcC5WQlJfcSBpcyBmb3IgZXhhbXBsZSBzZXQgYnkgdGhlIHN3aXRjaCAtViAqL1xuICAgICAgICAvKiBnZnAucXVhbGl0eSBieSAtcSwgLWgsIC1mLCBldGMgKi9cbiAgICAgICAgdmFyIHF1YWxpdHkgPSAoMTAwIC0gMTAgKiBnZnAuVkJSX3EgLSBnZnAucXVhbGl0eSk7XG5cbiAgICAgICAgdmFyIHZlcnNpb24gPSB2LmdldExhbWVWZXJ5U2hvcnRWZXJzaW9uKCk7XG4gICAgICAgIHZhciB2YnI7XG4gICAgICAgIHZhciByZXZpc2lvbiA9IDB4MDA7XG4gICAgICAgIHZhciByZXZNZXRob2Q7XG4gICAgICAgIC8vIG51bWJlcmluZyBkaWZmZXJlbnQgaW4gdmJyX21vZGUgdnMuIExhbWUgdGFnXG4gICAgICAgIHZhciB2YnJUeXBlVHJhbnNsYXRvciA9IFsxLCA1LCAzLCAyLCA0LCAwLCAzXTtcbiAgICAgICAgdmFyIGxvd3Bhc3MgPSAwIHwgKCgoZ2ZwLmxvd3Bhc3NmcmVxIC8gMTAwLjApICsgLjUpID4gMjU1ID8gMjU1XG4gICAgICAgICAgICAgICAgOiAoZ2ZwLmxvd3Bhc3NmcmVxIC8gMTAwLjApICsgLjUpO1xuICAgICAgICB2YXIgcGVha1NpZ25hbEFtcGxpdHVkZSA9IDA7XG4gICAgICAgIHZhciByYWRpb1JlcGxheUdhaW4gPSAwO1xuICAgICAgICB2YXIgYXVkaW9waGlsZVJlcGxheUdhaW4gPSAwO1xuICAgICAgICB2YXIgbm9pc2VTaGFwaW5nID0gZ2ZwLmludGVybmFsX2ZsYWdzLm5vaXNlX3NoYXBpbmc7XG4gICAgICAgIHZhciBzdGVyZW9Nb2RlID0gMDtcbiAgICAgICAgdmFyIG5vbk9wdGltYWwgPSAwO1xuICAgICAgICB2YXIgc291cmNlRnJlcSA9IDA7XG4gICAgICAgIHZhciBtaXNjID0gMDtcbiAgICAgICAgdmFyIG11c2ljQ1JDID0gMDtcblxuICAgICAgICAvLyBwc3kgbW9kZWwgdHlwZTogR3BzeWNobyBvciBOc1BzeXR1bmVcbiAgICAgICAgdmFyIGV4cE5Qc3lUdW5lID0gKGdmcC5leHBfbnNwc3l0dW5lICYgMSkgIT0gMDtcbiAgICAgICAgdmFyIHNhZmVKb2ludCA9IChnZnAuZXhwX25zcHN5dHVuZSAmIDIpICE9IDA7XG4gICAgICAgIHZhciBub0dhcE1vcmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIG5vR2FwUHJldmlvdXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIG5vR2FwQ291bnQgPSBnZnAuaW50ZXJuYWxfZmxhZ3Mubm9nYXBfdG90YWw7XG4gICAgICAgIHZhciBub0dhcEN1cnIgPSBnZnAuaW50ZXJuYWxfZmxhZ3Mubm9nYXBfY3VycmVudDtcblxuICAgICAgICAvLyA0IGJpdHNcbiAgICAgICAgdmFyIGF0aFR5cGUgPSBnZnAuQVRIdHlwZTtcbiAgICAgICAgdmFyIGZsYWdzID0gMDtcblxuICAgICAgICAvLyB2YnIgbW9kZXNcbiAgICAgICAgdmFyIGFickJpdHJhdGU7XG4gICAgICAgIHN3aXRjaCAoZ2ZwLlZCUikge1xuICAgICAgICAgICAgY2FzZSB2YnJfYWJyOlxuICAgICAgICAgICAgICAgIGFickJpdHJhdGUgPSBnZnAuVkJSX21lYW5fYml0cmF0ZV9rYnBzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB2YnJfb2ZmOlxuICAgICAgICAgICAgICAgIGFickJpdHJhdGUgPSBnZnAuYnJhdGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGFickJpdHJhdGUgPSBnZnAuVkJSX21pbl9iaXRyYXRlX2ticHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXZpc2lvbiBhbmQgdmJyIG1ldGhvZFxuICAgICAgICBpZiAoZ2ZwLlZCUi5vcmRpbmFsKCkgPCB2YnJUeXBlVHJhbnNsYXRvci5sZW5ndGgpXG4gICAgICAgICAgICB2YnIgPSB2YnJUeXBlVHJhbnNsYXRvcltnZnAuVkJSLm9yZGluYWwoKV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZiciA9IDB4MDA7IC8vIHVua25vd25cblxuICAgICAgICByZXZNZXRob2QgPSAweDEwICogcmV2aXNpb24gKyB2YnI7XG5cbiAgICAgICAgLy8gUmVwbGF5R2FpblxuICAgICAgICBpZiAoZ2ZjLmZpbmRSZXBsYXlHYWluKSB7XG4gICAgICAgICAgICBpZiAoZ2ZjLlJhZGlvR2FpbiA+IDB4MUZFKVxuICAgICAgICAgICAgICAgIGdmYy5SYWRpb0dhaW4gPSAweDFGRTtcbiAgICAgICAgICAgIGlmIChnZmMuUmFkaW9HYWluIDwgLTB4MUZFKVxuICAgICAgICAgICAgICAgIGdmYy5SYWRpb0dhaW4gPSAtMHgxRkU7XG5cbiAgICAgICAgICAgIC8vIHNldCBuYW1lIGNvZGVcbiAgICAgICAgICAgIHJhZGlvUmVwbGF5R2FpbiA9IDB4MjAwMDtcbiAgICAgICAgICAgIC8vIHNldCBvcmlnaW5hdG9yIGNvZGUgdG8gYGRldGVybWluZWQgYXV0b21hdGljYWxseSdcbiAgICAgICAgICAgIHJhZGlvUmVwbGF5R2FpbiB8PSAweEMwMDtcblxuICAgICAgICAgICAgaWYgKGdmYy5SYWRpb0dhaW4gPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHNldCBnYWluIGFkanVzdG1lbnRcbiAgICAgICAgICAgICAgICByYWRpb1JlcGxheUdhaW4gfD0gZ2ZjLlJhZGlvR2FpbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBzaWduIGJpdFxuICAgICAgICAgICAgICAgIHJhZGlvUmVwbGF5R2FpbiB8PSAweDIwMDtcbiAgICAgICAgICAgICAgICAvLyBzZXQgZ2FpbiBhZGp1c3RtZW50XG4gICAgICAgICAgICAgICAgcmFkaW9SZXBsYXlHYWluIHw9IC1nZmMuUmFkaW9HYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVhayBzYW1wbGVcbiAgICAgICAgaWYgKGdmYy5maW5kUGVha1NhbXBsZSlcbiAgICAgICAgICAgIHBlYWtTaWduYWxBbXBsaXR1ZGUgPSBNYXRoXG4gICAgICAgICAgICAgICAgLmFicygwIHwgKCgoIGdmYy5QZWFrU2FtcGxlKSAvIDMyNzY3LjApICogTWF0aC5wb3coMiwgMjMpICsgLjUpKTtcblxuICAgICAgICAvLyBub2dhcFxuICAgICAgICBpZiAobm9HYXBDb3VudCAhPSAtMSkge1xuICAgICAgICAgICAgaWYgKG5vR2FwQ3VyciA+IDApXG4gICAgICAgICAgICAgICAgbm9HYXBQcmV2aW91cyA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChub0dhcEN1cnIgPCBub0dhcENvdW50IC0gMSlcbiAgICAgICAgICAgICAgICBub0dhcE1vcmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmxhZ3NcbiAgICAgICAgZmxhZ3MgPSBhdGhUeXBlICsgKChleHBOUHN5VHVuZSA/IDEgOiAwKSA8PCA0KVxuICAgICAgICAgICAgKyAoKHNhZmVKb2ludCA/IDEgOiAwKSA8PCA1KSArICgobm9HYXBNb3JlID8gMSA6IDApIDw8IDYpXG4gICAgICAgICAgICArICgobm9HYXBQcmV2aW91cyA/IDEgOiAwKSA8PCA3KTtcblxuICAgICAgICBpZiAocXVhbGl0eSA8IDApXG4gICAgICAgICAgICBxdWFsaXR5ID0gMDtcblxuICAgICAgICAvLyBzdGVyZW8gbW9kZSBmaWVsZCAoSW50ZW5zaXR5IHN0ZXJlbyBpcyBub3QgaW1wbGVtZW50ZWQpXG4gICAgICAgIHN3aXRjaCAoZ2ZwLm1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgTU9OTzpcbiAgICAgICAgICAgICAgICBzdGVyZW9Nb2RlID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU1RFUkVPOlxuICAgICAgICAgICAgICAgIHN0ZXJlb01vZGUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEVUFMX0NIQU5ORUw6XG4gICAgICAgICAgICAgICAgc3RlcmVvTW9kZSA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEpPSU5UX1NURVJFTzpcbiAgICAgICAgICAgICAgICBpZiAoZ2ZwLmZvcmNlX21zKVxuICAgICAgICAgICAgICAgICAgICBzdGVyZW9Nb2RlID0gNDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHN0ZXJlb01vZGUgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBOT1RfU0VUOlxuICAgICAgICAgICAgLy8kRkFMTC1USFJPVUdIJFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzdGVyZW9Nb2RlID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZnAuaW5fc2FtcGxlcmF0ZSA8PSAzMjAwMClcbiAgICAgICAgICAgIHNvdXJjZUZyZXEgPSAweDAwO1xuICAgICAgICBlbHNlIGlmIChnZnAuaW5fc2FtcGxlcmF0ZSA9PSA0ODAwMClcbiAgICAgICAgICAgIHNvdXJjZUZyZXEgPSAweDAyO1xuICAgICAgICBlbHNlIGlmIChnZnAuaW5fc2FtcGxlcmF0ZSA+IDQ4MDAwKVxuICAgICAgICAgICAgc291cmNlRnJlcSA9IDB4MDM7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCBpcyA0NDEwMEh6XG4gICAgICAgICAgICBzb3VyY2VGcmVxID0gMHgwMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSB1c2VyIG92ZXJyaWRlZCB0aGUgZGVmYXVsdCBMQU1FIGJlaGF2aW9yIHdpdGggc29tZVxuICAgICAgICAvLyBuYXN0eSBvcHRpb25zXG4gICAgICAgIGlmIChnZnAuc2hvcnRfYmxvY2tzID09IFNob3J0QmxvY2skMjIuc2hvcnRfYmxvY2tfZm9yY2VkXG4gICAgICAgICAgICB8fCBnZnAuc2hvcnRfYmxvY2tzID09IFNob3J0QmxvY2skMjIuc2hvcnRfYmxvY2tfZGlzcGVuc2VkXG4gICAgICAgICAgICB8fCAoKGdmcC5sb3dwYXNzZnJlcSA9PSAtMSkgJiYgKGdmcC5oaWdocGFzc2ZyZXEgPT0gLTEpKSB8fCAvKiBcIi1rXCIgKi9cbiAgICAgICAgICAgIChnZnAuc2NhbGVfbGVmdCA8IGdmcC5zY2FsZV9yaWdodClcbiAgICAgICAgICAgIHx8IChnZnAuc2NhbGVfbGVmdCA+IGdmcC5zY2FsZV9yaWdodClcbiAgICAgICAgICAgIHx8IChnZnAuZGlzYWJsZV9yZXNlcnZvaXIgJiYgZ2ZwLmJyYXRlIDwgMzIwKSB8fCBnZnAubm9BVEhcbiAgICAgICAgICAgIHx8IGdmcC5BVEhvbmx5IHx8IChhdGhUeXBlID09IDApIHx8IGdmcC5pbl9zYW1wbGVyYXRlIDw9IDMyMDAwKVxuICAgICAgICAgICAgbm9uT3B0aW1hbCA9IDE7XG5cbiAgICAgICAgbWlzYyA9IG5vaXNlU2hhcGluZyArIChzdGVyZW9Nb2RlIDw8IDIpICsgKG5vbk9wdGltYWwgPDwgNSlcbiAgICAgICAgICAgICsgKHNvdXJjZUZyZXEgPDwgNik7XG5cbiAgICAgICAgbXVzaWNDUkMgPSBnZmMubk11c2ljQ1JDO1xuXG4gICAgICAgIC8vIFdyaXRlIGFsbCB0aGlzIGluZm9ybWF0aW9uIGludG8gdGhlIHN0cmVhbVxuXG4gICAgICAgIGNyZWF0ZUludGVnZXIoc3RyZWFtQnVmZmVyLCBzdHJlYW1CdWZmZXJQb3MgKyBieXRlc1dyaXR0ZW4sIHF1YWxpdHkpO1xuICAgICAgICBieXRlc1dyaXR0ZW4gKz0gNDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDk7IGorKykge1xuICAgICAgICAgICAgc3RyZWFtQnVmZmVyW3N0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbiArIGpdID0gMHhmZiAmIHZlcnNpb24gLmNoYXJBdChqKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlc1dyaXR0ZW4gKz0gOTtcblxuICAgICAgICBzdHJlYW1CdWZmZXJbc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuXSA9IDB4ZmYgJiByZXZNZXRob2Q7XG4gICAgICAgIGJ5dGVzV3JpdHRlbisrO1xuXG4gICAgICAgIHN0cmVhbUJ1ZmZlcltzdHJlYW1CdWZmZXJQb3MgKyBieXRlc1dyaXR0ZW5dID0gMHhmZiAmIGxvd3Bhc3M7XG4gICAgICAgIGJ5dGVzV3JpdHRlbisrO1xuXG4gICAgICAgIGNyZWF0ZUludGVnZXIoc3RyZWFtQnVmZmVyLCBzdHJlYW1CdWZmZXJQb3MgKyBieXRlc1dyaXR0ZW4sXG4gICAgICAgICAgICBwZWFrU2lnbmFsQW1wbGl0dWRlKTtcbiAgICAgICAgYnl0ZXNXcml0dGVuICs9IDQ7XG5cbiAgICAgICAgY3JlYXRlU2hvcnQoc3RyZWFtQnVmZmVyLCBzdHJlYW1CdWZmZXJQb3MgKyBieXRlc1dyaXR0ZW4sXG4gICAgICAgICAgICByYWRpb1JlcGxheUdhaW4pO1xuICAgICAgICBieXRlc1dyaXR0ZW4gKz0gMjtcblxuICAgICAgICBjcmVhdGVTaG9ydChzdHJlYW1CdWZmZXIsIHN0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbixcbiAgICAgICAgICAgIGF1ZGlvcGhpbGVSZXBsYXlHYWluKTtcbiAgICAgICAgYnl0ZXNXcml0dGVuICs9IDI7XG5cbiAgICAgICAgc3RyZWFtQnVmZmVyW3N0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbl0gPSAweGZmICYgZmxhZ3M7XG4gICAgICAgIGJ5dGVzV3JpdHRlbisrO1xuXG4gICAgICAgIGlmIChhYnJCaXRyYXRlID49IDI1NSlcbiAgICAgICAgICAgIHN0cmVhbUJ1ZmZlcltzdHJlYW1CdWZmZXJQb3MgKyBieXRlc1dyaXR0ZW5dID0gMHhGRjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3RyZWFtQnVmZmVyW3N0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbl0gPSAweGZmICYgYWJyQml0cmF0ZTtcbiAgICAgICAgYnl0ZXNXcml0dGVuKys7XG5cbiAgICAgICAgc3RyZWFtQnVmZmVyW3N0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbl0gPSAweGZmICYgKGVuY0RlbGF5ID4+IDQpO1xuICAgICAgICBzdHJlYW1CdWZmZXJbc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuICsgMV0gPSAweGZmICYgKChlbmNEZWxheSA8PCA0KSArIChlbmNQYWRkaW5nID4+IDgpKTtcbiAgICAgICAgc3RyZWFtQnVmZmVyW3N0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbiArIDJdID0gMHhmZiAmIGVuY1BhZGRpbmc7XG5cbiAgICAgICAgYnl0ZXNXcml0dGVuICs9IDM7XG5cbiAgICAgICAgc3RyZWFtQnVmZmVyW3N0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbl0gPSAweGZmICYgbWlzYztcbiAgICAgICAgYnl0ZXNXcml0dGVuKys7XG5cbiAgICAgICAgLy8gdW51c2VkIGluIHJldjBcbiAgICAgICAgc3RyZWFtQnVmZmVyW3N0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbisrXSA9IDA7XG5cbiAgICAgICAgY3JlYXRlU2hvcnQoc3RyZWFtQnVmZmVyLCBzdHJlYW1CdWZmZXJQb3MgKyBieXRlc1dyaXR0ZW4sIGdmcC5wcmVzZXQpO1xuICAgICAgICBieXRlc1dyaXR0ZW4gKz0gMjtcblxuICAgICAgICBjcmVhdGVJbnRlZ2VyKHN0cmVhbUJ1ZmZlciwgc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuLCBtdXNpY0xlbmd0aCk7XG4gICAgICAgIGJ5dGVzV3JpdHRlbiArPSA0O1xuXG4gICAgICAgIGNyZWF0ZVNob3J0KHN0cmVhbUJ1ZmZlciwgc3RyZWFtQnVmZmVyUG9zICsgYnl0ZXNXcml0dGVuLCBtdXNpY0NSQyk7XG4gICAgICAgIGJ5dGVzV3JpdHRlbiArPSAyO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0YWcgQ1JDLi4uLiBtdXN0IGJlIGRvbmUgaGVyZSwgc2luY2UgaXQgaW5jbHVkZXMgcHJldmlvdXNcbiAgICAgICAgLy8gaW5mb3JtYXRpb25cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzV3JpdHRlbjsgaSsrKVxuICAgICAgICAgICAgY3JjID0gY3JjVXBkYXRlTG9va3VwKHN0cmVhbUJ1ZmZlcltzdHJlYW1CdWZmZXJQb3MgKyBpXSwgY3JjKTtcblxuICAgICAgICBjcmVhdGVTaG9ydChzdHJlYW1CdWZmZXIsIHN0cmVhbUJ1ZmZlclBvcyArIGJ5dGVzV3JpdHRlbiwgY3JjKTtcbiAgICAgICAgYnl0ZXNXcml0dGVuICs9IDI7XG5cbiAgICAgICAgcmV0dXJuIGJ5dGVzV3JpdHRlbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwSWQzdjIoZnBTdHJlYW0pIHtcbiAgICAgICAgLy8gc2VlayB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJlYW1cbiAgICAgICAgZnBTdHJlYW0uc2VlaygwKTtcbiAgICAgICAgLy8gcmVhZCAxMCBieXRlcyBpbiBjYXNlIHRoZXJlJ3MgYW4gSUQzIHZlcnNpb24gMiBoZWFkZXIgaGVyZVxuICAgICAgICB2YXIgaWQzdjJIZWFkZXIgPSBuZXdfYnl0ZSQyMigxMCk7XG4gICAgICAgIGZwU3RyZWFtLnJlYWRGdWxseShpZDN2MkhlYWRlcik7XG4gICAgICAgIC8qIGRvZXMgdGhlIHN0cmVhbSBiZWdpbiB3aXRoIHRoZSBJRDMgdmVyc2lvbiAyIGZpbGUgaWRlbnRpZmllcj8gKi9cbiAgICAgICAgdmFyIGlkM3YyVGFnU2l6ZTtcbiAgICAgICAgaWYgKCFuZXcgU3RyaW5nKGlkM3YySGVhZGVyLCBcIklTTy04ODU5LTFcIikuc3RhcnRzV2l0aChcIklEM1wiKSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHRoZSB0YWcgc2l6ZSAobWludXMgdGhlIDEwLWJ5dGUgaGVhZGVyKSBpcyBlbmNvZGVkIGludG8gZm91clxuICAgICAgICAgICAgICogYnl0ZXMgd2hlcmUgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGlzIGNsZWFyIGluIGVhY2ggYnl0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZDN2MlRhZ1NpemUgPSAoKChpZDN2MkhlYWRlcls2XSAmIDB4N2YpIDw8IDIxKVxuICAgICAgICAgICAgICAgIHwgKChpZDN2MkhlYWRlcls3XSAmIDB4N2YpIDw8IDE0KVxuICAgICAgICAgICAgICAgIHwgKChpZDN2MkhlYWRlcls4XSAmIDB4N2YpIDw8IDcpIHwgKGlkM3YySGVhZGVyWzldICYgMHg3ZikpXG4gICAgICAgICAgICAgICAgKyBpZDN2MkhlYWRlci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBubyBJRDMgdmVyc2lvbiAyIHRhZyBpbiB0aGlzIHN0cmVhbSAqL1xuICAgICAgICAgICAgaWQzdjJUYWdTaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQzdjJUYWdTaXplO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0TGFtZVRhZ0ZyYW1lID0gZnVuY3Rpb24gKGdmcCwgYnVmZmVyKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgaWYgKCFnZnAuYldyaXRlVmJyVGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2ZjLkNsYXNzX0lEICE9IExhbWUuTEFNRV9JRCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdmYy5WQlJfc2Vla190YWJsZS5wb3MgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBnZmMuVkJSX3NlZWtfdGFibGUuVG90YWxGcmFtZVNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZmMuVkJSX3NlZWtfdGFibGUuVG90YWxGcmFtZVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBBcnJheXMkMjIuZmlsbChidWZmZXIsIDAsIGdmYy5WQlJfc2Vla190YWJsZS5Ub3RhbEZyYW1lU2l6ZSwgMCk7XG5cbiAgICAgICAgLy8gNCBieXRlcyBmcmFtZSBoZWFkZXJcbiAgICAgICAgc2V0TGFtZVRhZ0ZyYW1lSGVhZGVyKGdmcCwgYnVmZmVyKTtcblxuICAgICAgICAvLyBDcmVhdGUgVE9DIGVudHJpZXNcbiAgICAgICAgdmFyIHRvYyA9IG5ld19ieXRlJDIyKE5VTVRPQ0VOVFJJRVMpO1xuXG4gICAgICAgIGlmIChnZnAuZnJlZV9mb3JtYXQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgTlVNVE9DRU5UUklFUzsgKytpKVxuICAgICAgICAgICAgICAgIHRvY1tpXSA9IDB4ZmYgJiAoMjU1ICogaSAvIDEwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4aW5nU2Vla1RhYmxlKGdmYy5WQlJfc2Vla190YWJsZSwgdG9jKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHdyaXRpbmcgdGhlIHRhZyBhZnRlciB0aGUgemVybyBmcmFtZVxuICAgICAgICB2YXIgc3RyZWFtSW5kZXggPSBnZmMuc2lkZWluZm9fbGVuO1xuICAgICAgICAvKipcbiAgICAgICAgICogTm90ZTogWGluZyBoZWFkZXIgc3BlY2lmaWVzIHRoYXQgWGluZyBkYXRhIGdvZXMgaW4gdGhlIGFuY2lsbGFyeSBkYXRhXG4gICAgICAgICAqIHdpdGggTk8gRVJST1IgUFJPVEVDVElPTi4gSWYgZXJyb3IgcHJvdGVjdG9uIGluIGVuYWJsZWQsIHRoZSBYaW5nXG4gICAgICAgICAqIGRhdGEgc3RpbGwgc3RhcnRzIGF0IHRoZSBzYW1lIG9mZnNldCwgYW5kIG5vdyBpdCBpcyBpbiBzaWRlaW5mbyBkYXRhXG4gICAgICAgICAqIGJsb2NrLCBhbmQgdGh1cyB3aWxsIG5vdCBkZWNvZGUgY29ycmVjdGx5IGJ5IG5vbi1YaW5nIHRhZyBhd2FyZVxuICAgICAgICAgKiBwbGF5ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZ2ZwLmVycm9yX3Byb3RlY3Rpb24pXG4gICAgICAgICAgICBzdHJlYW1JbmRleCAtPSAyO1xuXG4gICAgICAgIC8vIFB1dCBWYnIgdGFnXG4gICAgICAgIGlmIChnZnAuVkJSID09IFZick1vZGUkMjIudmJyX29mZikge1xuICAgICAgICAgICAgYnVmZmVyW3N0cmVhbUluZGV4KytdID0gMHhmZiAmIFZCUlRhZzEuY2hhckF0KDApO1xuICAgICAgICAgICAgYnVmZmVyW3N0cmVhbUluZGV4KytdID0gMHhmZiAmIFZCUlRhZzEuY2hhckF0KDEpO1xuICAgICAgICAgICAgYnVmZmVyW3N0cmVhbUluZGV4KytdID0gMHhmZiAmIFZCUlRhZzEuY2hhckF0KDIpO1xuICAgICAgICAgICAgYnVmZmVyW3N0cmVhbUluZGV4KytdID0gMHhmZiAmIFZCUlRhZzEuY2hhckF0KDMpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXJbc3RyZWFtSW5kZXgrK10gPSAweGZmICYgVkJSVGFnMC5jaGFyQXQoMCk7XG4gICAgICAgICAgICBidWZmZXJbc3RyZWFtSW5kZXgrK10gPSAweGZmICYgVkJSVGFnMC5jaGFyQXQoMSk7XG4gICAgICAgICAgICBidWZmZXJbc3RyZWFtSW5kZXgrK10gPSAweGZmICYgVkJSVGFnMC5jaGFyQXQoMik7XG4gICAgICAgICAgICBidWZmZXJbc3RyZWFtSW5kZXgrK10gPSAweGZmICYgVkJSVGFnMC5jaGFyQXQoMyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXQgaGVhZGVyIGZsYWdzXG4gICAgICAgIGNyZWF0ZUludGVnZXIoYnVmZmVyLCBzdHJlYW1JbmRleCwgRlJBTUVTX0ZMQUcgKyBCWVRFU19GTEFHICsgVE9DX0ZMQUdcbiAgICAgICAgICAgICsgVkJSX1NDQUxFX0ZMQUcpO1xuICAgICAgICBzdHJlYW1JbmRleCArPSA0O1xuXG4gICAgICAgIC8vIFB1dCBUb3RhbCBOdW1iZXIgb2YgZnJhbWVzXG4gICAgICAgIGNyZWF0ZUludGVnZXIoYnVmZmVyLCBzdHJlYW1JbmRleCwgZ2ZjLlZCUl9zZWVrX3RhYmxlLm5WYnJOdW1GcmFtZXMpO1xuICAgICAgICBzdHJlYW1JbmRleCArPSA0O1xuXG4gICAgICAgIC8vIFB1dCB0b3RhbCBhdWRpbyBzdHJlYW0gc2l6ZSwgaW5jbHVkaW5nIFhpbmcvTEFNRSBIZWFkZXJcbiAgICAgICAgdmFyIHN0cmVhbVNpemUgPSAoZ2ZjLlZCUl9zZWVrX3RhYmxlLm5CeXRlc1dyaXR0ZW4gKyBnZmMuVkJSX3NlZWtfdGFibGUuVG90YWxGcmFtZVNpemUpO1xuICAgICAgICBjcmVhdGVJbnRlZ2VyKGJ1ZmZlciwgc3RyZWFtSW5kZXgsIDAgfCBzdHJlYW1TaXplKTtcbiAgICAgICAgc3RyZWFtSW5kZXggKz0gNDtcblxuICAgICAgICAvKiBQdXQgVE9DICovXG4gICAgICAgIFN5c3RlbSQyMi5hcnJheWNvcHkodG9jLCAwLCBidWZmZXIsIHN0cmVhbUluZGV4LCB0b2MubGVuZ3RoKTtcbiAgICAgICAgc3RyZWFtSW5kZXggKz0gdG9jLmxlbmd0aDtcblxuICAgICAgICBpZiAoZ2ZwLmVycm9yX3Byb3RlY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIChqbykgZXJyb3JfcHJvdGVjdGlvbjogYWRkIGNyYzE2IGluZm9ybWF0aW9uIHRvIGhlYWRlclxuICAgICAgICAgICAgYnMuQ1JDX3dyaXRlaGVhZGVyKGdmYywgYnVmZmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdvcmsgb3V0IENSQyBzbyBmYXI6IGluaXRpYWxseSBjcmMgPSAwXG4gICAgICAgIHZhciBjcmMgPSAweDAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmVhbUluZGV4OyBpKyspXG4gICAgICAgICAgICBjcmMgPSBjcmNVcGRhdGVMb29rdXAoYnVmZmVyW2ldLCBjcmMpO1xuICAgICAgICAvLyBQdXQgTEFNRSBWQlIgaW5mb1xuICAgICAgICBzdHJlYW1JbmRleCArPSBwdXRMYW1lVkJSKGdmcCwgc3RyZWFtU2l6ZSwgYnVmZmVyLCBzdHJlYW1JbmRleCwgY3JjKTtcblxuICAgICAgICByZXR1cm4gZ2ZjLlZCUl9zZWVrX3RhYmxlLlRvdGFsRnJhbWVTaXplO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSBmaW5hbCBWQlIgdGFnIHRvIHRoZSBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdmcFxuICAgICAqICAgICAgICAgICAgZ2xvYmFsIGZsYWdzXG4gICAgICogQHBhcmFtIHN0cmVhbVxuICAgICAqICAgICAgICAgICAgc3RyZWFtIHRvIGFkZCB0aGUgVkJSIHRhZyB0b1xuICAgICAqIEByZXR1cm4gMCAoT0spLCAtMSBlbHNlXG4gICAgICogQHRocm93cyBJT0V4Y2VwdGlvblxuICAgICAqICAgICAgICAgICAgIEkvTyBlcnJvclxuICAgICAqL1xuICAgIHRoaXMucHV0VmJyVGFnID0gZnVuY3Rpb24gKGdmcCwgc3RyZWFtKSB7XG4gICAgICAgIHZhciBnZmMgPSBnZnAuaW50ZXJuYWxfZmxhZ3M7XG5cbiAgICAgICAgaWYgKGdmYy5WQlJfc2Vla190YWJsZS5wb3MgPD0gMClcbiAgICAgICAgICAgIHJldHVybiAtMTtcblxuICAgICAgICAvLyBTZWVrIHRvIGVuZCBvZiBmaWxlXG4gICAgICAgIHN0cmVhbS5zZWVrKHN0cmVhbS5sZW5ndGgoKSk7XG5cbiAgICAgICAgLy8gR2V0IGZpbGUgc2l6ZSwgYWJvcnQgaWYgZmlsZSBoYXMgemVybyBsZW5ndGguXG4gICAgICAgIGlmIChzdHJlYW0ubGVuZ3RoKCkgPT0gMClcbiAgICAgICAgICAgIHJldHVybiAtMTtcblxuICAgICAgICAvLyBUaGUgVkJSIHRhZyBtYXkgTk9UIGJlIGxvY2F0ZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyZWFtLiBJZiBhblxuICAgICAgICAvLyBJRDMgdmVyc2lvbiAyIHRhZyB3YXMgYWRkZWQsIHRoZW4gaXQgbXVzdCBiZSBza2lwcGVkIHRvIHdyaXRlIHRoZSBWQlJcbiAgICAgICAgLy8gdGFnIGRhdGEuXG4gICAgICAgIHZhciBpZDN2MlRhZ1NpemUgPSBza2lwSWQzdjIoc3RyZWFtKTtcblxuICAgICAgICAvLyBTZWVrIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmVhbVxuICAgICAgICBzdHJlYW0uc2VlayhpZDN2MlRhZ1NpemUpO1xuXG4gICAgICAgIHZhciBidWZmZXIgPSBuZXdfYnl0ZSQyMihNQVhGUkFNRVNJWkUpO1xuICAgICAgICB2YXIgYnl0ZXMgPSBnZXRMYW1lVGFnRnJhbWUoZ2ZwLCBidWZmZXIpO1xuICAgICAgICBpZiAoYnl0ZXMgPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnl0ZXMgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1dCBpdCBhbGwgdG8gZGlzayBhZ2FpblxuICAgICAgICBzdHJlYW0ud3JpdGUoYnVmZmVyLCAwLCBieXRlcyk7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcblxufVxuXG52YXIgVkJSVGFnXzEgPSBWQlJUYWc7XG5cbnZhciBuZXdfYnl0ZSA9IGNvbW1vbi5uZXdfYnl0ZTtcbnZhciBhc3NlcnQgPSBjb21tb24uYXNzZXJ0O1xuXG5MYW1lID0gTGFtZV8xO1xuUHJlc2V0cyA9IFByZXNldHNfMTtcbkdhaW5BbmFseXNpcyA9IEdhaW5BbmFseXNpc18xO1xuUXVhbnRpemVQVlQgPSBRdWFudGl6ZVBWVF8xO1xuUXVhbnRpemUgPSBRdWFudGl6ZV8xO1xuVGFrZWhpcm8gPSBUYWtlaGlyb18xO1xuUmVzZXJ2b2lyID0gUmVzZXJ2b2lyXzE7XG5NUEVHTW9kZSA9IE1QRUdNb2RlXzE7XG5CaXRTdHJlYW0gPSBCaXRTdHJlYW1fMTtcblxuXG5cblxuZnVuY3Rpb24gR2V0QXVkaW8oKSB7XG4gICAgdmFyIHBhcnNlO1xuICAgIHZhciBtcGc7XG5cbiAgICB0aGlzLnNldE1vZHVsZXMgPSBmdW5jdGlvbiAocGFyc2UyLCBtcGcyKSB7XG4gICAgICAgIHBhcnNlID0gcGFyc2UyO1xuICAgICAgICBtcGcgPSBtcGcyO1xuICAgIH07XG59XG5cblxuZnVuY3Rpb24gUGFyc2UoKSB7XG4gICAgdmFyIHZlcjtcbiAgICB2YXIgaWQzO1xuICAgIHZhciBwcmU7XG5cbiAgICB0aGlzLnNldE1vZHVsZXMgPSBmdW5jdGlvbiAodmVyMiwgaWQzMiwgcHJlMikge1xuICAgICAgICB2ZXIgPSB2ZXIyO1xuICAgICAgICBpZDMgPSBpZDMyO1xuICAgICAgICBwcmUgPSBwcmUyO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIE1QR0xpYigpIHtcbn1cblxuZnVuY3Rpb24gSUQzVGFnKCkge1xuICAgIHZhciBiaXRzO1xuICAgIHZhciB2ZXI7XG5cbiAgICB0aGlzLnNldE1vZHVsZXMgPSBmdW5jdGlvbiAoX2JpdHMsIF92ZXIpIHtcbiAgICAgICAgYml0cyA9IF9iaXRzO1xuICAgICAgICB2ZXIgPSBfdmVyO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIE1wM0VuY29kZXIoY2hhbm5lbHMsIHNhbXBsZXJhdGUsIGticHMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dBUk46IE1wM0VuY29kZXIoY2hhbm5lbHMsIHNhbXBsZXJhdGUsIGticHMpIG5vdCBzcGVjaWZpZWQnKTtcbiAgICAgICAgY2hhbm5lbHMgPSAxO1xuICAgICAgICBzYW1wbGVyYXRlID0gNDQxMDA7XG4gICAgICAgIGticHMgPSAxMjg7XG4gICAgfVxuICAgIHZhciBsYW1lID0gbmV3IExhbWUoKTtcbiAgICB2YXIgZ2F1ZCA9IG5ldyBHZXRBdWRpbygpO1xuICAgIHZhciBnYSA9IG5ldyBHYWluQW5hbHlzaXMoKTtcbiAgICB2YXIgYnMgPSBuZXcgQml0U3RyZWFtKCk7XG4gICAgdmFyIHAgPSBuZXcgUHJlc2V0cygpO1xuICAgIHZhciBxdXB2dCA9IG5ldyBRdWFudGl6ZVBWVCgpO1xuICAgIHZhciBxdSA9IG5ldyBRdWFudGl6ZSgpO1xuICAgIHZhciB2YnIgPSBuZXcgVkJSVGFnXzEoKTtcbiAgICB2YXIgdmVyID0gbmV3IFZlcnNpb25fMSgpO1xuICAgIHZhciBpZDMgPSBuZXcgSUQzVGFnKCk7XG4gICAgdmFyIHJ2ID0gbmV3IFJlc2Vydm9pcigpO1xuICAgIHZhciB0YWsgPSBuZXcgVGFrZWhpcm8oKTtcbiAgICB2YXIgcGFyc2UgPSBuZXcgUGFyc2UoKTtcbiAgICB2YXIgbXBnID0gbmV3IE1QR0xpYigpO1xuXG4gICAgbGFtZS5zZXRNb2R1bGVzKGdhLCBicywgcCwgcXVwdnQsIHF1LCB2YnIsIHZlciwgaWQzLCBtcGcpO1xuICAgIGJzLnNldE1vZHVsZXMoZ2EsIG1wZywgdmVyLCB2YnIpO1xuICAgIGlkMy5zZXRNb2R1bGVzKGJzLCB2ZXIpO1xuICAgIHAuc2V0TW9kdWxlcyhsYW1lKTtcbiAgICBxdS5zZXRNb2R1bGVzKGJzLCBydiwgcXVwdnQsIHRhayk7XG4gICAgcXVwdnQuc2V0TW9kdWxlcyh0YWssIHJ2LCBsYW1lLmVuYy5wc3kpO1xuICAgIHJ2LnNldE1vZHVsZXMoYnMpO1xuICAgIHRhay5zZXRNb2R1bGVzKHF1cHZ0KTtcbiAgICB2YnIuc2V0TW9kdWxlcyhsYW1lLCBicywgdmVyKTtcbiAgICBnYXVkLnNldE1vZHVsZXMocGFyc2UsIG1wZyk7XG4gICAgcGFyc2Uuc2V0TW9kdWxlcyh2ZXIsIGlkMywgcCk7XG5cbiAgICB2YXIgZ2ZwID0gbGFtZS5sYW1lX2luaXQoKTtcblxuICAgIGdmcC5udW1fY2hhbm5lbHMgPSBjaGFubmVscztcbiAgICBnZnAuaW5fc2FtcGxlcmF0ZSA9IHNhbXBsZXJhdGU7XG4gICAgZ2ZwLmJyYXRlID0ga2JwcztcbiAgICBnZnAubW9kZSA9IE1QRUdNb2RlLlNURVJFTztcbiAgICBnZnAucXVhbGl0eSA9IDM7XG4gICAgZ2ZwLmJXcml0ZVZiclRhZyA9IGZhbHNlO1xuICAgIGdmcC5kaXNhYmxlX3Jlc2Vydm9pciA9IHRydWU7XG4gICAgZ2ZwLndyaXRlX2lkM3RhZ19hdXRvbWF0aWMgPSBmYWxzZTtcblxuICAgIHZhciByZXRjb2RlID0gbGFtZS5sYW1lX2luaXRfcGFyYW1zKGdmcCk7XG4gICAgYXNzZXJ0KDAgPT0gcmV0Y29kZSk7XG4gICAgdmFyIG1heFNhbXBsZXMgPSAxMTUyO1xuICAgIHZhciBtcDNidWZfc2l6ZSA9IDAgfCAoMS4yNSAqIG1heFNhbXBsZXMgKyA3MjAwKTtcbiAgICB2YXIgbXAzYnVmID0gbmV3X2J5dGUobXAzYnVmX3NpemUpO1xuXG4gICAgdGhpcy5lbmNvZGVCdWZmZXIgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGNoYW5uZWxzID09IDEpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gbGVmdDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQobGVmdC5sZW5ndGggPT0gcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgaWYgKGxlZnQubGVuZ3RoID4gbWF4U2FtcGxlcykge1xuICAgICAgICAgICAgbWF4U2FtcGxlcyA9IGxlZnQubGVuZ3RoO1xuICAgICAgICAgICAgbXAzYnVmX3NpemUgPSAwIHwgKDEuMjUgKiBtYXhTYW1wbGVzICsgNzIwMCk7XG4gICAgICAgICAgICBtcDNidWYgPSBuZXdfYnl0ZShtcDNidWZfc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N6ID0gbGFtZS5sYW1lX2VuY29kZV9idWZmZXIoZ2ZwLCBsZWZ0LCByaWdodCwgbGVmdC5sZW5ndGgsIG1wM2J1ZiwgMCwgbXAzYnVmX3NpemUpO1xuICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShtcDNidWYuc3ViYXJyYXkoMCwgX3N6KSk7XG4gICAgfTtcblxuICAgIHRoaXMuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfc3ogPSBsYW1lLmxhbWVfZW5jb2RlX2ZsdXNoKGdmcCwgbXAzYnVmLCAwLCBtcDNidWZfc2l6ZSk7XG4gICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KG1wM2J1Zi5zdWJhcnJheSgwLCBfc3opKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBXYXZIZWFkZXIoKSB7XG4gICAgdGhpcy5kYXRhT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmRhdGFMZW4gPSAwO1xuICAgIHRoaXMuY2hhbm5lbHMgPSAwO1xuICAgIHRoaXMuc2FtcGxlUmF0ZSA9IDA7XG59XG5cbmZ1bmN0aW9uIGZvdXJjY1RvSW50KGZvdXJjYykge1xuICAgIHJldHVybiBmb3VyY2MuY2hhckNvZGVBdCgwKSA8PCAyNCB8IGZvdXJjYy5jaGFyQ29kZUF0KDEpIDw8IDE2IHwgZm91cmNjLmNoYXJDb2RlQXQoMikgPDwgOCB8IGZvdXJjYy5jaGFyQ29kZUF0KDMpO1xufVxuXG5XYXZIZWFkZXIuUklGRiA9IGZvdXJjY1RvSW50KFwiUklGRlwiKTtcbldhdkhlYWRlci5XQVZFID0gZm91cmNjVG9JbnQoXCJXQVZFXCIpO1xuV2F2SGVhZGVyLmZtdF8gPSBmb3VyY2NUb0ludChcImZtdCBcIik7XG5XYXZIZWFkZXIuZGF0YSA9IGZvdXJjY1RvSW50KFwiZGF0YVwiKTtcblxuV2F2SGVhZGVyLnJlYWRIZWFkZXIgPSBmdW5jdGlvbiAoZGF0YVZpZXcpIHtcbiAgICB2YXIgdyA9IG5ldyBXYXZIZWFkZXIoKTtcblxuICAgIHZhciBoZWFkZXIgPSBkYXRhVmlldy5nZXRVaW50MzIoMCwgZmFsc2UpO1xuICAgIGlmIChXYXZIZWFkZXIuUklGRiAhPSBoZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZmlsZUxlbiA9IGRhdGFWaWV3LmdldFVpbnQzMig0LCB0cnVlKTtcbiAgICBpZiAoV2F2SGVhZGVyLldBVkUgIT0gZGF0YVZpZXcuZ2V0VWludDMyKDgsIGZhbHNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChXYXZIZWFkZXIuZm10XyAhPSBkYXRhVmlldy5nZXRVaW50MzIoMTIsIGZhbHNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBmbXRMZW4gPSBkYXRhVmlldy5nZXRVaW50MzIoMTYsIHRydWUpO1xuICAgIHZhciBwb3MgPSAxNiArIDQ7XG4gICAgc3dpdGNoIChmbXRMZW4pIHtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIHcuY2hhbm5lbHMgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zICsgMiwgdHJ1ZSk7XG4gICAgICAgICAgICB3LnNhbXBsZVJhdGUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zICsgNCwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdleHRlbmRlZCBmbXQgY2h1bmsgbm90IGltcGxlbWVudGVkJztcbiAgICB9XG4gICAgcG9zICs9IGZtdExlbjtcbiAgICB2YXIgZGF0YSA9IFdhdkhlYWRlci5kYXRhO1xuICAgIHZhciBsZW4gPSAwO1xuICAgIHdoaWxlIChkYXRhICE9IGhlYWRlcikge1xuICAgICAgICBoZWFkZXIgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zLCBmYWxzZSk7XG4gICAgICAgIGxlbiA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3MgKyA0LCB0cnVlKTtcbiAgICAgICAgaWYgKGRhdGEgPT0gaGVhZGVyKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gKGxlbiArIDgpO1xuICAgIH1cbiAgICB3LmRhdGFMZW4gPSBsZW47XG4gICAgdy5kYXRhT2Zmc2V0ID0gcG9zICsgODtcbiAgICByZXR1cm4gdztcbn07XG5cbnZhciBNcDNFbmNvZGVyXzEgPSBNcDNFbmNvZGVyO1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG52YXIgRW5jb2RlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW5jb2Rlcihjb25maWcpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBFbmNvZGVyKTtcblxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgc2FtcGxlUmF0ZTogNDQxMDAsXG4gICAgICBiaXRSYXRlOiAxMjhcbiAgICB9O1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZywgY29uZmlnKTtcblxuICAgIHRoaXMubXAzRW5jb2RlciA9IG5ldyBNcDNFbmNvZGVyXzEoMSwgdGhpcy5jb25maWcuc2FtcGxlUmF0ZSwgdGhpcy5jb25maWcuYml0UmF0ZSk7XG5cbiAgICAvLyBBdWRpbyBpcyBwcm9jZXNzZWQgYnkgZnJhbWVzIG9mIDExNTIgc2FtcGxlcyBwZXIgYXVkaW8gY2hhbm5lbFxuICAgIC8vIGh0dHA6Ly9sYW1lLnNvdXJjZWZvcmdlLm5ldC90ZWNoLUZBUS50eHRcbiAgICB0aGlzLm1heFNhbXBsZXMgPSAxMTUyO1xuXG4gICAgdGhpcy5zYW1wbGVzTW9ubyA9IG51bGw7XG4gICAgdGhpcy5jbGVhckJ1ZmZlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFjdGl2ZSBidWZmZXJcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhFbmNvZGVyLCBbe1xuICAgIGtleTogJ2NsZWFyQnVmZmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJCdWZmZXIoKSB7XG4gICAgICB0aGlzLmRhdGFCdWZmZXIgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgbmV3IGF1ZGlvIGJ1ZmZlciB0byBjdXJyZW50IGFjdGl2ZSBidWZmZXJcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FwcGVuZFRvQnVmZmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kVG9CdWZmZXIoYnVmZmVyKSB7XG4gICAgICB0aGlzLmRhdGFCdWZmZXIucHVzaChuZXcgSW50OEFycmF5KGJ1ZmZlcikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsb2F0IGN1cnJlbnQgZGF0YSB0byAxNiBiaXRzIFBDTVxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7SW50MTZBcnJheX0gb3V0cHV0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Zsb2F0VG8xNkJpdFBDTScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsb2F0VG8xNkJpdFBDTShpbnB1dCwgb3V0cHV0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGlucHV0W2ldKSk7XG4gICAgICAgIG91dHB1dFtpXSA9IHMgPCAwID8gcyAqIDB4ODAwMCA6IHMgKiAweDdGRkY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBidWZmZXIgdG8gcHJvcGVyIGZvcm1hdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5QnVmZmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NvbnZlcnRCdWZmZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgdmFyIG91dCA9IG5ldyBJbnQxNkFycmF5KGFycmF5QnVmZmVyLmxlbmd0aCk7XG4gICAgICB0aGlzLmZsb2F0VG8xNkJpdFBDTShkYXRhLCBvdXQpO1xuXG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZSBhbmQgYXBwZW5kIGN1cnJlbnQgYnVmZmVyIHRvIGRhdGFCdWZmZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheUJ1ZmZlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmNvZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNvZGUoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHRoaXMuc2FtcGxlc01vbm8gPSB0aGlzLmNvbnZlcnRCdWZmZXIoYXJyYXlCdWZmZXIpO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHRoaXMuc2FtcGxlc01vbm8ubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgcmVtYWluaW5nID49IDA7IGkgKz0gdGhpcy5tYXhTYW1wbGVzKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5zYW1wbGVzTW9uby5zdWJhcnJheShpLCBpICsgdGhpcy5tYXhTYW1wbGVzKTtcbiAgICAgICAgdmFyIG1wM2J1ZmZlciA9IHRoaXMubXAzRW5jb2Rlci5lbmNvZGVCdWZmZXIobGVmdCk7XG4gICAgICAgIHRoaXMuYXBwZW5kVG9CdWZmZXIobXAzYnVmZmVyKTtcbiAgICAgICAgcmVtYWluaW5nIC09IHRoaXMubWF4U2FtcGxlcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gZnVsbCBkYXRhQnVmZmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbmlzaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9CdWZmZXIodGhpcy5tcDNFbmNvZGVyLmZsdXNoKCkpO1xuXG4gICAgICByZXR1cm4gdGhpcy5kYXRhQnVmZmVyO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRW5jb2Rlcjtcbn0oKTtcblxudmFyIE1pY1JlY29yZGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNaWNSZWNvcmRlcihjb25maWcpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNaWNSZWNvcmRlcik7XG5cbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC8vIDEyOCBvciAxNjAga2JpdC9zIOKAkyBtaWQtcmFuZ2UgYml0cmF0ZSBxdWFsaXR5XG4gICAgICBiaXRSYXRlOiAxMjgsXG5cbiAgICAgIC8vIFRoZXJlIGlzIGEga25vd24gaXNzdWUgd2l0aCBzb21lIG1hY09TIG1hY2hpbmVzLCB3aGVyZSB0aGUgcmVjb3JkaW5nXG4gICAgICAvLyB3aWxsIHNvbWV0aW1lcyBoYXZlIGEgbG91ZCAncG9wJyBvciAncG9wLWNsaWNrJyBzb3VuZC4gVGhpcyBmbGFnXG4gICAgICAvLyBwcmV2ZW50cyBnZXR0aW5nIGF1ZGlvIGZyb20gdGhlIG1pY3JvcGhvbmUgYSBmZXcgbWlsbGlzZWNvbmRzIGFmdGVyXG4gICAgICAvLyB0aGUgYmVnaW5pbmcgb2YgdGhlIHJlY29yZGluZy4gSXQgYWxzbyBoZWxwcyB0byByZW1vdmUgdGhlIG1vdXNlXG4gICAgICAvLyBcImNsaWNrXCIgc291bmQgZnJvbSB0aGUgb3V0cHV0IG1wMyBmaWxlLlxuICAgICAgc3RhcnRSZWNvcmRpbmdBdDogMzAwLFxuICAgICAgZGV2aWNlSWQ6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5hY3RpdmVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5taWNyb3Bob25lID0gbnVsbDtcbiAgICB0aGlzLnByb2Nlc3NvciA9IG51bGw7XG4gICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZywgY29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdG8gbGlzdGVuIGZvciB0aGUgbWljcm9waG9uZSBzb3VuZFxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhNaWNSZWNvcmRlciwgW3tcbiAgICBrZXk6ICdhZGRNaWNyb3Bob25lTGlzdGVuZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNaWNyb3Bob25lTGlzdGVuZXIoc3RyZWFtKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmFjdGl2ZVN0cmVhbSA9IHN0cmVhbTtcblxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyB0aGUgd2VpcmQgbm9pc2Ugb25jZSB5b3Ugc3RhcnQgbGlzdGVuaW5nIHRvIHRoZSBtaWNyb3Bob25lXG4gICAgICB0aGlzLnRpbWVyVG9TdGFydCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWxldGUgX3RoaXMudGltZXJUb1N0YXJ0O1xuICAgICAgfSwgdGhpcy5jb25maWcuc3RhcnRSZWNvcmRpbmdBdCk7XG5cbiAgICAgIC8vIFNldCB1cCBXZWIgQXVkaW8gQVBJIHRvIHByb2Nlc3MgZGF0YSBmcm9tIHRoZSBtZWRpYSBzdHJlYW0gKG1pY3JvcGhvbmUpLlxuICAgICAgdGhpcy5taWNyb3Bob25lID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSk7XG5cbiAgICAgIC8vIFNldHRpbmdzIGEgYnVmZmVyU2l6ZSBvZiAwIGluc3RydWN0cyB0aGUgYnJvd3NlciB0byBjaG9vc2UgdGhlIGJlc3QgYnVmZmVyU2l6ZVxuICAgICAgdGhpcy5wcm9jZXNzb3IgPSB0aGlzLmNvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKDAsIDEsIDEpO1xuXG4gICAgICAvLyBBZGQgYWxsIGJ1ZmZlcnMgZnJvbSBMQU1FIGludG8gYW4gYXJyYXkuXG4gICAgICB0aGlzLnByb2Nlc3Nvci5vbmF1ZGlvcHJvY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoX3RoaXMudGltZXJUb1N0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VuZCBtaWNyb3Bob25lIGRhdGEgdG8gTEFNRSBmb3IgTVAzIGVuY29kaW5nIHdoaWxlIHJlY29yZGluZy5cbiAgICAgICAgX3RoaXMubGFtZUVuY29kZXIuZW5jb2RlKGV2ZW50LmlucHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKDApKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEJlZ2luIHJldHJpZXZpbmcgbWljcm9waG9uZSBkYXRhLlxuICAgICAgdGhpcy5taWNyb3Bob25lLmNvbm5lY3QodGhpcy5wcm9jZXNzb3IpO1xuICAgICAgdGhpcy5wcm9jZXNzb3IuY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0b3AnLFxuXG5cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IG1pY3JvcGhvbmUsIHByb2Nlc3NvciBhbmQgcmVtb3ZlIGFjdGl2ZVN0cmVhbVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yICYmIHRoaXMubWljcm9waG9uZSkge1xuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgV2ViIEF1ZGlvIEFQSSByZXNvdXJjZXMuXG4gICAgICAgIHRoaXMubWljcm9waG9uZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICAvLyBJZiBhbGwgcmVmZXJlbmNlcyB1c2luZyB0aGlzLmNvbnRleHQgYXJlIGRlc3Ryb3llZCwgY29udGV4dCBpcyBjbG9zZWRcbiAgICAgICAgLy8gYXV0b21hdGljYWxseS4gRE9NRXhjZXB0aW9uIGlzIGZpcmVkIHdoZW4gdHJ5aW5nIHRvIGNsb3NlIGFnYWluXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQgJiYgdGhpcy5jb250ZXh0LnN0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgIHRoaXMuY29udGV4dC5jbG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9jZXNzb3Iub25hdWRpb3Byb2Nlc3MgPSBudWxsO1xuXG4gICAgICAgIC8vIFN0b3AgYWxsIGF1ZGlvIHRyYWNrcy4gQWxzbywgcmVtb3ZlcyByZWNvcmRpbmcgaWNvbiBmcm9tIGNocm9tZSB0YWJcbiAgICAgICAgdGhpcy5hY3RpdmVTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgIHJldHVybiB0cmFjay5zdG9wKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGFydCcsXG5cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGFjY2VzcyB0byB0aGUgbWljcm9waG9uZSBhbmQgc3RhcnQgcmVjb3JkaW5nXG4gICAgICogQHJldHVybiBQcm9taXNlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBBdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG4gICAgICB0aGlzLmNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgICB0aGlzLmNvbmZpZy5zYW1wbGVSYXRlID0gdGhpcy5jb250ZXh0LnNhbXBsZVJhdGU7XG4gICAgICB0aGlzLmxhbWVFbmNvZGVyID0gbmV3IEVuY29kZXIodGhpcy5jb25maWcpO1xuXG4gICAgICB2YXIgYXVkaW8gPSB0aGlzLmNvbmZpZy5kZXZpY2VJZCA/IHsgZGV2aWNlSWQ6IHsgZXhhY3Q6IHRoaXMuY29uZmlnLmRldmljZUlkIH0gfSA6IHRydWU7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgYXVkaW86IGF1ZGlvIH0pLnRoZW4oZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgIF90aGlzMi5hZGRNaWNyb3Bob25lTGlzdGVuZXIoc3RyZWFtKTtcbiAgICAgICAgICByZXNvbHZlKHN0cmVhbSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRNcDMnLFxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gTXAzIEJ1ZmZlciBhbmQgQmxvYiB3aXRoIHR5cGUgbXAzXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TXAzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBmaW5hbEJ1ZmZlciA9IHRoaXMubGFtZUVuY29kZXIuZmluaXNoKCk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmIChmaW5hbEJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdObyBidWZmZXIgdG8gc2VuZCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKFtmaW5hbEJ1ZmZlciwgbmV3IEJsb2IoZmluYWxCdWZmZXIsIHsgdHlwZTogJ2F1ZGlvL21wMycgfSldKTtcbiAgICAgICAgICBfdGhpczMubGFtZUVuY29kZXIuY2xlYXJCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNaWNSZWNvcmRlcjtcbn0oKTtcblxucmV0dXJuIE1pY1JlY29yZGVyO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mic-recorder-to-mp3/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar ref, ref1;\nmodule.exports = ((ref = __webpack_require__.g.process) == null ? void 0 : ref.env) && typeof ((ref1 = __webpack_require__.g.process) == null ? void 0 : ref1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSx5QkFBeUIscUJBQU0seURBQXlELHFCQUFNLHNEQUFzRCxxQkFBTSxXQUFXLG1CQUFPLENBQUMsb0ZBQXdCOztBQUVyTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzP2NhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVmLCByZWYxO1xubW9kdWxlLmV4cG9ydHMgPSAoKHJlZiA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLmVudikgJiYgdHlwZW9mICgocmVmMSA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMS5lbnYpID09PSBcIm9iamVjdFwiID8gZ2xvYmFsLnByb2Nlc3MgOiByZXF1aXJlKFwiLi4vLi4vY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Home.module.css":
/*!************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Home.module.css ***!
  \************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Home_container__bCOhY {\\n  padding: 0 2rem;\\n}\\n\\n.Home_main__nLjiQ {\\n  min-height: 100vh;\\n  padding: 4rem 0;\\n  flex: 1 1;\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.Home_footer____T7K {\\n  display: flex;\\n  flex: 1 1;\\n  padding: 2rem 0;\\n  border-top: 1px solid #eaeaea;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.Home_footer____T7K a {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  flex-grow: 1;\\n}\\n\\n.Home_title__T09hD a {\\n  color: #0070f3;\\n  text-decoration: none;\\n}\\n\\n.Home_title__T09hD a:hover,\\n.Home_title__T09hD a:focus,\\n.Home_title__T09hD a:active {\\n  text-decoration: underline;\\n}\\n\\n.Home_title__T09hD {\\n  margin: 0;\\n  line-height: 1.15;\\n  font-size: 4rem;\\n}\\n\\n.Home_title__T09hD,\\n.Home_description__41Owk {\\n  text-align: center;\\n}\\n\\n.Home_description__41Owk {\\n  margin: 4rem 0;\\n  line-height: 1.5;\\n  font-size: 1.5rem;\\n}\\n\\n.Home_code__suPER {\\n  background: #fafafa;\\n  border-radius: 5px;\\n  padding: 0.75rem;\\n  font-size: 1.1rem;\\n  font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono,\\n    Bitstream Vera Sans Mono, Courier New, monospace;\\n}\\n\\n.Home_grid__GxQ85 {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  flex-wrap: wrap;\\n  max-width: 800px;\\n}\\n\\n.Home_card___LpL1 {\\n  margin: 1rem;\\n  padding: 1.5rem;\\n  text-align: left;\\n  color: inherit;\\n  text-decoration: none;\\n  border: 1px solid #eaeaea;\\n  border-radius: 10px;\\n  transition: color 0.15s ease, border-color 0.15s ease;\\n  max-width: 300px;\\n}\\n\\n.Home_card___LpL1:hover,\\n.Home_card___LpL1:focus,\\n.Home_card___LpL1:active {\\n  color: #0070f3;\\n  border-color: #0070f3;\\n}\\n\\n.Home_card___LpL1 h2 {\\n  margin: 0 0 1rem 0;\\n  font-size: 1.5rem;\\n}\\n\\n.Home_card___LpL1 p {\\n  margin: 0;\\n  font-size: 1.25rem;\\n  line-height: 1.5;\\n}\\n\\n.Home_logo__27_tb {\\n  height: 1em;\\n  margin-left: 0.5rem;\\n}\\n\\n@media (max-width: 600px) {\\n  .Home_grid__GxQ85 {\\n    width: 100%;\\n    flex-direction: column;\\n  }\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  .Home_card___LpL1,\\n  .Home_footer____T7K {\\n    border-color: #222;\\n  }\\n  .Home_code__suPER {\\n    background: #111;\\n  }\\n  .Home_logo__27_tb img {\\n    filter: invert(1);\\n  }\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/Home.module.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,eAAe;AACjB;;AAEA;EACE,iBAAiB;EACjB,eAAe;EACf,SAAO;EACP,aAAa;EACb,sBAAsB;EACtB,uBAAuB;EACvB,mBAAmB;AACrB;;AAEA;EACE,aAAa;EACb,SAAO;EACP,eAAe;EACf,6BAA6B;EAC7B,uBAAuB;EACvB,mBAAmB;AACrB;;AAEA;EACE,aAAa;EACb,uBAAuB;EACvB,mBAAmB;EACnB,YAAY;AACd;;AAEA;EACE,cAAc;EACd,qBAAqB;AACvB;;AAEA;;;EAGE,0BAA0B;AAC5B;;AAEA;EACE,SAAS;EACT,iBAAiB;EACjB,eAAe;AACjB;;AAEA;;EAEE,kBAAkB;AACpB;;AAEA;EACE,cAAc;EACd,gBAAgB;EAChB,iBAAiB;AACnB;;AAEA;EACE,mBAAmB;EACnB,kBAAkB;EAClB,gBAAgB;EAChB,iBAAiB;EACjB;oDACkD;AACpD;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,YAAY;EACZ,eAAe;EACf,gBAAgB;EAChB,cAAc;EACd,qBAAqB;EACrB,yBAAyB;EACzB,mBAAmB;EACnB,qDAAqD;EACrD,gBAAgB;AAClB;;AAEA;;;EAGE,cAAc;EACd,qBAAqB;AACvB;;AAEA;EACE,kBAAkB;EAClB,iBAAiB;AACnB;;AAEA;EACE,SAAS;EACT,kBAAkB;EAClB,gBAAgB;AAClB;;AAEA;EACE,WAAW;EACX,mBAAmB;AACrB;;AAEA;EACE;IACE,WAAW;IACX,sBAAsB;EACxB;AACF;;AAEA;EACE;;IAEE,kBAAkB;EACpB;EACA;IACE,gBAAgB;EAClB;EACA;IACE,iBAAiB;EACnB;AACF\",\"sourcesContent\":[\".container {\\n  padding: 0 2rem;\\n}\\n\\n.main {\\n  min-height: 100vh;\\n  padding: 4rem 0;\\n  flex: 1;\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.footer {\\n  display: flex;\\n  flex: 1;\\n  padding: 2rem 0;\\n  border-top: 1px solid #eaeaea;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.footer a {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  flex-grow: 1;\\n}\\n\\n.title a {\\n  color: #0070f3;\\n  text-decoration: none;\\n}\\n\\n.title a:hover,\\n.title a:focus,\\n.title a:active {\\n  text-decoration: underline;\\n}\\n\\n.title {\\n  margin: 0;\\n  line-height: 1.15;\\n  font-size: 4rem;\\n}\\n\\n.title,\\n.description {\\n  text-align: center;\\n}\\n\\n.description {\\n  margin: 4rem 0;\\n  line-height: 1.5;\\n  font-size: 1.5rem;\\n}\\n\\n.code {\\n  background: #fafafa;\\n  border-radius: 5px;\\n  padding: 0.75rem;\\n  font-size: 1.1rem;\\n  font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono,\\n    Bitstream Vera Sans Mono, Courier New, monospace;\\n}\\n\\n.grid {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  flex-wrap: wrap;\\n  max-width: 800px;\\n}\\n\\n.card {\\n  margin: 1rem;\\n  padding: 1.5rem;\\n  text-align: left;\\n  color: inherit;\\n  text-decoration: none;\\n  border: 1px solid #eaeaea;\\n  border-radius: 10px;\\n  transition: color 0.15s ease, border-color 0.15s ease;\\n  max-width: 300px;\\n}\\n\\n.card:hover,\\n.card:focus,\\n.card:active {\\n  color: #0070f3;\\n  border-color: #0070f3;\\n}\\n\\n.card h2 {\\n  margin: 0 0 1rem 0;\\n  font-size: 1.5rem;\\n}\\n\\n.card p {\\n  margin: 0;\\n  font-size: 1.25rem;\\n  line-height: 1.5;\\n}\\n\\n.logo {\\n  height: 1em;\\n  margin-left: 0.5rem;\\n}\\n\\n@media (max-width: 600px) {\\n  .grid {\\n    width: 100%;\\n    flex-direction: column;\\n  }\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  .card,\\n  .footer {\\n    border-color: #222;\\n  }\\n  .code {\\n    background: #111;\\n  }\\n  .logo img {\\n    filter: invert(1);\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"container\": \"Home_container__bCOhY\",\n\t\"main\": \"Home_main__nLjiQ\",\n\t\"footer\": \"Home_footer____T7K\",\n\t\"title\": \"Home_title__T09hD\",\n\t\"description\": \"Home_description__41Owk\",\n\t\"code\": \"Home_code__suPER\",\n\t\"grid\": \"Home_grid__GxQ85\",\n\t\"card\": \"Home_card___LpL1\",\n\t\"logo\": \"Home_logo__27_tb\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vc3R5bGVzL0hvbWUubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLG1LQUErRTtBQUN6SDtBQUNBO0FBQ0Esa0VBQWtFLG9CQUFvQixHQUFHLHVCQUF1QixzQkFBc0Isb0JBQW9CLGNBQWMsa0JBQWtCLDJCQUEyQiw0QkFBNEIsd0JBQXdCLEdBQUcseUJBQXlCLGtCQUFrQixjQUFjLG9CQUFvQixrQ0FBa0MsNEJBQTRCLHdCQUF3QixHQUFHLDJCQUEyQixrQkFBa0IsNEJBQTRCLHdCQUF3QixpQkFBaUIsR0FBRywwQkFBMEIsbUJBQW1CLDBCQUEwQixHQUFHLDJGQUEyRiwrQkFBK0IsR0FBRyx3QkFBd0IsY0FBYyxzQkFBc0Isb0JBQW9CLEdBQUcsbURBQW1ELHVCQUF1QixHQUFHLDhCQUE4QixtQkFBbUIscUJBQXFCLHNCQUFzQixHQUFHLHVCQUF1Qix3QkFBd0IsdUJBQXVCLHFCQUFxQixzQkFBc0IseUlBQXlJLEdBQUcsdUJBQXVCLGtCQUFrQix3QkFBd0IsNEJBQTRCLG9CQUFvQixxQkFBcUIsR0FBRyx1QkFBdUIsaUJBQWlCLG9CQUFvQixxQkFBcUIsbUJBQW1CLDBCQUEwQiw4QkFBOEIsd0JBQXdCLDBEQUEwRCxxQkFBcUIsR0FBRyxrRkFBa0YsbUJBQW1CLDBCQUEwQixHQUFHLDBCQUEwQix1QkFBdUIsc0JBQXNCLEdBQUcseUJBQXlCLGNBQWMsdUJBQXVCLHFCQUFxQixHQUFHLHVCQUF1QixnQkFBZ0Isd0JBQXdCLEdBQUcsK0JBQStCLHVCQUF1QixrQkFBa0IsNkJBQTZCLEtBQUssR0FBRyx5Q0FBeUMsK0NBQStDLHlCQUF5QixLQUFLLHVCQUF1Qix1QkFBdUIsS0FBSywyQkFBMkIsd0JBQXdCLEtBQUssR0FBRyxTQUFTLHVGQUF1RixVQUFVLE9BQU8sS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxVQUFVLFVBQVUsVUFBVSxZQUFZLGFBQWEsYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsV0FBVyxNQUFNLEtBQUssVUFBVSxZQUFZLE9BQU8sT0FBTyxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksV0FBVyxPQUFPLE1BQU0sWUFBWSxPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxhQUFhLGFBQWEsTUFBTSxPQUFPLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxXQUFXLFlBQVksT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLE9BQU8sT0FBTyxVQUFVLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxPQUFPLEtBQUssS0FBSyxVQUFVLFlBQVksTUFBTSxNQUFNLEtBQUssTUFBTSxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0scUNBQXFDLG9CQUFvQixHQUFHLFdBQVcsc0JBQXNCLG9CQUFvQixZQUFZLGtCQUFrQiwyQkFBMkIsNEJBQTRCLHdCQUF3QixHQUFHLGFBQWEsa0JBQWtCLFlBQVksb0JBQW9CLGtDQUFrQyw0QkFBNEIsd0JBQXdCLEdBQUcsZUFBZSxrQkFBa0IsNEJBQTRCLHdCQUF3QixpQkFBaUIsR0FBRyxjQUFjLG1CQUFtQiwwQkFBMEIsR0FBRyx1REFBdUQsK0JBQStCLEdBQUcsWUFBWSxjQUFjLHNCQUFzQixvQkFBb0IsR0FBRywyQkFBMkIsdUJBQXVCLEdBQUcsa0JBQWtCLG1CQUFtQixxQkFBcUIsc0JBQXNCLEdBQUcsV0FBVyx3QkFBd0IsdUJBQXVCLHFCQUFxQixzQkFBc0IseUlBQXlJLEdBQUcsV0FBVyxrQkFBa0Isd0JBQXdCLDRCQUE0QixvQkFBb0IscUJBQXFCLEdBQUcsV0FBVyxpQkFBaUIsb0JBQW9CLHFCQUFxQixtQkFBbUIsMEJBQTBCLDhCQUE4Qix3QkFBd0IsMERBQTBELHFCQUFxQixHQUFHLDhDQUE4QyxtQkFBbUIsMEJBQTBCLEdBQUcsY0FBYyx1QkFBdUIsc0JBQXNCLEdBQUcsYUFBYSxjQUFjLHVCQUF1QixxQkFBcUIsR0FBRyxXQUFXLGdCQUFnQix3QkFBd0IsR0FBRywrQkFBK0IsV0FBVyxrQkFBa0IsNkJBQTZCLEtBQUssR0FBRyx5Q0FBeUMsdUJBQXVCLHlCQUF5QixLQUFLLFdBQVcsdUJBQXVCLEtBQUssZUFBZSx3QkFBd0IsS0FBSyxHQUFHLHFCQUFxQjtBQUN0MEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL0hvbWUubW9kdWxlLmNzcz8xY2I0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuSG9tZV9jb250YWluZXJfX2JDT2hZIHtcXG4gIHBhZGRpbmc6IDAgMnJlbTtcXG59XFxuXFxuLkhvbWVfbWFpbl9fbkxqaVEge1xcbiAgbWluLWhlaWdodDogMTAwdmg7XFxuICBwYWRkaW5nOiA0cmVtIDA7XFxuICBmbGV4OiAxIDE7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLkhvbWVfZm9vdGVyX19fX1Q3SyB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleDogMSAxO1xcbiAgcGFkZGluZzogMnJlbSAwO1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlYWVhZWE7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5Ib21lX2Zvb3Rlcl9fX19UN0sgYSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZmxleC1ncm93OiAxO1xcbn1cXG5cXG4uSG9tZV90aXRsZV9fVDA5aEQgYSB7XFxuICBjb2xvcjogIzAwNzBmMztcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuXFxuLkhvbWVfdGl0bGVfX1QwOWhEIGE6aG92ZXIsXFxuLkhvbWVfdGl0bGVfX1QwOWhEIGE6Zm9jdXMsXFxuLkhvbWVfdGl0bGVfX1QwOWhEIGE6YWN0aXZlIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG5cXG4uSG9tZV90aXRsZV9fVDA5aEQge1xcbiAgbWFyZ2luOiAwO1xcbiAgbGluZS1oZWlnaHQ6IDEuMTU7XFxuICBmb250LXNpemU6IDRyZW07XFxufVxcblxcbi5Ib21lX3RpdGxlX19UMDloRCxcXG4uSG9tZV9kZXNjcmlwdGlvbl9fNDFPd2sge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4uSG9tZV9kZXNjcmlwdGlvbl9fNDFPd2sge1xcbiAgbWFyZ2luOiA0cmVtIDA7XFxuICBsaW5lLWhlaWdodDogMS41O1xcbiAgZm9udC1zaXplOiAxLjVyZW07XFxufVxcblxcbi5Ib21lX2NvZGVfX3N1UEVSIHtcXG4gIGJhY2tncm91bmQ6ICNmYWZhZmE7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBwYWRkaW5nOiAwLjc1cmVtO1xcbiAgZm9udC1zaXplOiAxLjFyZW07XFxuICBmb250LWZhbWlseTogTWVubG8sIE1vbmFjbywgTHVjaWRhIENvbnNvbGUsIExpYmVyYXRpb24gTW9ubywgRGVqYVZ1IFNhbnMgTW9ubyxcXG4gICAgQml0c3RyZWFtIFZlcmEgU2FucyBNb25vLCBDb3VyaWVyIE5ldywgbW9ub3NwYWNlO1xcbn1cXG5cXG4uSG9tZV9ncmlkX19HeFE4NSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbiAgbWF4LXdpZHRoOiA4MDBweDtcXG59XFxuXFxuLkhvbWVfY2FyZF9fX0xwTDEge1xcbiAgbWFyZ2luOiAxcmVtO1xcbiAgcGFkZGluZzogMS41cmVtO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2VhZWFlYTtcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICB0cmFuc2l0aW9uOiBjb2xvciAwLjE1cyBlYXNlLCBib3JkZXItY29sb3IgMC4xNXMgZWFzZTtcXG4gIG1heC13aWR0aDogMzAwcHg7XFxufVxcblxcbi5Ib21lX2NhcmRfX19McEwxOmhvdmVyLFxcbi5Ib21lX2NhcmRfX19McEwxOmZvY3VzLFxcbi5Ib21lX2NhcmRfX19McEwxOmFjdGl2ZSB7XFxuICBjb2xvcjogIzAwNzBmMztcXG4gIGJvcmRlci1jb2xvcjogIzAwNzBmMztcXG59XFxuXFxuLkhvbWVfY2FyZF9fX0xwTDEgaDIge1xcbiAgbWFyZ2luOiAwIDAgMXJlbSAwO1xcbiAgZm9udC1zaXplOiAxLjVyZW07XFxufVxcblxcbi5Ib21lX2NhcmRfX19McEwxIHAge1xcbiAgbWFyZ2luOiAwO1xcbiAgZm9udC1zaXplOiAxLjI1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG59XFxuXFxuLkhvbWVfbG9nb19fMjdfdGIge1xcbiAgaGVpZ2h0OiAxZW07XFxuICBtYXJnaW4tbGVmdDogMC41cmVtO1xcbn1cXG5cXG5AbWVkaWEgKG1heC13aWR0aDogNjAwcHgpIHtcXG4gIC5Ib21lX2dyaWRfX0d4UTg1IHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB9XFxufVxcblxcbkBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHtcXG4gIC5Ib21lX2NhcmRfX19McEwxLFxcbiAgLkhvbWVfZm9vdGVyX19fX1Q3SyB7XFxuICAgIGJvcmRlci1jb2xvcjogIzIyMjtcXG4gIH1cXG4gIC5Ib21lX2NvZGVfX3N1UEVSIHtcXG4gICAgYmFja2dyb3VuZDogIzExMTtcXG4gIH1cXG4gIC5Ib21lX2xvZ29fXzI3X3RiIGltZyB7XFxuICAgIGZpbHRlcjogaW52ZXJ0KDEpO1xcbiAgfVxcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3R5bGVzL0hvbWUubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxpQkFBaUI7RUFDakIsZUFBZTtFQUNmLFNBQU87RUFDUCxhQUFhO0VBQ2Isc0JBQXNCO0VBQ3RCLHVCQUF1QjtFQUN2QixtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsU0FBTztFQUNQLGVBQWU7RUFDZiw2QkFBNkI7RUFDN0IsdUJBQXVCO0VBQ3ZCLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFLGFBQWE7RUFDYix1QkFBdUI7RUFDdkIsbUJBQW1CO0VBQ25CLFlBQVk7QUFDZDs7QUFFQTtFQUNFLGNBQWM7RUFDZCxxQkFBcUI7QUFDdkI7O0FBRUE7OztFQUdFLDBCQUEwQjtBQUM1Qjs7QUFFQTtFQUNFLFNBQVM7RUFDVCxpQkFBaUI7RUFDakIsZUFBZTtBQUNqQjs7QUFFQTs7RUFFRSxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxjQUFjO0VBQ2QsZ0JBQWdCO0VBQ2hCLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLG1CQUFtQjtFQUNuQixrQkFBa0I7RUFDbEIsZ0JBQWdCO0VBQ2hCLGlCQUFpQjtFQUNqQjtvREFDa0Q7QUFDcEQ7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsbUJBQW1CO0VBQ25CLHVCQUF1QjtFQUN2QixlQUFlO0VBQ2YsZ0JBQWdCO0FBQ2xCOztBQUVBO0VBQ0UsWUFBWTtFQUNaLGVBQWU7RUFDZixnQkFBZ0I7RUFDaEIsY0FBYztFQUNkLHFCQUFxQjtFQUNyQix5QkFBeUI7RUFDekIsbUJBQW1CO0VBQ25CLHFEQUFxRDtFQUNyRCxnQkFBZ0I7QUFDbEI7O0FBRUE7OztFQUdFLGNBQWM7RUFDZCxxQkFBcUI7QUFDdkI7O0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0UsU0FBUztFQUNULGtCQUFrQjtFQUNsQixnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxXQUFXO0VBQ1gsbUJBQW1CO0FBQ3JCOztBQUVBO0VBQ0U7SUFDRSxXQUFXO0lBQ1gsc0JBQXNCO0VBQ3hCO0FBQ0Y7O0FBRUE7RUFDRTs7SUFFRSxrQkFBa0I7RUFDcEI7RUFDQTtJQUNFLGdCQUFnQjtFQUNsQjtFQUNBO0lBQ0UsaUJBQWlCO0VBQ25CO0FBQ0ZcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmNvbnRhaW5lciB7XFxuICBwYWRkaW5nOiAwIDJyZW07XFxufVxcblxcbi5tYWluIHtcXG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xcbiAgcGFkZGluZzogNHJlbSAwO1xcbiAgZmxleDogMTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4uZm9vdGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4OiAxO1xcbiAgcGFkZGluZzogMnJlbSAwO1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlYWVhZWE7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5mb290ZXIgYSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZmxleC1ncm93OiAxO1xcbn1cXG5cXG4udGl0bGUgYSB7XFxuICBjb2xvcjogIzAwNzBmMztcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuXFxuLnRpdGxlIGE6aG92ZXIsXFxuLnRpdGxlIGE6Zm9jdXMsXFxuLnRpdGxlIGE6YWN0aXZlIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG5cXG4udGl0bGUge1xcbiAgbWFyZ2luOiAwO1xcbiAgbGluZS1oZWlnaHQ6IDEuMTU7XFxuICBmb250LXNpemU6IDRyZW07XFxufVxcblxcbi50aXRsZSxcXG4uZGVzY3JpcHRpb24ge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4uZGVzY3JpcHRpb24ge1xcbiAgbWFyZ2luOiA0cmVtIDA7XFxuICBsaW5lLWhlaWdodDogMS41O1xcbiAgZm9udC1zaXplOiAxLjVyZW07XFxufVxcblxcbi5jb2RlIHtcXG4gIGJhY2tncm91bmQ6ICNmYWZhZmE7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBwYWRkaW5nOiAwLjc1cmVtO1xcbiAgZm9udC1zaXplOiAxLjFyZW07XFxuICBmb250LWZhbWlseTogTWVubG8sIE1vbmFjbywgTHVjaWRhIENvbnNvbGUsIExpYmVyYXRpb24gTW9ubywgRGVqYVZ1IFNhbnMgTW9ubyxcXG4gICAgQml0c3RyZWFtIFZlcmEgU2FucyBNb25vLCBDb3VyaWVyIE5ldywgbW9ub3NwYWNlO1xcbn1cXG5cXG4uZ3JpZCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbiAgbWF4LXdpZHRoOiA4MDBweDtcXG59XFxuXFxuLmNhcmQge1xcbiAgbWFyZ2luOiAxcmVtO1xcbiAgcGFkZGluZzogMS41cmVtO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2VhZWFlYTtcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICB0cmFuc2l0aW9uOiBjb2xvciAwLjE1cyBlYXNlLCBib3JkZXItY29sb3IgMC4xNXMgZWFzZTtcXG4gIG1heC13aWR0aDogMzAwcHg7XFxufVxcblxcbi5jYXJkOmhvdmVyLFxcbi5jYXJkOmZvY3VzLFxcbi5jYXJkOmFjdGl2ZSB7XFxuICBjb2xvcjogIzAwNzBmMztcXG4gIGJvcmRlci1jb2xvcjogIzAwNzBmMztcXG59XFxuXFxuLmNhcmQgaDIge1xcbiAgbWFyZ2luOiAwIDAgMXJlbSAwO1xcbiAgZm9udC1zaXplOiAxLjVyZW07XFxufVxcblxcbi5jYXJkIHAge1xcbiAgbWFyZ2luOiAwO1xcbiAgZm9udC1zaXplOiAxLjI1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG59XFxuXFxuLmxvZ28ge1xcbiAgaGVpZ2h0OiAxZW07XFxuICBtYXJnaW4tbGVmdDogMC41cmVtO1xcbn1cXG5cXG5AbWVkaWEgKG1heC13aWR0aDogNjAwcHgpIHtcXG4gIC5ncmlkIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB9XFxufVxcblxcbkBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHtcXG4gIC5jYXJkLFxcbiAgLmZvb3RlciB7XFxuICAgIGJvcmRlci1jb2xvcjogIzIyMjtcXG4gIH1cXG4gIC5jb2RlIHtcXG4gICAgYmFja2dyb3VuZDogIzExMTtcXG4gIH1cXG4gIC5sb2dvIGltZyB7XFxuICAgIGZpbHRlcjogaW52ZXJ0KDEpO1xcbiAgfVxcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJjb250YWluZXJcIjogXCJIb21lX2NvbnRhaW5lcl9fYkNPaFlcIixcblx0XCJtYWluXCI6IFwiSG9tZV9tYWluX19uTGppUVwiLFxuXHRcImZvb3RlclwiOiBcIkhvbWVfZm9vdGVyX19fX1Q3S1wiLFxuXHRcInRpdGxlXCI6IFwiSG9tZV90aXRsZV9fVDA5aERcIixcblx0XCJkZXNjcmlwdGlvblwiOiBcIkhvbWVfZGVzY3JpcHRpb25fXzQxT3drXCIsXG5cdFwiY29kZVwiOiBcIkhvbWVfY29kZV9fc3VQRVJcIixcblx0XCJncmlkXCI6IFwiSG9tZV9ncmlkX19HeFE4NVwiLFxuXHRcImNhcmRcIjogXCJIb21lX2NhcmRfX19McEwxXCIsXG5cdFwibG9nb1wiOiBcIkhvbWVfbG9nb19fMjdfdGJcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Home.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2FJon%2FProjects%2Fchrome-extension%2FOpenAI%20Hackathon%2Fopenai-hackathon-dec-22%2Fpages%2Findex.tsx&page=%2F!":
/*!*****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2FJon%2FProjects%2Fchrome-extension%2FOpenAI%20Hackathon%2Fopenai-hackathon-dec-22%2Fpages%2Findex.tsx&page=%2F! ***!
  \*****************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.tsx */ \"./pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRkpvbiUyRlByb2plY3RzJTJGY2hyb21lLWV4dGVuc2lvbiUyRk9wZW5BSSUyMEhhY2thdGhvbiUyRm9wZW5haS1oYWNrYXRob24tZGVjLTIyJTJGcGFnZXMlMkZpbmRleC50c3gmcGFnZT0lMkYhLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsNENBQW1CO0FBQzFDO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9lYWUyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiLi9wYWdlcy9pbmRleC50c3hcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2FJon%2FProjects%2Fchrome-extension%2FOpenAI%20Hackathon%2Fopenai-hackathon-dec-22%2Fpages%2Findex.tsx&page=%2F!\n"));

/***/ }),

/***/ "./styles/Home.module.css":
/*!********************************!*\
  !*** ./styles/Home.module.css ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Home.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Home.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./styles/Home.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvSG9tZS5tb2R1bGUuY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxvTkFBd0c7QUFDMUgsMEJBQTBCLG1CQUFPLENBQUMsK2VBQW1QOztBQUVyUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0sK2VBQW1QO0FBQ3pQO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsK2VBQW1QOztBQUU3UTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdHlsZXMvSG9tZS5tb2R1bGUuY3NzPzM4ZjciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vSG9tZS5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsyXSEuL0hvbWUubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMl0hLi9Ib21lLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./styles/Home.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/image.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/image.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\"use client\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _head = _interop_require_default(__webpack_require__(/*! ../shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\"));\nvar _imageBlurSvg = __webpack_require__(/*! ../shared/lib/image-blur-svg */ \"./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nvar _imageConfig = __webpack_require__(/*! ../shared/lib/image-config */ \"./node_modules/next/dist/shared/lib/image-config.js\");\nvar _imageConfigContext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\nvar _warnOnce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nvar _imageLoader = _interop_require_default(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"./node_modules/next/dist/shared/lib/image-loader.js\"));\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]};\nconst allImgs = new Map();\nlet perfObserver;\nif (false) {}\nconst VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes , allSizes  } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config , src , unoptimized , width , quality , sizes , loader  } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths , kind  } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map((w, i)=>\"\".concat(loader({\n                config,\n                src,\n                quality,\n                width: w\n            }), \" \").concat(kind === \"w\" ? w : i + 1).concat(kind)).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getInt(x) {\n    if (typeof x === \"number\" || typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, src, onLoadRef, onLoadingCompleteRef, unoptimized) {\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    const p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentNode) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current(_extends({}, event, {\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            }));\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!img.getAttribute(\"sizes\") || img.getAttribute(\"sizes\") === \"100vw\")) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        (0, _warnOnce).warnOnce('Image with src \"'.concat(src, '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes'));\n                    }\n                }\n                if (img.parentElement) {\n                    const { position  } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnOnce).warnOnce('Image with src \"'.concat(src, '\" has \"fill\" and parent element with invalid \"position\". Provided \"').concat(position, '\" should be one of ').concat(valid.map(String).join(\",\"), \".\"));\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnOnce).warnOnce('Image with src \"'.concat(src, '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.'));\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            const widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnOnce).warnOnce('Image with src \"'.concat(src, '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.'));\n            }\n        }\n    });\n}\nconst ImageElement = /*#__PURE__*/ (0, _react).forwardRef(_s((_param, forwardedRef)=>{\n    _s();\n    var { imgAttributes , heightInt , widthInt , qualityInt , className , imgStyle , blurStyle , isLazy , fill , placeholder , loading , srcString , config , unoptimized , loader , onLoadRef , onLoadingCompleteRef , onLoad , onError  } = _param, rest = _object_without_properties_loose(_param, [\n        \"imgAttributes\",\n        \"heightInt\",\n        \"widthInt\",\n        \"qualityInt\",\n        \"className\",\n        \"imgStyle\",\n        \"blurStyle\",\n        \"isLazy\",\n        \"fill\",\n        \"placeholder\",\n        \"loading\",\n        \"srcString\",\n        \"config\",\n        \"unoptimized\",\n        \"loader\",\n        \"onLoadRef\",\n        \"onLoadingCompleteRef\",\n        \"onLoad\",\n        \"onError\"\n    ]);\n    loading = isLazy ? \"lazy\" : loading;\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"img\", Object.assign({}, rest, imgAttributes, {\n        width: widthInt,\n        height: heightInt,\n        decoding: \"async\",\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        // @ts-ignore - TODO: upgrade to `@types/react@17`\n        loading: loading,\n        style: _extends({}, imgStyle, blurStyle),\n        ref: (0, _react).useCallback((img)=>{\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!srcString) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, srcString, onLoadRef, onLoadingCompleteRef, unoptimized);\n            }\n        }, [\n            srcString,\n            onLoadRef,\n            onLoadingCompleteRef,\n            onError,\n            unoptimized,\n            forwardedRef\n        ]),\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, srcString, onLoadRef, onLoadingCompleteRef, unoptimized);\n        },\n        onError: (event)=>{\n            // Note: We removed React.useState() in the error case here\n            // because it was causing Safari to become very slow when\n            // there were many images on the same page.\n            const { style  } = event.currentTarget;\n            if (style.color === \"transparent\") {\n                // If src image fails to load, this will ensure \"alt\" is visible\n                style.color = \"\";\n            }\n            if (placeholder === \"blur\" && style.backgroundImage) {\n                // If src image fails to load, this will ensure the placeholder is removed\n                style.backgroundSize = \"\";\n                style.backgroundPosition = \"\";\n                style.backgroundRepeat = \"\";\n                style.backgroundImage = \"\";\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    })));\n}, \"epj4qY15NHsef74wNqHIp5fdZmg=\"));\n_c = ImageElement;\nconst Image = _s1(/*#__PURE__*/ (0, _react).forwardRef(_c1 = _s1((_param, forwardedRef)=>{\n    _s1();\n    var { src , sizes , unoptimized =false , priority =false , loading , className , quality , width , height , fill , style , onLoad , onLoadingComplete , placeholder =\"empty\" , blurDataURL , layout , objectFit , objectPosition , lazyBoundary , lazyRoot  } = _param, all = _object_without_properties_loose(_param, [\n        \"src\",\n        \"sizes\",\n        \"unoptimized\",\n        \"priority\",\n        \"loading\",\n        \"className\",\n        \"quality\",\n        \"width\",\n        \"height\",\n        \"fill\",\n        \"style\",\n        \"onLoad\",\n        \"onLoadingComplete\",\n        \"placeholder\",\n        \"blurDataURL\",\n        \"layout\",\n        \"objectFit\",\n        \"objectPosition\",\n        \"lazyBoundary\",\n        \"lazyRoot\"\n    ]);\n    const configContext = (0, _react).useContext(_imageConfigContext.ImageConfigContext);\n    const config = (0, _react).useMemo(()=>{\n        const c = configEnv || configContext || _imageConfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return _extends({}, c, {\n            allSizes,\n            deviceSizes\n        });\n    }, [\n        configContext\n    ]);\n    let rest = all;\n    let loader = rest.loader || _imageLoader.default;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    if (\"__next_img_default\" in loader) {\n        // This special value indicates that the user\n        // didn't define a \"loader\" prop or config.\n        if (config.loader === \"custom\") {\n            throw new Error('Image with src \"'.concat(src, '\" is missing \"loader\" prop.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        var _tmp;\n        _tmp = (obj)=>{\n            const { config: _  } = obj, opts = _object_without_properties_loose(obj, [\n                \"config\"\n            ]);\n            return customImageLoader(opts);\n        }, loader = _tmp, _tmp;\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        const layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = _extends({}, style, layoutStyle);\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = \"\";\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \".concat(JSON.stringify(staticImageData)));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \".concat(JSON.stringify(staticImageData)));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio1 = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio1);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    let isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"'.concat(src, '\" has both \"width\" and \"fill\" properties. Only one should be used.'));\n                }\n                if (height) {\n                    throw new Error('Image with src \"'.concat(src, '\" has both \"height\" and \"fill\" properties. Only one should be used.'));\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error('Image with src \"'.concat(src, '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.'));\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error('Image with src \"'.concat(src, '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.'));\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error('Image with src \"'.concat(src, '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.'));\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error('Image with src \"'.concat(src, '\" is missing required \"width\" property.'));\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"'.concat(src, '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"').concat(width, '\".'));\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error('Image with src \"'.concat(src, '\" is missing required \"height\" property.'));\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"'.concat(src, '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"').concat(height, '\".'));\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"'.concat(src, '\" has invalid \"loading\" property. Provided \"').concat(loading, '\" should be one of ').concat(VALID_LOADING_VALUES.map(String).join(\",\"), \".\"));\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"'.concat(src, '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.'));\n        }\n        if (placeholder === \"blur\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnOnce).warnOnce('Image with src \"'.concat(src, '\" is smaller than 40x40. Consider removing the \"placeholder=\\'blur\\'\" property to improve performance.'));\n            }\n            if (!blurDataURL) {\n                const VALID_BLUR_EXT = [\n                    \"jpeg\",\n                    \"png\",\n                    \"webp\",\n                    \"avif\"\n                ] // should match next-image-loader\n                ;\n                throw new Error('Image with src \"'.concat(src, '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n          Possible solutions:\\n            - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n            - Change the \"src\" property to a static import with one of the supported file types: ').concat(VALID_BLUR_EXT.join(\",\"), '\\n            - Remove the \"placeholder\" property, effectively no blur effect\\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url'));\n            }\n        }\n        if (\"ref\" in rest) {\n            (0, _warnOnce).warnOnce('Image with src \"'.concat(src, '\" is using unsupported \"ref\" property. Consider using the \"onLoadingComplete\" property instead.'));\n        }\n        if (!unoptimized && loader !== _imageLoader.default) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnOnce).warnOnce('Image with src \"'.concat(src, '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnOnce).warnOnce('Image with src \"'.concat(src, '\" has legacy prop \"').concat(legacyKey, '\". Did you forget to run the codemod?') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if ( true && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var ref;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (ref = entry.element) == null ? void 0 : ref.src) || \"\";\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder !== \"blur\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnOnce).warnOnce('Image with src \"'.concat(lcpImage.src, '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.') + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err1) {\n                // Log error but don't crash the app\n                console.error(err1);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, {\n        color: \"transparent\"\n    }, style);\n    const blurStyle = placeholder === \"blur\" && blurDataURL ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: 'url(\"data:image/svg+xml;charset=utf-8,'.concat((0, _imageBlurSvg).getImageBlurSvg({\n            widthInt,\n            heightInt,\n            blurWidth,\n            blurHeight,\n            blurDataURL\n        }), '\")')\n    } : {};\n    if (true) {\n        if (blurStyle.backgroundImage && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            blurStyle.backgroundImage = 'url(\"'.concat(blurDataURL, '\")');\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    let srcString = src;\n    if (true) {\n        if (true) {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const linkProps = {\n        // @ts-expect-error upgrade react types to react 18\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: rest.crossOrigin\n    };\n    const onLoadRef = (0, _react).useRef(onLoad);\n    (0, _react).useEffect(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react).useRef(onLoadingComplete);\n    (0, _react).useEffect(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const imgElementArgs = _extends({\n        isLazy,\n        imgAttributes,\n        heightInt,\n        widthInt,\n        qualityInt,\n        className,\n        imgStyle,\n        blurStyle,\n        loading,\n        config,\n        fill,\n        unoptimized,\n        placeholder,\n        loader,\n        srcString,\n        onLoadRef,\n        onLoadingCompleteRef\n    }, rest);\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(ImageElement, Object.assign({}, imgElementArgs, {\n        ref: forwardedRef\n    })), priority ? // for browsers that do not support `imagesrcset`, and in those cases\n    // it would likely cause the incorrect image to be preloaded.\n    //\n    // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n    /*#__PURE__*/ _react.default.createElement(_head.default, null, /*#__PURE__*/ _react.default.createElement(\"link\", Object.assign({\n        key: \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n        rel: \"preload\",\n        as: \"image\",\n        href: imgAttributes.srcSet ? undefined : imgAttributes.src\n    }, linkProps))) : null);\n}, \"PVCHsAJ5AHFn9v5UrhxvLPQk4xA=\")), \"PVCHsAJ5AHFn9v5UrhxvLPQk4xA=\");\n_c2 = Image;\nvar _default = Image;\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"ImageElement\");\n$RefreshReg$(_c1, \"Image$(0, _react).forwardRef\");\n$RefreshReg$(_c2, \"Image\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7QUFEYjtBQUVBQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUcsV0FBV0MsbUhBQStDO0FBQzlELElBQUlDLDJCQUEyQkQsbUpBQStEO0FBQzlGLElBQUlFLDRCQUE0QkYscUpBQWdFO0FBQ2hHLElBQUlHLG1DQUFtQ0gsbUtBQXVFO0FBQzlHLElBQUlJLFNBQVNGLDBCQUEwQkYsbUJBQU9BLENBQUMsNENBQU87QUFDdEQsSUFBSUssUUFBUUoseUJBQXlCRCxtQkFBT0EsQ0FBQyx1RUFBb0I7QUFDakUsSUFBSU0sZ0JBQWdCTixtQkFBT0EsQ0FBQywyRkFBOEI7QUFDMUQsSUFBSU8sZUFBZVAsbUJBQU9BLENBQUMsdUZBQTRCO0FBQ3ZELElBQUlRLHNCQUFzQlIsbUJBQU9BLENBQUMsdUdBQW9DO0FBQ3RFLElBQUlTLFlBQVlULG1CQUFPQSxDQUFDLDZGQUErQjtBQUN2RCxJQUFJVSxlQUFlVCx5QkFBeUJELG1CQUFPQSxDQUFDLDhGQUFtQztBQUV2RixNQUFNVyxZQUFZQywwTkFBNkI7QUFDL0MsTUFBTUcsVUFBVSxJQUFJQztBQUNwQixJQUFJQztBQUNKLElBQUksS0FBa0IsRUFBYSxFQUVsQztBQUNELE1BQU1HLHVCQUF1QjtJQUN6QjtJQUNBO0lBQ0FDO0NBQ0g7QUFDRCxTQUFTQyxnQkFBZ0JDLEdBQUcsRUFBRTtJQUMxQixPQUFPQSxJQUFJekIsT0FBTyxLQUFLdUI7QUFDM0I7QUFDQSxTQUFTRyxrQkFBa0JELEdBQUcsRUFBRTtJQUM1QixPQUFPQSxJQUFJQSxHQUFHLEtBQUtGO0FBQ3ZCO0FBQ0EsU0FBU0ksZUFBZUYsR0FBRyxFQUFFO0lBQ3pCLE9BQU8sT0FBT0EsUUFBUSxZQUFhRCxDQUFBQSxnQkFBZ0JDLFFBQVFDLGtCQUFrQkQsSUFBRztBQUNwRjtB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QUssYUFBYTtJQUNyS25PLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUUsT0FBTyxFQUFFLGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9rSSxNQUFNLENBQUNoSSxRQUFRRSxPQUFPLEVBQUVGO0lBQy9Ca08sT0FBT2xPLE9BQU8sR0FBR0EsUUFBUUUsT0FBTztBQUNsQyxDQUFDLENBRUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLmpzPzgyZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9oZWFkID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWRcIikpO1xudmFyIF9pbWFnZUJsdXJTdmcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Z1wiKTtcbnZhciBfaW1hZ2VDb25maWcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWdcIik7XG52YXIgX2ltYWdlQ29uZmlnQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0XCIpO1xudmFyIF93YXJuT25jZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZVwiKTtcbnZhciBfaW1hZ2VMb2FkZXIgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIm5leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWxvYWRlclwiKSk7XG5cbmNvbnN0IGNvbmZpZ0VudiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTO1xuY29uc3QgYWxsSW1ncyA9IG5ldyBNYXAoKTtcbmxldCBwZXJmT2JzZXJ2ZXI7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBnbG9iYWxUaGlzLl9fTkVYVF9JTUFHRV9JTVBPUlRFRCA9IHRydWU7XG59XG5jb25zdCBWQUxJRF9MT0FESU5HX1ZBTFVFUyA9IFtcbiAgICAnbGF6eScsXG4gICAgJ2VhZ2VyJyxcbiAgICB1bmRlZmluZWRcbl07XG5mdW5jdGlvbiBpc1N0YXRpY1JlcXVpcmUoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5kZWZhdWx0ICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1N0YXRpY0ltYWdlRGF0YShzcmMpIHtcbiAgICByZXR1cm4gc3JjLnNyYyAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbXBvcnQoc3JjKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmIChpc1N0YXRpY1JlcXVpcmUoc3JjKSB8fCBpc1N0YXRpY0ltYWdlRGF0YShzcmMpKTtcbn1cbmZ1bmN0aW9uIGdldFdpZHRocyh7IGRldmljZVNpemVzICwgYWxsU2l6ZXMgIH0sIHdpZHRoLCBzaXplcykge1xuICAgIGlmIChzaXplcykge1xuICAgICAgICAvLyBGaW5kIGFsbCB0aGUgXCJ2d1wiIHBlcmNlbnQgc2l6ZXMgdXNlZCBpbiB0aGUgc2l6ZXMgcHJvcFxuICAgICAgICBjb25zdCB2aWV3cG9ydFdpZHRoUmUgPSAvKF58XFxzKSgxP1xcZD9cXGQpdncvZztcbiAgICAgICAgY29uc3QgcGVyY2VudFNpemVzID0gW107XG4gICAgICAgIGZvcihsZXQgbWF0Y2g7IG1hdGNoID0gdmlld3BvcnRXaWR0aFJlLmV4ZWMoc2l6ZXMpOyBtYXRjaCl7XG4gICAgICAgICAgICBwZXJjZW50U2l6ZXMucHVzaChwYXJzZUludChtYXRjaFsyXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJjZW50U2l6ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzbWFsbGVzdFJhdGlvID0gTWF0aC5taW4oLi4ucGVyY2VudFNpemVzKSAqIDAuMDE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoczogYWxsU2l6ZXMuZmlsdGVyKChzKT0+cyA+PSBkZXZpY2VTaXplc1swXSAqIHNtYWxsZXN0UmF0aW8pLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICd3J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBhbGxTaXplcyxcbiAgICAgICAgICAgIGtpbmQ6ICd3J1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBkZXZpY2VTaXplcyxcbiAgICAgICAgICAgIGtpbmQ6ICd3J1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB3aWR0aHMgPSBbXG4gICAgICAgIC4uLm5ldyBTZXQoLy8gPiBUaGlzIG1lYW5zIHRoYXQgbW9zdCBPTEVEIHNjcmVlbnMgdGhhdCBzYXkgdGhleSBhcmUgM3ggcmVzb2x1dGlvbixcbiAgICAgICAgLy8gPiBhcmUgYWN0dWFsbHkgM3ggaW4gdGhlIGdyZWVuIGNvbG9yLCBidXQgb25seSAxLjV4IGluIHRoZSByZWQgYW5kXG4gICAgICAgIC8vID4gYmx1ZSBjb2xvcnMuIFNob3dpbmcgYSAzeCByZXNvbHV0aW9uIGltYWdlIGluIHRoZSBhcHAgdnMgYSAyeFxuICAgICAgICAvLyA+IHJlc29sdXRpb24gaW1hZ2Ugd2lsbCBiZSB2aXN1YWxseSB0aGUgc2FtZSwgdGhvdWdoIHRoZSAzeCBpbWFnZVxuICAgICAgICAvLyA+IHRha2VzIHNpZ25pZmljYW50bHkgbW9yZSBkYXRhLiBFdmVuIHRydWUgM3ggcmVzb2x1dGlvbiBzY3JlZW5zIGFyZVxuICAgICAgICAvLyA+IHdhc3RlZnVsIGFzIHRoZSBodW1hbiBleWUgY2Fubm90IHNlZSB0aGF0IGxldmVsIG9mIGRldGFpbCB3aXRob3V0XG4gICAgICAgIC8vID4gc29tZXRoaW5nIGxpa2UgYSBtYWduaWZ5aW5nIGdsYXNzLlxuICAgICAgICAvLyBodHRwczovL2Jsb2cudHdpdHRlci5jb20vZW5naW5lZXJpbmcvZW5fdXMvdG9waWNzL2luZnJhc3RydWN0dXJlLzIwMTkvY2FwcGluZy1pbWFnZS1maWRlbGl0eS1vbi11bHRyYS1oaWdoLXJlc29sdXRpb24tZGV2aWNlcy5odG1sXG4gICAgICAgIFtcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgd2lkdGggKiAyIC8qLCB3aWR0aCAqIDMqLyBcbiAgICAgICAgXS5tYXAoKHcpPT5hbGxTaXplcy5maW5kKChwKT0+cCA+PSB3KSB8fCBhbGxTaXplc1thbGxTaXplcy5sZW5ndGggLSAxXSkpLCBcbiAgICBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRocyxcbiAgICAgICAga2luZDogJ3gnXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1nQXR0cnMoeyBjb25maWcgLCBzcmMgLCB1bm9wdGltaXplZCAsIHdpZHRoICwgcXVhbGl0eSAsIHNpemVzICwgbG9hZGVyICB9KSB7XG4gICAgaWYgKHVub3B0aW1pemVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICBzcmNTZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNpemVzOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyB3aWR0aHMgLCBraW5kICB9ID0gZ2V0V2lkdGhzKGNvbmZpZywgd2lkdGgsIHNpemVzKTtcbiAgICBjb25zdCBsYXN0ID0gd2lkdGhzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZXM6ICFzaXplcyAmJiBraW5kID09PSAndycgPyAnMTAwdncnIDogc2l6ZXMsXG4gICAgICAgIHNyY1NldDogd2lkdGhzLm1hcCgodywgaSk9PmAke2xvYWRlcih7XG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3XG4gICAgICAgICAgICB9KX0gJHtraW5kID09PSAndycgPyB3IDogaSArIDF9JHtraW5kfWApLmpvaW4oJywgJyksXG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgc3JjYCB0aGUgbGFzdCBhdHRyaWJ1dGUgYmVjYXVzZSBSZWFjdCB1cGRhdGVzXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgICAgICAvLyB1cGRhdGVkIGJ5IFJlYWN0LiBUaGF0IGNhdXNlcyBtdWx0aXBsZSB1bm5lY2Vzc2FyeSByZXF1ZXN0cyBpZiBgc3JjU2V0YFxuICAgICAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAgICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgICAgIHNyYzogbG9hZGVyKHtcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHF1YWxpdHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGhzW2xhc3RdXG4gICAgICAgIH0pXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEludCh4KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgL15bMC05XSskLy50ZXN0KHgpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh4LCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBOYU47XG59XG4vLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM5Nzc3ODMzLzI2NjUzNSBmb3Igd2h5IHdlIHVzZSB0aGlzIHJlZlxuLy8gaGFuZGxlciBpbnN0ZWFkIG9mIHRoZSBpbWcncyBvbkxvYWQgYXR0cmlidXRlLlxuZnVuY3Rpb24gaGFuZGxlTG9hZGluZyhpbWcsIHNyYywgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgdW5vcHRpbWl6ZWQpIHtcbiAgICBpZiAoIWltZyB8fCBpbWdbJ2RhdGEtbG9hZGVkLXNyYyddID09PSBzcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbWdbJ2RhdGEtbG9hZGVkLXNyYyddID0gc3JjO1xuICAgIGNvbnN0IHAgPSAnZGVjb2RlJyBpbiBpbWcgPyBpbWcuZGVjb2RlKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBwLmNhdGNoKCgpPT57fSkudGhlbigoKT0+e1xuICAgICAgICBpZiAoIWltZy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGluIGNhc2Ugb2YgcmFjZSBjb25kaXRpb246XG4gICAgICAgICAgICAvLyAtIG9ubG9hZCgpIGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBpcyBjYWxsZWQgYnV0IGluY29tcGxldGVcbiAgICAgICAgICAgIC8vIC0gdW5tb3VudCBpcyBjYWxsZWRcbiAgICAgICAgICAgIC8vIC0gZGVjb2RlKCkgY29tcGxldGVzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTG9hZFJlZiA9PSBudWxsID8gdm9pZCAwIDogb25Mb2FkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGhhdmUgdGhlIFN5bnRoZXRpY0V2ZW50IGhlcmUsXG4gICAgICAgICAgICAvLyB3ZSBtdXN0IGNyZWF0ZSBvbmUgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXZlbnRzLmh0bWxcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdsb2FkJyk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsICd0YXJnZXQnLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG9uTG9hZFJlZi5jdXJyZW50KF9leHRlbmRzKHt9LCBldmVudCwge1xuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBpbWcsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpbWcsXG4gICAgICAgICAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiAoKT0+cHJldmVudGVkLFxuICAgICAgICAgICAgICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiAoKT0+c3RvcHBlZCxcbiAgICAgICAgICAgICAgICBwZXJzaXN0OiAoKT0+e30sXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlUmVmID09IG51bGwgPyB2b2lkIDAgOiBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KGltZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChpbWcuZ2V0QXR0cmlidXRlKCdkYXRhLW5pbWcnKSA9PT0gJ2ZpbGwnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bm9wdGltaXplZCAmJiAoIWltZy5nZXRBdHRyaWJ1dGUoJ3NpemVzJykgfHwgaW1nLmdldEF0dHJpYnV0ZSgnc2l6ZXMnKSA9PT0gJzEwMHZ3JykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoVmlld3BvcnRSYXRpbyA9IGltZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAvIHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGhWaWV3cG9ydFJhdGlvIDwgMC42KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5PbmNlKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgXCJmaWxsXCIgYnV0IGlzIG1pc3NpbmcgXCJzaXplc1wiIHByb3AuIFBsZWFzZSBhZGQgaXQgdG8gaW1wcm92ZSBwYWdlIHBlcmZvcm1hbmNlLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNzaXplc2ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbWcucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uICB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaW1nLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZml4ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlbGF0aXZlJ1xuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkLmluY2x1ZGVzKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF93YXJuT25jZSkud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIFwiZmlsbFwiIGFuZCBwYXJlbnQgZWxlbWVudCB3aXRoIGludmFsaWQgXCJwb3NpdGlvblwiLiBQcm92aWRlZCBcIiR7cG9zaXRpb259XCIgc2hvdWxkIGJlIG9uZSBvZiAke3ZhbGlkLm1hcChTdHJpbmcpLmpvaW4oJywnKX0uYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF93YXJuT25jZSkud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIFwiZmlsbFwiIGFuZCBhIGhlaWdodCB2YWx1ZSBvZiAwLiBUaGlzIGlzIGxpa2VseSBiZWNhdXNlIHRoZSBwYXJlbnQgZWxlbWVudCBvZiB0aGUgaW1hZ2UgaGFzIG5vdCBiZWVuIHN0eWxlZCB0byBoYXZlIGEgc2V0IGhlaWdodC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWlnaHRNb2RpZmllZCA9IGltZy5oZWlnaHQudG9TdHJpbmcoKSAhPT0gaW1nLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aE1vZGlmaWVkID0gaW1nLndpZHRoLnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0TW9kaWZpZWQgJiYgIXdpZHRoTW9kaWZpZWQgfHwgIWhlaWdodE1vZGlmaWVkICYmIHdpZHRoTW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3dhcm5PbmNlKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgZWl0aGVyIHdpZHRoIG9yIGhlaWdodCBtb2RpZmllZCwgYnV0IG5vdCB0aGUgb3RoZXIuIElmIHlvdSB1c2UgQ1NTIHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB5b3VyIGltYWdlLCBhbHNvIGluY2x1ZGUgdGhlIHN0eWxlcyAnd2lkdGg6IFwiYXV0b1wiJyBvciAnaGVpZ2h0OiBcImF1dG9cIicgdG8gbWFpbnRhaW4gdGhlIGFzcGVjdCByYXRpby5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgSW1hZ2VFbGVtZW50ID0gLyojX19QVVJFX18qLyAoMCwgX3JlYWN0KS5mb3J3YXJkUmVmKChfcGFyYW0sIGZvcndhcmRlZFJlZik9PntcbiAgICB2YXIgeyBpbWdBdHRyaWJ1dGVzICwgaGVpZ2h0SW50ICwgd2lkdGhJbnQgLCBxdWFsaXR5SW50ICwgY2xhc3NOYW1lICwgaW1nU3R5bGUgLCBibHVyU3R5bGUgLCBpc0xhenkgLCBmaWxsICwgcGxhY2Vob2xkZXIgLCBsb2FkaW5nICwgc3JjU3RyaW5nICwgY29uZmlnICwgdW5vcHRpbWl6ZWQgLCBsb2FkZXIgLCBvbkxvYWRSZWYgLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiAsIG9uTG9hZCAsIG9uRXJyb3IgIH0gPSBfcGFyYW0sIHJlc3QgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShfcGFyYW0sIFtcbiAgICAgICAgXCJpbWdBdHRyaWJ1dGVzXCIsXG4gICAgICAgIFwiaGVpZ2h0SW50XCIsXG4gICAgICAgIFwid2lkdGhJbnRcIixcbiAgICAgICAgXCJxdWFsaXR5SW50XCIsXG4gICAgICAgIFwiY2xhc3NOYW1lXCIsXG4gICAgICAgIFwiaW1nU3R5bGVcIixcbiAgICAgICAgXCJibHVyU3R5bGVcIixcbiAgICAgICAgXCJpc0xhenlcIixcbiAgICAgICAgXCJmaWxsXCIsXG4gICAgICAgIFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgXCJsb2FkaW5nXCIsXG4gICAgICAgIFwic3JjU3RyaW5nXCIsXG4gICAgICAgIFwiY29uZmlnXCIsXG4gICAgICAgIFwidW5vcHRpbWl6ZWRcIixcbiAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgXCJvbkxvYWRSZWZcIixcbiAgICAgICAgXCJvbkxvYWRpbmdDb21wbGV0ZVJlZlwiLFxuICAgICAgICBcIm9uTG9hZFwiLFxuICAgICAgICBcIm9uRXJyb3JcIlxuICAgIF0pO1xuICAgIGxvYWRpbmcgPSBpc0xhenkgPyAnbGF6eScgOiBsb2FkaW5nO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLCBPYmplY3QuYXNzaWduKHt9LCByZXN0LCBpbWdBdHRyaWJ1dGVzLCB7XG4gICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRJbnQsXG4gICAgICAgIGRlY29kaW5nOiBcImFzeW5jXCIsXG4gICAgICAgIFwiZGF0YS1uaW1nXCI6IGZpbGwgPyAnZmlsbCcgOiAnMScsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICAvLyBAdHMtaWdub3JlIC0gVE9ETzogdXBncmFkZSB0byBgQHR5cGVzL3JlYWN0QDE3YFxuICAgICAgICBsb2FkaW5nOiBsb2FkaW5nLFxuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGltZ1N0eWxlLCBibHVyU3R5bGUpLFxuICAgICAgICByZWY6ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKChpbWcpPT57XG4gICAgICAgICAgICBpZiAoZm9yd2FyZGVkUmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3J3YXJkZWRSZWYgPT09ICdmdW5jdGlvbicpIGZvcndhcmRlZFJlZihpbWcpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmb3J3YXJkZWRSZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSAuY3VycmVudCBpcyByZWFkIG9ubHkgaXQncyB1c3VhbGx5IGFzc2lnbmVkIGJ5IHJlYWN0IGludGVybmFsbHlcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBpbWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBoYXMgYW4gZXJyb3IgYmVmb3JlIHJlYWN0IGh5ZHJhdGVzLCB0aGVuIHRoZSBlcnJvciBpcyBsb3N0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSB3b3JrYXJvdW5kIGlzIHRvIHdhaXQgdW50aWwgdGhlIGltYWdlIGlzIG1vdW50ZWQgd2hpY2ggaXMgYWZ0ZXIgaHlkcmF0aW9uLFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2V0IHRoZSBzcmMgYWdhaW4gdG8gdHJpZ2dlciB0aGUgZXJyb3IgaGFuZGxlciAoaWYgdGhlcmUgd2FzIGFuIGVycm9yKS5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gaW1nLnNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcmNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcInNyY1wiIHByb3BlcnR5OmAsIGltZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbWcuZ2V0QXR0cmlidXRlKCdhbHQnKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBJbWFnZSBpcyBtaXNzaW5nIHJlcXVpcmVkIFwiYWx0XCIgcHJvcGVydHkuIFBsZWFzZSBhZGQgQWx0ZXJuYXRpdmUgVGV4dCB0byBkZXNjcmliZSB0aGUgaW1hZ2UgZm9yIHNjcmVlbiByZWFkZXJzIGFuZCBzZWFyY2ggZW5naW5lcy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTG9hZGluZyhpbWcsIHNyY1N0cmluZywgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgdW5vcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBzcmNTdHJpbmcsXG4gICAgICAgICAgICBvbkxvYWRSZWYsXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgICAgIGZvcndhcmRlZFJlZiwgXG4gICAgICAgIF0pLFxuICAgICAgICBvbkxvYWQ6IChldmVudCk9PntcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBoYW5kbGVMb2FkaW5nKGltZywgc3JjU3RyaW5nLCBvbkxvYWRSZWYsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCB1bm9wdGltaXplZCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChldmVudCk9PntcbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIHJlbW92ZWQgUmVhY3QudXNlU3RhdGUoKSBpbiB0aGUgZXJyb3IgY2FzZSBoZXJlXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0IHdhcyBjYXVzaW5nIFNhZmFyaSB0byBiZWNvbWUgdmVyeSBzbG93IHdoZW5cbiAgICAgICAgICAgIC8vIHRoZXJlIHdlcmUgbWFueSBpbWFnZXMgb24gdGhlIHNhbWUgcGFnZS5cbiAgICAgICAgICAgIGNvbnN0IHsgc3R5bGUgIH0gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHN0eWxlLmNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc3JjIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBlbnN1cmUgXCJhbHRcIiBpcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgc3R5bGUuY29sb3IgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInICYmIHN0eWxlLmJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHNyYyBpbWFnZSBmYWlscyB0byBsb2FkLCB0aGlzIHdpbGwgZW5zdXJlIHRoZSBwbGFjZWhvbGRlciBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnJztcbiAgICAgICAgICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAnJztcbiAgICAgICAgICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kUmVwZWF0ID0gJyc7XG4gICAgICAgICAgICAgICAgc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkpKTtcbn0pO1xuY29uc3QgSW1hZ2UgPSAvKiNfX1BVUkVfXyovICgwLCBfcmVhY3QpLmZvcndhcmRSZWYoKF9wYXJhbSwgZm9yd2FyZGVkUmVmKT0+e1xuICAgIHZhciB7IHNyYyAsIHNpemVzICwgdW5vcHRpbWl6ZWQgPWZhbHNlICwgcHJpb3JpdHkgPWZhbHNlICwgbG9hZGluZyAsIGNsYXNzTmFtZSAsIHF1YWxpdHkgLCB3aWR0aCAsIGhlaWdodCAsIGZpbGwgLCBzdHlsZSAsIG9uTG9hZCAsIG9uTG9hZGluZ0NvbXBsZXRlICwgcGxhY2Vob2xkZXIgPSdlbXB0eScgLCBibHVyRGF0YVVSTCAsIGxheW91dCAsIG9iamVjdEZpdCAsIG9iamVjdFBvc2l0aW9uICwgbGF6eUJvdW5kYXJ5ICwgbGF6eVJvb3QgIH0gPSBfcGFyYW0sIGFsbCA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKF9wYXJhbSwgW1xuICAgICAgICBcInNyY1wiLFxuICAgICAgICBcInNpemVzXCIsXG4gICAgICAgIFwidW5vcHRpbWl6ZWRcIixcbiAgICAgICAgXCJwcmlvcml0eVwiLFxuICAgICAgICBcImxvYWRpbmdcIixcbiAgICAgICAgXCJjbGFzc05hbWVcIixcbiAgICAgICAgXCJxdWFsaXR5XCIsXG4gICAgICAgIFwid2lkdGhcIixcbiAgICAgICAgXCJoZWlnaHRcIixcbiAgICAgICAgXCJmaWxsXCIsXG4gICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgXCJvbkxvYWRcIixcbiAgICAgICAgXCJvbkxvYWRpbmdDb21wbGV0ZVwiLFxuICAgICAgICBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIFwiYmx1ckRhdGFVUkxcIixcbiAgICAgICAgXCJsYXlvdXRcIixcbiAgICAgICAgXCJvYmplY3RGaXRcIixcbiAgICAgICAgXCJvYmplY3RQb3NpdGlvblwiLFxuICAgICAgICBcImxhenlCb3VuZGFyeVwiLFxuICAgICAgICBcImxhenlSb290XCJcbiAgICBdKTtcbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfaW1hZ2VDb25maWdDb250ZXh0LkltYWdlQ29uZmlnQ29udGV4dCk7XG4gICAgY29uc3QgY29uZmlnID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBjID0gY29uZmlnRW52IHx8IGNvbmZpZ0NvbnRleHQgfHwgX2ltYWdlQ29uZmlnLmltYWdlQ29uZmlnRGVmYXVsdDtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbXG4gICAgICAgICAgICAuLi5jLmRldmljZVNpemVzLFxuICAgICAgICAgICAgLi4uYy5pbWFnZVNpemVzXG4gICAgICAgIF0uc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYywge1xuICAgICAgICAgICAgYWxsU2l6ZXMsXG4gICAgICAgICAgICBkZXZpY2VTaXplc1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGNvbmZpZ0NvbnRleHRcbiAgICBdKTtcbiAgICBsZXQgcmVzdCA9IGFsbDtcbiAgICBsZXQgbG9hZGVyID0gcmVzdC5sb2FkZXIgfHwgX2ltYWdlTG9hZGVyLmRlZmF1bHQ7XG4gICAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBvbiA8aW1nPiBlbGVtZW50XG4gICAgZGVsZXRlIHJlc3QubG9hZGVyO1xuICAgIGlmICgnX19uZXh0X2ltZ19kZWZhdWx0JyBpbiBsb2FkZXIpIHtcbiAgICAgICAgLy8gVGhpcyBzcGVjaWFsIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSB1c2VyXG4gICAgICAgIC8vIGRpZG4ndCBkZWZpbmUgYSBcImxvYWRlclwiIHByb3Agb3IgY29uZmlnLlxuICAgICAgICBpZiAoY29uZmlnLmxvYWRlciA9PT0gJ2N1c3RvbScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBtaXNzaW5nIFwibG9hZGVyXCIgcHJvcC5gICsgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS1taXNzaW5nLWxvYWRlcmApO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHVzZXIgZGVmaW5lZCBhIFwibG9hZGVyXCIgcHJvcCBvciBjb25maWcuXG4gICAgICAgIC8vIFNpbmNlIHRoZSBjb25maWcgb2JqZWN0IGlzIGludGVybmFsIG9ubHksIHdlXG4gICAgICAgIC8vIG11c3Qgbm90IHBhc3MgaXQgdG8gdGhlIHVzZXItZGVmaW5lZCBcImxvYWRlclwiLlxuICAgICAgICBjb25zdCBjdXN0b21JbWFnZUxvYWRlciA9IGxvYWRlcjtcbiAgICAgICAgdmFyIF90bXA7XG4gICAgICAgIF90bXAgPSAob2JqKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBjb25maWc6IF8gIH0gPSBvYmosIG9wdHMgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShvYmosIFtcbiAgICAgICAgICAgICAgICBcImNvbmZpZ1wiXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiBjdXN0b21JbWFnZUxvYWRlcihvcHRzKTtcbiAgICAgICAgfSwgbG9hZGVyID0gX3RtcCwgX3RtcDtcbiAgICB9XG4gICAgaWYgKGxheW91dCkge1xuICAgICAgICBpZiAobGF5b3V0ID09PSAnZmlsbCcpIHtcbiAgICAgICAgICAgIGZpbGwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxheW91dFRvU3R5bGUgPSB7XG4gICAgICAgICAgICBpbnRyaW5zaWM6IHtcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJ2F1dG8nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzcG9uc2l2ZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnYXV0bydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbGF5b3V0VG9TaXplcyA9IHtcbiAgICAgICAgICAgIHJlc3BvbnNpdmU6ICcxMDB2dycsXG4gICAgICAgICAgICBmaWxsOiAnMTAwdncnXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxheW91dFN0eWxlID0gbGF5b3V0VG9TdHlsZVtsYXlvdXRdO1xuICAgICAgICBpZiAobGF5b3V0U3R5bGUpIHtcbiAgICAgICAgICAgIHN0eWxlID0gX2V4dGVuZHMoe30sIHN0eWxlLCBsYXlvdXRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0U2l6ZXMgPSBsYXlvdXRUb1NpemVzW2xheW91dF07XG4gICAgICAgIGlmIChsYXlvdXRTaXplcyAmJiAhc2l6ZXMpIHtcbiAgICAgICAgICAgIHNpemVzID0gbGF5b3V0U2l6ZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXRpY1NyYyA9ICcnO1xuICAgIGxldCB3aWR0aEludCA9IGdldEludCh3aWR0aCk7XG4gICAgbGV0IGhlaWdodEludCA9IGdldEludChoZWlnaHQpO1xuICAgIGxldCBibHVyV2lkdGg7XG4gICAgbGV0IGJsdXJIZWlnaHQ7XG4gICAgaWYgKGlzU3RhdGljSW1wb3J0KHNyYykpIHtcbiAgICAgICAgY29uc3Qgc3RhdGljSW1hZ2VEYXRhID0gaXNTdGF0aWNSZXF1aXJlKHNyYykgPyBzcmMuZGVmYXVsdCA6IHNyYztcbiAgICAgICAgaWYgKCFzdGF0aWNJbWFnZURhdGEuc3JjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIG9iamVjdCBzaG91bGQgb25seSBiZSBwYXNzZWQgdG8gdGhlIGltYWdlIGNvbXBvbmVudCBzcmMgcGFyYW1ldGVyIGlmIGl0IGNvbWVzIGZyb20gYSBzdGF0aWMgaW1hZ2UgaW1wb3J0LiBJdCBtdXN0IGluY2x1ZGUgc3JjLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHN0YXRpY0ltYWdlRGF0YSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGF0aWNJbWFnZURhdGEuaGVpZ2h0IHx8ICFzdGF0aWNJbWFnZURhdGEud2lkdGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBoZWlnaHQgYW5kIHdpZHRoLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHN0YXRpY0ltYWdlRGF0YSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYmx1cldpZHRoID0gc3RhdGljSW1hZ2VEYXRhLmJsdXJXaWR0aDtcbiAgICAgICAgYmx1ckhlaWdodCA9IHN0YXRpY0ltYWdlRGF0YS5ibHVySGVpZ2h0O1xuICAgICAgICBibHVyRGF0YVVSTCA9IGJsdXJEYXRhVVJMIHx8IHN0YXRpY0ltYWdlRGF0YS5ibHVyRGF0YVVSTDtcbiAgICAgICAgc3RhdGljU3JjID0gc3RhdGljSW1hZ2VEYXRhLnNyYztcbiAgICAgICAgaWYgKCFmaWxsKSB7XG4gICAgICAgICAgICBpZiAoIXdpZHRoSW50ICYmICFoZWlnaHRJbnQpIHtcbiAgICAgICAgICAgICAgICB3aWR0aEludCA9IHN0YXRpY0ltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHRJbnQgPSBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aWR0aEludCAmJiAhaGVpZ2h0SW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPSB3aWR0aEludCAvIHN0YXRpY0ltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHRJbnQgPSBNYXRoLnJvdW5kKHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgKiByYXRpbyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF3aWR0aEludCAmJiBoZWlnaHRJbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXRpbyA9IGhlaWdodEludCAvIHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgd2lkdGhJbnQgPSBNYXRoLnJvdW5kKHN0YXRpY0ltYWdlRGF0YS53aWR0aCAqIHJhdGlvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzcmMgPSB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyA/IHNyYyA6IHN0YXRpY1NyYztcbiAgICBsZXQgaXNMYXp5ID0gIXByaW9yaXR5ICYmIChsb2FkaW5nID09PSAnbGF6eScgfHwgdHlwZW9mIGxvYWRpbmcgPT09ICd1bmRlZmluZWQnKTtcbiAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJ2RhdGE6JykgfHwgc3JjLnN0YXJ0c1dpdGgoJ2Jsb2I6JykpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSSXNcbiAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICBpc0xhenkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy51bm9wdGltaXplZCkge1xuICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHF1YWxpdHlJbnQgPSBnZXRJbnQocXVhbGl0eSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgIC8vIFJlYWN0IGRvZXNuJ3Qgc2hvdyB0aGUgc3RhY2sgdHJhY2UgYW5kIHRoZXJlJ3NcbiAgICAgICAgICAgIC8vIG5vIGBzcmNgIHRvIGhlbHAgaWRlbnRpZnkgd2hpY2ggaW1hZ2UsIHNvIHdlXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIGNvbnNvbGUuZXJyb3IocmVmKSBkdXJpbmcgbW91bnQuXG4gICAgICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJ3aWR0aFwiIGFuZCBcImZpbGxcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJoZWlnaHRcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoc3R5bGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0eWxlLnBvc2l0aW9uKSAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUucG9zaXRpb25cIiBwcm9wZXJ0aWVzLiBJbWFnZXMgd2l0aCBcImZpbGxcIiBhbHdheXMgdXNlIHBvc2l0aW9uIGFic29sdXRlIC0gaXQgY2Fubm90IGJlIG1vZGlmaWVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHN0eWxlID09IG51bGwgPyB2b2lkIDAgOiBzdHlsZS53aWR0aCkgJiYgc3R5bGUud2lkdGggIT09ICcxMDAlJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUud2lkdGhcIiBwcm9wZXJ0aWVzLiBJbWFnZXMgd2l0aCBcImZpbGxcIiBhbHdheXMgdXNlIHdpZHRoIDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoc3R5bGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0eWxlLmhlaWdodCkgJiYgc3R5bGUuaGVpZ2h0ICE9PSAnMTAwJScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLmhlaWdodFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2UgaGVpZ2h0IDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgbWlzc2luZyByZXF1aXJlZCBcIndpZHRoXCIgcHJvcGVydHkuYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTih3aWR0aEludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwid2lkdGhcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCIke3dpZHRofVwiLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhlaWdodEludCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKGhlaWdodEludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwiaGVpZ2h0XCIgcHJvcGVydHkuIEV4cGVjdGVkIGEgbnVtZXJpYyB2YWx1ZSBpbiBwaXhlbHMgYnV0IHJlY2VpdmVkIFwiJHtoZWlnaHR9XCIuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghVkFMSURfTE9BRElOR19WQUxVRVMuaW5jbHVkZXMobG9hZGluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCIke2xvYWRpbmd9XCIgc2hvdWxkIGJlIG9uZSBvZiAke1ZBTElEX0xPQURJTkdfVkFMVUVTLm1hcChTdHJpbmcpLmpvaW4oJywnKX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yaXR5ICYmIGxvYWRpbmcgPT09ICdsYXp5Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPSdsYXp5J1wiIHByb3BlcnRpZXMuIE9ubHkgb25lIHNob3VsZCBiZSB1c2VkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSB7XG4gICAgICAgICAgICBpZiAod2lkdGhJbnQgJiYgaGVpZ2h0SW50ICYmIHdpZHRoSW50ICogaGVpZ2h0SW50IDwgMTYwMCkge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybk9uY2UpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIHNtYWxsZXIgdGhhbiA0MHg0MC4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIFwicGxhY2Vob2xkZXI9J2JsdXInXCIgcHJvcGVydHkgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYmx1ckRhdGFVUkwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBWQUxJRF9CTFVSX0VYVCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2pwZWcnLFxuICAgICAgICAgICAgICAgICAgICAncG5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ3dlYnAnLFxuICAgICAgICAgICAgICAgICAgICAnYXZpZidcbiAgICAgICAgICAgICAgICBdIC8vIHNob3VsZCBtYXRjaCBuZXh0LWltYWdlLWxvYWRlclxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIFwicGxhY2Vob2xkZXI9J2JsdXInXCIgcHJvcGVydHkgYnV0IGlzIG1pc3NpbmcgdGhlIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eS5cbiAgICAgICAgICBQb3NzaWJsZSBzb2x1dGlvbnM6XG4gICAgICAgICAgICAtIEFkZCBhIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eSwgdGhlIGNvbnRlbnRzIHNob3VsZCBiZSBhIHNtYWxsIERhdGEgVVJMIHRvIHJlcHJlc2VudCB0aGUgaW1hZ2VcbiAgICAgICAgICAgIC0gQ2hhbmdlIHRoZSBcInNyY1wiIHByb3BlcnR5IHRvIGEgc3RhdGljIGltcG9ydCB3aXRoIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbGUgdHlwZXM6ICR7VkFMSURfQkxVUl9FWFQuam9pbignLCcpfVxuICAgICAgICAgICAgLSBSZW1vdmUgdGhlIFwicGxhY2Vob2xkZXJcIiBwcm9wZXJ0eSwgZWZmZWN0aXZlbHkgbm8gYmx1ciBlZmZlY3RcbiAgICAgICAgICBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3BsYWNlaG9sZGVyLWJsdXItZGF0YS11cmxgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3JlZicgaW4gcmVzdCkge1xuICAgICAgICAgICAgKDAsIF93YXJuT25jZSkud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgdXNpbmcgdW5zdXBwb3J0ZWQgXCJyZWZcIiBwcm9wZXJ0eS4gQ29uc2lkZXIgdXNpbmcgdGhlIFwib25Mb2FkaW5nQ29tcGxldGVcIiBwcm9wZXJ0eSBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgbG9hZGVyICE9PSBfaW1hZ2VMb2FkZXIuZGVmYXVsdCkge1xuICAgICAgICAgICAgY29uc3QgdXJsU3RyID0gbG9hZGVyKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCB8fCA0MDAsXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgdXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHVybFN0cik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgdXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJuT25jZSkud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGEgXCJsb2FkZXJcIiBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IGltcGxlbWVudCB3aWR0aC4gUGxlYXNlIGltcGxlbWVudCBpdCBvciB1c2UgdGhlIFwidW5vcHRpbWl6ZWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLmAgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyLXdpZHRoYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbbGVnYWN5S2V5LCBsZWdhY3lWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoe1xuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgb2JqZWN0Rml0LFxuICAgICAgICAgICAgb2JqZWN0UG9zaXRpb24sXG4gICAgICAgICAgICBsYXp5Qm91bmRhcnksXG4gICAgICAgICAgICBsYXp5Um9vdFxuICAgICAgICB9KSl7XG4gICAgICAgICAgICBpZiAobGVnYWN5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3dhcm5PbmNlKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgbGVnYWN5IHByb3AgXCIke2xlZ2FjeUtleX1cIi4gRGlkIHlvdSBmb3JnZXQgdG8gcnVuIHRoZSBjb2RlbW9kP2AgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVwZ3JhZGUtdG8tMTNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXBlcmZPYnNlcnZlciAmJiB3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlcikge1xuICAgICAgICAgICAgcGVyZk9ic2VydmVyID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGVudHJ5TGlzdCk9PntcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbWlzc2luZyBcIkxhcmdlc3RDb250ZW50ZnVsUGFpbnRcIiBjbGFzcyB3aXRoIFwiZWxlbWVudFwiIHByb3BcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nU3JjID0gKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiAocmVmID0gZW50cnkuZWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5zcmMpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsY3BJbWFnZSA9IGFsbEltZ3MuZ2V0KGltZ1NyYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsY3BJbWFnZSAmJiAhbGNwSW1hZ2UucHJpb3JpdHkgJiYgbGNwSW1hZ2UucGxhY2Vob2xkZXIgIT09ICdibHVyJyAmJiAhbGNwSW1hZ2Uuc3JjLnN0YXJ0c1dpdGgoJ2RhdGE6JykgJiYgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3dlYi5kZXYvbGNwLyNtZWFzdXJlLWxjcC1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5PbmNlKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke2xjcEltYWdlLnNyY31cIiB3YXMgZGV0ZWN0ZWQgYXMgdGhlIExhcmdlc3QgQ29udGVudGZ1bCBQYWludCAoTENQKS4gUGxlYXNlIGFkZCB0aGUgXCJwcmlvcml0eVwiIHByb3BlcnR5IGlmIHRoaXMgaW1hZ2UgaXMgYWJvdmUgdGhlIGZvbGQuYCArIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNwcmlvcml0eWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBlcmZPYnNlcnZlci5vYnNlcnZlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xhcmdlc3QtY29udGVudGZ1bC1wYWludCcsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgYnV0IGRvbid0IGNyYXNoIHRoZSBhcHBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nU3R5bGUgPSBPYmplY3QuYXNzaWduKGZpbGwgPyB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgIG9iamVjdFBvc2l0aW9uXG4gICAgfSA6IHt9LCB7XG4gICAgICAgIGNvbG9yOiAndHJhbnNwYXJlbnQnXG4gICAgfSwgc3R5bGUpO1xuICAgIGNvbnN0IGJsdXJTdHlsZSA9IHBsYWNlaG9sZGVyID09PSAnYmx1cicgJiYgYmx1ckRhdGFVUkwgPyB7XG4gICAgICAgIGJhY2tncm91bmRTaXplOiBpbWdTdHlsZS5vYmplY3RGaXQgfHwgJ2NvdmVyJyxcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBpbWdTdHlsZS5vYmplY3RQb3NpdGlvbiB8fCAnNTAlIDUwJScsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6ICduby1yZXBlYXQnLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwkeygwLCBfaW1hZ2VCbHVyU3ZnKS5nZXRJbWFnZUJsdXJTdmcoe1xuICAgICAgICAgICAgd2lkdGhJbnQsXG4gICAgICAgICAgICBoZWlnaHRJbnQsXG4gICAgICAgICAgICBibHVyV2lkdGgsXG4gICAgICAgICAgICBibHVySGVpZ2h0LFxuICAgICAgICAgICAgYmx1ckRhdGFVUkxcbiAgICAgICAgfSl9XCIpYFxuICAgIH0gOiB7fTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgaWYgKGJsdXJTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgJiYgKGJsdXJEYXRhVVJMID09IG51bGwgPyB2b2lkIDAgOiBibHVyRGF0YVVSTC5zdGFydHNXaXRoKCcvJykpKSB7XG4gICAgICAgICAgICAvLyBEdXJpbmcgYG5leHQgZGV2YCwgd2UgZG9uJ3Qgd2FudCB0byBnZW5lcmF0ZSBibHVyIHBsYWNlaG9sZGVycyB3aXRoIHdlYnBhY2tcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgY2FuIGRlbGF5IHN0YXJ0aW5nIHRoZSBkZXYgc2VydmVyLiBJbnN0ZWFkLCBgbmV4dC1pbWFnZS1sb2FkZXIuanNgXG4gICAgICAgICAgICAvLyB3aWxsIGlubGluZSBhIHNwZWNpYWwgdXJsIHRvIGxhemlseSBnZW5lcmF0ZSB0aGUgYmx1ciBwbGFjZWhvbGRlciBhdCByZXF1ZXN0IHRpbWUuXG4gICAgICAgICAgICBibHVyU3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybChcIiR7Ymx1ckRhdGFVUkx9XCIpYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbWdBdHRyaWJ1dGVzID0gZ2VuZXJhdGVJbWdBdHRycyh7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgc3JjLFxuICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgd2lkdGg6IHdpZHRoSW50LFxuICAgICAgICBxdWFsaXR5OiBxdWFsaXR5SW50LFxuICAgICAgICBzaXplcyxcbiAgICAgICAgbG9hZGVyXG4gICAgfSk7XG4gICAgbGV0IHNyY1N0cmluZyA9IHNyYztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxldCBmdWxsVXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsbEltZ3Muc2V0KGZ1bGxVcmwuaHJlZiwge1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGlua1Byb3BzID0ge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHVwZ3JhZGUgcmVhY3QgdHlwZXMgdG8gcmVhY3QgMThcbiAgICAgICAgaW1hZ2VTcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgICAgICBpbWFnZVNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICBjcm9zc09yaWdpbjogcmVzdC5jcm9zc09yaWdpblxuICAgIH07XG4gICAgY29uc3Qgb25Mb2FkUmVmID0gKDAsIF9yZWFjdCkudXNlUmVmKG9uTG9hZCk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIG9uTG9hZFJlZi5jdXJyZW50ID0gb25Mb2FkO1xuICAgIH0sIFtcbiAgICAgICAgb25Mb2FkXG4gICAgXSk7XG4gICAgY29uc3Qgb25Mb2FkaW5nQ29tcGxldGVSZWYgPSAoMCwgX3JlYWN0KS51c2VSZWYob25Mb2FkaW5nQ29tcGxldGUpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50ID0gb25Mb2FkaW5nQ29tcGxldGU7XG4gICAgfSwgW1xuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVxuICAgIF0pO1xuICAgIGNvbnN0IGltZ0VsZW1lbnRBcmdzID0gX2V4dGVuZHMoe1xuICAgICAgICBpc0xhenksXG4gICAgICAgIGltZ0F0dHJpYnV0ZXMsXG4gICAgICAgIGhlaWdodEludCxcbiAgICAgICAgd2lkdGhJbnQsXG4gICAgICAgIHF1YWxpdHlJbnQsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgaW1nU3R5bGUsXG4gICAgICAgIGJsdXJTdHlsZSxcbiAgICAgICAgbG9hZGluZyxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBmaWxsLFxuICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIGxvYWRlcixcbiAgICAgICAgc3JjU3RyaW5nLFxuICAgICAgICBvbkxvYWRSZWYsXG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmXG4gICAgfSwgcmVzdCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEltYWdlRWxlbWVudCwgT2JqZWN0LmFzc2lnbih7fSwgaW1nRWxlbWVudEFyZ3MsIHtcbiAgICAgICAgcmVmOiBmb3J3YXJkZWRSZWZcbiAgICB9KSksIHByaW9yaXR5ID8gLy8gTm90ZSBob3cgd2Ugb21pdCB0aGUgYGhyZWZgIGF0dHJpYnV0ZSwgYXMgaXQgd291bGQgb25seSBiZSByZWxldmFudFxuICAgIC8vIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGBpbWFnZXNyY3NldGAsIGFuZCBpbiB0aG9zZSBjYXNlc1xuICAgIC8vIGl0IHdvdWxkIGxpa2VseSBjYXVzZSB0aGUgaW5jb3JyZWN0IGltYWdlIHRvIGJlIHByZWxvYWRlZC5cbiAgICAvL1xuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI2F0dHItbGluay1pbWFnZXNyY3NldFxuICAgIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaGVhZC5kZWZhdWx0LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBrZXk6ICdfX25pbWctJyArIGltZ0F0dHJpYnV0ZXMuc3JjICsgaW1nQXR0cmlidXRlcy5zcmNTZXQgKyBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICBhczogXCJpbWFnZVwiLFxuICAgICAgICBocmVmOiBpbWdBdHRyaWJ1dGVzLnNyY1NldCA/IHVuZGVmaW5lZCA6IGltZ0F0dHJpYnV0ZXMuc3JjXG4gICAgfSwgbGlua1Byb3BzKSkpIDogbnVsbCk7XG59KTtcbnZhciBfZGVmYXVsdCA9IEltYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfZXh0ZW5kcyIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UiLCJfcmVhY3QiLCJfaGVhZCIsIl9pbWFnZUJsdXJTdmciLCJfaW1hZ2VDb25maWciLCJfaW1hZ2VDb25maWdDb250ZXh0IiwiX3dhcm5PbmNlIiwiX2ltYWdlTG9hZGVyIiwiY29uZmlnRW52IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwiYWxsSW1ncyIsIk1hcCIsInBlcmZPYnNlcnZlciIsImdsb2JhbFRoaXMiLCJfX05FWFRfSU1BR0VfSU1QT1JURUQiLCJWQUxJRF9MT0FESU5HX1ZBTFVFUyIsInVuZGVmaW5lZCIsImlzU3RhdGljUmVxdWlyZSIsInNyYyIsImlzU3RhdGljSW1hZ2VEYXRhIiwiaXNTdGF0aWNJbXBvcnQiLCJnZXRXaWR0aHMiLCJ3aWR0aCIsInNpemVzIiwiZGV2aWNlU2l6ZXMiLCJhbGxTaXplcyIsInZpZXdwb3J0V2lkdGhSZSIsInBlcmNlbnRTaXplcyIsIm1hdGNoIiwiZXhlYyIsInB1c2giLCJwYXJzZUludCIsImxlbmd0aCIsInNtYWxsZXN0UmF0aW8iLCJNYXRoIiwibWluIiwid2lkdGhzIiwiZmlsdGVyIiwicyIsImtpbmQiLCJTZXQiLCJtYXAiLCJ3IiwiZmluZCIsInAiLCJnZW5lcmF0ZUltZ0F0dHJzIiwiY29uZmlnIiwidW5vcHRpbWl6ZWQiLCJxdWFsaXR5IiwibG9hZGVyIiwic3JjU2V0IiwibGFzdCIsImkiLCJqb2luIiwiZ2V0SW50IiwieCIsInRlc3QiLCJOYU4iLCJoYW5kbGVMb2FkaW5nIiwiaW1nIiwib25Mb2FkUmVmIiwib25Mb2FkaW5nQ29tcGxldGVSZWYiLCJkZWNvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwidGhlbiIsInBhcmVudE5vZGUiLCJjdXJyZW50IiwiZXZlbnQiLCJFdmVudCIsIndyaXRhYmxlIiwicHJldmVudGVkIiwic3RvcHBlZCIsIm5hdGl2ZUV2ZW50IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwicGVyc2lzdCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiZ2V0QXR0cmlidXRlIiwid2lkdGhWaWV3cG9ydFJhdGlvIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2luZG93IiwiaW5uZXJXaWR0aCIsIndhcm5PbmNlIiwicGFyZW50RWxlbWVudCIsInBvc2l0aW9uIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInZhbGlkIiwiaW5jbHVkZXMiLCJTdHJpbmciLCJoZWlnaHQiLCJoZWlnaHRNb2RpZmllZCIsInRvU3RyaW5nIiwid2lkdGhNb2RpZmllZCIsIkltYWdlRWxlbWVudCIsImZvcndhcmRSZWYiLCJfcGFyYW0iLCJmb3J3YXJkZWRSZWYiLCJpbWdBdHRyaWJ1dGVzIiwiaGVpZ2h0SW50Iiwid2lkdGhJbnQiLCJxdWFsaXR5SW50IiwiY2xhc3NOYW1lIiwiaW1nU3R5bGUiLCJibHVyU3R5bGUiLCJpc0xhenkiLCJmaWxsIiwicGxhY2Vob2xkZXIiLCJsb2FkaW5nIiwic3JjU3RyaW5nIiwib25Mb2FkIiwib25FcnJvciIsInJlc3QiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJhc3NpZ24iLCJkZWNvZGluZyIsInN0eWxlIiwicmVmIiwidXNlQ2FsbGJhY2siLCJjb25zb2xlIiwiZXJyb3IiLCJjb21wbGV0ZSIsImNvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFNpemUiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwiSW1hZ2UiLCJwcmlvcml0eSIsIm9uTG9hZGluZ0NvbXBsZXRlIiwiYmx1ckRhdGFVUkwiLCJsYXlvdXQiLCJvYmplY3RGaXQiLCJvYmplY3RQb3NpdGlvbiIsImxhenlCb3VuZGFyeSIsImxhenlSb290IiwiYWxsIiwiY29uZmlnQ29udGV4dCIsInVzZUNvbnRleHQiLCJJbWFnZUNvbmZpZ0NvbnRleHQiLCJ1c2VNZW1vIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJFcnJvciIsImN1c3RvbUltYWdlTG9hZGVyIiwiX3RtcCIsIm9iaiIsIl8iLCJvcHRzIiwibGF5b3V0VG9TdHlsZSIsImludHJpbnNpYyIsIm1heFdpZHRoIiwicmVzcG9uc2l2ZSIsImxheW91dFRvU2l6ZXMiLCJsYXlvdXRTdHlsZSIsImxheW91dFNpemVzIiwic3RhdGljU3JjIiwiYmx1cldpZHRoIiwiYmx1ckhlaWdodCIsInN0YXRpY0ltYWdlRGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyYXRpbyIsInJvdW5kIiwic3RhcnRzV2l0aCIsImlzTmFOIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsImxlZ2FjeUtleSIsImxlZ2FjeVZhbHVlIiwiZW50cmllcyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJlbnRyeSIsImdldEVudHJpZXMiLCJpbWdTcmMiLCJlbGVtZW50IiwibGNwSW1hZ2UiLCJnZXQiLCJvYnNlcnZlIiwidHlwZSIsImJ1ZmZlcmVkIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiZ2V0SW1hZ2VCbHVyU3ZnIiwiZnVsbFVybCIsImUiLCJsb2NhdGlvbiIsImhyZWYiLCJzZXQiLCJsaW5rUHJvcHMiLCJpbWFnZVNyY1NldCIsImNyb3NzT3JpZ2luIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiaW1nRWxlbWVudEFyZ3MiLCJrZXkiLCJyZWwiLCJhcyIsIl9kZWZhdWx0IiwiX19lc01vZHVsZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/image.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getImageBlurSvg = getImageBlurSvg;\nfunction getImageBlurSvg(param) {\n    let { widthInt , heightInt , blurWidth , blurHeight , blurDataURL  } = param;\n    const std = blurWidth && blurHeight ? \"1\" : \"20\";\n    const svgWidth = blurWidth || widthInt;\n    const svgHeight = blurHeight || heightInt;\n    const feComponentTransfer = blurDataURL.startsWith(\"data:image/jpeg\") ? \"%3CfeComponentTransfer%3E%3CfeFuncA type='discrete' tableValues='1 1'/%3E%3C/feComponentTransfer%3E%\" : \"\";\n    if (svgWidth && svgHeight) {\n        return \"%3Csvg xmlns='http%3A//www.w3.org/2000/svg' viewBox='0 0 \".concat(svgWidth, \" \").concat(svgHeight, \"'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\").concat(std, \"'/%3E\").concat(feComponentTransfer, \"%3C/filter%3E%3Cimage preserveAspectRatio='none' filter='url(%23b)' x='0' y='0' height='100%25' width='100%25' href='\").concat(blurDataURL, \"'/%3E%3C/svg%3E\");\n    }\n    return \"%3Csvg xmlns='http%3A//www.w3.org/2000/svg'%3E%3Cimage style='filter:blur(20px)' x='0' y='0' height='100%25' width='100%25' href='\".concat(blurDataURL, \"'/%3E%3C/svg%3E\");\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtYmx1ci1zdmcuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUdFO0FBQzFCLFNBQVNBLGdCQUFnQixLQUFnRSxFQUFFO1FBQWxFLEVBQUVDLFNBQVEsRUFBR0MsVUFBUyxFQUFHQyxVQUFTLEVBQUdDLFdBQVUsRUFBR0MsWUFBVyxFQUFHLEdBQWhFO0lBQ3JCLE1BQU1DLE1BQU1ILGFBQWFDLGFBQWEsTUFBTSxJQUFJO0lBQ2hELE1BQU1HLFdBQVdKLGFBQWFGO0lBQzlCLE1BQU1PLFlBQVlKLGNBQWNGO0lBQ2hDLE1BQU1PLHNCQUFzQkosWUFBWUssVUFBVSxDQUFDLHFCQUFzQix5R0FBd0csRUFBRTtJQUNuTCxJQUFJSCxZQUFZQyxXQUFXO1FBQ3ZCLE9BQU8sNERBQXdFQSxPQUFaRCxVQUFTLEtBQXlHRCxPQUF0R0UsV0FBVSw4RkFBdUdDLE9BQVhILEtBQUksU0FBa0pELE9BQTNJSSxxQkFBb0IseUhBQW1JLE9BQVpKLGFBQVk7SUFDM1YsQ0FBQztJQUNELE9BQU8scUlBQWlKLE9BQVpBLGFBQVk7QUFDNUosRUFFQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWJsdXItc3ZnLmpzPzk1NzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEltYWdlQmx1clN2ZyA9IGdldEltYWdlQmx1clN2ZztcbmZ1bmN0aW9uIGdldEltYWdlQmx1clN2Zyh7IHdpZHRoSW50ICwgaGVpZ2h0SW50ICwgYmx1cldpZHRoICwgYmx1ckhlaWdodCAsIGJsdXJEYXRhVVJMICB9KSB7XG4gICAgY29uc3Qgc3RkID0gYmx1cldpZHRoICYmIGJsdXJIZWlnaHQgPyAnMScgOiAnMjAnO1xuICAgIGNvbnN0IHN2Z1dpZHRoID0gYmx1cldpZHRoIHx8IHdpZHRoSW50O1xuICAgIGNvbnN0IHN2Z0hlaWdodCA9IGJsdXJIZWlnaHQgfHwgaGVpZ2h0SW50O1xuICAgIGNvbnN0IGZlQ29tcG9uZW50VHJhbnNmZXIgPSBibHVyRGF0YVVSTC5zdGFydHNXaXRoKCdkYXRhOmltYWdlL2pwZWcnKSA/IGAlM0NmZUNvbXBvbmVudFRyYW5zZmVyJTNFJTNDZmVGdW5jQSB0eXBlPSdkaXNjcmV0ZScgdGFibGVWYWx1ZXM9JzEgMScvJTNFJTNDL2ZlQ29tcG9uZW50VHJhbnNmZXIlM0UlYCA6ICcnO1xuICAgIGlmIChzdmdXaWR0aCAmJiBzdmdIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGAlM0NzdmcgeG1sbnM9J2h0dHAlM0EvL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCAke3N2Z1dpZHRofSAke3N2Z0hlaWdodH0nJTNFJTNDZmlsdGVyIGlkPSdiJyBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9J3NSR0InJTNFJTNDZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPScke3N0ZH0nLyUzRSR7ZmVDb21wb25lbnRUcmFuc2Zlcn0lM0MvZmlsdGVyJTNFJTNDaW1hZ2UgcHJlc2VydmVBc3BlY3RSYXRpbz0nbm9uZScgZmlsdGVyPSd1cmwoJTIzYiknIHg9JzAnIHk9JzAnIGhlaWdodD0nMTAwJTI1JyB3aWR0aD0nMTAwJTI1JyBocmVmPScke2JsdXJEYXRhVVJMfScvJTNFJTNDL3N2ZyUzRWA7XG4gICAgfVxuICAgIHJldHVybiBgJTNDc3ZnIHhtbG5zPSdodHRwJTNBLy93d3cudzMub3JnLzIwMDAvc3ZnJyUzRSUzQ2ltYWdlIHN0eWxlPSdmaWx0ZXI6Ymx1cigyMHB4KScgeD0nMCcgeT0nMCcgaGVpZ2h0PScxMDAlMjUnIHdpZHRoPScxMDAlMjUnIGhyZWY9JyR7Ymx1ckRhdGFVUkx9Jy8lM0UlM0Mvc3ZnJTNFYDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtYmx1ci1zdmcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0SW1hZ2VCbHVyU3ZnIiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0IiwiYmx1ckRhdGFVUkwiLCJzdGQiLCJzdmdXaWR0aCIsInN2Z0hlaWdodCIsImZlQ29tcG9uZW50VHJhbnNmZXIiLCJzdGFydHNXaXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nfunction defaultLoader(param) {\n    let { config , src , width , quality  } = param;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \".concat(missingValues.join(\", \"), \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \").concat(JSON.stringify({\n                src,\n                width,\n                quality\n            })));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)'));\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)'));\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasMatch  } = __webpack_require__(/*! ./match-remote-pattern */ \"./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\".concat(src, ') on `next/image`, hostname \"').concat(parsedSrc.hostname, '\" is not configured under images in your `next.config.js`\\n') + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    if (src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        return src;\n    }\n    return \"\".concat(config.path, \"?url=\").concat(encodeURIComponent(src), \"&w=\").concat(width, \"&q=\").concat(quality || 75);\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nvar _default = defaultLoader;\nexports[\"default\"] = _default; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUcsS0FBSztBQUN2QixTQUFTRyxjQUFjLEtBQW1DLEVBQUU7UUFBckMsRUFBRUMsT0FBTSxFQUFHQyxJQUFHLEVBQUdDLE1BQUssRUFBR0MsUUFBTyxFQUFHLEdBQW5DO0lBQ25CLElBQUlDLElBQXlCLEVBQWM7UUFDdkMsTUFBTUMsZ0JBQWdCLEVBQUU7UUFDeEIseURBQXlEO1FBQ3pELElBQUksQ0FBQ0osS0FBS0ksY0FBY0MsSUFBSSxDQUFDO1FBQzdCLElBQUksQ0FBQ0osT0FBT0csY0FBY0MsSUFBSSxDQUFDO1FBQy9CLElBQUlELGNBQWNFLE1BQU0sR0FBRyxHQUFHO1lBQzFCLE1BQU0sSUFBSUMsTUFBTSxvQ0FBNEpDLE9BQXhISixjQUFjSyxJQUFJLENBQUMsT0FBTSwrRkFJMUUsT0FKeUtELEtBQUtFLFNBQVMsQ0FBQztnQkFDdkxWO2dCQUNBQztnQkFDQUM7WUFDSixLQUFNO1FBQ1YsQ0FBQztRQUNELElBQUlGLElBQUlXLFVBQVUsQ0FBQyxPQUFPO1lBQ3RCLE1BQU0sSUFBSUosTUFBTSx3QkFBNEIsT0FBSlAsS0FBSSwyR0FBMkc7UUFDM0osQ0FBQztRQUNELElBQUksQ0FBQ0EsSUFBSVcsVUFBVSxDQUFDLFFBQVNaLENBQUFBLE9BQU9hLE9BQU8sSUFBSWIsT0FBT2MsY0FBYyxHQUFHO1lBQ25FLElBQUlDO1lBQ0osSUFBSTtnQkFDQUEsWUFBWSxJQUFJQyxJQUFJZjtZQUN4QixFQUFFLE9BQU9nQixLQUFLO2dCQUNWQyxRQUFRQyxLQUFLLENBQUNGO2dCQUNkLE1BQU0sSUFBSVQsTUFBTSx3QkFBNEIsT0FBSlAsS0FBSSxrSUFBa0k7WUFDbEw7WUFDQSxJQUFJRyxJQUF5QixFQUFRO2dCQUNqQyx1RUFBdUU7Z0JBQ3ZFLE1BQU0sRUFBRWdCLFNBQVEsRUFBRyxHQUFHQyxtQkFBT0EsQ0FBQztnQkFDOUIsSUFBSSxDQUFDRCxTQUFTcEIsT0FBT2EsT0FBTyxFQUFFYixPQUFPYyxjQUFjLEVBQUVDLFlBQVk7b0JBQzdELE1BQU0sSUFBSVAsTUFBTSxxQkFBMERPLE9BQXJDZCxLQUFJLGlDQUFvRCxPQUFuQmMsVUFBVU8sUUFBUSxFQUFDLGlFQUFrRSxnRkFBK0U7Z0JBQ2xQLENBQUM7WUFDTCxDQUFDO1FBQ0wsQ0FBQztJQUNMLENBQUM7SUFDRCxJQUFJckIsSUFBSXNCLFFBQVEsQ0FBQyxXQUFXLENBQUN2QixPQUFPd0IsbUJBQW1CLEVBQUU7UUFDckQseURBQXlEO1FBQ3pELCtDQUErQztRQUMvQyxPQUFPdkI7SUFDWCxDQUFDO0lBQ0QsT0FBTyxHQUFzQndCLE9BQW5CekIsT0FBTzBCLElBQUksRUFBQyxTQUFvQ3hCLE9BQTdCdUIsbUJBQW1CeEIsTUFBSyxPQUFnQkUsT0FBWEQsT0FBTSxPQUFtQixPQUFkQyxXQUFXO0FBQ3BGO0FBQ0EsK0RBQStEO0FBQy9ELDJEQUEyRDtBQUMzREosY0FBYzRCLGtCQUFrQixHQUFHLElBQUk7QUFDdkMsSUFBSUMsV0FBVzdCO0FBQ2ZILGtCQUFlLEdBQUdnQyxVQUVsQix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWxvYWRlci5qcz9jMGExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuZnVuY3Rpb24gZGVmYXVsdExvYWRlcih7IGNvbmZpZyAsIHNyYyAsIHdpZHRoICwgcXVhbGl0eSAgfSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdWYWx1ZXMgPSBbXTtcbiAgICAgICAgLy8gdGhlc2Ugc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZCBidXQgbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgICAgIGlmICghc3JjKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3NyYycpO1xuICAgICAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3dpZHRoJyk7XG4gICAgICAgIGlmIChtaXNzaW5nVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmV4dCBJbWFnZSBPcHRpbWl6YXRpb24gcmVxdWlyZXMgJHttaXNzaW5nVmFsdWVzLmpvaW4oJywgJyl9IHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgXFxgbmV4dC9pbWFnZVxcYCBjb21wb25lbnQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgcXVhbGl0eVxuICAgICAgICAgICAgfSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzcmMgXCIke3NyY31cIiBvbiBcXGBuZXh0L2ltYWdlXFxgLCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgKC8vKSBtdXN0IGJlIGNoYW5nZWQgdG8gYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoJy8nKSAmJiAoY29uZmlnLmRvbWFpbnMgfHwgY29uZmlnLnJlbW90ZVBhdHRlcm5zKSkge1xuICAgICAgICAgICAgbGV0IHBhcnNlZFNyYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkU3JjID0gbmV3IFVSTChzcmMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHNyYyBcIiR7c3JjfVwiIG9uIFxcYG5leHQvaW1hZ2VcXGAsIGlmIHVzaW5nIHJlbGF0aXZlIGltYWdlIGl0IG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgc2xhc2ggXCIvXCIgb3IgYmUgYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFzTWF0Y2ggIH0gPSByZXF1aXJlKCcuL21hdGNoLXJlbW90ZS1wYXR0ZXJuJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNNYXRjaChjb25maWcuZG9tYWlucywgY29uZmlnLnJlbW90ZVBhdHRlcm5zLCBwYXJzZWRTcmMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzcmMgcHJvcCAoJHtzcmN9KSBvbiBcXGBuZXh0L2ltYWdlXFxgLCBob3N0bmFtZSBcIiR7cGFyc2VkU3JjLmhvc3RuYW1lfVwiIGlzIG5vdCBjb25maWd1cmVkIHVuZGVyIGltYWdlcyBpbiB5b3VyIFxcYG5leHQuY29uZmlnLmpzXFxgXFxuYCArIGBTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1ob3N0YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzcmMuZW5kc1dpdGgoJy5zdmcnKSAmJiAhY29uZmlnLmRhbmdlcm91c2x5QWxsb3dTVkcpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIG1ha2Ugc3ZnIHNlcnZlIGFzLWlzIHRvIGF2b2lkIHByb3h5aW5nXG4gICAgICAgIC8vIHRocm91Z2ggdGhlIGJ1aWx0LWluIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxuICAgIHJldHVybiBgJHtjb25maWcucGF0aH0/dXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNyYyl9Jnc9JHt3aWR0aH0mcT0ke3F1YWxpdHkgfHwgNzV9YDtcbn1cbi8vIFdlIHVzZSB0aGlzIHRvIGRldGVybWluZSBpZiB0aGUgaW1wb3J0IGlzIHRoZSBkZWZhdWx0IGxvYWRlclxuLy8gb3IgYSBjdXN0b20gbG9hZGVyIGRlZmluZWQgYnkgdGhlIHVzZXIgaW4gbmV4dC5jb25maWcuanNcbmRlZmF1bHRMb2FkZXIuX19uZXh0X2ltZ19kZWZhdWx0ID0gdHJ1ZTtcbnZhciBfZGVmYXVsdCA9IGRlZmF1bHRMb2FkZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtbG9hZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJkZWZhdWx0TG9hZGVyIiwiY29uZmlnIiwic3JjIiwid2lkdGgiLCJxdWFsaXR5IiwicHJvY2VzcyIsIm1pc3NpbmdWYWx1ZXMiLCJwdXNoIiwibGVuZ3RoIiwiRXJyb3IiLCJKU09OIiwiam9pbiIsInN0cmluZ2lmeSIsInN0YXJ0c1dpdGgiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJwYXJzZWRTcmMiLCJVUkwiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJoYXNNYXRjaCIsInJlcXVpcmUiLCJob3N0bmFtZSIsImVuZHNXaXRoIiwiZGFuZ2Vyb3VzbHlBbGxvd1NWRyIsImVuY29kZVVSSUNvbXBvbmVudCIsInBhdGgiLCJfX25leHRfaW1nX2RlZmF1bHQiLCJfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.matchRemotePattern = matchRemotePattern;\nexports.hasMatch = hasMatch;\nvar _micromatch = __webpack_require__(/*! next/dist/compiled/micromatch */ \"./node_modules/next/dist/compiled/micromatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        const actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\".concat(JSON.stringify(pattern)));\n    } else {\n        if (!(0, _micromatch).makeRe(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    var _pathname;\n    if (!(0, _micromatch).makeRe((_pathname = pattern.pathname) != null ? _pathname : \"**\").test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUdFO0FBQzdCRixnQkFBZ0IsR0FBR0c7QUFDbkIsSUFBSUMsY0FBY0MsbUJBQU9BLENBQUMsNEZBQStCO0FBQ3pELFNBQVNILG1CQUFtQkksT0FBTyxFQUFFQyxHQUFHLEVBQUU7SUFDdEMsSUFBSUQsUUFBUUUsUUFBUSxLQUFLQyxXQUFXO1FBQ2hDLE1BQU1DLGNBQWNILElBQUlDLFFBQVEsQ0FBQ0csS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUMzQyxJQUFJTCxRQUFRRSxRQUFRLEtBQUtFLGFBQWE7WUFDbEMsT0FBTyxLQUFLO1FBQ2hCLENBQUM7SUFDTCxDQUFDO0lBQ0QsSUFBSUosUUFBUU0sSUFBSSxLQUFLSCxXQUFXO1FBQzVCLElBQUlILFFBQVFNLElBQUksS0FBS0wsSUFBSUssSUFBSSxFQUFFO1lBQzNCLE9BQU8sS0FBSztRQUNoQixDQUFDO0lBQ0wsQ0FBQztJQUNELElBQUlOLFFBQVFPLFFBQVEsS0FBS0osV0FBVztRQUNoQyxNQUFNLElBQUlLLE1BQU0sNkNBQXFFLE9BQXhCQyxLQUFLQyxTQUFTLENBQUNWLFdBQVk7SUFDNUYsT0FBTztRQUNILElBQUksQ0FBQyxDQUFDLEdBQUdGLFdBQVcsRUFBRWEsTUFBTSxDQUFDWCxRQUFRTyxRQUFRLEVBQUVLLElBQUksQ0FBQ1gsSUFBSU0sUUFBUSxHQUFHO1lBQy9ELE9BQU8sS0FBSztRQUNoQixDQUFDO0lBQ0wsQ0FBQztJQUNELElBQUlNO0lBQ0osSUFBSSxDQUFDLENBQUMsR0FBR2YsV0FBVyxFQUFFYSxNQUFNLENBQUMsQ0FBQ0UsWUFBWWIsUUFBUWMsUUFBUSxLQUFLLElBQUksR0FBR0QsWUFBWSxJQUFJLEVBQUVELElBQUksQ0FBQ1gsSUFBSWEsUUFBUSxHQUFHO1FBQ3hHLE9BQU8sS0FBSztJQUNoQixDQUFDO0lBQ0QsT0FBTyxJQUFJO0FBQ2Y7QUFDQSxTQUFTakIsU0FBU2tCLE9BQU8sRUFBRUMsY0FBYyxFQUFFZixHQUFHLEVBQUU7SUFDNUMsT0FBT2MsUUFBUUUsSUFBSSxDQUFDLENBQUNDLFNBQVNqQixJQUFJTSxRQUFRLEtBQUtXLFdBQVdGLGVBQWVDLElBQUksQ0FBQyxDQUFDRSxJQUFJdkIsbUJBQW1CdUIsR0FBR2xCO0FBQzdHLEVBRUEsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcz8wYzliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYXRjaFJlbW90ZVBhdHRlcm4gPSBtYXRjaFJlbW90ZVBhdHRlcm47XG5leHBvcnRzLmhhc01hdGNoID0gaGFzTWF0Y2g7XG52YXIgX21pY3JvbWF0Y2ggPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2hcIik7XG5mdW5jdGlvbiBtYXRjaFJlbW90ZVBhdHRlcm4ocGF0dGVybiwgdXJsKSB7XG4gICAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IHVybC5wcm90b2NvbC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGlmIChwYXR0ZXJuLnByb3RvY29sICE9PSBhY3R1YWxQcm90bykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocGF0dGVybi5wb3J0ICE9PSB1cmwucG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLmhvc3RuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXR0ZXJuIHNob3VsZCBkZWZpbmUgaG9zdG5hbWUgYnV0IGZvdW5kXFxuJHtKU09OLnN0cmluZ2lmeShwYXR0ZXJuKX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoISgwLCBfbWljcm9tYXRjaCkubWFrZVJlKHBhdHRlcm4uaG9zdG5hbWUpLnRlc3QodXJsLmhvc3RuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBfcGF0aG5hbWU7XG4gICAgaWYgKCEoMCwgX21pY3JvbWF0Y2gpLm1ha2VSZSgoX3BhdGhuYW1lID0gcGF0dGVybi5wYXRobmFtZSkgIT0gbnVsbCA/IF9wYXRobmFtZSA6ICcqKicpLnRlc3QodXJsLnBhdGhuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaGFzTWF0Y2goZG9tYWlucywgcmVtb3RlUGF0dGVybnMsIHVybCkge1xuICAgIHJldHVybiBkb21haW5zLnNvbWUoKGRvbWFpbik9PnVybC5ob3N0bmFtZSA9PT0gZG9tYWluKSB8fCByZW1vdGVQYXR0ZXJucy5zb21lKChwKT0+bWF0Y2hSZW1vdGVQYXR0ZXJuKHAsIHVybCkpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRjaC1yZW1vdGUtcGF0dGVybi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtYXRjaFJlbW90ZVBhdHRlcm4iLCJoYXNNYXRjaCIsIl9taWNyb21hdGNoIiwicmVxdWlyZSIsInBhdHRlcm4iLCJ1cmwiLCJwcm90b2NvbCIsInVuZGVmaW5lZCIsImFjdHVhbFByb3RvIiwic2xpY2UiLCJwb3J0IiwiaG9zdG5hbWUiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYWtlUmUiLCJ0ZXN0IiwiX3BhdGhuYW1lIiwicGF0aG5hbWUiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJzb21lIiwiZG9tYWluIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "./pages/api/whisper.tsx":
/*!*******************************!*\
  !*** ./pages/api/whisper.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Whisper; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var mic_recorder_to_mp3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mic-recorder-to-mp3 */ \"./node_modules/mic-recorder-to-mp3/dist/index.js\");\n/* harmony import */ var mic_recorder_to_mp3__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mic_recorder_to_mp3__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! form-data */ \"./node_modules/form-data/lib/browser.js\");\n/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(form_data__WEBPACK_IMPORTED_MODULE_4__);\n\nvar _s = $RefreshSig$();\n\n\n\n\nfunction Whisper(props) {\n    _s();\n    const { setText  } = props;\n    let isRecorded = false;\n    const recorder = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>new (mic_recorder_to_mp3__WEBPACK_IMPORTED_MODULE_3___default())({\n            bitRate: 128\n        }), []);\n    const recordHandler = ()=>{\n        isRecorded = true;\n        recorder.stop();\n        recorder.start().then(()=>{}).catch((e)=>{\n            console.error(e);\n        });\n    };\n    const stopHandler = ()=>{\n        recorder.stop();\n        if (!isRecorded) {\n            console.log(\"Please record before stopping...\");\n            return;\n        }\n        isRecorded = false;\n        recorder.stop().getMp3().then((param)=>{\n            let [buffer, blob] = param;\n            const file = new File(buffer, \"voice.mp3\", {\n                type: blob.type,\n                lastModified: Date.now()\n            });\n            const formdata = new (form_data__WEBPACK_IMPORTED_MODULE_4___default())();\n            formdata.append(\"audio_file\", file, \"voice.mp3\");\n            const requestOptions = {\n                method: \"POST\",\n                body: formdata,\n                redirect: \"follow\"\n            };\n            fetch(\"https://whisper.lablab.ai/asr\", requestOptions).then((response)=>response.text()).then((result)=>setText(JSON.parse(result).text)).catch((error)=>console.log(\"error\", error));\n        }).catch((e)=>{\n            alert(\"We could not retrieve your message\");\n            console.log(e);\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                    children: \"Whisper\"\n                }, void 0, false, {\n                    fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/api/whisper.tsx\",\n                    lineNumber: 66,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/api/whisper.tsx\",\n                lineNumber: 65,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: recordHandler,\n                children: \"Record\"\n            }, void 0, false, {\n                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/api/whisper.tsx\",\n                lineNumber: 68,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: stopHandler,\n                children: \"Stop\"\n            }, void 0, false, {\n                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/api/whisper.tsx\",\n                lineNumber: 69,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(Whisper, \"WSXPOULsi4xs2cS7oEgBBXtgmsI=\");\n_c = Whisper;\nvar _c;\n$RefreshReg$(_c, \"Whisper\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9hcGkvd2hpc3Blci50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDNkI7QUFFd0I7QUFDUDtBQUNiO0FBRWxCLFNBQVNJLFFBQVFDLEtBQUssRUFBRTs7SUFDckMsTUFBTSxFQUFFQyxRQUFPLEVBQUUsR0FBR0Q7SUFFcEIsSUFBSUUsYUFBYSxLQUFLO0lBRXRCLE1BQU1DLFdBQVdQLDhDQUFPQSxDQUFDLElBQU0sSUFBSUMsNERBQVdBLENBQUM7WUFBRU8sU0FBUztRQUFJLElBQUksRUFBRTtJQUVwRSxNQUFNQyxnQkFBZ0IsSUFBTTtRQUMxQkgsYUFBYSxJQUFJO1FBQ2pCQyxTQUFTRyxJQUFJO1FBQ2JILFNBQ0dJLEtBQUssR0FDTEMsSUFBSSxDQUFDLElBQU0sQ0FBQyxHQUNaQyxLQUFLLENBQUMsQ0FBQ0MsSUFBTTtZQUNaQyxRQUFRQyxLQUFLLENBQUNGO1FBQ2hCO0lBQ0o7SUFFQSxNQUFNRyxjQUFjLElBQU07UUFDeEJWLFNBQVNHLElBQUk7UUFFYixJQUFJLENBQUNKLFlBQVk7WUFDZlMsUUFBUUcsR0FBRyxDQUFDO1lBQ1o7UUFDRixDQUFDO1FBQ0RaLGFBQWEsS0FBSztRQUNsQkMsU0FDR0csSUFBSSxHQUNKUyxNQUFNLEdBQ05QLElBQUksQ0FBQyxTQUFvQjtnQkFBbkIsQ0FBQ1EsUUFBUUMsS0FBSztZQUNuQixNQUFNQyxPQUFPLElBQUlDLEtBQUtILFFBQVEsYUFBYTtnQkFDekNJLE1BQU1ILEtBQUtHLElBQUk7Z0JBQ2ZDLGNBQWNDLEtBQUtDLEdBQUc7WUFDeEI7WUFFQSxNQUFNQyxXQUFXLElBQUkxQixrREFBUUE7WUFFN0IwQixTQUFTQyxNQUFNLENBQUMsY0FBY1AsTUFBTTtZQUNwQyxNQUFNUSxpQkFBaUI7Z0JBQ3JCQyxRQUFRO2dCQUNSQyxNQUFNSjtnQkFDTkssVUFBVTtZQUNaO1lBRUFDLE1BQU0saUNBQWlDSixnQkFDcENsQixJQUFJLENBQUMsQ0FBQ3VCLFdBQWFBLFNBQVNDLElBQUksSUFDaEN4QixJQUFJLENBQUMsQ0FBQ3lCLFNBQVdoQyxRQUFRaUMsS0FBS0MsS0FBSyxDQUFDRixRQUFRRCxJQUFJLEdBQ2hEdkIsS0FBSyxDQUFDLENBQUNHLFFBQVVELFFBQVFHLEdBQUcsQ0FBQyxTQUFTRjtRQUMzQyxHQUNDSCxLQUFLLENBQUMsQ0FBQ0MsSUFBTTtZQUNaMEIsTUFBTTtZQUNOekIsUUFBUUcsR0FBRyxDQUFDSjtRQUNkO0lBQ0o7SUFFQSxxQkFDRTs7MEJBQ0UsOERBQUNmLGtEQUFJQTswQkFDSCw0RUFBQzBDOzhCQUFNOzs7Ozs7Ozs7OzswQkFFVCw4REFBQ0M7Z0JBQU9DLFNBQVNsQzswQkFBZTs7Ozs7OzBCQUNoQyw4REFBQ2lDO2dCQUFPQyxTQUFTMUI7MEJBQWE7Ozs7Ozs7O0FBR3BDLENBQUM7R0FoRXVCZDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9hcGkvd2hpc3Blci50c3g/YjBmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTGluayBmcm9tIFwibmV4dC9saW5rXCI7XG5pbXBvcnQgSGVhZCBmcm9tIFwibmV4dC9oZWFkXCI7XG5pbXBvcnQgU2NyaXB0IGZyb20gXCJuZXh0L3NjcmlwdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZU1lbW8sIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IE1pY1JlY29yZGVyIGZyb20gXCJtaWMtcmVjb3JkZXItdG8tbXAzXCI7XG5pbXBvcnQgRm9ybURhdGEgZnJvbSBcImZvcm0tZGF0YVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBXaGlzcGVyKHByb3BzKSB7XG4gIGNvbnN0IHsgc2V0VGV4dCB9ID0gcHJvcHM7XG5cbiAgbGV0IGlzUmVjb3JkZWQgPSBmYWxzZTtcblxuICBjb25zdCByZWNvcmRlciA9IHVzZU1lbW8oKCkgPT4gbmV3IE1pY1JlY29yZGVyKHsgYml0UmF0ZTogMTI4IH0pLCBbXSk7XG5cbiAgY29uc3QgcmVjb3JkSGFuZGxlciA9ICgpID0+IHtcbiAgICBpc1JlY29yZGVkID0gdHJ1ZTtcbiAgICByZWNvcmRlci5zdG9wKCk7XG4gICAgcmVjb3JkZXJcbiAgICAgIC5zdGFydCgpXG4gICAgICAudGhlbigoKSA9PiB7fSlcbiAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfSk7XG4gIH07XG5cbiAgY29uc3Qgc3RvcEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgcmVjb3JkZXIuc3RvcCgpO1xuXG4gICAgaWYgKCFpc1JlY29yZGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlBsZWFzZSByZWNvcmQgYmVmb3JlIHN0b3BwaW5nLi4uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc1JlY29yZGVkID0gZmFsc2U7XG4gICAgcmVjb3JkZXJcbiAgICAgIC5zdG9wKClcbiAgICAgIC5nZXRNcDMoKVxuICAgICAgLnRoZW4oKFtidWZmZXIsIGJsb2JdKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgRmlsZShidWZmZXIsIFwidm9pY2UubXAzXCIsIHtcbiAgICAgICAgICB0eXBlOiBibG9iLnR5cGUsXG4gICAgICAgICAgbGFzdE1vZGlmaWVkOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBmb3JtZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgIGZvcm1kYXRhLmFwcGVuZChcImF1ZGlvX2ZpbGVcIiwgZmlsZSwgXCJ2b2ljZS5tcDNcIik7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgYm9keTogZm9ybWRhdGEsXG4gICAgICAgICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgICAgIH07XG5cbiAgICAgICAgZmV0Y2goXCJodHRwczovL3doaXNwZXIubGFibGFiLmFpL2FzclwiLCByZXF1ZXN0T3B0aW9ucylcbiAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLnRleHQoKSlcbiAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiBzZXRUZXh0KEpTT04ucGFyc2UocmVzdWx0KS50ZXh0KSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBjb25zb2xlLmxvZyhcImVycm9yXCIsIGVycm9yKSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGFsZXJ0KFwiV2UgY291bGQgbm90IHJldHJpZXZlIHlvdXIgbWVzc2FnZVwiKTtcbiAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8SGVhZD5cbiAgICAgICAgPHRpdGxlPldoaXNwZXI8L3RpdGxlPlxuICAgICAgPC9IZWFkPlxuICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtyZWNvcmRIYW5kbGVyfT5SZWNvcmQ8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gb25DbGljaz17c3RvcEhhbmRsZXJ9PlN0b3A8L2J1dHRvbj5cbiAgICA8Lz5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJIZWFkIiwidXNlTWVtbyIsIk1pY1JlY29yZGVyIiwiRm9ybURhdGEiLCJXaGlzcGVyIiwicHJvcHMiLCJzZXRUZXh0IiwiaXNSZWNvcmRlZCIsInJlY29yZGVyIiwiYml0UmF0ZSIsInJlY29yZEhhbmRsZXIiLCJzdG9wIiwic3RhcnQiLCJ0aGVuIiwiY2F0Y2giLCJlIiwiY29uc29sZSIsImVycm9yIiwic3RvcEhhbmRsZXIiLCJsb2ciLCJnZXRNcDMiLCJidWZmZXIiLCJibG9iIiwiZmlsZSIsIkZpbGUiLCJ0eXBlIiwibGFzdE1vZGlmaWVkIiwiRGF0ZSIsIm5vdyIsImZvcm1kYXRhIiwiYXBwZW5kIiwicmVxdWVzdE9wdGlvbnMiLCJtZXRob2QiLCJib2R5IiwicmVkaXJlY3QiLCJmZXRjaCIsInJlc3BvbnNlIiwidGV4dCIsInJlc3VsdCIsIkpTT04iLCJwYXJzZSIsImFsZXJ0IiwidGl0bGUiLCJidXR0b24iLCJvbkNsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/api/whisper.tsx\n"));

/***/ }),

/***/ "./pages/index.tsx":
/*!*************************!*\
  !*** ./pages/index.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../styles/Home.module.css */ \"./styles/Home.module.css\");\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _api_whisper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./api/whisper */ \"./pages/api/whisper.tsx\");\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! openai */ \"./node_modules/openai/dist/index.js\");\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(openai__WEBPACK_IMPORTED_MODULE_5__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst configuration = new openai__WEBPACK_IMPORTED_MODULE_5__.Configuration({\n    apiKey: \"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\"\n});\nconst openai = new openai__WEBPACK_IMPORTED_MODULE_5__.OpenAIApi(configuration);\nfunction Home() {\n    _s();\n    const [text, setText] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(\"\");\n    const [response, setResponse] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(\"\");\n    const [textHistory, setTextHistory] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    const [responseHistory, setResponseHistory] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    // When response is updated, playback response\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        const synth = window.speechSynthesis;\n        const voices = synth.getVoices();\n        const sayThis = new SpeechSynthesisUtterance(response);\n        sayThis.voice = voices[0]; // 0, 17, 10, 60, 58, 53, 51, 50, 49, 39, 33, 26\n        sayThis.rate = 1;\n        synth.speak(sayThis);\n    }, [\n        response\n    ]);\n    const sendQuery = async (prompt)=>{\n        const completion = await openai.createCompletion({\n            model: \"text-davinci-003\",\n            prompt,\n            max_tokens: 250\n        });\n        setResponse(await completion.data.choices[0].text);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (text === \"\") {\n            return;\n        }\n        console.log(text);\n        sendQuery(text);\n        setTextHistory([\n            ...textHistory,\n            text\n        ]);\n        setText(\"\");\n    }, [\n        text\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        console.log(response);\n        setResponseHistory([\n            ...responseHistory,\n            response\n        ]);\n    }, [\n        response\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().container),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Create Next App\"\n                    }, void 0, false, {\n                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                        lineNumber: 58,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"description\",\n                        content: \"Generated by create next app\"\n                    }, void 0, false, {\n                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                        lineNumber: 59,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/favicon.ico\"\n                    }, void 0, false, {\n                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                        lineNumber: 60,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                lineNumber: 57,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_api_whisper__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                setText: setText\n            }, void 0, false, {\n                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                lineNumber: 62,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    \"Prompt: \",\n                    textHistory\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                lineNumber: 63,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    \"Response: \",\n                    responseHistory\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                lineNumber: 64,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().main),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().title),\n                        children: [\n                            \"Welcome to \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"https://nextjs.org\",\n                                children: \"Next.js!\"\n                            }, void 0, false, {\n                                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                lineNumber: 67,\n                                columnNumber: 22\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                        lineNumber: 66,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().description),\n                        children: [\n                            \"Get started by editing\",\n                            \" \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"code\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().code),\n                                children: \"pages/index.tsx\"\n                            }, void 0, false, {\n                                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                lineNumber: 72,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                        lineNumber: 70,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().grid),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"https://nextjs.org/docs\",\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().card),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        children: \"Documentation →\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                        lineNumber: 77,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: \"Find in-depth information about Next.js features and API.\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                        lineNumber: 78,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                lineNumber: 76,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"https://nextjs.org/learn\",\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().card),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        children: \"Learn →\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                        lineNumber: 82,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: \"Learn about Next.js in an interactive course with quizzes!\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                        lineNumber: 83,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                lineNumber: 81,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"https://github.com/vercel/next.js/tree/canary/examples\",\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().card),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        children: \"Examples →\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                        lineNumber: 90,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: \"Discover and deploy boilerplate example Next.js projects.\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                        lineNumber: 91,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                lineNumber: 86,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"https://vercel.com/new?utm_source=create-next-app&utm_medium=default-template&utm_campaign=create-next-app\",\n                                target: \"_blank\",\n                                rel: \"noopener noreferrer\",\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().card),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        children: \"Deploy →\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                        lineNumber: 100,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: \"Instantly deploy your Next.js site to a public URL with Vercel.\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                        lineNumber: 101,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                lineNumber: 94,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                        lineNumber: 75,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                lineNumber: 65,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"footer\", {\n                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().footer),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                    href: \"https://vercel.com?utm_source=create-next-app&utm_medium=default-template&utm_campaign=create-next-app\",\n                    target: \"_blank\",\n                    rel: \"noopener noreferrer\",\n                    children: [\n                        \"Powered by\",\n                        \" \",\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6___default().logo),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_2___default()), {\n                                src: \"/vercel.svg\",\n                                alt: \"Vercel Logo\",\n                                width: 72,\n                                height: 16\n                            }, void 0, false, {\n                                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                                lineNumber: 116,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                            lineNumber: 115,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                    lineNumber: 109,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n                lineNumber: 108,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/Jon/Projects/chrome-extension/OpenAI Hackathon/openai-hackathon-dec-22/pages/index.tsx\",\n        lineNumber: 56,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"LKhcOLBHFTlRGbB673aG+gjQan4=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBVzs7a0RBQ3ZELDhEQUFDMkQ7a0RBQUc7Ozs7OztrREFDSiw4REFBQ0w7a0RBQUU7Ozs7Ozs7Ozs7OzswQ0FHTCw4REFBQ0Q7Z0NBQ0NILE1BQUs7Z0NBQ0xSLFdBQVcxQyxxRUFBVzs7a0RBRXRCLDhEQUFDMkQ7a0RBQUc7Ozs7OztrREFDSiw4REFBQ0w7a0RBQUU7Ozs7Ozs7Ozs7OzswQ0FHTCw4REFBQ0Q7Z0NBQ0NILE1BQUs7Z0NBQ0xVLFFBQU87Z0NBQ1BYLEtBQUk7Z0NBQ0pQLFdBQVcxQyxxRUFBVzs7a0RBRXRCLDhEQUFDMkQ7a0RBQUc7Ozs7OztrREFDSiw4REFBQ0w7a0RBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFPVCw4REFBQ087Z0JBQU9uQixXQUFXMUMsdUVBQWE7MEJBQzlCLDRFQUFDcUQ7b0JBQ0NILE1BQUs7b0JBQ0xVLFFBQU87b0JBQ1BYLEtBQUk7O3dCQUNMO3dCQUNZO3NDQUNYLDhEQUFDYTs0QkFBS3BCLFdBQVcxQyxxRUFBVztzQ0FDMUIsNEVBQUNELG1EQUFLQTtnQ0FBQ2lFLEtBQUk7Z0NBQWNDLEtBQUk7Z0NBQWNDLE9BQU87Z0NBQUlDLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNMUUsQ0FBQztHQTVHdUJ2RDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9pbmRleC50c3g/MDdmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSGVhZCBmcm9tIFwibmV4dC9oZWFkXCI7XG5pbXBvcnQgSW1hZ2UgZnJvbSBcIm5leHQvaW1hZ2VcIjtcbmltcG9ydCBzdHlsZXMgZnJvbSBcIi4uL3N0eWxlcy9Ib21lLm1vZHVsZS5jc3NcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBXaGlzcGVyIGZyb20gXCIuL2FwaS93aGlzcGVyXCI7XG5cbmltcG9ydCB7IENvbmZpZ3VyYXRpb24sIE9wZW5BSUFwaSB9IGZyb20gXCJvcGVuYWlcIjtcblxuY29uc3QgY29uZmlndXJhdGlvbiA9IG5ldyBDb25maWd1cmF0aW9uKHtcbiAgYXBpS2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19PUEVOQUlfQVBJX0tFWSxcbn0pO1xuY29uc3Qgb3BlbmFpID0gbmV3IE9wZW5BSUFwaShjb25maWd1cmF0aW9uKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZSgpIHtcbiAgY29uc3QgW3RleHQsIHNldFRleHRdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtyZXNwb25zZSwgc2V0UmVzcG9uc2VdID0gdXNlU3RhdGUoXCJcIik7XG5cbiAgY29uc3QgW3RleHRIaXN0b3J5LCBzZXRUZXh0SGlzdG9yeV0gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtyZXNwb25zZUhpc3RvcnksIHNldFJlc3BvbnNlSGlzdG9yeV0gPSB1c2VTdGF0ZShbXSk7XG5cbiAgLy8gV2hlbiByZXNwb25zZSBpcyB1cGRhdGVkLCBwbGF5YmFjayByZXNwb25zZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHN5bnRoID0gd2luZG93LnNwZWVjaFN5bnRoZXNpcztcbiAgICBjb25zdCB2b2ljZXMgPSBzeW50aC5nZXRWb2ljZXMoKTtcbiAgICBjb25zdCBzYXlUaGlzID0gbmV3IFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZShyZXNwb25zZSk7XG4gICAgc2F5VGhpcy52b2ljZSA9IHZvaWNlc1swXTsgLy8gMCwgMTcsIDEwLCA2MCwgNTgsIDUzLCA1MSwgNTAsIDQ5LCAzOSwgMzMsIDI2XG4gICAgc2F5VGhpcy5yYXRlID0gMTtcbiAgICBzeW50aC5zcGVhayhzYXlUaGlzKTtcbiAgfSwgW3Jlc3BvbnNlXSk7XG5cbiAgY29uc3Qgc2VuZFF1ZXJ5ID0gYXN5bmMgKHByb21wdDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgY29uc3QgY29tcGxldGlvbjogYW55ID0gYXdhaXQgb3BlbmFpLmNyZWF0ZUNvbXBsZXRpb24oe1xuICAgICAgbW9kZWw6IFwidGV4dC1kYXZpbmNpLTAwM1wiLFxuICAgICAgcHJvbXB0LFxuICAgICAgbWF4X3Rva2VuczogMjUwLFxuICAgIH0pO1xuICAgIHNldFJlc3BvbnNlKGF3YWl0IGNvbXBsZXRpb24uZGF0YS5jaG9pY2VzWzBdLnRleHQpO1xuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRleHQgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgc2VuZFF1ZXJ5KHRleHQpO1xuICAgIHNldFRleHRIaXN0b3J5KFsuLi50ZXh0SGlzdG9yeSwgdGV4dF0pO1xuICAgIHNldFRleHQoXCJcIik7XG4gIH0sIFt0ZXh0XSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgc2V0UmVzcG9uc2VIaXN0b3J5KFsuLi5yZXNwb25zZUhpc3RvcnksIHJlc3BvbnNlXSk7XG4gIH0sIFtyZXNwb25zZV0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb250YWluZXJ9PlxuICAgICAgPEhlYWQ+XG4gICAgICAgIDx0aXRsZT5DcmVhdGUgTmV4dCBBcHA8L3RpdGxlPlxuICAgICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PVwiR2VuZXJhdGVkIGJ5IGNyZWF0ZSBuZXh0IGFwcFwiIC8+XG4gICAgICAgIDxsaW5rIHJlbD1cImljb25cIiBocmVmPVwiL2Zhdmljb24uaWNvXCIgLz5cbiAgICAgIDwvSGVhZD5cbiAgICAgIDxXaGlzcGVyIHNldFRleHQ9e3NldFRleHR9PjwvV2hpc3Blcj5cbiAgICAgIDxkaXY+UHJvbXB0OiB7dGV4dEhpc3Rvcnl9PC9kaXY+XG4gICAgICA8ZGl2PlJlc3BvbnNlOiB7cmVzcG9uc2VIaXN0b3J5fTwvZGl2PlxuICAgICAgPG1haW4gY2xhc3NOYW1lPXtzdHlsZXMubWFpbn0+XG4gICAgICAgIDxoMSBjbGFzc05hbWU9e3N0eWxlcy50aXRsZX0+XG4gICAgICAgICAgV2VsY29tZSB0byA8YSBocmVmPVwiaHR0cHM6Ly9uZXh0anMub3JnXCI+TmV4dC5qcyE8L2E+XG4gICAgICAgIDwvaDE+XG5cbiAgICAgICAgPHAgY2xhc3NOYW1lPXtzdHlsZXMuZGVzY3JpcHRpb259PlxuICAgICAgICAgIEdldCBzdGFydGVkIGJ5IGVkaXRpbmd7XCIgXCJ9XG4gICAgICAgICAgPGNvZGUgY2xhc3NOYW1lPXtzdHlsZXMuY29kZX0+cGFnZXMvaW5kZXgudHN4PC9jb2RlPlxuICAgICAgICA8L3A+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5ncmlkfT5cbiAgICAgICAgICA8YSBocmVmPVwiaHR0cHM6Ly9uZXh0anMub3JnL2RvY3NcIiBjbGFzc05hbWU9e3N0eWxlcy5jYXJkfT5cbiAgICAgICAgICAgIDxoMj5Eb2N1bWVudGF0aW9uICZyYXJyOzwvaDI+XG4gICAgICAgICAgICA8cD5GaW5kIGluLWRlcHRoIGluZm9ybWF0aW9uIGFib3V0IE5leHQuanMgZmVhdHVyZXMgYW5kIEFQSS48L3A+XG4gICAgICAgICAgPC9hPlxuXG4gICAgICAgICAgPGEgaHJlZj1cImh0dHBzOi8vbmV4dGpzLm9yZy9sZWFyblwiIGNsYXNzTmFtZT17c3R5bGVzLmNhcmR9PlxuICAgICAgICAgICAgPGgyPkxlYXJuICZyYXJyOzwvaDI+XG4gICAgICAgICAgICA8cD5MZWFybiBhYm91dCBOZXh0LmpzIGluIGFuIGludGVyYWN0aXZlIGNvdXJzZSB3aXRoIHF1aXp6ZXMhPC9wPlxuICAgICAgICAgIDwvYT5cblxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL3RyZWUvY2FuYXJ5L2V4YW1wbGVzXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNhcmR9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGgyPkV4YW1wbGVzICZyYXJyOzwvaDI+XG4gICAgICAgICAgICA8cD5EaXNjb3ZlciBhbmQgZGVwbG95IGJvaWxlcnBsYXRlIGV4YW1wbGUgTmV4dC5qcyBwcm9qZWN0cy48L3A+XG4gICAgICAgICAgPC9hPlxuXG4gICAgICAgICAgPGFcbiAgICAgICAgICAgIGhyZWY9XCJodHRwczovL3ZlcmNlbC5jb20vbmV3P3V0bV9zb3VyY2U9Y3JlYXRlLW5leHQtYXBwJnV0bV9tZWRpdW09ZGVmYXVsdC10ZW1wbGF0ZSZ1dG1fY2FtcGFpZ249Y3JlYXRlLW5leHQtYXBwXCJcbiAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNhcmR9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGgyPkRlcGxveSAmcmFycjs8L2gyPlxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgIEluc3RhbnRseSBkZXBsb3kgeW91ciBOZXh0LmpzIHNpdGUgdG8gYSBwdWJsaWMgVVJMIHdpdGggVmVyY2VsLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L21haW4+XG5cbiAgICAgIDxmb290ZXIgY2xhc3NOYW1lPXtzdHlsZXMuZm9vdGVyfT5cbiAgICAgICAgPGFcbiAgICAgICAgICBocmVmPVwiaHR0cHM6Ly92ZXJjZWwuY29tP3V0bV9zb3VyY2U9Y3JlYXRlLW5leHQtYXBwJnV0bV9tZWRpdW09ZGVmYXVsdC10ZW1wbGF0ZSZ1dG1fY2FtcGFpZ249Y3JlYXRlLW5leHQtYXBwXCJcbiAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxuICAgICAgICA+XG4gICAgICAgICAgUG93ZXJlZCBieXtcIiBcIn1cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5sb2dvfT5cbiAgICAgICAgICAgIDxJbWFnZSBzcmM9XCIvdmVyY2VsLnN2Z1wiIGFsdD1cIlZlcmNlbCBMb2dvXCIgd2lkdGg9ezcyfSBoZWlnaHQ9ezE2fSAvPlxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9hPlxuICAgICAgPC9mb290ZXI+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiSGVhZCIsIkltYWdlIiwic3R5bGVzIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJXaGlzcGVyIiwiQ29uZmlndXJhdGlvbiIsIk9wZW5BSUFwaSIsImNvbmZpZ3VyYXRpb24iLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfT1BFTkFJX0FQSV9LRVkiLCJvcGVuYWkiLCJIb21lIiwidGV4dCIsInNldFRleHQiLCJyZXNwb25zZSIsInNldFJlc3BvbnNlIiwidGV4dEhpc3RvcnkiLCJzZXRUZXh0SGlzdG9yeSIsInJlc3BvbnNlSGlzdG9yeSIsInNldFJlc3BvbnNlSGlzdG9yeSIsInN5bnRoIiwid2luZG93Iiwic3BlZWNoU3ludGhlc2lzIiwidm9pY2VzIiwiZ2V0Vm9pY2VzIiwic2F5VGhpcyIsIlNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSIsInZvaWNlIiwicmF0ZSIsInNwZWFrIiwic2VuZFF1ZXJ5IiwicHJvbXB0IiwiY29tcGxldGlvbiIsImNyZWF0ZUNvbXBsZXRpb24iLCJtb2RlbCIsIm1heF90b2tlbnMiLCJkYXRhIiwiY2hvaWNlcyIsImNvbnNvbGUiLCJsb2ciLCJkaXYiLCJjbGFzc05hbWUiLCJjb250YWluZXIiLCJ0aXRsZSIsIm1ldGEiLCJuYW1lIiwiY29udGVudCIsImxpbmsiLCJyZWwiLCJocmVmIiwibWFpbiIsImgxIiwiYSIsInAiLCJkZXNjcmlwdGlvbiIsImNvZGUiLCJncmlkIiwiY2FyZCIsImgyIiwidGFyZ2V0IiwiZm9vdGVyIiwic3BhbiIsImxvZ28iLCJzcmMiLCJhbHQiLCJ3aWR0aCIsImhlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/index.tsx\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGtCQUFrQixhQUFhLHdCQUF3QiwwQkFBMEIsOEJBQThCLFNBQVMsU0FBUyx1REFBdUQseUVBQXlFLHVCQUF1QixJQUFJLEtBQUssVUFBVSxxQkFBcUIsd0JBQXdCLHdCQUF3QixvQkFBb0IsZUFBZSxVQUFVLGtFQUFrRSxxQkFBcUIsY0FBYyxvQkFBb0IsWUFBWSx1QkFBdUIsaUJBQWlCLFdBQVcsV0FBVyxrQkFBa0IsNEJBQTRCLGtCQUFrQix3QkFBd0IsTUFBTSxpQkFBaUIsV0FBVyxXQUFXLGdDQUFnQyxRQUFRLGdCQUFnQixNQUFNLFFBQVEsSUFBSSxNQUFNLCtGQUErRixpQkFBaUIsZ0JBQWdCLGFBQWEsVUFBVSxnREFBZ0QsYUFBYSxVQUFVLHlFQUF5RSxnQkFBZ0IsYUFBYSxTQUFTLDRCQUE0QixrREFBa0QsNEJBQTRCLE1BQU0sU0FBUyxZQUFZLElBQUksTUFBTSxxREFBcUQsMkJBQTJCLGtCQUFrQiwwQkFBMEIsTUFBTSxlQUFlLFVBQVUsU0FBUyxZQUFZLGtCQUFrQixJQUFJLE1BQU0scUNBQXFDLFVBQVUsU0FBUyxnQ0FBZ0MsZUFBZSxxQkFBcUIsMkNBQTJDLG1CQUFtQixvQkFBb0I7QUFDOXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSwrR0FBK0csZ0JBQWdCLHdCQUF3Qix1QkFBdUIsaUJBQWlCLGVBQWUsK0NBQStDLGlHQUFpRyxrS0FBa0ssNkJBQTZCLElBQUksd0JBQXdCLE9BQU8sZUFBZSxZQUFZLDhDQUE4QywyQkFBMkIsb0JBQW9CLFNBQVMsY0FBYyxpREFBaUQsK0JBQStCLDJDQUEyQyxvQkFBb0IsRUFBRSxpREFBaUQsK0JBQStCLDJDQUEyQyx3QkFBd0IsRUFBRSx5QkFBeUIsUUFBUSx1RUFBdUUsd0JBQXdCLDBDQUEwQyxTQUFTLHVCQUF1Qix3QkFBd0Isd0JB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QkFBNEIsY0FBYywyQkFBMkIsZUFBZSxJQUFJLEtBQUssbUNBQW1DLDJCQUEyQixJQUFJLEtBQUssV0FBVyxPQUFPLEtBQUsscUJBQXFCLFdBQVcsSUFBSSxLQUFLLFdBQVcsSUFBSSxJQUFJLGdCQUFnQix3QkFBd0IsTUFBTSxLQUFLLGtDQUFrQyxLQUFLLEtBQUssS0FBSyxnQ0FBZ0MsU0FBUyxLQUFLLEtBQUssSUFBSSxnQ0FBZ0MsbUJBQW1CLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLDhCQUE4QixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9idWZmZXIvaW5kZXguanM/Mzc3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17Njc1OmZ1bmN0aW9uKGUscil7XCJ1c2Ugc3RyaWN0XCI7ci5ieXRlTGVuZ3RoPWJ5dGVMZW5ndGg7ci50b0J5dGVBcnJheT10b0J5dGVBcnJheTtyLmZyb21CeXRlQXJyYXk9ZnJvbUJ5dGVBcnJheTt2YXIgdD1bXTt2YXIgZj1bXTt2YXIgbj10eXBlb2YgVWludDhBcnJheSE9PVwidW5kZWZpbmVkXCI/VWludDhBcnJheTpBcnJheTt2YXIgaT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtmb3IodmFyIG89MCx1PWkubGVuZ3RoO288dTsrK28pe3Rbb109aVtvXTtmW2kuY2hhckNvZGVBdChvKV09b31mW1wiLVwiLmNoYXJDb2RlQXQoMCldPTYyO2ZbXCJfXCIuY2hhckNvZGVBdCgwKV09NjM7ZnVuY3Rpb24gZ2V0TGVucyhlKXt2YXIgcj1lLmxlbmd0aDtpZihyJTQ+MCl7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKX12YXIgdD1lLmluZGV4T2YoXCI9XCIpO2lmKHQ9PT0tMSl0PXI7dmFyIGY9dD09PXI/MDo0LXQlNDtyZXR1cm5bdCxmXX1mdW5jdGlvbiBieXRlTGVuZ3RoKGUpe3ZhciByPWdldExlbnMoZSk7dmFyIHQ9clswXTt2YXIgZj1yWzFdO3JldHVybih0K2YpKjMvNC1mfWZ1bmN0aW9uIF9ieXRlTGVuZ3RoKGUscix0KXtyZXR1cm4ocit0KSozLzQtdH1mdW5jdGlvbiB0b0J5dGVBcnJheShlKXt2YXIgcjt2YXIgdD1nZXRMZW5zKGUpO3ZhciBpPXRbMF07dmFyIG89dFsxXTt2YXIgdT1uZXcgbihfYnl0ZUxlbmd0aChlLGksbykpO3ZhciBhPTA7dmFyIHM9bz4wP2ktNDppO3ZhciBoO2ZvcihoPTA7aDxzO2grPTQpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwxOHxmW2UuY2hhckNvZGVBdChoKzEpXTw8MTJ8ZltlLmNoYXJDb2RlQXQoaCsyKV08PDZ8ZltlLmNoYXJDb2RlQXQoaCszKV07dVthKytdPXI+PjE2JjI1NTt1W2ErK109cj4+OCYyNTU7dVthKytdPXImMjU1fWlmKG89PT0yKXtyPWZbZS5jaGFyQ29kZUF0KGgpXTw8MnxmW2UuY2hhckNvZGVBdChoKzEpXT4+NDt1W2ErK109ciYyNTV9aWYobz09PTEpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwxMHxmW2UuY2hhckNvZGVBdChoKzEpXTw8NHxmW2UuY2hhckNvZGVBdChoKzIpXT4+Mjt1W2ErK109cj4+OCYyNTU7dVthKytdPXImMjU1fXJldHVybiB1fWZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChlKXtyZXR1cm4gdFtlPj4xOCY2M10rdFtlPj4xMiY2M10rdFtlPj42JjYzXSt0W2UmNjNdfWZ1bmN0aW9uIGVuY29kZUNodW5rKGUscix0KXt2YXIgZjt2YXIgbj1bXTtmb3IodmFyIGk9cjtpPHQ7aSs9Myl7Zj0oZVtpXTw8MTYmMTY3MTE2ODApKyhlW2krMV08PDgmNjUyODApKyhlW2krMl0mMjU1KTtuLnB1c2godHJpcGxldFRvQmFzZTY0KGYpKX1yZXR1cm4gbi5qb2luKFwiXCIpfWZ1bmN0aW9uIGZyb21CeXRlQXJyYXkoZSl7dmFyIHI7dmFyIGY9ZS5sZW5ndGg7dmFyIG49ZiUzO3ZhciBpPVtdO3ZhciBvPTE2MzgzO2Zvcih2YXIgdT0wLGE9Zi1uO3U8YTt1Kz1vKXtpLnB1c2goZW5jb2RlQ2h1bmsoZSx1LHUrbz5hP2E6dStvKSl9aWYobj09PTEpe3I9ZVtmLTFdO2kucHVzaCh0W3I+PjJdK3Rbcjw8NCY2M10rXCI9PVwiKX1lbHNlIGlmKG49PT0yKXtyPShlW2YtMl08PDgpK2VbZi0xXTtpLnB1c2godFtyPj4xMF0rdFtyPj40JjYzXSt0W3I8PDImNjNdK1wiPVwiKX1yZXR1cm4gaS5qb2luKFwiXCIpfX0sNzI6ZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovdmFyIGY9dCg2NzUpO3ZhciBuPXQoNzgzKTt2YXIgaT10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLmZvcj09PVwiZnVuY3Rpb25cIj9TeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIik6bnVsbDtyLkJ1ZmZlcj1CdWZmZXI7ci5TbG93QnVmZmVyPVNsb3dCdWZmZXI7ci5JTlNQRUNUX01BWF9CWVRFUz01MDt2YXIgbz0yMTQ3NDgzNjQ3O3Iua01heExlbmd0aD1vO0J1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUPXR5cGVkQXJyYXlTdXBwb3J0KCk7aWYoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUJiZ0eXBlb2YgY29uc29sZSE9PVwidW5kZWZpbmVkXCImJnR5cGVvZiBjb25zb2xlLmVycm9yPT09XCJmdW5jdGlvblwiKXtjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5IFwiK1wiYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC5cIil9ZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQoKXt0cnl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoMSk7dmFyIHI9e2ZvbzpmdW5jdGlvbigpe3JldHVybiA0Mn19O09iamVjdC5zZXRQcm90b3R5cGVPZihyLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZSxyKTtyZXR1cm4gZS5mb28oKT09PTQyfWNhdGNoKGUpe3JldHVybiBmYWxzZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsXCJwYXJlbnRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpcmV0dXJuIHVuZGVmaW5lZDtyZXR1cm4gdGhpcy5idWZmZXJ9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsXCJvZmZzZXRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpcmV0dXJuIHVuZGVmaW5lZDtyZXR1cm4gdGhpcy5ieXRlT2Zmc2V0fX0pO2Z1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihlKXtpZihlPm8pe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfXZhciByPW5ldyBVaW50OEFycmF5KGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihyLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiByfWZ1bmN0aW9uIEJ1ZmZlcihlLHIsdCl7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyl9cmV0dXJuIGFsbG9jVW5zYWZlKGUpfXJldHVybiBmcm9tKGUscix0KX1CdWZmZXIucG9vbFNpemU9ODE5MjtmdW5jdGlvbiBmcm9tKGUscix0KXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBmcm9tU3RyaW5nKGUscil9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlPT1udWxsKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9aWYoaXNJbnN0YW5jZShlLEFycmF5QnVmZmVyKXx8ZSYmaXNJbnN0YW5jZShlLmJ1ZmZlcixBcnJheUJ1ZmZlcikpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpfWlmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJihpc0luc3RhbmNlKGUsU2hhcmVkQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLFNoYXJlZEFycmF5QnVmZmVyKSkpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpfWlmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX12YXIgZj1lLnZhbHVlT2YmJmUudmFsdWVPZigpO2lmKGYhPW51bGwmJmYhPT1lKXtyZXR1cm4gQnVmZmVyLmZyb20oZixyLHQpfXZhciBuPWZyb21PYmplY3QoZSk7aWYobilyZXR1cm4gbjtpZih0eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIiYmU3ltYm9sLnRvUHJpbWl0aXZlIT1udWxsJiZ0eXBlb2YgZVtTeW1ib2wudG9QcmltaXRpdmVdPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gQnVmZmVyLmZyb20oZVtTeW1ib2wudG9QcmltaXRpdmVdKFwic3RyaW5nXCIpLHIsdCl9dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIFwiK1wib3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfUJ1ZmZlci5mcm9tPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gZnJvbShlLHIsdCl9O09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLFVpbnQ4QXJyYXkpO2Z1bmN0aW9uIGFzc2VydFNpemUoZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyl9ZWxzZSBpZihlPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfX1mdW5jdGlvbiBhbGxvYyhlLHIsdCl7YXNzZXJ0U2l6ZShlKTtpZihlPD0wKXtyZXR1cm4gY3JlYXRlQnVmZmVyKGUpfWlmKHIhPT11bmRlZmluZWQpe3JldHVybiB0eXBlb2YgdD09PVwic3RyaW5nXCI/Y3JlYXRlQnVmZmVyKGUpLmZpbGwocix0KTpjcmVhdGVCdWZmZXIoZSkuZmlsbChyKX1yZXR1cm4gY3JlYXRlQnVmZmVyKGUpfUJ1ZmZlci5hbGxvYz1mdW5jdGlvbihlLHIsdCl7cmV0dXJuIGFsbG9jKGUscix0KX07ZnVuY3Rpb24gYWxsb2NVbnNhZmUoZSl7YXNzZXJ0U2l6ZShlKTtyZXR1cm4gY3JlYXRlQnVmZmVyKGU8MD8wOmNoZWNrZWQoZSl8MCl9QnVmZmVyLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07QnVmZmVyLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtyZXR1cm4gYWxsb2NVbnNhZmUoZSl9O2Z1bmN0aW9uIGZyb21TdHJpbmcoZSxyKXtpZih0eXBlb2YgciE9PVwic3RyaW5nXCJ8fHI9PT1cIlwiKXtyPVwidXRmOFwifWlmKCFCdWZmZXIuaXNFbmNvZGluZyhyKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3IpfXZhciB0PWJ5dGVMZW5ndGgoZSxyKXwwO3ZhciBmPWNyZWF0ZUJ1ZmZlcih0KTt2YXIgbj1mLndyaXRlKGUscik7aWYobiE9PXQpe2Y9Zi5zbGljZSgwLG4pfXJldHVybiBmfWZ1bmN0aW9uIGZyb21BcnJheUxpa2UoZSl7dmFyIHI9ZS5sZW5ndGg8MD8wOmNoZWNrZWQoZS5sZW5ndGgpfDA7dmFyIHQ9Y3JlYXRlQnVmZmVyKHIpO2Zvcih2YXIgZj0wO2Y8cjtmKz0xKXt0W2ZdPWVbZl0mMjU1fXJldHVybiB0fWZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl7aWYocjwwfHxlLmJ5dGVMZW5ndGg8cil7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyl9aWYoZS5ieXRlTGVuZ3RoPHIrKHR8fDApKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX12YXIgZjtpZihyPT09dW5kZWZpbmVkJiZ0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUpfWVsc2UgaWYodD09PXVuZGVmaW5lZCl7Zj1uZXcgVWludDhBcnJheShlLHIpfWVsc2V7Zj1uZXcgVWludDhBcnJheShlLHIsdCl9T2JqZWN0LnNldFByb3RvdHlwZU9mKGYsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbU9iamVjdChlKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3ZhciByPWNoZWNrZWQoZS5sZW5ndGgpfDA7dmFyIHQ9Y3JlYXRlQnVmZmVyKHIpO2lmKHQubGVuZ3RoPT09MCl7cmV0dXJuIHR9ZS5jb3B5KHQsMCwwLHIpO3JldHVybiB0fWlmKGUubGVuZ3RoIT09dW5kZWZpbmVkKXtpZih0eXBlb2YgZS5sZW5ndGghPT1cIm51bWJlclwifHxudW1iZXJJc05hTihlLmxlbmd0aCkpe3JldHVybiBjcmVhdGVCdWZmZXIoMCl9cmV0dXJuIGZyb21BcnJheUxpa2UoZSl9aWYoZS50eXBlPT09XCJCdWZmZXJcIiYmQXJyYXkuaXNBcnJheShlLmRhdGEpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShlLmRhdGEpfX1mdW5jdGlvbiBjaGVja2VkKGUpe2lmKGU+PW8pe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBcIitcInNpemU6IDB4XCIrby50b1N0cmluZygxNikrXCIgYnl0ZXNcIil9cmV0dXJuIGV8MH1mdW5jdGlvbiBTbG93QnVmZmVyKGUpe2lmKCtlIT1lKXtlPTB9cmV0dXJuIEJ1ZmZlci5hbGxvYygrZSl9QnVmZmVyLmlzQnVmZmVyPWZ1bmN0aW9uIGlzQnVmZmVyKGUpe3JldHVybiBlIT1udWxsJiZlLl9pc0J1ZmZlcj09PXRydWUmJmUhPT1CdWZmZXIucHJvdG90eXBlfTtCdWZmZXIuY29tcGFyZT1mdW5jdGlvbiBjb21wYXJlKGUscil7aWYoaXNJbnN0YW5jZShlLFVpbnQ4QXJyYXkpKWU9QnVmZmVyLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpO2lmKGlzSW5zdGFuY2UocixVaW50OEFycmF5KSlyPUJ1ZmZlci5mcm9tKHIsci5vZmZzZXQsci5ieXRlTGVuZ3RoKTtpZighQnVmZmVyLmlzQnVmZmVyKGUpfHwhQnVmZmVyLmlzQnVmZmVyKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5Jyl9aWYoZT09PXIpcmV0dXJuIDA7dmFyIHQ9ZS5sZW5ndGg7dmFyIGY9ci5sZW5ndGg7Zm9yKHZhciBuPTAsaT1NYXRoLm1pbih0LGYpO248aTsrK24pe2lmKGVbbl0hPT1yW25dKXt0PWVbbl07Zj1yW25dO2JyZWFrfX1pZih0PGYpcmV0dXJuLTE7aWYoZjx0KXJldHVybiAxO3JldHVybiAwfTtCdWZmZXIuaXNFbmNvZGluZz1mdW5jdGlvbiBpc0VuY29kaW5nKGUpe3N3aXRjaChTdHJpbmcoZSkudG9Mb3dlckNhc2UoKSl7Y2FzZVwiaGV4XCI6Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpjYXNlXCJiYXNlNjRcIjpjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZX19O0J1ZmZlci5jb25jYXQ9ZnVuY3Rpb24gY29uY2F0KGUscil7aWYoIUFycmF5LmlzQXJyYXkoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpfWlmKGUubGVuZ3RoPT09MCl7cmV0dXJuIEJ1ZmZlci5hbGxvYygwKX12YXIgdDtpZihyPT09dW5kZWZpbmVkKXtyPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7cis9ZVt0XS5sZW5ndGh9fXZhciBmPUJ1ZmZlci5hbGxvY1Vuc2FmZShyKTt2YXIgbj0wO2Zvcih0PTA7dDxlLmxlbmd0aDsrK3Qpe3ZhciBpPWVbdF07aWYoaXNJbnN0YW5jZShpLFVpbnQ4QXJyYXkpKXtpPUJ1ZmZlci5mcm9tKGkpfWlmKCFCdWZmZXIuaXNCdWZmZXIoaSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpfWkuY29weShmLG4pO24rPWkubGVuZ3RofXJldHVybiBmfTtmdW5jdGlvbiBieXRlTGVuZ3RoKGUscil7aWYoQnVmZmVyLmlzQnVmZmVyKGUpKXtyZXR1cm4gZS5sZW5ndGh9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpfHxpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpKXtyZXR1cm4gZS5ieXRlTGVuZ3RofWlmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcrXCJSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX12YXIgdD1lLmxlbmd0aDt2YXIgZj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXT09PXRydWU7aWYoIWYmJnQ9PT0wKXJldHVybiAwO3ZhciBuPWZhbHNlO2Zvcig7Oyl7c3dpdGNoKHIpe2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHQ7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhUb0J5dGVzKGUpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdCoyO2Nhc2VcImhleFwiOnJldHVybiB0Pj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0VG9CeXRlcyhlKS5sZW5ndGg7ZGVmYXVsdDppZihuKXtyZXR1cm4gZj8tMTp1dGY4VG9CeXRlcyhlKS5sZW5ndGh9cj0oXCJcIityKS50b0xvd2VyQ2FzZSgpO249dHJ1ZX19fUJ1ZmZlci5ieXRlTGVuZ3RoPWJ5dGVMZW5ndGg7ZnVuY3Rpb24gc2xvd1RvU3RyaW5nKGUscix0KXt2YXIgZj1mYWxzZTtpZihyPT09dW5kZWZpbmVkfHxyPDApe3I9MH1pZihyPnRoaXMubGVuZ3RoKXtyZXR1cm5cIlwifWlmKHQ9PT11bmRlZmluZWR8fHQ+dGhpcy5sZW5ndGgpe3Q9dGhpcy5sZW5ndGh9aWYodDw9MCl7cmV0dXJuXCJcIn10Pj4+PTA7cj4+Pj0wO2lmKHQ8PXIpe3JldHVyblwiXCJ9aWYoIWUpZT1cInV0ZjhcIjt3aGlsZSh0cnVlKXtzd2l0Y2goZSl7Y2FzZVwiaGV4XCI6cmV0dXJuIGhleFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFNsaWNlKHRoaXMscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVNsaWNlKHRoaXMscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbGF0aW4xU2xpY2UodGhpcyxyLHQpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRTbGljZSh0aGlzLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLHIsdCk7ZGVmYXVsdDppZihmKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitlKTtlPShlK1wiXCIpLnRvTG93ZXJDYXNlKCk7Zj10cnVlfX19QnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXI9dHJ1ZTtmdW5jdGlvbiBzd2FwKGUscix0KXt2YXIgZj1lW3JdO2Vbcl09ZVt0XTtlW3RdPWZ9QnVmZmVyLnByb3RvdHlwZS5zd2FwMTY9ZnVuY3Rpb24gc3dhcDE2KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSUyIT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9Mil7c3dhcCh0aGlzLHIscisxKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwMzI9ZnVuY3Rpb24gc3dhcDMyKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU0IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9NCl7c3dhcCh0aGlzLHIsciszKTtzd2FwKHRoaXMscisxLHIrMil9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUuc3dhcDY0PWZ1bmN0aW9uIHN3YXA2NCgpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlOCE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTgpe3N3YXAodGhpcyxyLHIrNyk7c3dhcCh0aGlzLHIrMSxyKzYpO3N3YXAodGhpcyxyKzIscis1KTtzd2FwKHRoaXMsciszLHIrNCl9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24gdG9TdHJpbmcoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlPT09MClyZXR1cm5cIlwiO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVybiB1dGY4U2xpY2UodGhpcywwLGUpO3JldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtCdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nPUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc7QnVmZmVyLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24gZXF1YWxzKGUpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7aWYodGhpcz09PWUpcmV0dXJuIHRydWU7cmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsZSk9PT0wfTtCdWZmZXIucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24gaW5zcGVjdCgpe3ZhciBlPVwiXCI7dmFyIHQ9ci5JTlNQRUNUX01BWF9CWVRFUztlPXRoaXMudG9TdHJpbmcoXCJoZXhcIiwwLHQpLnJlcGxhY2UoLyguezJ9KS9nLFwiJDEgXCIpLnRyaW0oKTtpZih0aGlzLmxlbmd0aD50KWUrPVwiIC4uLiBcIjtyZXR1cm5cIjxCdWZmZXIgXCIrZStcIj5cIn07aWYoaSl7QnVmZmVyLnByb3RvdHlwZVtpXT1CdWZmZXIucHJvdG90eXBlLmluc3BlY3R9QnVmZmVyLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyLHQsZixuKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpe2U9QnVmZmVyLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpfWlmKCFCdWZmZXIuaXNCdWZmZXIoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcrXCJSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihyPT09dW5kZWZpbmVkKXtyPTB9aWYodD09PXVuZGVmaW5lZCl7dD1lP2UubGVuZ3RoOjB9aWYoZj09PXVuZGVmaW5lZCl7Zj0wfWlmKG49PT11bmRlZmluZWQpe249dGhpcy5sZW5ndGh9aWYocjwwfHx0PmUubGVuZ3RofHxmPDB8fG4+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIGluZGV4XCIpfWlmKGY+PW4mJnI+PXQpe3JldHVybiAwfWlmKGY+PW4pe3JldHVybi0xfWlmKHI+PXQpe3JldHVybiAxfXI+Pj49MDt0Pj4+PTA7Zj4+Pj0wO24+Pj49MDtpZih0aGlzPT09ZSlyZXR1cm4gMDt2YXIgaT1uLWY7dmFyIG89dC1yO3ZhciB1PU1hdGgubWluKGksbyk7dmFyIGE9dGhpcy5zbGljZShmLG4pO3ZhciBzPWUuc2xpY2Uocix0KTtmb3IodmFyIGg9MDtoPHU7KytoKXtpZihhW2hdIT09c1toXSl7aT1hW2hdO289c1toXTticmVha319aWYoaTxvKXJldHVybi0xO2lmKG88aSlyZXR1cm4gMTtyZXR1cm4gMH07ZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YoZSxyLHQsZixuKXtpZihlLmxlbmd0aD09PTApcmV0dXJuLTE7aWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD0wfWVsc2UgaWYodD4yMTQ3NDgzNjQ3KXt0PTIxNDc0ODM2NDd9ZWxzZSBpZih0PC0yMTQ3NDgzNjQ4KXt0PS0yMTQ3NDgzNjQ4fXQ9K3Q7aWYobnVtYmVySXNOYU4odCkpe3Q9bj8wOmUubGVuZ3RoLTF9aWYodDwwKXQ9ZS5sZW5ndGgrdDtpZih0Pj1lLmxlbmd0aCl7aWYobilyZXR1cm4tMTtlbHNlIHQ9ZS5sZW5ndGgtMX1lbHNlIGlmKHQ8MCl7aWYobil0PTA7ZWxzZSByZXR1cm4tMX1pZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3I9QnVmZmVyLmZyb20ocixmKX1pZihCdWZmZXIuaXNCdWZmZXIocikpe2lmKHIubGVuZ3RoPT09MCl7cmV0dXJuLTF9cmV0dXJuIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pfWVsc2UgaWYodHlwZW9mIHI9PT1cIm51bWJlclwiKXtyPXImMjU1O2lmKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mPT09XCJmdW5jdGlvblwiKXtpZihuKXtyZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGUscix0KX1lbHNle3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGUscix0KX19cmV0dXJuIGFycmF5SW5kZXhPZihlLFtyXSx0LGYsbil9dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiBhcnJheUluZGV4T2YoZSxyLHQsZixuKXt2YXIgaT0xO3ZhciBvPWUubGVuZ3RoO3ZhciB1PXIubGVuZ3RoO2lmKGYhPT11bmRlZmluZWQpe2Y9U3RyaW5nKGYpLnRvTG93ZXJDYXNlKCk7aWYoZj09PVwidWNzMlwifHxmPT09XCJ1Y3MtMlwifHxmPT09XCJ1dGYxNmxlXCJ8fGY9PT1cInV0Zi0xNmxlXCIpe2lmKGUubGVuZ3RoPDJ8fHIubGVuZ3RoPDIpe3JldHVybi0xfWk9MjtvLz0yO3UvPTI7dC89Mn19ZnVuY3Rpb24gcmVhZChlLHIpe2lmKGk9PT0xKXtyZXR1cm4gZVtyXX1lbHNle3JldHVybiBlLnJlYWRVSW50MTZCRShyKmkpfX12YXIgYTtpZihuKXt2YXIgcz0tMTtmb3IoYT10O2E8bzthKyspe2lmKHJlYWQoZSxhKT09PXJlYWQocixzPT09LTE/MDphLXMpKXtpZihzPT09LTEpcz1hO2lmKGEtcysxPT09dSlyZXR1cm4gcyppfWVsc2V7aWYocyE9PS0xKWEtPWEtcztzPS0xfX19ZWxzZXtpZih0K3U+byl0PW8tdTtmb3IoYT10O2E+PTA7YS0tKXt2YXIgaD10cnVlO2Zvcih2YXIgYz0wO2M8dTtjKyspe2lmKHJlYWQoZSxhK2MpIT09cmVhZChyLGMpKXtoPWZhbHNlO2JyZWFrfX1pZihoKXJldHVybiBhfX1yZXR1cm4tMX1CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uIGluY2x1ZGVzKGUscix0KXtyZXR1cm4gdGhpcy5pbmRleE9mKGUscix0KSE9PS0xfTtCdWZmZXIucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24gaW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsdHJ1ZSl9O0J1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24gbGFzdEluZGV4T2YoZSxyLHQpe3JldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLGUscix0LGZhbHNlKX07ZnVuY3Rpb24gaGV4V3JpdGUoZSxyLHQsZil7dD1OdW1iZXIodCl8fDA7dmFyIG49ZS5sZW5ndGgtdDtpZighZil7Zj1ufWVsc2V7Zj1OdW1iZXIoZik7aWYoZj5uKXtmPW59fXZhciBpPXIubGVuZ3RoO2lmKGY+aS8yKXtmPWkvMn1mb3IodmFyIG89MDtvPGY7KytvKXt2YXIgdT1wYXJzZUludChyLnN1YnN0cihvKjIsMiksMTYpO2lmKG51bWJlcklzTmFOKHUpKXJldHVybiBvO2VbdCtvXT11fXJldHVybiBvfWZ1bmN0aW9uIHV0ZjhXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhyLGUubGVuZ3RoLXQpLGUsdCxmKX1mdW5jdGlvbiBhc2NpaVdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhyKSxlLHQsZil9ZnVuY3Rpb24gbGF0aW4xV3JpdGUoZSxyLHQsZil7cmV0dXJuIGFzY2lpV3JpdGUoZSxyLHQsZil9ZnVuY3Rpb24gYmFzZTY0V3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhyKSxlLHQsZil9ZnVuY3Rpb24gdWNzMldyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfUJ1ZmZlci5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24gd3JpdGUoZSxyLHQsZil7aWYocj09PXVuZGVmaW5lZCl7Zj1cInV0ZjhcIjt0PXRoaXMubGVuZ3RoO3I9MH1lbHNlIGlmKHQ9PT11bmRlZmluZWQmJnR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYoaXNGaW5pdGUocikpe3I9cj4+PjA7aWYoaXNGaW5pdGUodCkpe3Q9dD4+PjA7aWYoZj09PXVuZGVmaW5lZClmPVwidXRmOFwifWVsc2V7Zj10O3Q9dW5kZWZpbmVkfX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpfXZhciBuPXRoaXMubGVuZ3RoLXI7aWYodD09PXVuZGVmaW5lZHx8dD5uKXQ9bjtpZihlLmxlbmd0aD4wJiYodDwwfHxyPDApfHxyPnRoaXMubGVuZ3RoKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpfWlmKCFmKWY9XCJ1dGY4XCI7dmFyIGk9ZmFsc2U7Zm9yKDs7KXtzd2l0Y2goZil7Y2FzZVwiaGV4XCI6cmV0dXJuIGhleFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gYXNjaWlXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbGF0aW4xV3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB1Y3MyV3JpdGUodGhpcyxlLHIsdCk7ZGVmYXVsdDppZihpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitmKTtmPShcIlwiK2YpLnRvTG93ZXJDYXNlKCk7aT10cnVlfX19O0J1ZmZlci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uIHRvSlNPTigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTtmdW5jdGlvbiBiYXNlNjRTbGljZShlLHIsdCl7aWYocj09PTAmJnQ9PT1lLmxlbmd0aCl7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlKX1lbHNle3JldHVybiBmLmZyb21CeXRlQXJyYXkoZS5zbGljZShyLHQpKX19ZnVuY3Rpb24gdXRmOFNsaWNlKGUscix0KXt0PU1hdGgubWluKGUubGVuZ3RoLHQpO3ZhciBmPVtdO3ZhciBuPXI7d2hpbGUobjx0KXt2YXIgaT1lW25dO3ZhciBvPW51bGw7dmFyIHU9aT4yMzk/NDppPjIyMz8zOmk+MTkxPzI6MTtpZihuK3U8PXQpe3ZhciBhLHMsaCxjO3N3aXRjaCh1KXtjYXNlIDE6aWYoaTwxMjgpe289aX1icmVhaztjYXNlIDI6YT1lW24rMV07aWYoKGEmMTkyKT09PTEyOCl7Yz0oaSYzMSk8PDZ8YSY2MztpZihjPjEyNyl7bz1jfX1icmVhaztjYXNlIDM6YT1lW24rMV07cz1lW24rMl07aWYoKGEmMTkyKT09PTEyOCYmKHMmMTkyKT09PTEyOCl7Yz0oaSYxNSk8PDEyfChhJjYzKTw8NnxzJjYzO2lmKGM+MjA0NyYmKGM8NTUyOTZ8fGM+NTczNDMpKXtvPWN9fWJyZWFrO2Nhc2UgNDphPWVbbisxXTtzPWVbbisyXTtoPWVbbiszXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4JiYoaCYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTh8KGEmNjMpPDwxMnwocyY2Myk8PDZ8aCY2MztpZihjPjY1NTM1JiZjPDExMTQxMTIpe289Y319fX1pZihvPT09bnVsbCl7bz02NTUzMzt1PTF9ZWxzZSBpZihvPjY1NTM1KXtvLT02NTUzNjtmLnB1c2gobz4+PjEwJjEwMjN8NTUyOTYpO289NTYzMjB8byYxMDIzfWYucHVzaChvKTtuKz11fXJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoZil9dmFyIHU9NDA5NjtmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoZSl7dmFyIHI9ZS5sZW5ndGg7aWYocjw9dSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUpfXZhciB0PVwiXCI7dmFyIGY9MDt3aGlsZShmPHIpe3QrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUuc2xpY2UoZixmKz11KSl9cmV0dXJuIHR9ZnVuY3Rpb24gYXNjaWlTbGljZShlLHIsdCl7dmFyIGY9XCJcIjt0PU1hdGgubWluKGUubGVuZ3RoLHQpO2Zvcih2YXIgbj1yO248dDsrK24pe2YrPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtuXSYxMjcpfXJldHVybiBmfWZ1bmN0aW9uIGxhdGluMVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dKX1yZXR1cm4gZn1mdW5jdGlvbiBoZXhTbGljZShlLHIsdCl7dmFyIGY9ZS5sZW5ndGg7aWYoIXJ8fHI8MClyPTA7aWYoIXR8fHQ8MHx8dD5mKXQ9Zjt2YXIgbj1cIlwiO2Zvcih2YXIgaT1yO2k8dDsrK2kpe24rPXNbZVtpXV19cmV0dXJuIG59ZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGUscix0KXt2YXIgZj1lLnNsaWNlKHIsdCk7dmFyIG49XCJcIjtmb3IodmFyIGk9MDtpPGYubGVuZ3RoO2krPTIpe24rPVN0cmluZy5mcm9tQ2hhckNvZGUoZltpXStmW2krMV0qMjU2KX1yZXR1cm4gbn1CdWZmZXIucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uIHNsaWNlKGUscil7dmFyIHQ9dGhpcy5sZW5ndGg7ZT1+fmU7cj1yPT09dW5kZWZpbmVkP3Q6fn5yO2lmKGU8MCl7ZSs9dDtpZihlPDApZT0wfWVsc2UgaWYoZT50KXtlPXR9aWYocjwwKXtyKz10O2lmKHI8MClyPTB9ZWxzZSBpZihyPnQpe3I9dH1pZihyPGUpcj1lO3ZhciBmPXRoaXMuc3ViYXJyYXkoZSxyKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn07ZnVuY3Rpb24gY2hlY2tPZmZzZXQoZSxyLHQpe2lmKGUlMSE9PTB8fGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9mZnNldCBpcyBub3QgdWludFwiKTtpZihlK3I+dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uIHJlYWRVSW50TEUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXRoaXNbZV07dmFyIG49MTt2YXIgaT0wO3doaWxlKCsraTxyJiYobio9MjU2KSl7Zis9dGhpc1tlK2ldKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRT1mdW5jdGlvbiByZWFkVUludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpe2NoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCl9dmFyIGY9dGhpc1tlKy0tcl07dmFyIG49MTt3aGlsZShyPjAmJihuKj0yNTYpKXtmKz10aGlzW2UrLS1yXSpufXJldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OD1mdW5jdGlvbiByZWFkVUludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV19O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uIHJlYWRVSW50MTZMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXXx0aGlzW2UrMV08PDh9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFPWZ1bmN0aW9uIHJlYWRVSW50MTZCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXTw8OHx0aGlzW2UrMV19O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFPWZ1bmN0aW9uIHJlYWRVSW50MzJMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4odGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNikrdGhpc1tlKzNdKjE2Nzc3MjE2fTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbiByZWFkVUludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV0qMTY3NzcyMTYrKHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXSl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uIHJlYWRJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1uKj0xMjg7aWYoZj49bilmLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uIHJlYWRJbnRCRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9cjt2YXIgbj0xO3ZhciBpPXRoaXNbZSstLWZdO3doaWxlKGY+MCYmKG4qPTI1Nikpe2krPXRoaXNbZSstLWZdKm59bio9MTI4O2lmKGk+PW4paS09TWF0aC5wb3coMiw4KnIpO3JldHVybiBpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uIHJlYWRJbnQ4KGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDEsdGhpcy5sZW5ndGgpO2lmKCEodGhpc1tlXSYxMjgpKXJldHVybiB0aGlzW2VdO3JldHVybigyNTUtdGhpc1tlXSsxKSotMX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbiByZWFkSW50MTZMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTt2YXIgdD10aGlzW2VdfHRoaXNbZSsxXTw8ODtyZXR1cm4gdCYzMjc2OD90fDQyOTQ5MDE3NjA6dH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbiByZWFkSW50MTZCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTt2YXIgdD10aGlzW2UrMV18dGhpc1tlXTw8ODtyZXR1cm4gdCYzMjc2OD90fDQyOTQ5MDE3NjA6dH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbiByZWFkSW50MzJMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNnx0aGlzW2UrM108PDI0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uIHJlYWRJbnQzMkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDwyNHx0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM119O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24gcmVhZEZsb2F0TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSwyMyw0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbiByZWFkRmxvYXRCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSxmYWxzZSwyMyw0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24gcmVhZERvdWJsZUxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLHRydWUsNTIsOCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uIHJlYWREb3VibGVCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw4LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSxmYWxzZSw1Miw4KX07ZnVuY3Rpb24gY2hlY2tJbnQoZSxyLHQsZixuLGkpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7aWYocj5ufHxyPGkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEU9ZnVuY3Rpb24gd3JpdGVVSW50TEUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO3Q9dD4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0KS0xO2NoZWNrSW50KHRoaXMsZSxyLHQsbiwwKX12YXIgaT0xO3ZhciBvPTA7dGhpc1tyXT1lJjI1NTt3aGlsZSgrK288dCYmKGkqPTI1Nikpe3RoaXNbcitvXT1lL2kmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24gd3JpdGVVSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO3Q9dD4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0KS0xO2NoZWNrSW50KHRoaXMsZSxyLHQsbiwwKX12YXIgaT10LTE7dmFyIG89MTt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7dGhpc1tyK2ldPWUvbyYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uIHdyaXRlVUludDgoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwxLDI1NSwwKTt0aGlzW3JdPWUmMjU1O3JldHVybiByKzF9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24gd3JpdGVVSW50MTZCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsNjU1MzUsMCk7dGhpc1tyXT1lPj4+ODt0aGlzW3IrMV09ZSYyNTU7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlVUludDMyTEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyKzNdPWU+Pj4yNDt0aGlzW3IrMl09ZT4+PjE2O3RoaXNbcisxXT1lPj4+ODt0aGlzW3JdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRT1mdW5jdGlvbiB3cml0ZVVJbnQzMkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCw0Mjk0OTY3Mjk1LDApO3RoaXNbcl09ZT4+PjI0O3RoaXNbcisxXT1lPj4+MTY7dGhpc1tyKzJdPWU+Pj44O3RoaXNbciszXT1lJjI1NTtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24gd3JpdGVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0LTEpO2NoZWNrSW50KHRoaXMsZSxyLHQsbi0xLC1uKX12YXIgaT0wO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsraTx0JiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2ktMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRT1mdW5jdGlvbiB3cml0ZUludEJFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPXQtMTt2YXIgbz0xO3ZhciB1PTA7dGhpc1tyK2ldPWUmMjU1O3doaWxlKC0taT49MCYmKG8qPTI1Nikpe2lmKGU8MCYmdT09PTAmJnRoaXNbcitpKzFdIT09MCl7dT0xfXRoaXNbcitpXT0oZS9vPj4wKS11JjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbiB3cml0ZUludDgoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwxLDEyNywtMTI4KTtpZihlPDApZT0yNTUrZSsxO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU9ZnVuY3Rpb24gd3JpdGVJbnQxNkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uIHdyaXRlSW50MTZCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsMzI3NjcsLTMyNzY4KTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbiB3cml0ZUludDMyTEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzNdPWU+Pj4yNDtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbiB3cml0ZUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpO2lmKGU8MCllPTQyOTQ5NjcyOTUrZSsxO3RoaXNbcl09ZT4+PjI0O3RoaXNbcisxXT1lPj4+MTY7dGhpc1tyKzJdPWU+Pj44O3RoaXNbciszXT1lJjI1NTtyZXR1cm4gcis0fTtmdW5jdGlvbiBjaGVja0lFRUU3NTQoZSxyLHQsZixuLGkpe2lmKHQrZj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZih0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gd3JpdGVGbG9hdChlLHIsdCxmLGkpe3I9K3I7dD10Pj4+MDtpZighaSl7Y2hlY2tJRUVFNzU0KGUscix0LDQsMzQwMjgyMzQ2NjM4NTI4ODZlMjIsLTM0MDI4MjM0NjYzODUyODg2ZTIyKX1uLndyaXRlKGUscix0LGYsMjMsNCk7cmV0dXJuIHQrNH1CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbiB3cml0ZUZsb2F0TEUoZSxyLHQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uIHdyaXRlRmxvYXRCRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsZmFsc2UsdCl9O2Z1bmN0aW9uIHdyaXRlRG91YmxlKGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsOCwxNzk3NjkzMTM0ODYyMzE1N2UyOTIsLTE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mil9bi53cml0ZShlLHIsdCxmLDUyLDgpO3JldHVybiB0Kzh9QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uIHdyaXRlRG91YmxlTEUoZSxyLHQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLGUscix0cnVlLHQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24gd3JpdGVEb3VibGVCRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLGZhbHNlLHQpfTtCdWZmZXIucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24gY29weShlLHIsdCxmKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXJcIik7aWYoIXQpdD0wO2lmKCFmJiZmIT09MClmPXRoaXMubGVuZ3RoO2lmKHI+PWUubGVuZ3RoKXI9ZS5sZW5ndGg7aWYoIXIpcj0wO2lmKGY+MCYmZjx0KWY9dDtpZihmPT09dClyZXR1cm4gMDtpZihlLmxlbmd0aD09PTB8fHRoaXMubGVuZ3RoPT09MClyZXR1cm4gMDtpZihyPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKX1pZih0PDB8fHQ+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKGY8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO2lmKGY+dGhpcy5sZW5ndGgpZj10aGlzLmxlbmd0aDtpZihlLmxlbmd0aC1yPGYtdCl7Zj1lLmxlbmd0aC1yK3R9dmFyIG49Zi10O2lmKHRoaXM9PT1lJiZ0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbj09PVwiZnVuY3Rpb25cIil7dGhpcy5jb3B5V2l0aGluKHIsdCxmKX1lbHNlIGlmKHRoaXM9PT1lJiZ0PHImJnI8Zil7Zm9yKHZhciBpPW4tMTtpPj0wOy0taSl7ZVtpK3JdPXRoaXNbaSt0XX19ZWxzZXtVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChlLHRoaXMuc3ViYXJyYXkodCxmKSxyKX1yZXR1cm4gbn07QnVmZmVyLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uIGZpbGwoZSxyLHQsZil7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe2Y9cjtyPTA7dD10aGlzLmxlbmd0aH1lbHNlIGlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7Zj10O3Q9dGhpcy5sZW5ndGh9aWYoZiE9PXVuZGVmaW5lZCYmdHlwZW9mIGYhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKX1pZih0eXBlb2YgZj09PVwic3RyaW5nXCImJiFCdWZmZXIuaXNFbmNvZGluZyhmKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpfWlmKGUubGVuZ3RoPT09MSl7dmFyIG49ZS5jaGFyQ29kZUF0KDApO2lmKGY9PT1cInV0ZjhcIiYmbjwxMjh8fGY9PT1cImxhdGluMVwiKXtlPW59fX1lbHNlIGlmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7ZT1lJjI1NX1lbHNlIGlmKHR5cGVvZiBlPT09XCJib29sZWFuXCIpe2U9TnVtYmVyKGUpfWlmKHI8MHx8dGhpcy5sZW5ndGg8cnx8dGhpcy5sZW5ndGg8dCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYodDw9cil7cmV0dXJuIHRoaXN9cj1yPj4+MDt0PXQ9PT11bmRlZmluZWQ/dGhpcy5sZW5ndGg6dD4+PjA7aWYoIWUpZT0wO3ZhciBpO2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7Zm9yKGk9cjtpPHQ7KytpKXt0aGlzW2ldPWV9fWVsc2V7dmFyIG89QnVmZmVyLmlzQnVmZmVyKGUpP2U6QnVmZmVyLmZyb20oZSxmKTt2YXIgdT1vLmxlbmd0aDtpZih1PT09MCl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKX1mb3IoaT0wO2k8dC1yOysraSl7dGhpc1tpK3JdPW9baSV1XX19cmV0dXJuIHRoaXN9O3ZhciBhPS9bXisvMC05QS1aYS16LV9dL2c7ZnVuY3Rpb24gYmFzZTY0Y2xlYW4oZSl7ZT1lLnNwbGl0KFwiPVwiKVswXTtlPWUudHJpbSgpLnJlcGxhY2UoYSxcIlwiKTtpZihlLmxlbmd0aDwyKXJldHVyblwiXCI7d2hpbGUoZS5sZW5ndGglNCE9PTApe2U9ZStcIj1cIn1yZXR1cm4gZX1mdW5jdGlvbiB1dGY4VG9CeXRlcyhlLHIpe3I9cnx8SW5maW5pdHk7dmFyIHQ7dmFyIGY9ZS5sZW5ndGg7dmFyIG49bnVsbDt2YXIgaT1bXTtmb3IodmFyIG89MDtvPGY7KytvKXt0PWUuY2hhckNvZGVBdChvKTtpZih0PjU1Mjk1JiZ0PDU3MzQ0KXtpZighbil7aWYodD41NjMxOSl7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9ZWxzZSBpZihvKzE9PT1mKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1uPXQ7Y29udGludWV9aWYodDw1NjMyMCl7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7bj10O2NvbnRpbnVlfXQ9KG4tNTUyOTY8PDEwfHQtNTYzMjApKzY1NTM2fWVsc2UgaWYobil7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSl9bj1udWxsO2lmKHQ8MTI4KXtpZigoci09MSk8MClicmVhaztpLnB1c2godCl9ZWxzZSBpZih0PDIwNDgpe2lmKChyLT0yKTwwKWJyZWFrO2kucHVzaCh0Pj42fDE5Mix0JjYzfDEyOCl9ZWxzZSBpZih0PDY1NTM2KXtpZigoci09Myk8MClicmVhaztpLnB1c2godD4+MTJ8MjI0LHQ+PjYmNjN8MTI4LHQmNjN8MTI4KX1lbHNlIGlmKHQ8MTExNDExMil7aWYoKHItPTQpPDApYnJlYWs7aS5wdXNoKHQ+PjE4fDI0MCx0Pj4xMiY2M3wxMjgsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpfX1yZXR1cm4gaX1mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoZSl7dmFyIHI9W107Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDsrK3Qpe3IucHVzaChlLmNoYXJDb2RlQXQodCkmMjU1KX1yZXR1cm4gcn1mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhlLHIpe3ZhciB0LGYsbjt2YXIgaT1bXTtmb3IodmFyIG89MDtvPGUubGVuZ3RoOysrbyl7aWYoKHItPTIpPDApYnJlYWs7dD1lLmNoYXJDb2RlQXQobyk7Zj10Pj44O249dCUyNTY7aS5wdXNoKG4pO2kucHVzaChmKX1yZXR1cm4gaX1mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKGUpe3JldHVybiBmLnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKGUpKX1mdW5jdGlvbiBibGl0QnVmZmVyKGUscix0LGYpe2Zvcih2YXIgbj0wO248ZjsrK24pe2lmKG4rdD49ci5sZW5ndGh8fG4+PWUubGVuZ3RoKWJyZWFrO3Jbbit0XT1lW25dfXJldHVybiBufWZ1bmN0aW9uIGlzSW5zdGFuY2UoZSxyKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHJ8fGUhPW51bGwmJmUuY29uc3RydWN0b3IhPW51bGwmJmUuY29uc3RydWN0b3IubmFtZSE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lPT09ci5uYW1lfWZ1bmN0aW9uIG51bWJlcklzTmFOKGUpe3JldHVybiBlIT09ZX12YXIgcz1mdW5jdGlvbigpe3ZhciBlPVwiMDEyMzQ1Njc4OWFiY2RlZlwiO3ZhciByPW5ldyBBcnJheSgyNTYpO2Zvcih2YXIgdD0wO3Q8MTY7Kyt0KXt2YXIgZj10KjE2O2Zvcih2YXIgbj0wO248MTY7KytuKXtyW2Yrbl09ZVt0XStlW25dfX1yZXR1cm4gcn0oKX0sNzgzOmZ1bmN0aW9uKGUscil7XG4vKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuci5yZWFkPWZ1bmN0aW9uKGUscix0LGYsbil7dmFyIGksbzt2YXIgdT1uKjgtZi0xO3ZhciBhPSgxPDx1KS0xO3ZhciBzPWE+PjE7dmFyIGg9LTc7dmFyIGM9dD9uLTE6MDt2YXIgbD10Py0xOjE7dmFyIHA9ZVtyK2NdO2MrPWw7aT1wJigxPDwtaCktMTtwPj49LWg7aCs9dTtmb3IoO2g+MDtpPWkqMjU2K2VbcitjXSxjKz1sLGgtPTgpe31vPWkmKDE8PC1oKS0xO2k+Pj0taDtoKz1mO2Zvcig7aD4wO289byoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fWlmKGk9PT0wKXtpPTEtc31lbHNlIGlmKGk9PT1hKXtyZXR1cm4gbz9OYU46KHA/LTE6MSkqSW5maW5pdHl9ZWxzZXtvPW8rTWF0aC5wb3coMixmKTtpPWktc31yZXR1cm4ocD8tMToxKSpvKk1hdGgucG93KDIsaS1mKX07ci53cml0ZT1mdW5jdGlvbihlLHIsdCxmLG4saSl7dmFyIG8sdSxhO3ZhciBzPWkqOC1uLTE7dmFyIGg9KDE8PHMpLTE7dmFyIGM9aD4+MTt2YXIgbD1uPT09MjM/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowO3ZhciBwPWY/MDppLTE7dmFyIHk9Zj8xOi0xO3ZhciBnPXI8MHx8cj09PTAmJjEvcjwwPzE6MDtyPU1hdGguYWJzKHIpO2lmKGlzTmFOKHIpfHxyPT09SW5maW5pdHkpe3U9aXNOYU4ocik/MTowO289aH1lbHNle289TWF0aC5mbG9vcihNYXRoLmxvZyhyKS9NYXRoLkxOMik7aWYociooYT1NYXRoLnBvdygyLC1vKSk8MSl7by0tO2EqPTJ9aWYobytjPj0xKXtyKz1sL2F9ZWxzZXtyKz1sKk1hdGgucG93KDIsMS1jKX1pZihyKmE+PTIpe28rKzthLz0yfWlmKG8rYz49aCl7dT0wO289aH1lbHNlIGlmKG8rYz49MSl7dT0ociphLTEpKk1hdGgucG93KDIsbik7bz1vK2N9ZWxzZXt1PXIqTWF0aC5wb3coMixjLTEpKk1hdGgucG93KDIsbik7bz0wfX1mb3IoO24+PTg7ZVt0K3BdPXUmMjU1LHArPXksdS89MjU2LG4tPTgpe31vPW88PG58dTtzKz1uO2Zvcig7cz4wO2VbdCtwXT1vJjI1NSxwKz15LG8vPTI1NixzLT04KXt9ZVt0K3AteV18PWcqMTI4fX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIGY9clt0XTtpZihmIT09dW5kZWZpbmVkKXtyZXR1cm4gZi5leHBvcnRzfXZhciBuPXJbdF09e2V4cG9ydHM6e319O3ZhciBpPXRydWU7dHJ5e2VbdF0obixuLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7aT1mYWxzZX1maW5hbGx5e2lmKGkpZGVsZXRlIHJbdF19cmV0dXJuIG4uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXyg3Mik7bW9kdWxlLmV4cG9ydHM9dH0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/micromatch/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/micromatch/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var e={333:(e,t,r)=>{const n=r(137);const u=r(179);const s=r(13);const o=r(719);const braces=(e,t={})=>{let r=[];if(Array.isArray(e)){for(let n of e){let e=braces.create(n,t);if(Array.isArray(e)){r.push(...e)}else{r.push(e)}}}else{r=[].concat(braces.create(e,t))}if(t&&t.expand===true&&t.nodupes===true){r=[...new Set(r)]}return r};braces.parse=(e,t={})=>o(e,t);braces.stringify=(e,t={})=>{if(typeof e===\"string\"){return n(braces.parse(e,t),t)}return n(e,t)};braces.compile=(e,t={})=>{if(typeof e===\"string\"){e=braces.parse(e,t)}return u(e,t)};braces.expand=(e,t={})=>{if(typeof e===\"string\"){e=braces.parse(e,t)}let r=s(e,t);if(t.noempty===true){r=r.filter(Boolean)}if(t.nodupes===true){r=[...new Set(r)]}return r};braces.create=(e,t={})=>{if(e===\"\"||e.length<3){return[e]}return t.expand!==true?braces.compile(e,t):braces.expand(e,t)};e.exports=braces},179:(e,t,r)=>{const n=r(783);const u=r(617);const compile=(e,t={})=>{let walk=(e,r={})=>{let s=u.isInvalidBrace(r);let o=e.invalid===true&&t.escapeInvalid===true;let i=s===true||o===true;let a=t.escapeInvalid===true?\"\\\\\":\"\";let l=\"\";if(e.isOpen===true){return a+e.value}if(e.isClose===true){return a+e.value}if(e.type===\"open\"){return i?a+e.value:\"(\"}if(e.type===\"close\"){return i?a+e.value:\")\"}if(e.type===\"comma\"){return e.prev.type===\"comma\"?\"\":i?e.value:\"|\"}if(e.value){return e.value}if(e.nodes&&e.ranges>0){let r=u.reduce(e.nodes);let s=n(...r,{...t,wrap:false,toRegex:true});if(s.length!==0){return r.length>1&&s.length>1?`(${s})`:s}}if(e.nodes){for(let t of e.nodes){l+=walk(t,e)}}return l};return walk(e)};e.exports=compile},457:e=>{e.exports={MAX_LENGTH:1024*64,CHAR_0:\"0\",CHAR_9:\"9\",CHAR_UPPERCASE_A:\"A\",CHAR_LOWERCASE_A:\"a\",CHAR_UPPERCASE_Z:\"Z\",CHAR_LOWERCASE_Z:\"z\",CHAR_LEFT_PARENTHESES:\"(\",CHAR_RIGHT_PARENTHESES:\")\",CHAR_ASTERISK:\"*\",CHAR_AMPERSAND:\"&\",CHAR_AT:\"@\",CHAR_BACKSLASH:\"\\\\\",CHAR_BACKTICK:\"`\",CHAR_CARRIAGE_RETURN:\"\\r\",CHAR_CIRCUMFLEX_ACCENT:\"^\",CHAR_COLON:\":\",CHAR_COMMA:\",\",CHAR_DOLLAR:\"$\",CHAR_DOT:\".\",CHAR_DOUBLE_QUOTE:'\"',CHAR_EQUAL:\"=\",CHAR_EXCLAMATION_MARK:\"!\",CHAR_FORM_FEED:\"\\f\",CHAR_FORWARD_SLASH:\"/\",CHAR_HASH:\"#\",CHAR_HYPHEN_MINUS:\"-\",CHAR_LEFT_ANGLE_BRACKET:\"<\",CHAR_LEFT_CURLY_BRACE:\"{\",CHAR_LEFT_SQUARE_BRACKET:\"[\",CHAR_LINE_FEED:\"\\n\",CHAR_NO_BREAK_SPACE:\" \",CHAR_PERCENT:\"%\",CHAR_PLUS:\"+\",CHAR_QUESTION_MARK:\"?\",CHAR_RIGHT_ANGLE_BRACKET:\">\",CHAR_RIGHT_CURLY_BRACE:\"}\",CHAR_RIGHT_SQUARE_BRACKET:\"]\",CHAR_SEMICOLON:\";\",CHAR_SINGLE_QUOTE:\"'\",CHAR_SPACE:\" \",CHAR_TAB:\"\\t\",CHAR_UNDERSCORE:\"_\",CHAR_VERTICAL_LINE:\"|\",CHAR_ZERO_WIDTH_NOBREAK_SPACE:\"\\ufeff\"}},13:(e,t,r)=>{const n=r(783);const u=r(137);const s=r(617);const append=(e=\"\",t=\"\",r=false)=>{let n=[];e=[].concat(e);t=[].concat(t);if(!t.length)return e;if(!e.length){return r?s.flatten(t).map((e=>`{${e}}`)):t}for(let u of e){if(Array.isArray(u)){for(let e of u){n.push(append(e,t,r))}}else{for(let e of t){if(r===true&&typeof e===\"string\")e=`{${e}}`;n.push(Array.isArray(e)?append(u,e,r):u+e)}}}return s.flatten(n)};const expand=(e,t={})=>{let r=t.rangeLimit===void 0?1e3:t.rangeLimit;let walk=(e,o={})=>{e.queue=[];let i=o;let a=o.queue;while(i.type!==\"brace\"&&i.type!==\"root\"&&i.parent){i=i.parent;a=i.queue}if(e.invalid||e.dollar){a.push(append(a.pop(),u(e,t)));return}if(e.type===\"brace\"&&e.invalid!==true&&e.nodes.length===2){a.push(append(a.pop(),[\"{}\"]));return}if(e.nodes&&e.ranges>0){let o=s.reduce(e.nodes);if(s.exceedsLimit(...o,t.step,r)){throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\")}let i=n(...o,t);if(i.length===0){i=u(e,t)}a.push(append(a.pop(),i));e.nodes=[];return}let l=s.encloseBrace(e);let c=e.queue;let p=e;while(p.type!==\"brace\"&&p.type!==\"root\"&&p.parent){p=p.parent;c=p.queue}for(let t=0;t<e.nodes.length;t++){let r=e.nodes[t];if(r.type===\"comma\"&&e.type===\"brace\"){if(t===1)c.push(\"\");c.push(\"\");continue}if(r.type===\"close\"){a.push(append(a.pop(),c,l));continue}if(r.value&&r.type!==\"open\"){c.push(append(c.pop(),r.value));continue}if(r.nodes){walk(r,e)}}return c};return s.flatten(walk(e))};e.exports=expand},719:(e,t,r)=>{const n=r(137);const{MAX_LENGTH:u,CHAR_BACKSLASH:s,CHAR_BACKTICK:o,CHAR_COMMA:i,CHAR_DOT:a,CHAR_LEFT_PARENTHESES:l,CHAR_RIGHT_PARENTHESES:c,CHAR_LEFT_CURLY_BRACE:p,CHAR_RIGHT_CURLY_BRACE:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_RIGHT_SQUARE_BRACKET:R,CHAR_DOUBLE_QUOTE:_,CHAR_SINGLE_QUOTE:h,CHAR_NO_BREAK_SPACE:g,CHAR_ZERO_WIDTH_NOBREAK_SPACE:E}=r(457);const parse=(e,t={})=>{if(typeof e!==\"string\"){throw new TypeError(\"Expected a string\")}let r=t||{};let C=typeof r.maxLength===\"number\"?Math.min(u,r.maxLength):u;if(e.length>C){throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${C})`)}let y={type:\"root\",input:e,nodes:[]};let d=[y];let x=y;let b=y;let S=0;let H=e.length;let v=0;let $=0;let m;let T={};const advance=()=>e[v++];const push=e=>{if(e.type===\"text\"&&b.type===\"dot\"){b.type=\"text\"}if(b&&b.type===\"text\"&&e.type===\"text\"){b.value+=e.value;return}x.nodes.push(e);e.parent=x;e.prev=b;b=e;return e};push({type:\"bos\"});while(v<H){x=d[d.length-1];m=advance();if(m===E||m===g){continue}if(m===s){push({type:\"text\",value:(t.keepEscaping?m:\"\")+advance()});continue}if(m===R){push({type:\"text\",value:\"\\\\\"+m});continue}if(m===A){S++;let e=true;let t;while(v<H&&(t=advance())){m+=t;if(t===A){S++;continue}if(t===s){m+=advance();continue}if(t===R){S--;if(S===0){break}}}push({type:\"text\",value:m});continue}if(m===l){x=push({type:\"paren\",nodes:[]});d.push(x);push({type:\"text\",value:m});continue}if(m===c){if(x.type!==\"paren\"){push({type:\"text\",value:m});continue}x=d.pop();push({type:\"text\",value:m});x=d[d.length-1];continue}if(m===_||m===h||m===o){let e=m;let r;if(t.keepQuotes!==true){m=\"\"}while(v<H&&(r=advance())){if(r===s){m+=r+advance();continue}if(r===e){if(t.keepQuotes===true)m+=r;break}m+=r}push({type:\"text\",value:m});continue}if(m===p){$++;let e=b.value&&b.value.slice(-1)===\"$\"||x.dollar===true;let t={type:\"brace\",open:true,close:false,dollar:e,depth:$,commas:0,ranges:0,nodes:[]};x=push(t);d.push(x);push({type:\"open\",value:m});continue}if(m===f){if(x.type!==\"brace\"){push({type:\"text\",value:m});continue}let e=\"close\";x=d.pop();x.close=true;push({type:e,value:m});$--;x=d[d.length-1];continue}if(m===i&&$>0){if(x.ranges>0){x.ranges=0;let e=x.nodes.shift();x.nodes=[e,{type:\"text\",value:n(x)}]}push({type:\"comma\",value:m});x.commas++;continue}if(m===a&&$>0&&x.commas===0){let e=x.nodes;if($===0||e.length===0){push({type:\"text\",value:m});continue}if(b.type===\"dot\"){x.range=[];b.value+=m;b.type=\"range\";if(x.nodes.length!==3&&x.nodes.length!==5){x.invalid=true;x.ranges=0;b.type=\"text\";continue}x.ranges++;x.args=[];continue}if(b.type===\"range\"){e.pop();let t=e[e.length-1];t.value+=b.value+m;b=t;x.ranges--;continue}push({type:\"dot\",value:m});continue}push({type:\"text\",value:m})}do{x=d.pop();if(x.type!==\"root\"){x.nodes.forEach((e=>{if(!e.nodes){if(e.type===\"open\")e.isOpen=true;if(e.type===\"close\")e.isClose=true;if(!e.nodes)e.type=\"text\";e.invalid=true}}));let e=d[d.length-1];let t=e.nodes.indexOf(x);e.nodes.splice(t,1,...x.nodes)}}while(d.length>0);push({type:\"eos\"});return y};e.exports=parse},137:(e,t,r)=>{const n=r(617);e.exports=(e,t={})=>{let stringify=(e,r={})=>{let u=t.escapeInvalid&&n.isInvalidBrace(r);let s=e.invalid===true&&t.escapeInvalid===true;let o=\"\";if(e.value){if((u||s)&&n.isOpenOrClose(e)){return\"\\\\\"+e.value}return e.value}if(e.value){return e.value}if(e.nodes){for(let t of e.nodes){o+=stringify(t)}}return o};return stringify(e)}},617:(e,t)=>{t.isInteger=e=>{if(typeof e===\"number\"){return Number.isInteger(e)}if(typeof e===\"string\"&&e.trim()!==\"\"){return Number.isInteger(Number(e))}return false};t.find=(e,t)=>e.nodes.find((e=>e.type===t));t.exceedsLimit=(e,r,n=1,u)=>{if(u===false)return false;if(!t.isInteger(e)||!t.isInteger(r))return false;return(Number(r)-Number(e))/Number(n)>=u};t.escapeNode=(e,t=0,r)=>{let n=e.nodes[t];if(!n)return;if(r&&n.type===r||n.type===\"open\"||n.type===\"close\"){if(n.escaped!==true){n.value=\"\\\\\"+n.value;n.escaped=true}}};t.encloseBrace=e=>{if(e.type!==\"brace\")return false;if(e.commas>>0+e.ranges>>0===0){e.invalid=true;return true}return false};t.isInvalidBrace=e=>{if(e.type!==\"brace\")return false;if(e.invalid===true||e.dollar)return true;if(e.commas>>0+e.ranges>>0===0){e.invalid=true;return true}if(e.open!==true||e.close!==true){e.invalid=true;return true}return false};t.isOpenOrClose=e=>{if(e.type===\"open\"||e.type===\"close\"){return true}return e.open===true||e.close===true};t.reduce=e=>e.reduce(((e,t)=>{if(t.type===\"text\")e.push(t.value);if(t.type===\"range\")t.type=\"text\";return e}),[]);t.flatten=(...e)=>{const t=[];const flat=e=>{for(let r=0;r<e.length;r++){let n=e[r];Array.isArray(n)?flat(n,t):n!==void 0&&t.push(n)}return t};flat(e);return t}},783:(e,t,r)=>{\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\nconst n=r(837);const u=r(492);const isObject=e=>e!==null&&typeof e===\"object\"&&!Array.isArray(e);const transform=e=>t=>e===true?Number(t):String(t);const isValidValue=e=>typeof e===\"number\"||typeof e===\"string\"&&e!==\"\";const isNumber=e=>Number.isInteger(+e);const zeros=e=>{let t=`${e}`;let r=-1;if(t[0]===\"-\")t=t.slice(1);if(t===\"0\")return false;while(t[++r]===\"0\");return r>0};const stringify=(e,t,r)=>{if(typeof e===\"string\"||typeof t===\"string\"){return true}return r.stringify===true};const pad=(e,t,r)=>{if(t>0){let r=e[0]===\"-\"?\"-\":\"\";if(r)e=e.slice(1);e=r+e.padStart(r?t-1:t,\"0\")}if(r===false){return String(e)}return e};const toMaxLen=(e,t)=>{let r=e[0]===\"-\"?\"-\":\"\";if(r){e=e.slice(1);t--}while(e.length<t)e=\"0\"+e;return r?\"-\"+e:e};const toSequence=(e,t)=>{e.negatives.sort(((e,t)=>e<t?-1:e>t?1:0));e.positives.sort(((e,t)=>e<t?-1:e>t?1:0));let r=t.capture?\"\":\"?:\";let n=\"\";let u=\"\";let s;if(e.positives.length){n=e.positives.join(\"|\")}if(e.negatives.length){u=`-(${r}${e.negatives.join(\"|\")})`}if(n&&u){s=`${n}|${u}`}else{s=n||u}if(t.wrap){return`(${r}${s})`}return s};const toRange=(e,t,r,n)=>{if(r){return u(e,t,{wrap:false,...n})}let s=String.fromCharCode(e);if(e===t)return s;let o=String.fromCharCode(t);return`[${s}-${o}]`};const toRegex=(e,t,r)=>{if(Array.isArray(e)){let t=r.wrap===true;let n=r.capture?\"\":\"?:\";return t?`(${n}${e.join(\"|\")})`:e.join(\"|\")}return u(e,t,r)};const rangeError=(...e)=>new RangeError(\"Invalid range arguments: \"+n.inspect(...e));const invalidRange=(e,t,r)=>{if(r.strictRanges===true)throw rangeError([e,t]);return[]};const invalidStep=(e,t)=>{if(t.strictRanges===true){throw new TypeError(`Expected step \"${e}\" to be a number`)}return[]};const fillNumbers=(e,t,r=1,n={})=>{let u=Number(e);let s=Number(t);if(!Number.isInteger(u)||!Number.isInteger(s)){if(n.strictRanges===true)throw rangeError([e,t]);return[]}if(u===0)u=0;if(s===0)s=0;let o=u>s;let i=String(e);let a=String(t);let l=String(r);r=Math.max(Math.abs(r),1);let c=zeros(i)||zeros(a)||zeros(l);let p=c?Math.max(i.length,a.length,l.length):0;let f=c===false&&stringify(e,t,n)===false;let A=n.transform||transform(f);if(n.toRegex&&r===1){return toRange(toMaxLen(e,p),toMaxLen(t,p),true,n)}let R={negatives:[],positives:[]};let push=e=>R[e<0?\"negatives\":\"positives\"].push(Math.abs(e));let _=[];let h=0;while(o?u>=s:u<=s){if(n.toRegex===true&&r>1){push(u)}else{_.push(pad(A(u,h),p,f))}u=o?u-r:u+r;h++}if(n.toRegex===true){return r>1?toSequence(R,n):toRegex(_,null,{wrap:false,...n})}return _};const fillLetters=(e,t,r=1,n={})=>{if(!isNumber(e)&&e.length>1||!isNumber(t)&&t.length>1){return invalidRange(e,t,n)}let u=n.transform||(e=>String.fromCharCode(e));let s=`${e}`.charCodeAt(0);let o=`${t}`.charCodeAt(0);let i=s>o;let a=Math.min(s,o);let l=Math.max(s,o);if(n.toRegex&&r===1){return toRange(a,l,false,n)}let c=[];let p=0;while(i?s>=o:s<=o){c.push(u(s,p));s=i?s-r:s+r;p++}if(n.toRegex===true){return toRegex(c,null,{wrap:false,options:n})}return c};const fill=(e,t,r,n={})=>{if(t==null&&isValidValue(e)){return[e]}if(!isValidValue(e)||!isValidValue(t)){return invalidRange(e,t,n)}if(typeof r===\"function\"){return fill(e,t,1,{transform:r})}if(isObject(r)){return fill(e,t,0,r)}let u={...n};if(u.capture===true)u.wrap=true;r=r||u.step||1;if(!isNumber(r)){if(r!=null&&!isObject(r))return invalidStep(r,u);return fill(e,t,1,r)}if(isNumber(e)&&isNumber(t)){return fillNumbers(e,t,r,u)}return fillLetters(e,t,Math.max(Math.abs(r),1),u)};e.exports=fill},357:e=>{\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\ne.exports=function(e){if(typeof e===\"number\"){return e-e===0}if(typeof e===\"string\"&&e.trim()!==\"\"){return Number.isFinite?Number.isFinite(+e):isFinite(+e)}return false}},971:(e,t,r)=>{const n=r(837);const u=r(333);const s=r(251);const o=r(513);const isEmptyString=e=>e===\"\"||e===\"./\";const micromatch=(e,t,r)=>{t=[].concat(t);e=[].concat(e);let n=new Set;let u=new Set;let o=new Set;let i=0;let onResult=e=>{o.add(e.output);if(r&&r.onResult){r.onResult(e)}};for(let o=0;o<t.length;o++){let a=s(String(t[o]),{...r,onResult:onResult},true);let l=a.state.negated||a.state.negatedExtglob;if(l)i++;for(let t of e){let e=a(t,true);let r=l?!e.isMatch:e.isMatch;if(!r)continue;if(l){n.add(e.output)}else{n.delete(e.output);u.add(e.output)}}}let a=i===t.length?[...o]:[...u];let l=a.filter((e=>!n.has(e)));if(r&&l.length===0){if(r.failglob===true){throw new Error(`No matches found for \"${t.join(\", \")}\"`)}if(r.nonull===true||r.nullglob===true){return r.unescape?t.map((e=>e.replace(/\\\\/g,\"\"))):t}}return l};micromatch.match=micromatch;micromatch.matcher=(e,t)=>s(e,t);micromatch.isMatch=(e,t,r)=>s(t,r)(e);micromatch.any=micromatch.isMatch;micromatch.not=(e,t,r={})=>{t=[].concat(t).map(String);let n=new Set;let u=[];let onResult=e=>{if(r.onResult)r.onResult(e);u.push(e.output)};let s=micromatch(e,t,{...r,onResult:onResult});for(let e of u){if(!s.includes(e)){n.add(e)}}return[...n]};micromatch.contains=(e,t,r)=>{if(typeof e!==\"string\"){throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`)}if(Array.isArray(t)){return t.some((t=>micromatch.contains(e,t,r)))}if(typeof t===\"string\"){if(isEmptyString(e)||isEmptyString(t)){return false}if(e.includes(t)||e.startsWith(\"./\")&&e.slice(2).includes(t)){return true}}return micromatch.isMatch(e,t,{...r,contains:true})};micromatch.matchKeys=(e,t,r)=>{if(!o.isObject(e)){throw new TypeError(\"Expected the first argument to be an object\")}let n=micromatch(Object.keys(e),t,r);let u={};for(let t of n)u[t]=e[t];return u};micromatch.some=(e,t,r)=>{let n=[].concat(e);for(let e of[].concat(t)){let t=s(String(e),r);if(n.some((e=>t(e)))){return true}}return false};micromatch.every=(e,t,r)=>{let n=[].concat(e);for(let e of[].concat(t)){let t=s(String(e),r);if(!n.every((e=>t(e)))){return false}}return true};micromatch.all=(e,t,r)=>{if(typeof e!==\"string\"){throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`)}return[].concat(t).every((t=>s(t,r)(e)))};micromatch.capture=(e,t,r)=>{let n=o.isWindows(r);let u=s.makeRe(String(e),{...r,capture:true});let i=u.exec(n?o.toPosixSlashes(t):t);if(i){return i.slice(1).map((e=>e===void 0?\"\":e))}};micromatch.makeRe=(...e)=>s.makeRe(...e);micromatch.scan=(...e)=>s.scan(...e);micromatch.parse=(e,t)=>{let r=[];for(let n of[].concat(e||[])){for(let e of u(String(n),t)){r.push(s.parse(e,t))}}return r};micromatch.braces=(e,t)=>{if(typeof e!==\"string\")throw new TypeError(\"Expected a string\");if(t&&t.nobrace===true||!/\\{.*\\}/.test(e)){return[e]}return u(e,t)};micromatch.braceExpand=(e,t)=>{if(typeof e!==\"string\")throw new TypeError(\"Expected a string\");return micromatch.braces(e,{...t,expand:true})};e.exports=micromatch},251:(e,t,r)=>{e.exports=r(683)},356:(e,t,r)=>{const n=r(17);const u=\"\\\\\\\\/\";const s=`[^${u}]`;const o=\"\\\\.\";const i=\"\\\\+\";const a=\"\\\\?\";const l=\"\\\\/\";const c=\"(?=.)\";const p=\"[^/]\";const f=`(?:${l}|$)`;const A=`(?:^|${l})`;const R=`${o}{1,2}${f}`;const _=`(?!${o})`;const h=`(?!${A}${R})`;const g=`(?!${o}{0,1}${f})`;const E=`(?!${R})`;const C=`[^.${l}]`;const y=`${p}*?`;const d={DOT_LITERAL:o,PLUS_LITERAL:i,QMARK_LITERAL:a,SLASH_LITERAL:l,ONE_CHAR:c,QMARK:p,END_ANCHOR:f,DOTS_SLASH:R,NO_DOT:_,NO_DOTS:h,NO_DOT_SLASH:g,NO_DOTS_SLASH:E,QMARK_NO_DOT:C,STAR:y,START_ANCHOR:A};const x={...d,SLASH_LITERAL:`[${u}]`,QMARK:s,STAR:`${s}*?`,DOTS_SLASH:`${o}{1,2}(?:[${u}]|$)`,NO_DOT:`(?!${o})`,NO_DOTS:`(?!(?:^|[${u}])${o}{1,2}(?:[${u}]|$))`,NO_DOT_SLASH:`(?!${o}{0,1}(?:[${u}]|$))`,NO_DOTS_SLASH:`(?!${o}{1,2}(?:[${u}]|$))`,QMARK_NO_DOT:`[^.${u}]`,START_ANCHOR:`(?:^|[${u}])`,END_ANCHOR:`(?:[${u}]|$)`};const b={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};e.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:b,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,SEP:n.sep,extglobChars(e){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${e.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(e){return e===true?x:d}}},754:(e,t,r)=>{const n=r(356);const u=r(513);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:o,REGEX_NON_SPECIAL_CHARS:i,REGEX_SPECIAL_CHARS_BACKREF:a,REPLACEMENTS:l}=n;const expandRange=(e,t)=>{if(typeof t.expandRange===\"function\"){return t.expandRange(...e,t)}e.sort();const r=`[${e.join(\"-\")}]`;try{new RegExp(r)}catch(t){return e.map((e=>u.escapeRegex(e))).join(\"..\")}return r};const syntaxError=(e,t)=>`Missing ${e}: \"${t}\" - use \"\\\\\\\\${t}\" to match literal characters`;const parse=(e,t)=>{if(typeof e!==\"string\"){throw new TypeError(\"Expected a string\")}e=l[e]||e;const r={...t};const c=typeof r.maxLength===\"number\"?Math.min(s,r.maxLength):s;let p=e.length;if(p>c){throw new SyntaxError(`Input length: ${p}, exceeds maximum allowed length: ${c}`)}const f={type:\"bos\",value:\"\",output:r.prepend||\"\"};const A=[f];const R=r.capture?\"\":\"?:\";const _=u.isWindows(t);const h=n.globChars(_);const g=n.extglobChars(h);const{DOT_LITERAL:E,PLUS_LITERAL:C,SLASH_LITERAL:y,ONE_CHAR:d,DOTS_SLASH:x,NO_DOT:b,NO_DOT_SLASH:S,NO_DOTS_SLASH:H,QMARK:v,QMARK_NO_DOT:$,STAR:m,START_ANCHOR:T}=h;const globstar=e=>`(${R}(?:(?!${T}${e.dot?x:E}).)*?)`;const L=r.dot?\"\":b;const O=r.dot?v:$;let w=r.bash===true?globstar(r):m;if(r.capture){w=`(${w})`}if(typeof r.noext===\"boolean\"){r.noextglob=r.noext}const N={input:e,index:-1,start:0,dot:r.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};e=u.removePrefix(e,N);p=e.length;const k=[];const I=[];const M=[];let P=f;let B;const eos=()=>N.index===p-1;const G=N.peek=(t=1)=>e[N.index+t];const D=N.advance=()=>e[++N.index];const remaining=()=>e.slice(N.index+1);const consume=(e=\"\",t=0)=>{N.consumed+=e;N.index+=t};const append=e=>{N.output+=e.output!=null?e.output:e.value;consume(e.value)};const negate=()=>{let e=1;while(G()===\"!\"&&(G(2)!==\"(\"||G(3)===\"?\")){D();N.start++;e++}if(e%2===0){return false}N.negated=true;N.start++;return true};const increment=e=>{N[e]++;M.push(e)};const decrement=e=>{N[e]--;M.pop()};const push=e=>{if(P.type===\"globstar\"){const t=N.braces>0&&(e.type===\"comma\"||e.type===\"brace\");const r=e.extglob===true||k.length&&(e.type===\"pipe\"||e.type===\"paren\");if(e.type!==\"slash\"&&e.type!==\"paren\"&&!t&&!r){N.output=N.output.slice(0,-P.output.length);P.type=\"star\";P.value=\"*\";P.output=w;N.output+=P.output}}if(k.length&&e.type!==\"paren\"&&!g[e.value]){k[k.length-1].inner+=e.value}if(e.value||e.output)append(e);if(P&&P.type===\"text\"&&e.type===\"text\"){P.value+=e.value;P.output=(P.output||\"\")+e.value;return}e.prev=P;A.push(e);P=e};const extglobOpen=(e,t)=>{const n={...g[t],conditions:1,inner:\"\"};n.prev=P;n.parens=N.parens;n.output=N.output;const u=(r.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:e,value:t,output:N.output?\"\":d});push({type:\"paren\",extglob:true,value:D(),output:u});k.push(n)};const extglobClose=e=>{let t=e.close+(r.capture?\")\":\"\");if(e.type===\"negate\"){let n=w;if(e.inner&&e.inner.length>1&&e.inner.includes(\"/\")){n=globstar(r)}if(n!==w||eos()||/^\\)+$/.test(remaining())){t=e.close=`)$))${n}`}if(e.prev.type===\"bos\"){N.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:B,output:t});decrement(\"parens\")};if(r.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(e)){let n=false;let s=e.replace(a,((e,t,r,u,s,o)=>{if(u===\"\\\\\"){n=true;return e}if(u===\"?\"){if(t){return t+u+(s?v.repeat(s.length):\"\")}if(o===0){return O+(s?v.repeat(s.length):\"\")}return v.repeat(r.length)}if(u===\".\"){return E.repeat(r.length)}if(u===\"*\"){if(t){return t+u+(s?w:\"\")}return w}return t?e:`\\\\${e}`}));if(n===true){if(r.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(e=>e.length%2===0?\"\\\\\\\\\":e?\"\\\\\":\"\"))}}if(s===e&&r.contains===true){N.output=e;return N}N.output=u.wrapOutput(s,N,t);return N}while(!eos()){B=D();if(B===\"\\0\"){continue}if(B===\"\\\\\"){const e=G();if(e===\"/\"&&r.bash!==true){continue}if(e===\".\"||e===\";\"){continue}if(!e){B+=\"\\\\\";push({type:\"text\",value:B});continue}const t=/^\\\\+/.exec(remaining());let n=0;if(t&&t[0].length>2){n=t[0].length;N.index+=n;if(n%2!==0){B+=\"\\\\\"}}if(r.unescape===true){B=D()||\"\"}else{B+=D()||\"\"}if(N.brackets===0){push({type:\"text\",value:B});continue}}if(N.brackets>0&&(B!==\"]\"||P.value===\"[\"||P.value===\"[^\")){if(r.posix!==false&&B===\":\"){const e=P.value.slice(1);if(e.includes(\"[\")){P.posix=true;if(e.includes(\":\")){const e=P.value.lastIndexOf(\"[\");const t=P.value.slice(0,e);const r=P.value.slice(e+2);const n=o[r];if(n){P.value=t+n;N.backtrack=true;D();if(!f.output&&A.indexOf(P)===1){f.output=d}continue}}}}if(B===\"[\"&&G()!==\":\"||B===\"-\"&&G()===\"]\"){B=`\\\\${B}`}if(B===\"]\"&&(P.value===\"[\"||P.value===\"[^\")){B=`\\\\${B}`}if(r.posix===true&&B===\"!\"&&P.value===\"[\"){B=\"^\"}P.value+=B;append({value:B});continue}if(N.quotes===1&&B!=='\"'){B=u.escapeRegex(B);P.value+=B;append({value:B});continue}if(B==='\"'){N.quotes=N.quotes===1?0:1;if(r.keepQuotes===true){push({type:\"text\",value:B})}continue}if(B===\"(\"){increment(\"parens\");push({type:\"paren\",value:B});continue}if(B===\")\"){if(N.parens===0&&r.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const e=k[k.length-1];if(e&&N.parens===e.parens+1){extglobClose(k.pop());continue}push({type:\"paren\",value:B,output:N.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(B===\"[\"){if(r.nobracket===true||!remaining().includes(\"]\")){if(r.nobracket!==true&&r.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}B=`\\\\${B}`}else{increment(\"brackets\")}push({type:\"bracket\",value:B});continue}if(B===\"]\"){if(r.nobracket===true||P&&P.type===\"bracket\"&&P.value.length===1){push({type:\"text\",value:B,output:`\\\\${B}`});continue}if(N.brackets===0){if(r.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:B,output:`\\\\${B}`});continue}decrement(\"brackets\");const e=P.value.slice(1);if(P.posix!==true&&e[0]===\"^\"&&!e.includes(\"/\")){B=`/${B}`}P.value+=B;append({value:B});if(r.literalBrackets===false||u.hasRegexChars(e)){continue}const t=u.escapeRegex(P.value);N.output=N.output.slice(0,-P.value.length);if(r.literalBrackets===true){N.output+=t;P.value=t;continue}P.value=`(${R}${t}|${P.value})`;N.output+=P.value;continue}if(B===\"{\"&&r.nobrace!==true){increment(\"braces\");const e={type:\"brace\",value:B,output:\"(\",outputIndex:N.output.length,tokensIndex:N.tokens.length};I.push(e);push(e);continue}if(B===\"}\"){const e=I[I.length-1];if(r.nobrace===true||!e){push({type:\"text\",value:B,output:B});continue}let t=\")\";if(e.dots===true){const e=A.slice();const n=[];for(let t=e.length-1;t>=0;t--){A.pop();if(e[t].type===\"brace\"){break}if(e[t].type!==\"dots\"){n.unshift(e[t].value)}}t=expandRange(n,r);N.backtrack=true}if(e.comma!==true&&e.dots!==true){const r=N.output.slice(0,e.outputIndex);const n=N.tokens.slice(e.tokensIndex);e.value=e.output=\"\\\\{\";B=t=\"\\\\}\";N.output=r;for(const e of n){N.output+=e.output||e.value}}push({type:\"brace\",value:B,output:t});decrement(\"braces\");I.pop();continue}if(B===\"|\"){if(k.length>0){k[k.length-1].conditions++}push({type:\"text\",value:B});continue}if(B===\",\"){let e=B;const t=I[I.length-1];if(t&&M[M.length-1]===\"braces\"){t.comma=true;e=\"|\"}push({type:\"comma\",value:B,output:e});continue}if(B===\"/\"){if(P.type===\"dot\"&&N.index===N.start+1){N.start=N.index+1;N.consumed=\"\";N.output=\"\";A.pop();P=f;continue}push({type:\"slash\",value:B,output:y});continue}if(B===\".\"){if(N.braces>0&&P.type===\"dot\"){if(P.value===\".\")P.output=E;const e=I[I.length-1];P.type=\"dots\";P.output+=B;P.value+=B;e.dots=true;continue}if(N.braces+N.parens===0&&P.type!==\"bos\"&&P.type!==\"slash\"){push({type:\"text\",value:B,output:E});continue}push({type:\"dot\",value:B,output:E});continue}if(B===\"?\"){const e=P&&P.value===\"(\";if(!e&&r.noextglob!==true&&G()===\"(\"&&G(2)!==\"?\"){extglobOpen(\"qmark\",B);continue}if(P&&P.type===\"paren\"){const e=G();let t=B;if(e===\"<\"&&!u.supportsLookbehinds()){throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\")}if(P.value===\"(\"&&!/[!=<:]/.test(e)||e===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){t=`\\\\${B}`}push({type:\"text\",value:B,output:t});continue}if(r.dot!==true&&(P.type===\"slash\"||P.type===\"bos\")){push({type:\"qmark\",value:B,output:$});continue}push({type:\"qmark\",value:B,output:v});continue}if(B===\"!\"){if(r.noextglob!==true&&G()===\"(\"){if(G(2)!==\"?\"||!/[!=<:]/.test(G(3))){extglobOpen(\"negate\",B);continue}}if(r.nonegate!==true&&N.index===0){negate();continue}}if(B===\"+\"){if(r.noextglob!==true&&G()===\"(\"&&G(2)!==\"?\"){extglobOpen(\"plus\",B);continue}if(P&&P.value===\"(\"||r.regex===false){push({type:\"plus\",value:B,output:C});continue}if(P&&(P.type===\"bracket\"||P.type===\"paren\"||P.type===\"brace\")||N.parens>0){push({type:\"plus\",value:B});continue}push({type:\"plus\",value:C});continue}if(B===\"@\"){if(r.noextglob!==true&&G()===\"(\"&&G(2)!==\"?\"){push({type:\"at\",extglob:true,value:B,output:\"\"});continue}push({type:\"text\",value:B});continue}if(B!==\"*\"){if(B===\"$\"||B===\"^\"){B=`\\\\${B}`}const e=i.exec(remaining());if(e){B+=e[0];N.index+=e[0].length}push({type:\"text\",value:B});continue}if(P&&(P.type===\"globstar\"||P.star===true)){P.type=\"star\";P.star=true;P.value+=B;P.output=w;N.backtrack=true;N.globstar=true;consume(B);continue}let t=remaining();if(r.noextglob!==true&&/^\\([^?]/.test(t)){extglobOpen(\"star\",B);continue}if(P.type===\"star\"){if(r.noglobstar===true){consume(B);continue}const n=P.prev;const u=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const o=u&&(u.type===\"star\"||u.type===\"globstar\");if(r.bash===true&&(!s||t[0]&&t[0]!==\"/\")){push({type:\"star\",value:B,output:\"\"});continue}const i=N.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const a=k.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!i&&!a){push({type:\"star\",value:B,output:\"\"});continue}while(t.slice(0,3)===\"/**\"){const r=e[N.index+4];if(r&&r!==\"/\"){break}t=t.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){P.type=\"globstar\";P.value+=B;P.output=globstar(r);N.output=P.output;N.globstar=true;consume(B);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!o&&eos()){N.output=N.output.slice(0,-(n.output+P.output).length);n.output=`(?:${n.output}`;P.type=\"globstar\";P.output=globstar(r)+(r.strictSlashes?\")\":\"|$)\");P.value+=B;N.globstar=true;N.output+=n.output+P.output;consume(B);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&t[0]===\"/\"){const e=t[1]!==void 0?\"|$\":\"\";N.output=N.output.slice(0,-(n.output+P.output).length);n.output=`(?:${n.output}`;P.type=\"globstar\";P.output=`${globstar(r)}${y}|${y}${e})`;P.value+=B;N.output+=n.output+P.output;N.globstar=true;consume(B+D());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&t[0]===\"/\"){P.type=\"globstar\";P.value+=B;P.output=`(?:^|${y}|${globstar(r)}${y})`;N.output=P.output;N.globstar=true;consume(B+D());push({type:\"slash\",value:\"/\",output:\"\"});continue}N.output=N.output.slice(0,-P.output.length);P.type=\"globstar\";P.output=globstar(r);P.value+=B;N.output+=P.output;N.globstar=true;consume(B);continue}const n={type:\"star\",value:B,output:w};if(r.bash===true){n.output=\".*?\";if(P.type===\"bos\"||P.type===\"slash\"){n.output=L+n.output}push(n);continue}if(P&&(P.type===\"bracket\"||P.type===\"paren\")&&r.regex===true){n.output=B;push(n);continue}if(N.index===N.start||P.type===\"slash\"||P.type===\"dot\"){if(P.type===\"dot\"){N.output+=S;P.output+=S}else if(r.dot===true){N.output+=H;P.output+=H}else{N.output+=L;P.output+=L}if(G()!==\"*\"){N.output+=d;P.output+=d}}push(n)}while(N.brackets>0){if(r.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));N.output=u.escapeLast(N.output,\"[\");decrement(\"brackets\")}while(N.parens>0){if(r.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));N.output=u.escapeLast(N.output,\"(\");decrement(\"parens\")}while(N.braces>0){if(r.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));N.output=u.escapeLast(N.output,\"{\");decrement(\"braces\")}if(r.strictSlashes!==true&&(P.type===\"star\"||P.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${y}?`})}if(N.backtrack===true){N.output=\"\";for(const e of N.tokens){N.output+=e.output!=null?e.output:e.value;if(e.suffix){N.output+=e.suffix}}}return N};parse.fastpaths=(e,t)=>{const r={...t};const o=typeof r.maxLength===\"number\"?Math.min(s,r.maxLength):s;const i=e.length;if(i>o){throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${o}`)}e=l[e]||e;const a=u.isWindows(t);const{DOT_LITERAL:c,SLASH_LITERAL:p,ONE_CHAR:f,DOTS_SLASH:A,NO_DOT:R,NO_DOTS:_,NO_DOTS_SLASH:h,STAR:g,START_ANCHOR:E}=n.globChars(a);const C=r.dot?_:R;const y=r.dot?h:R;const d=r.capture?\"\":\"?:\";const x={negated:false,prefix:\"\"};let b=r.bash===true?\".*?\":g;if(r.capture){b=`(${b})`}const globstar=e=>{if(e.noglobstar===true)return b;return`(${d}(?:(?!${E}${e.dot?A:c}).)*?)`};const create=e=>{switch(e){case\"*\":return`${C}${f}${b}`;case\".*\":return`${c}${f}${b}`;case\"*.*\":return`${C}${b}${c}${f}${b}`;case\"*/*\":return`${C}${b}${p}${f}${y}${b}`;case\"**\":return C+globstar(r);case\"**/*\":return`(?:${C}${globstar(r)}${p})?${y}${f}${b}`;case\"**/*.*\":return`(?:${C}${globstar(r)}${p})?${y}${b}${c}${f}${b}`;case\"**/.*\":return`(?:${C}${globstar(r)}${p})?${c}${f}${b}`;default:{const t=/^(.*?)\\.(\\w+)$/.exec(e);if(!t)return;const r=create(t[1]);if(!r)return;return r+c+t[2]}}};const S=u.removePrefix(e,x);let H=create(S);if(H&&r.strictSlashes!==true){H+=`${p}?`}return H};e.exports=parse},683:(e,t,r)=>{const n=r(17);const u=r(700);const s=r(754);const o=r(513);const i=r(356);const isObject=e=>e&&typeof e===\"object\"&&!Array.isArray(e);const picomatch=(e,t,r=false)=>{if(Array.isArray(e)){const n=e.map((e=>picomatch(e,t,r)));const arrayMatcher=e=>{for(const t of n){const r=t(e);if(r)return r}return false};return arrayMatcher}const n=isObject(e)&&e.tokens&&e.input;if(e===\"\"||typeof e!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const u=t||{};const s=o.isWindows(t);const i=n?picomatch.compileRe(e,t):picomatch.makeRe(e,t,false,true);const a=i.state;delete i.state;let isIgnored=()=>false;if(u.ignore){const e={...t,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(u.ignore,e,r)}const matcher=(r,n=false)=>{const{isMatch:o,match:l,output:c}=picomatch.test(r,i,t,{glob:e,posix:s});const p={glob:e,state:a,regex:i,posix:s,input:r,output:c,match:l,isMatch:o};if(typeof u.onResult===\"function\"){u.onResult(p)}if(o===false){p.isMatch=false;return n?p:false}if(isIgnored(r)){if(typeof u.onIgnore===\"function\"){u.onIgnore(p)}p.isMatch=false;return n?p:false}if(typeof u.onMatch===\"function\"){u.onMatch(p)}return n?p:true};if(r){matcher.state=a}return matcher};picomatch.test=(e,t,r,{glob:n,posix:u}={})=>{if(typeof e!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(e===\"\"){return{isMatch:false,output:\"\"}}const s=r||{};const i=s.format||(u?o.toPosixSlashes:null);let a=e===n;let l=a&&i?i(e):e;if(a===false){l=i?i(e):e;a=l===n}if(a===false||s.capture===true){if(s.matchBase===true||s.basename===true){a=picomatch.matchBase(e,t,r,u)}else{a=t.exec(l)}}return{isMatch:Boolean(a),match:a,output:l}};picomatch.matchBase=(e,t,r,u=o.isWindows(r))=>{const s=t instanceof RegExp?t:picomatch.makeRe(t,r);return s.test(n.basename(e))};picomatch.isMatch=(e,t,r)=>picomatch(t,r)(e);picomatch.parse=(e,t)=>{if(Array.isArray(e))return e.map((e=>picomatch.parse(e,t)));return s(e,{...t,fastpaths:false})};picomatch.scan=(e,t)=>u(e,t);picomatch.compileRe=(e,t,r=false,n=false)=>{if(r===true){return e.output}const u=t||{};const s=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let i=`${s}(?:${e.output})${o}`;if(e&&e.negated===true){i=`^(?!${i}).*$`}const a=picomatch.toRegex(i,t);if(n===true){a.state=e}return a};picomatch.makeRe=(e,t,r=false,n=false)=>{if(!e||typeof e!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}const u=t||{};let o={negated:false,fastpaths:true};let i=\"\";let a;if(e.startsWith(\"./\")){e=e.slice(2);i=o.prefix=\"./\"}if(u.fastpaths!==false&&(e[0]===\".\"||e[0]===\"*\")){a=s.fastpaths(e,t)}if(a===undefined){o=s(e,t);o.prefix=i+(o.prefix||\"\")}else{o.output=a}return picomatch.compileRe(o,t,r,n)};picomatch.toRegex=(e,t)=>{try{const r=t||{};return new RegExp(e,r.flags||(r.nocase?\"i\":\"\"))}catch(e){if(t&&t.debug===true)throw e;return/$^/}};picomatch.constants=i;e.exports=picomatch},700:(e,t,r)=>{const n=r(513);const{CHAR_ASTERISK:u,CHAR_AT:s,CHAR_BACKWARD_SLASH:o,CHAR_COMMA:i,CHAR_DOT:a,CHAR_EXCLAMATION_MARK:l,CHAR_FORWARD_SLASH:c,CHAR_LEFT_CURLY_BRACE:p,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:R,CHAR_QUESTION_MARK:_,CHAR_RIGHT_CURLY_BRACE:h,CHAR_RIGHT_PARENTHESES:g,CHAR_RIGHT_SQUARE_BRACKET:E}=r(356);const isPathSeparator=e=>e===c||e===o;const depth=e=>{if(e.isPrefix!==true){e.depth=e.isGlobstar?Infinity:1}};const scan=(e,t)=>{const r=t||{};const C=e.length-1;const y=r.parts===true||r.scanToEnd===true;const d=[];const x=[];const b=[];let S=e;let H=-1;let v=0;let $=0;let m=false;let T=false;let L=false;let O=false;let w=false;let N=false;let k=false;let I=false;let M=false;let P=0;let B;let G;let D={value:\"\",depth:0,isGlob:false};const eos=()=>H>=C;const peek=()=>S.charCodeAt(H+1);const advance=()=>{B=G;return S.charCodeAt(++H)};while(H<C){G=advance();let e;if(G===o){k=D.backslashes=true;G=advance();if(G===p){N=true}continue}if(N===true||G===p){P++;while(eos()!==true&&(G=advance())){if(G===o){k=D.backslashes=true;advance();continue}if(G===p){P++;continue}if(N!==true&&G===a&&(G=advance())===a){m=D.isBrace=true;L=D.isGlob=true;M=true;if(y===true){continue}break}if(N!==true&&G===i){m=D.isBrace=true;L=D.isGlob=true;M=true;if(y===true){continue}break}if(G===h){P--;if(P===0){N=false;m=D.isBrace=true;M=true;break}}}if(y===true){continue}break}if(G===c){d.push(H);x.push(D);D={value:\"\",depth:0,isGlob:false};if(M===true)continue;if(B===a&&H===v+1){v+=2;continue}$=H+1;continue}if(r.noext!==true){const e=G===R||G===s||G===u||G===_||G===l;if(e===true&&peek()===f){L=D.isGlob=true;O=D.isExtglob=true;M=true;if(y===true){while(eos()!==true&&(G=advance())){if(G===o){k=D.backslashes=true;G=advance();continue}if(G===g){L=D.isGlob=true;M=true;break}}continue}break}}if(G===u){if(B===u)w=D.isGlobstar=true;L=D.isGlob=true;M=true;if(y===true){continue}break}if(G===_){L=D.isGlob=true;M=true;if(y===true){continue}break}if(G===A){while(eos()!==true&&(e=advance())){if(e===o){k=D.backslashes=true;advance();continue}if(e===E){T=D.isBracket=true;L=D.isGlob=true;M=true;break}}if(y===true){continue}break}if(r.nonegate!==true&&G===l&&H===v){I=D.negated=true;v++;continue}if(r.noparen!==true&&G===f){L=D.isGlob=true;if(y===true){while(eos()!==true&&(G=advance())){if(G===f){k=D.backslashes=true;G=advance();continue}if(G===g){M=true;break}}continue}break}if(L===true){M=true;if(y===true){continue}break}}if(r.noext===true){O=false;L=false}let U=S;let K=\"\";let F=\"\";if(v>0){K=S.slice(0,v);S=S.slice(v);$-=v}if(U&&L===true&&$>0){U=S.slice(0,$);F=S.slice($)}else if(L===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(r.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&k===true){U=n.removeBackslashes(U)}}const Q={prefix:K,input:e,start:v,base:U,glob:F,isBrace:m,isBracket:T,isGlob:L,isExtglob:O,isGlobstar:w,negated:I};if(r.tokens===true){Q.maxDepth=0;if(!isPathSeparator(G)){x.push(D)}Q.tokens=x}if(r.parts===true||r.tokens===true){let t;for(let n=0;n<d.length;n++){const u=t?t+1:v;const s=d[n];const o=e.slice(u,s);if(r.tokens){if(n===0&&v!==0){x[n].isPrefix=true;x[n].value=K}else{x[n].value=o}depth(x[n]);Q.maxDepth+=x[n].depth}if(n!==0||o!==\"\"){b.push(o)}t=s}if(t&&t+1<e.length){const n=e.slice(t+1);b.push(n);if(r.tokens){x[x.length-1].value=n;depth(x[x.length-1]);Q.maxDepth+=x[x.length-1].depth}}Q.slashes=d;Q.parts=b}return Q};e.exports=scan},513:(e,t,r)=>{const n=r(17);const u=process.platform===\"win32\";const{REGEX_BACKSLASH:s,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:i,REGEX_SPECIAL_CHARS_GLOBAL:a}=r(356);t.isObject=e=>e!==null&&typeof e===\"object\"&&!Array.isArray(e);t.hasRegexChars=e=>i.test(e);t.isRegexChar=e=>e.length===1&&t.hasRegexChars(e);t.escapeRegex=e=>e.replace(a,\"\\\\$1\");t.toPosixSlashes=e=>e.replace(s,\"/\");t.removeBackslashes=e=>e.replace(o,(e=>e===\"\\\\\"?\"\":e));t.supportsLookbehinds=()=>{const e=process.version.slice(1).split(\".\").map(Number);if(e.length===3&&e[0]>=9||e[0]===8&&e[1]>=10){return true}return false};t.isWindows=e=>{if(e&&typeof e.windows===\"boolean\"){return e.windows}return u===true||n.sep===\"\\\\\"};t.escapeLast=(e,r,n)=>{const u=e.lastIndexOf(r,n);if(u===-1)return e;if(e[u-1]===\"\\\\\")return t.escapeLast(e,r,u-1);return`${e.slice(0,u)}\\\\${e.slice(u)}`};t.removePrefix=(e,t={})=>{let r=e;if(r.startsWith(\"./\")){r=r.slice(2);t.prefix=\"./\"}return r};t.wrapOutput=(e,t={},r={})=>{const n=r.contains?\"\":\"^\";const u=r.contains?\"\":\"$\";let s=`${n}(?:${e})${u}`;if(t.negated===true){s=`(?:^(?!${s}).*$)`}return s}},492:(e,t,r)=>{\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\nconst n=r(357);const toRegexRange=(e,t,r)=>{if(n(e)===false){throw new TypeError(\"toRegexRange: expected the first argument to be a number\")}if(t===void 0||e===t){return String(e)}if(n(t)===false){throw new TypeError(\"toRegexRange: expected the second argument to be a number.\")}let u={relaxZeros:true,...r};if(typeof u.strictZeros===\"boolean\"){u.relaxZeros=u.strictZeros===false}let s=String(u.relaxZeros);let o=String(u.shorthand);let i=String(u.capture);let a=String(u.wrap);let l=e+\":\"+t+\"=\"+s+o+i+a;if(toRegexRange.cache.hasOwnProperty(l)){return toRegexRange.cache[l].result}let c=Math.min(e,t);let p=Math.max(e,t);if(Math.abs(c-p)===1){let r=e+\"|\"+t;if(u.capture){return`(${r})`}if(u.wrap===false){return r}return`(?:${r})`}let f=hasPadding(e)||hasPadding(t);let A={min:e,max:t,a:c,b:p};let R=[];let _=[];if(f){A.isPadded=f;A.maxLen=String(A.max).length}if(c<0){let e=p<0?Math.abs(p):1;_=splitToPatterns(e,Math.abs(c),A,u);c=A.a=0}if(p>=0){R=splitToPatterns(c,p,A,u)}A.negatives=_;A.positives=R;A.result=collatePatterns(_,R,u);if(u.capture===true){A.result=`(${A.result})`}else if(u.wrap!==false&&R.length+_.length>1){A.result=`(?:${A.result})`}toRegexRange.cache[l]=A;return A.result};function collatePatterns(e,t,r){let n=filterPatterns(e,t,\"-\",false,r)||[];let u=filterPatterns(t,e,\"\",false,r)||[];let s=filterPatterns(e,t,\"-?\",true,r)||[];let o=n.concat(s).concat(u);return o.join(\"|\")}function splitToRanges(e,t){let r=1;let n=1;let u=countNines(e,r);let s=new Set([t]);while(e<=u&&u<=t){s.add(u);r+=1;u=countNines(e,r)}u=countZeros(t+1,n)-1;while(e<u&&u<=t){s.add(u);n+=1;u=countZeros(t+1,n)-1}s=[...s];s.sort(compare);return s}function rangeToPattern(e,t,r){if(e===t){return{pattern:e,count:[],digits:0}}let n=zip(e,t);let u=n.length;let s=\"\";let o=0;for(let e=0;e<u;e++){let[t,u]=n[e];if(t===u){s+=t}else if(t!==\"0\"||u!==\"9\"){s+=toCharacterClass(t,u,r)}else{o++}}if(o){s+=r.shorthand===true?\"\\\\d\":\"[0-9]\"}return{pattern:s,count:[o],digits:u}}function splitToPatterns(e,t,r,n){let u=splitToRanges(e,t);let s=[];let o=e;let i;for(let e=0;e<u.length;e++){let t=u[e];let a=rangeToPattern(String(o),String(t),n);let l=\"\";if(!r.isPadded&&i&&i.pattern===a.pattern){if(i.count.length>1){i.count.pop()}i.count.push(a.count[0]);i.string=i.pattern+toQuantifier(i.count);o=t+1;continue}if(r.isPadded){l=padZeros(t,r,n)}a.string=l+a.pattern+toQuantifier(a.count);s.push(a);o=t+1;i=a}return s}function filterPatterns(e,t,r,n,u){let s=[];for(let u of e){let{string:e}=u;if(!n&&!contains(t,\"string\",e)){s.push(r+e)}if(n&&contains(t,\"string\",e)){s.push(r+e)}}return s}function zip(e,t){let r=[];for(let n=0;n<e.length;n++)r.push([e[n],t[n]]);return r}function compare(e,t){return e>t?1:t>e?-1:0}function contains(e,t,r){return e.some((e=>e[t]===r))}function countNines(e,t){return Number(String(e).slice(0,-t)+\"9\".repeat(t))}function countZeros(e,t){return e-e%Math.pow(10,t)}function toQuantifier(e){let[t=0,r=\"\"]=e;if(r||t>1){return`{${t+(r?\",\"+r:\"\")}}`}return\"\"}function toCharacterClass(e,t,r){return`[${e}${t-e===1?\"\":\"-\"}${t}]`}function hasPadding(e){return/^-?(0+)\\d/.test(e)}function padZeros(e,t,r){if(!t.isPadded){return e}let n=Math.abs(t.maxLen-String(e).length);let u=r.relaxZeros!==false;switch(n){case 0:return\"\";case 1:return u?\"0?\":\"0\";case 2:return u?\"0{0,2}\":\"00\";default:{return u?`0{0,${n}}`:`0{${n}}`}}}toRegexRange.cache={};toRegexRange.clearCache=()=>toRegexRange.cache={};e.exports=toRegexRange},17:e=>{e.exports=__webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\")},837:e=>{e.exports=__webpack_require__(/*! util */ \"./node_modules/next/dist/compiled/util/util.js\")}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var u=t[r]={exports:{}};var s=true;try{e[r](u,u.exports,__nccwpck_require__);s=false}finally{if(s)delete t[r]}return u.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(971);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGVBQWUsZUFBZSxjQUFjLGVBQWUsb0JBQW9CLElBQUksU0FBUyxxQkFBcUIsZ0JBQWdCLHlCQUF5QixxQkFBcUIsYUFBYSxLQUFLLFlBQVksS0FBSyxnQ0FBZ0MseUNBQXlDLGtCQUFrQixVQUFVLG9CQUFvQixVQUFVLHdCQUF3QixJQUFJLHdCQUF3Qiw4QkFBOEIsZUFBZSxzQkFBc0IsSUFBSSx3QkFBd0Isb0JBQW9CLGVBQWUscUJBQXFCLElBQUksd0JBQXdCLG9CQUFvQixhQUFhLHFCQUFxQixvQkFBb0IscUJBQXFCLGtCQUFrQixVQUFVLHFCQUFxQixJQUFJLHVCQUF1QixVQUFVLCtEQUErRCxpQkFBaUIsZUFBZSxlQUFlLGVBQWUscUJBQXFCLElBQUksZ0JBQWdCLElBQUksMEJBQTBCLCtDQUErQyx5QkFBeUIscUNBQXFDLFNBQVMsb0JBQW9CLGlCQUFpQixxQkFBcUIsaUJBQWlCLG9CQUFvQix1QkFBdUIscUJBQXFCLHVCQUF1QixxQkFBcUIsOENBQThDLFlBQVksZUFBZSx3QkFBd0Isd0JBQXdCLGNBQWMsNkJBQTZCLEVBQUUsaUJBQWlCLGtDQUFrQyxFQUFFLE1BQU0sWUFBWSxzQkFBc0IsY0FBYyxVQUFVLGdCQUFnQixrQkFBa0IsU0FBUyxXQUFXLDJqQkFBMmpCLHVMQUF1TCxpREFBaUQsd0lBQXdJLGNBQWMsZUFBZSxlQUFlLGVBQWUsbUNBQW1DLFNBQVMsZUFBZSxlQUFlLHNCQUFzQixjQUFjLGdDQUFnQyxFQUFFLEdBQUcsTUFBTSxnQkFBZ0IscUJBQXFCLGdCQUFnQix1QkFBdUIsS0FBSyxnQkFBZ0IscUNBQXFDLEVBQUUsR0FBRyxFQUFFLDZDQUE2QyxxQkFBcUIsb0JBQW9CLElBQUksNkNBQTZDLGdCQUFnQixJQUFJLFdBQVcsUUFBUSxjQUFjLG1EQUFtRCxXQUFXLFVB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QUUsU0FBUyxpQ0FBaUMsVUFBVSxFQUFFLEVBQUUsZUFBZSxFQUFFLEVBQUUsR0FBRyx1QkFBdUIsMEJBQTBCLHlCQUF5QixnQkFBZ0IsU0FBUywwQ0FBMEMsMkJBQTJCLFVBQVUsZ0JBQWdCLHlCQUF5QixtQkFBbUIsSUFBSSxPQUFPLFNBQVMsWUFBWSxJQUFJLEdBQUcsS0FBSyxFQUFFLEdBQUcsSUFBSSxzQkFBc0Isa0RBQWtELHVCQUF1QixRQUFRLFVBQVUsbUJBQU8sQ0FBQyx3RUFBTSxFQUFFLFNBQVMsVUFBVSxtQkFBTyxDQUFDLDREQUFNLElBQUksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanM/M2NlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17MzMzOihlLHQscik9Pntjb25zdCBuPXIoMTM3KTtjb25zdCB1PXIoMTc5KTtjb25zdCBzPXIoMTMpO2NvbnN0IG89cig3MTkpO2NvbnN0IGJyYWNlcz0oZSx0PXt9KT0+e2xldCByPVtdO2lmKEFycmF5LmlzQXJyYXkoZSkpe2ZvcihsZXQgbiBvZiBlKXtsZXQgZT1icmFjZXMuY3JlYXRlKG4sdCk7aWYoQXJyYXkuaXNBcnJheShlKSl7ci5wdXNoKC4uLmUpfWVsc2V7ci5wdXNoKGUpfX19ZWxzZXtyPVtdLmNvbmNhdChicmFjZXMuY3JlYXRlKGUsdCkpfWlmKHQmJnQuZXhwYW5kPT09dHJ1ZSYmdC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5wYXJzZT0oZSx0PXt9KT0+byhlLHQpO2JyYWNlcy5zdHJpbmdpZnk9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBuKGJyYWNlcy5wYXJzZShlLHQpLHQpfXJldHVybiBuKGUsdCl9O2JyYWNlcy5jb21waWxlPShlLHQ9e30pPT57aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtlPWJyYWNlcy5wYXJzZShlLHQpfXJldHVybiB1KGUsdCl9O2JyYWNlcy5leHBhbmQ9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2U9YnJhY2VzLnBhcnNlKGUsdCl9bGV0IHI9cyhlLHQpO2lmKHQubm9lbXB0eT09PXRydWUpe3I9ci5maWx0ZXIoQm9vbGVhbil9aWYodC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5jcmVhdGU9KGUsdD17fSk9PntpZihlPT09XCJcInx8ZS5sZW5ndGg8Myl7cmV0dXJuW2VdfXJldHVybiB0LmV4cGFuZCE9PXRydWU/YnJhY2VzLmNvbXBpbGUoZSx0KTpicmFjZXMuZXhwYW5kKGUsdCl9O2UuZXhwb3J0cz1icmFjZXN9LDE3OTooZSx0LHIpPT57Y29uc3Qgbj1yKDc4Myk7Y29uc3QgdT1yKDYxNyk7Y29uc3QgY29tcGlsZT0oZSx0PXt9KT0+e2xldCB3YWxrPShlLHI9e30pPT57bGV0IHM9dS5pc0ludmFsaWRCcmFjZShyKTtsZXQgbz1lLmludmFsaWQ9PT10cnVlJiZ0LmVzY2FwZUludmFsaWQ9PT10cnVlO2xldCBpPXM9PT10cnVlfHxvPT09dHJ1ZTtsZXQgYT10LmVzY2FwZUludmFsaWQ9PT10cnVlP1wiXFxcXFwiOlwiXCI7bGV0IGw9XCJcIjtpZihlLmlzT3Blbj09PXRydWUpe3JldHVybiBhK2UudmFsdWV9aWYoZS5pc0Nsb3NlPT09dHJ1ZSl7cmV0dXJuIGErZS52YWx1ZX1pZihlLnR5cGU9PT1cIm9wZW5cIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKFwifWlmKGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKVwifWlmKGUudHlwZT09PVwiY29tbWFcIil7cmV0dXJuIGUucHJldi50eXBlPT09XCJjb21tYVwiP1wiXCI6aT9lLnZhbHVlOlwifFwifWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMmJmUucmFuZ2VzPjApe2xldCByPXUucmVkdWNlKGUubm9kZXMpO2xldCBzPW4oLi4ucix7Li4udCx3cmFwOmZhbHNlLHRvUmVnZXg6dHJ1ZX0pO2lmKHMubGVuZ3RoIT09MCl7cmV0dXJuIHIubGVuZ3RoPjEmJnMubGVuZ3RoPjE/YCgke3N9KWA6c319aWYoZS5ub2Rlcyl7Zm9yKGxldCB0IG9mIGUubm9kZXMpe2wrPXdhbGsodCxlKX19cmV0dXJuIGx9O3JldHVybiB3YWxrKGUpfTtlLmV4cG9ydHM9Y29tcGlsZX0sNDU3OmU9PntlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxDSEFSXzA6XCIwXCIsQ0hBUl85OlwiOVwiLENIQVJfVVBQRVJDQVNFX0E6XCJBXCIsQ0hBUl9MT1dFUkNBU0VfQTpcImFcIixDSEFSX1VQUEVSQ0FTRV9aOlwiWlwiLENIQVJfTE9XRVJDQVNFX1o6XCJ6XCIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOlwiKFwiLENIQVJfUklHSFRfUEFSRU5USEVTRVM6XCIpXCIsQ0hBUl9BU1RFUklTSzpcIipcIixDSEFSX0FNUEVSU0FORDpcIiZcIixDSEFSX0FUOlwiQFwiLENIQVJfQkFDS1NMQVNIOlwiXFxcXFwiLENIQVJfQkFDS1RJQ0s6XCJgXCIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46XCJcXHJcIixDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOlwiXlwiLENIQVJfQ09MT046XCI6XCIsQ0hBUl9DT01NQTpcIixcIixDSEFSX0RPTExBUjpcIiRcIixDSEFSX0RPVDpcIi5cIixDSEFSX0RPVUJMRV9RVU9URTonXCInLENIQVJfRVFVQUw6XCI9XCIsQ0hBUl9FWENMQU1BVElPTl9NQVJLOlwiIVwiLENIQVJfRk9STV9GRUVEOlwiXFxmXCIsQ0hBUl9GT1JXQVJEX1NMQVNIOlwiL1wiLENIQVJfSEFTSDpcIiNcIixDSEFSX0hZUEhFTl9NSU5VUzpcIi1cIixDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDpcIjxcIixDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6XCJ7XCIsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOlwiW1wiLENIQVJfTElORV9GRUVEOlwiXFxuXCIsQ0hBUl9OT19CUkVBS19TUEFDRTpcIsKgXCIsQ0hBUl9QRVJDRU5UOlwiJVwiLENIQVJfUExVUzpcIitcIixDSEFSX1FVRVNUSU9OX01BUks6XCI/XCIsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOlwiPlwiLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6XCJ9XCIsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpcIl1cIixDSEFSX1NFTUlDT0xPTjpcIjtcIixDSEFSX1NJTkdMRV9RVU9URTpcIidcIixDSEFSX1NQQUNFOlwiIFwiLENIQVJfVEFCOlwiXFx0XCIsQ0hBUl9VTkRFUlNDT1JFOlwiX1wiLENIQVJfVkVSVElDQUxfTElORTpcInxcIixDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTpcIlxcdWZlZmZcIn19LDEzOihlLHQscik9Pntjb25zdCBuPXIoNzgzKTtjb25zdCB1PXIoMTM3KTtjb25zdCBzPXIoNjE3KTtjb25zdCBhcHBlbmQ9KGU9XCJcIix0PVwiXCIscj1mYWxzZSk9PntsZXQgbj1bXTtlPVtdLmNvbmNhdChlKTt0PVtdLmNvbmNhdCh0KTtpZighdC5sZW5ndGgpcmV0dXJuIGU7aWYoIWUubGVuZ3RoKXtyZXR1cm4gcj9zLmZsYXR0ZW4odCkubWFwKChlPT5geyR7ZX19YCkpOnR9Zm9yKGxldCB1IG9mIGUpe2lmKEFycmF5LmlzQXJyYXkodSkpe2ZvcihsZXQgZSBvZiB1KXtuLnB1c2goYXBwZW5kKGUsdCxyKSl9fWVsc2V7Zm9yKGxldCBlIG9mIHQpe2lmKHI9PT10cnVlJiZ0eXBlb2YgZT09PVwic3RyaW5nXCIpZT1geyR7ZX19YDtuLnB1c2goQXJyYXkuaXNBcnJheShlKT9hcHBlbmQodSxlLHIpOnUrZSl9fX1yZXR1cm4gcy5mbGF0dGVuKG4pfTtjb25zdCBleHBhbmQ9KGUsdD17fSk9PntsZXQgcj10LnJhbmdlTGltaXQ9PT12b2lkIDA/MWUzOnQucmFuZ2VMaW1pdDtsZXQgd2Fsaz0oZSxvPXt9KT0+e2UucXVldWU9W107bGV0IGk9bztsZXQgYT1vLnF1ZXVlO3doaWxlKGkudHlwZSE9PVwiYnJhY2VcIiYmaS50eXBlIT09XCJyb290XCImJmkucGFyZW50KXtpPWkucGFyZW50O2E9aS5xdWV1ZX1pZihlLmludmFsaWR8fGUuZG9sbGFyKXthLnB1c2goYXBwZW5kKGEucG9wKCksdShlLHQpKSk7cmV0dXJufWlmKGUudHlwZT09PVwiYnJhY2VcIiYmZS5pbnZhbGlkIT09dHJ1ZSYmZS5ub2Rlcy5sZW5ndGg9PT0yKXthLnB1c2goYXBwZW5kKGEucG9wKCksW1wie31cIl0pKTtyZXR1cm59aWYoZS5ub2RlcyYmZS5yYW5nZXM+MCl7bGV0IG89cy5yZWR1Y2UoZS5ub2Rlcyk7aWYocy5leGNlZWRzTGltaXQoLi4ubyx0LnN0ZXAscikpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiZXhwYW5kZWQgYXJyYXkgbGVuZ3RoIGV4Y2VlZHMgcmFuZ2UgbGltaXQuIFVzZSBvcHRpb25zLnJhbmdlTGltaXQgdG8gaW5jcmVhc2Ugb3IgZGlzYWJsZSB0aGUgbGltaXQuXCIpfWxldCBpPW4oLi4ubyx0KTtpZihpLmxlbmd0aD09PTApe2k9dShlLHQpfWEucHVzaChhcHBlbmQoYS5wb3AoKSxpKSk7ZS5ub2Rlcz1bXTtyZXR1cm59bGV0IGw9cy5lbmNsb3NlQnJhY2UoZSk7bGV0IGM9ZS5xdWV1ZTtsZXQgcD1lO3doaWxlKHAudHlwZSE9PVwiYnJhY2VcIiYmcC50eXBlIT09XCJyb290XCImJnAucGFyZW50KXtwPXAucGFyZW50O2M9cC5xdWV1ZX1mb3IobGV0IHQ9MDt0PGUubm9kZXMubGVuZ3RoO3QrKyl7bGV0IHI9ZS5ub2Rlc1t0XTtpZihyLnR5cGU9PT1cImNvbW1hXCImJmUudHlwZT09PVwiYnJhY2VcIil7aWYodD09PTEpYy5wdXNoKFwiXCIpO2MucHVzaChcIlwiKTtjb250aW51ZX1pZihyLnR5cGU9PT1cImNsb3NlXCIpe2EucHVzaChhcHBlbmQoYS5wb3AoKSxjLGwpKTtjb250aW51ZX1pZihyLnZhbHVlJiZyLnR5cGUhPT1cIm9wZW5cIil7Yy5wdXNoKGFwcGVuZChjLnBvcCgpLHIudmFsdWUpKTtjb250aW51ZX1pZihyLm5vZGVzKXt3YWxrKHIsZSl9fXJldHVybiBjfTtyZXR1cm4gcy5mbGF0dGVuKHdhbGsoZSkpfTtlLmV4cG9ydHM9ZXhwYW5kfSw3MTk6KGUsdCxyKT0+e2NvbnN0IG49cigxMzcpO2NvbnN0e01BWF9MRU5HVEg6dSxDSEFSX0JBQ0tTTEFTSDpzLENIQVJfQkFDS1RJQ0s6byxDSEFSX0NPTU1BOmksQ0hBUl9ET1Q6YSxDSEFSX0xFRlRfUEFSRU5USEVTRVM6bCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmMsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOnAsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6UixDSEFSX0RPVUJMRV9RVU9URTpfLENIQVJfU0lOR0xFX1FVT1RFOmgsQ0hBUl9OT19CUkVBS19TUEFDRTpnLENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOkV9PXIoNDU3KTtjb25zdCBwYXJzZT0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfWxldCByPXR8fHt9O2xldCBDPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4odSxyLm1heExlbmd0aCk6dTtpZihlLmxlbmd0aD5DKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aCAoJHtlLmxlbmd0aH0pLCBleGNlZWRzIG1heCBjaGFyYWN0ZXJzICgke0N9KWApfWxldCB5PXt0eXBlOlwicm9vdFwiLGlucHV0OmUsbm9kZXM6W119O2xldCBkPVt5XTtsZXQgeD15O2xldCBiPXk7bGV0IFM9MDtsZXQgSD1lLmxlbmd0aDtsZXQgdj0wO2xldCAkPTA7bGV0IG07bGV0IFQ9e307Y29uc3QgYWR2YW5jZT0oKT0+ZVt2KytdO2NvbnN0IHB1c2g9ZT0+e2lmKGUudHlwZT09PVwidGV4dFwiJiZiLnR5cGU9PT1cImRvdFwiKXtiLnR5cGU9XCJ0ZXh0XCJ9aWYoYiYmYi50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtiLnZhbHVlKz1lLnZhbHVlO3JldHVybn14Lm5vZGVzLnB1c2goZSk7ZS5wYXJlbnQ9eDtlLnByZXY9YjtiPWU7cmV0dXJuIGV9O3B1c2goe3R5cGU6XCJib3NcIn0pO3doaWxlKHY8SCl7eD1kW2QubGVuZ3RoLTFdO209YWR2YW5jZSgpO2lmKG09PT1FfHxtPT09Zyl7Y29udGludWV9aWYobT09PXMpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6KHQua2VlcEVzY2FwaW5nP206XCJcIikrYWR2YW5jZSgpfSk7Y29udGludWV9aWYobT09PVIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6XCJcXFxcXCIrbX0pO2NvbnRpbnVlfWlmKG09PT1BKXtTKys7bGV0IGU9dHJ1ZTtsZXQgdDt3aGlsZSh2PEgmJih0PWFkdmFuY2UoKSkpe20rPXQ7aWYodD09PUEpe1MrKztjb250aW51ZX1pZih0PT09cyl7bSs9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKHQ9PT1SKXtTLS07aWYoUz09PTApe2JyZWFrfX19cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWwpe3g9cHVzaCh7dHlwZTpcInBhcmVuXCIsbm9kZXM6W119KTtkLnB1c2goeCk7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWMpe2lmKHgudHlwZSE9PVwicGFyZW5cIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9eD1kLnBvcCgpO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09X3x8bT09PWh8fG09PT1vKXtsZXQgZT1tO2xldCByO2lmKHQua2VlcFF1b3RlcyE9PXRydWUpe209XCJcIn13aGlsZSh2PEgmJihyPWFkdmFuY2UoKSkpe2lmKHI9PT1zKXttKz1yK2FkdmFuY2UoKTtjb250aW51ZX1pZihyPT09ZSl7aWYodC5rZWVwUXVvdGVzPT09dHJ1ZSltKz1yO2JyZWFrfW0rPXJ9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PXApeyQrKztsZXQgZT1iLnZhbHVlJiZiLnZhbHVlLnNsaWNlKC0xKT09PVwiJFwifHx4LmRvbGxhcj09PXRydWU7bGV0IHQ9e3R5cGU6XCJicmFjZVwiLG9wZW46dHJ1ZSxjbG9zZTpmYWxzZSxkb2xsYXI6ZSxkZXB0aDokLGNvbW1hczowLHJhbmdlczowLG5vZGVzOltdfTt4PXB1c2godCk7ZC5wdXNoKHgpO3B1c2goe3R5cGU6XCJvcGVuXCIsdmFsdWU6bX0pO2NvbnRpbnVlfWlmKG09PT1mKXtpZih4LnR5cGUhPT1cImJyYWNlXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO2NvbnRpbnVlfWxldCBlPVwiY2xvc2VcIjt4PWQucG9wKCk7eC5jbG9zZT10cnVlO3B1c2goe3R5cGU6ZSx2YWx1ZTptfSk7JC0tO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09aSYmJD4wKXtpZih4LnJhbmdlcz4wKXt4LnJhbmdlcz0wO2xldCBlPXgubm9kZXMuc2hpZnQoKTt4Lm5vZGVzPVtlLHt0eXBlOlwidGV4dFwiLHZhbHVlOm4oeCl9XX1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTptfSk7eC5jb21tYXMrKztjb250aW51ZX1pZihtPT09YSYmJD4wJiZ4LmNvbW1hcz09PTApe2xldCBlPXgubm9kZXM7aWYoJD09PTB8fGUubGVuZ3RoPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYoYi50eXBlPT09XCJkb3RcIil7eC5yYW5nZT1bXTtiLnZhbHVlKz1tO2IudHlwZT1cInJhbmdlXCI7aWYoeC5ub2Rlcy5sZW5ndGghPT0zJiZ4Lm5vZGVzLmxlbmd0aCE9PTUpe3guaW52YWxpZD10cnVlO3gucmFuZ2VzPTA7Yi50eXBlPVwidGV4dFwiO2NvbnRpbnVlfXgucmFuZ2VzKys7eC5hcmdzPVtdO2NvbnRpbnVlfWlmKGIudHlwZT09PVwicmFuZ2VcIil7ZS5wb3AoKTtsZXQgdD1lW2UubGVuZ3RoLTFdO3QudmFsdWUrPWIudmFsdWUrbTtiPXQ7eC5yYW5nZXMtLTtjb250aW51ZX1wdXNoKHt0eXBlOlwiZG90XCIsdmFsdWU6bX0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pfWRve3g9ZC5wb3AoKTtpZih4LnR5cGUhPT1cInJvb3RcIil7eC5ub2Rlcy5mb3JFYWNoKChlPT57aWYoIWUubm9kZXMpe2lmKGUudHlwZT09PVwib3BlblwiKWUuaXNPcGVuPXRydWU7aWYoZS50eXBlPT09XCJjbG9zZVwiKWUuaXNDbG9zZT10cnVlO2lmKCFlLm5vZGVzKWUudHlwZT1cInRleHRcIjtlLmludmFsaWQ9dHJ1ZX19KSk7bGV0IGU9ZFtkLmxlbmd0aC0xXTtsZXQgdD1lLm5vZGVzLmluZGV4T2YoeCk7ZS5ub2Rlcy5zcGxpY2UodCwxLC4uLngubm9kZXMpfX13aGlsZShkLmxlbmd0aD4wKTtwdXNoKHt0eXBlOlwiZW9zXCJ9KTtyZXR1cm4geX07ZS5leHBvcnRzPXBhcnNlfSwxMzc6KGUsdCxyKT0+e2NvbnN0IG49cig2MTcpO2UuZXhwb3J0cz0oZSx0PXt9KT0+e2xldCBzdHJpbmdpZnk9KGUscj17fSk9PntsZXQgdT10LmVzY2FwZUludmFsaWQmJm4uaXNJbnZhbGlkQnJhY2Uocik7bGV0IHM9ZS5pbnZhbGlkPT09dHJ1ZSYmdC5lc2NhcGVJbnZhbGlkPT09dHJ1ZTtsZXQgbz1cIlwiO2lmKGUudmFsdWUpe2lmKCh1fHxzKSYmbi5pc09wZW5PckNsb3NlKGUpKXtyZXR1cm5cIlxcXFxcIitlLnZhbHVlfXJldHVybiBlLnZhbHVlfWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMpe2ZvcihsZXQgdCBvZiBlLm5vZGVzKXtvKz1zdHJpbmdpZnkodCl9fXJldHVybiBvfTtyZXR1cm4gc3RyaW5naWZ5KGUpfX0sNjE3OihlLHQpPT57dC5pc0ludGVnZXI9ZT0+e2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZSl9aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlLnRyaW0oKSE9PVwiXCIpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcihlKSl9cmV0dXJuIGZhbHNlfTt0LmZpbmQ9KGUsdCk9PmUubm9kZXMuZmluZCgoZT0+ZS50eXBlPT09dCkpO3QuZXhjZWVkc0xpbWl0PShlLHIsbj0xLHUpPT57aWYodT09PWZhbHNlKXJldHVybiBmYWxzZTtpZighdC5pc0ludGVnZXIoZSl8fCF0LmlzSW50ZWdlcihyKSlyZXR1cm4gZmFsc2U7cmV0dXJuKE51bWJlcihyKS1OdW1iZXIoZSkpL051bWJlcihuKT49dX07dC5lc2NhcGVOb2RlPShlLHQ9MCxyKT0+e2xldCBuPWUubm9kZXNbdF07aWYoIW4pcmV0dXJuO2lmKHImJm4udHlwZT09PXJ8fG4udHlwZT09PVwib3BlblwifHxuLnR5cGU9PT1cImNsb3NlXCIpe2lmKG4uZXNjYXBlZCE9PXRydWUpe24udmFsdWU9XCJcXFxcXCIrbi52YWx1ZTtuLmVzY2FwZWQ9dHJ1ZX19fTt0LmVuY2xvc2VCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc0ludmFsaWRCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmludmFsaWQ9PT10cnVlfHxlLmRvbGxhcilyZXR1cm4gdHJ1ZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfWlmKGUub3BlbiE9PXRydWV8fGUuY2xvc2UhPT10cnVlKXtlLmludmFsaWQ9dHJ1ZTtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9O3QuaXNPcGVuT3JDbG9zZT1lPT57aWYoZS50eXBlPT09XCJvcGVuXCJ8fGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIHRydWV9cmV0dXJuIGUub3Blbj09PXRydWV8fGUuY2xvc2U9PT10cnVlfTt0LnJlZHVjZT1lPT5lLnJlZHVjZSgoKGUsdCk9PntpZih0LnR5cGU9PT1cInRleHRcIillLnB1c2godC52YWx1ZSk7aWYodC50eXBlPT09XCJyYW5nZVwiKXQudHlwZT1cInRleHRcIjtyZXR1cm4gZX0pLFtdKTt0LmZsYXR0ZW49KC4uLmUpPT57Y29uc3QgdD1bXTtjb25zdCBmbGF0PWU9Pntmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IG49ZVtyXTtBcnJheS5pc0FycmF5KG4pP2ZsYXQobix0KTpuIT09dm9pZCAwJiZ0LnB1c2gobil9cmV0dXJuIHR9O2ZsYXQoZSk7cmV0dXJuIHR9fSw3ODM6KGUsdCxyKT0+e1xuLyohXG4gKiBmaWxsLXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9maWxsLXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDQ5Mik7Y29uc3QgaXNPYmplY3Q9ZT0+ZSE9PW51bGwmJnR5cGVvZiBlPT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoZSk7Y29uc3QgdHJhbnNmb3JtPWU9PnQ9PmU9PT10cnVlP051bWJlcih0KTpTdHJpbmcodCk7Y29uc3QgaXNWYWxpZFZhbHVlPWU9PnR5cGVvZiBlPT09XCJudW1iZXJcInx8dHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlIT09XCJcIjtjb25zdCBpc051bWJlcj1lPT5OdW1iZXIuaXNJbnRlZ2VyKCtlKTtjb25zdCB6ZXJvcz1lPT57bGV0IHQ9YCR7ZX1gO2xldCByPS0xO2lmKHRbMF09PT1cIi1cIil0PXQuc2xpY2UoMSk7aWYodD09PVwiMFwiKXJldHVybiBmYWxzZTt3aGlsZSh0Wysrcl09PT1cIjBcIik7cmV0dXJuIHI+MH07Y29uc3Qgc3RyaW5naWZ5PShlLHQscik9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCJ8fHR5cGVvZiB0PT09XCJzdHJpbmdcIil7cmV0dXJuIHRydWV9cmV0dXJuIHIuc3RyaW5naWZ5PT09dHJ1ZX07Y29uc3QgcGFkPShlLHQscik9PntpZih0PjApe2xldCByPWVbMF09PT1cIi1cIj9cIi1cIjpcIlwiO2lmKHIpZT1lLnNsaWNlKDEpO2U9citlLnBhZFN0YXJ0KHI/dC0xOnQsXCIwXCIpfWlmKHI9PT1mYWxzZSl7cmV0dXJuIFN0cmluZyhlKX1yZXR1cm4gZX07Y29uc3QgdG9NYXhMZW49KGUsdCk9PntsZXQgcj1lWzBdPT09XCItXCI/XCItXCI6XCJcIjtpZihyKXtlPWUuc2xpY2UoMSk7dC0tfXdoaWxlKGUubGVuZ3RoPHQpZT1cIjBcIitlO3JldHVybiByP1wiLVwiK2U6ZX07Y29uc3QgdG9TZXF1ZW5jZT0oZSx0KT0+e2UubmVnYXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2UucG9zaXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2xldCByPXQuY2FwdHVyZT9cIlwiOlwiPzpcIjtsZXQgbj1cIlwiO2xldCB1PVwiXCI7bGV0IHM7aWYoZS5wb3NpdGl2ZXMubGVuZ3RoKXtuPWUucG9zaXRpdmVzLmpvaW4oXCJ8XCIpfWlmKGUubmVnYXRpdmVzLmxlbmd0aCl7dT1gLSgke3J9JHtlLm5lZ2F0aXZlcy5qb2luKFwifFwiKX0pYH1pZihuJiZ1KXtzPWAke259fCR7dX1gfWVsc2V7cz1ufHx1fWlmKHQud3JhcCl7cmV0dXJuYCgke3J9JHtzfSlgfXJldHVybiBzfTtjb25zdCB0b1JhbmdlPShlLHQscixuKT0+e2lmKHIpe3JldHVybiB1KGUsdCx7d3JhcDpmYWxzZSwuLi5ufSl9bGV0IHM9U3RyaW5nLmZyb21DaGFyQ29kZShlKTtpZihlPT09dClyZXR1cm4gcztsZXQgbz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO3JldHVybmBbJHtzfS0ke299XWB9O2NvbnN0IHRvUmVnZXg9KGUsdCxyKT0+e2lmKEFycmF5LmlzQXJyYXkoZSkpe2xldCB0PXIud3JhcD09PXRydWU7bGV0IG49ci5jYXB0dXJlP1wiXCI6XCI/OlwiO3JldHVybiB0P2AoJHtufSR7ZS5qb2luKFwifFwiKX0pYDplLmpvaW4oXCJ8XCIpfXJldHVybiB1KGUsdCxyKX07Y29uc3QgcmFuZ2VFcnJvcj0oLi4uZSk9Pm5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBhcmd1bWVudHM6IFwiK24uaW5zcGVjdCguLi5lKSk7Y29uc3QgaW52YWxpZFJhbmdlPShlLHQscik9PntpZihyLnN0cmljdFJhbmdlcz09PXRydWUpdGhyb3cgcmFuZ2VFcnJvcihbZSx0XSk7cmV0dXJuW119O2NvbnN0IGludmFsaWRTdGVwPShlLHQpPT57aWYodC5zdHJpY3RSYW5nZXM9PT10cnVlKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBzdGVwIFwiJHtlfVwiIHRvIGJlIGEgbnVtYmVyYCl9cmV0dXJuW119O2NvbnN0IGZpbGxOdW1iZXJzPShlLHQscj0xLG49e30pPT57bGV0IHU9TnVtYmVyKGUpO2xldCBzPU51bWJlcih0KTtpZighTnVtYmVyLmlzSW50ZWdlcih1KXx8IU51bWJlci5pc0ludGVnZXIocykpe2lmKG4uc3RyaWN0UmFuZ2VzPT09dHJ1ZSl0aHJvdyByYW5nZUVycm9yKFtlLHRdKTtyZXR1cm5bXX1pZih1PT09MCl1PTA7aWYocz09PTApcz0wO2xldCBvPXU+cztsZXQgaT1TdHJpbmcoZSk7bGV0IGE9U3RyaW5nKHQpO2xldCBsPVN0cmluZyhyKTtyPU1hdGgubWF4KE1hdGguYWJzKHIpLDEpO2xldCBjPXplcm9zKGkpfHx6ZXJvcyhhKXx8emVyb3MobCk7bGV0IHA9Yz9NYXRoLm1heChpLmxlbmd0aCxhLmxlbmd0aCxsLmxlbmd0aCk6MDtsZXQgZj1jPT09ZmFsc2UmJnN0cmluZ2lmeShlLHQsbik9PT1mYWxzZTtsZXQgQT1uLnRyYW5zZm9ybXx8dHJhbnNmb3JtKGYpO2lmKG4udG9SZWdleCYmcj09PTEpe3JldHVybiB0b1JhbmdlKHRvTWF4TGVuKGUscCksdG9NYXhMZW4odCxwKSx0cnVlLG4pfWxldCBSPXtuZWdhdGl2ZXM6W10scG9zaXRpdmVzOltdfTtsZXQgcHVzaD1lPT5SW2U8MD9cIm5lZ2F0aXZlc1wiOlwicG9zaXRpdmVzXCJdLnB1c2goTWF0aC5hYnMoZSkpO2xldCBfPVtdO2xldCBoPTA7d2hpbGUobz91Pj1zOnU8PXMpe2lmKG4udG9SZWdleD09PXRydWUmJnI+MSl7cHVzaCh1KX1lbHNle18ucHVzaChwYWQoQSh1LGgpLHAsZikpfXU9bz91LXI6dStyO2grK31pZihuLnRvUmVnZXg9PT10cnVlKXtyZXR1cm4gcj4xP3RvU2VxdWVuY2UoUixuKTp0b1JlZ2V4KF8sbnVsbCx7d3JhcDpmYWxzZSwuLi5ufSl9cmV0dXJuIF99O2NvbnN0IGZpbGxMZXR0ZXJzPShlLHQscj0xLG49e30pPT57aWYoIWlzTnVtYmVyKGUpJiZlLmxlbmd0aD4xfHwhaXNOdW1iZXIodCkmJnQubGVuZ3RoPjEpe3JldHVybiBpbnZhbGlkUmFuZ2UoZSx0LG4pfWxldCB1PW4udHJhbnNmb3JtfHwoZT0+U3RyaW5nLmZyb21DaGFyQ29kZShlKSk7bGV0IHM9YCR7ZX1gLmNoYXJDb2RlQXQoMCk7bGV0IG89YCR7dH1gLmNoYXJDb2RlQXQoMCk7bGV0IGk9cz5vO2xldCBhPU1hdGgubWluKHMsbyk7bGV0IGw9TWF0aC5tYXgocyxvKTtpZihuLnRvUmVnZXgmJnI9PT0xKXtyZXR1cm4gdG9SYW5nZShhLGwsZmFsc2Usbil9bGV0IGM9W107bGV0IHA9MDt3aGlsZShpP3M+PW86czw9byl7Yy5wdXNoKHUocyxwKSk7cz1pP3MtcjpzK3I7cCsrfWlmKG4udG9SZWdleD09PXRydWUpe3JldHVybiB0b1JlZ2V4KGMsbnVsbCx7d3JhcDpmYWxzZSxvcHRpb25zOm59KX1yZXR1cm4gY307Y29uc3QgZmlsbD0oZSx0LHIsbj17fSk9PntpZih0PT1udWxsJiZpc1ZhbGlkVmFsdWUoZSkpe3JldHVybltlXX1pZighaXNWYWxpZFZhbHVlKGUpfHwhaXNWYWxpZFZhbHVlKHQpKXtyZXR1cm4gaW52YWxpZFJhbmdlKGUsdCxuKX1pZih0eXBlb2Ygcj09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZpbGwoZSx0LDEse3RyYW5zZm9ybTpyfSl9aWYoaXNPYmplY3Qocikpe3JldHVybiBmaWxsKGUsdCwwLHIpfWxldCB1PXsuLi5ufTtpZih1LmNhcHR1cmU9PT10cnVlKXUud3JhcD10cnVlO3I9cnx8dS5zdGVwfHwxO2lmKCFpc051bWJlcihyKSl7aWYociE9bnVsbCYmIWlzT2JqZWN0KHIpKXJldHVybiBpbnZhbGlkU3RlcChyLHUpO3JldHVybiBmaWxsKGUsdCwxLHIpfWlmKGlzTnVtYmVyKGUpJiZpc051bWJlcih0KSl7cmV0dXJuIGZpbGxOdW1iZXJzKGUsdCxyLHUpfXJldHVybiBmaWxsTGV0dGVycyhlLHQsTWF0aC5tYXgoTWF0aC5hYnMociksMSksdSl9O2UuZXhwb3J0cz1maWxsfSwzNTc6ZT0+e1xuLyohXG4gKiBpcy1udW1iZXIgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLW51bWJlcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmUuZXhwb3J0cz1mdW5jdGlvbihlKXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3JldHVybiBlLWU9PT0wfWlmKHR5cGVvZiBlPT09XCJzdHJpbmdcIiYmZS50cmltKCkhPT1cIlwiKXtyZXR1cm4gTnVtYmVyLmlzRmluaXRlP051bWJlci5pc0Zpbml0ZSgrZSk6aXNGaW5pdGUoK2UpfXJldHVybiBmYWxzZX19LDk3MTooZSx0LHIpPT57Y29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDMzMyk7Y29uc3Qgcz1yKDI1MSk7Y29uc3Qgbz1yKDUxMyk7Y29uc3QgaXNFbXB0eVN0cmluZz1lPT5lPT09XCJcInx8ZT09PVwiLi9cIjtjb25zdCBtaWNyb21hdGNoPShlLHQscik9Pnt0PVtdLmNvbmNhdCh0KTtlPVtdLmNvbmNhdChlKTtsZXQgbj1uZXcgU2V0O2xldCB1PW5ldyBTZXQ7bGV0IG89bmV3IFNldDtsZXQgaT0wO2xldCBvblJlc3VsdD1lPT57by5hZGQoZS5vdXRwdXQpO2lmKHImJnIub25SZXN1bHQpe3Iub25SZXN1bHQoZSl9fTtmb3IobGV0IG89MDtvPHQubGVuZ3RoO28rKyl7bGV0IGE9cyhTdHJpbmcodFtvXSksey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9LHRydWUpO2xldCBsPWEuc3RhdGUubmVnYXRlZHx8YS5zdGF0ZS5uZWdhdGVkRXh0Z2xvYjtpZihsKWkrKztmb3IobGV0IHQgb2YgZSl7bGV0IGU9YSh0LHRydWUpO2xldCByPWw/IWUuaXNNYXRjaDplLmlzTWF0Y2g7aWYoIXIpY29udGludWU7aWYobCl7bi5hZGQoZS5vdXRwdXQpfWVsc2V7bi5kZWxldGUoZS5vdXRwdXQpO3UuYWRkKGUub3V0cHV0KX19fWxldCBhPWk9PT10Lmxlbmd0aD9bLi4ub106Wy4uLnVdO2xldCBsPWEuZmlsdGVyKChlPT4hbi5oYXMoZSkpKTtpZihyJiZsLmxlbmd0aD09PTApe2lmKHIuZmFpbGdsb2I9PT10cnVlKXt0aHJvdyBuZXcgRXJyb3IoYE5vIG1hdGNoZXMgZm91bmQgZm9yIFwiJHt0LmpvaW4oXCIsIFwiKX1cImApfWlmKHIubm9udWxsPT09dHJ1ZXx8ci5udWxsZ2xvYj09PXRydWUpe3JldHVybiByLnVuZXNjYXBlP3QubWFwKChlPT5lLnJlcGxhY2UoL1xcXFwvZyxcIlwiKSkpOnR9fXJldHVybiBsfTttaWNyb21hdGNoLm1hdGNoPW1pY3JvbWF0Y2g7bWljcm9tYXRjaC5tYXRjaGVyPShlLHQpPT5zKGUsdCk7bWljcm9tYXRjaC5pc01hdGNoPShlLHQscik9PnModCxyKShlKTttaWNyb21hdGNoLmFueT1taWNyb21hdGNoLmlzTWF0Y2g7bWljcm9tYXRjaC5ub3Q9KGUsdCxyPXt9KT0+e3Q9W10uY29uY2F0KHQpLm1hcChTdHJpbmcpO2xldCBuPW5ldyBTZXQ7bGV0IHU9W107bGV0IG9uUmVzdWx0PWU9PntpZihyLm9uUmVzdWx0KXIub25SZXN1bHQoZSk7dS5wdXNoKGUub3V0cHV0KX07bGV0IHM9bWljcm9tYXRjaChlLHQsey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9KTtmb3IobGV0IGUgb2YgdSl7aWYoIXMuaW5jbHVkZXMoZSkpe24uYWRkKGUpfX1yZXR1cm5bLi4ubl19O21pY3JvbWF0Y2guY29udGFpbnM9KGUsdCxyKT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmc6IFwiJHtuLmluc3BlY3QoZSl9XCJgKX1pZihBcnJheS5pc0FycmF5KHQpKXtyZXR1cm4gdC5zb21lKCh0PT5taWNyb21hdGNoLmNvbnRhaW5zKGUsdCxyKSkpfWlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7aWYoaXNFbXB0eVN0cmluZyhlKXx8aXNFbXB0eVN0cmluZyh0KSl7cmV0dXJuIGZhbHNlfWlmKGUuaW5jbHVkZXModCl8fGUuc3RhcnRzV2l0aChcIi4vXCIpJiZlLnNsaWNlKDIpLmluY2x1ZGVzKHQpKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIG1pY3JvbWF0Y2guaXNNYXRjaChlLHQsey4uLnIsY29udGFpbnM6dHJ1ZX0pfTttaWNyb21hdGNoLm1hdGNoS2V5cz0oZSx0LHIpPT57aWYoIW8uaXNPYmplY3QoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0XCIpfWxldCBuPW1pY3JvbWF0Y2goT2JqZWN0LmtleXMoZSksdCxyKTtsZXQgdT17fTtmb3IobGV0IHQgb2Ygbil1W3RdPWVbdF07cmV0dXJuIHV9O21pY3JvbWF0Y2guc29tZT0oZSx0LHIpPT57bGV0IG49W10uY29uY2F0KGUpO2ZvcihsZXQgZSBvZltdLmNvbmNhdCh0KSl7bGV0IHQ9cyhTdHJpbmcoZSkscik7aWYobi5zb21lKChlPT50KGUpKSkpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O21pY3JvbWF0Y2guZXZlcnk9KGUsdCxyKT0+e2xldCBuPVtdLmNvbmNhdChlKTtmb3IobGV0IGUgb2ZbXS5jb25jYXQodCkpe2xldCB0PXMoU3RyaW5nKGUpLHIpO2lmKCFuLmV2ZXJ5KChlPT50KGUpKSkpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9O21pY3JvbWF0Y2guYWxsPShlLHQscik9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nOiBcIiR7bi5pbnNwZWN0KGUpfVwiYCl9cmV0dXJuW10uY29uY2F0KHQpLmV2ZXJ5KCh0PT5zKHQscikoZSkpKX07bWljcm9tYXRjaC5jYXB0dXJlPShlLHQscik9PntsZXQgbj1vLmlzV2luZG93cyhyKTtsZXQgdT1zLm1ha2VSZShTdHJpbmcoZSksey4uLnIsY2FwdHVyZTp0cnVlfSk7bGV0IGk9dS5leGVjKG4/by50b1Bvc2l4U2xhc2hlcyh0KTp0KTtpZihpKXtyZXR1cm4gaS5zbGljZSgxKS5tYXAoKGU9PmU9PT12b2lkIDA/XCJcIjplKSl9fTttaWNyb21hdGNoLm1ha2VSZT0oLi4uZSk9PnMubWFrZVJlKC4uLmUpO21pY3JvbWF0Y2guc2Nhbj0oLi4uZSk9PnMuc2NhbiguLi5lKTttaWNyb21hdGNoLnBhcnNlPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBuIG9mW10uY29uY2F0KGV8fFtdKSl7Zm9yKGxldCBlIG9mIHUoU3RyaW5nKG4pLHQpKXtyLnB1c2gocy5wYXJzZShlLHQpKX19cmV0dXJuIHJ9O21pY3JvbWF0Y2guYnJhY2VzPShlLHQpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtpZih0JiZ0Lm5vYnJhY2U9PT10cnVlfHwhL1xcey4qXFx9Ly50ZXN0KGUpKXtyZXR1cm5bZV19cmV0dXJuIHUoZSx0KX07bWljcm9tYXRjaC5icmFjZUV4cGFuZD0oZSx0KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIik7cmV0dXJuIG1pY3JvbWF0Y2guYnJhY2VzKGUsey4uLnQsZXhwYW5kOnRydWV9KX07ZS5leHBvcnRzPW1pY3JvbWF0Y2h9LDI1MTooZSx0LHIpPT57ZS5leHBvcnRzPXIoNjgzKX0sMzU2OihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9XCJcXFxcXFxcXC9cIjtjb25zdCBzPWBbXiR7dX1dYDtjb25zdCBvPVwiXFxcXC5cIjtjb25zdCBpPVwiXFxcXCtcIjtjb25zdCBhPVwiXFxcXD9cIjtjb25zdCBsPVwiXFxcXC9cIjtjb25zdCBjPVwiKD89LilcIjtjb25zdCBwPVwiW14vXVwiO2NvbnN0IGY9YCg/OiR7bH18JClgO2NvbnN0IEE9YCg/Ol58JHtsfSlgO2NvbnN0IFI9YCR7b317MSwyfSR7Zn1gO2NvbnN0IF89YCg/ISR7b30pYDtjb25zdCBoPWAoPyEke0F9JHtSfSlgO2NvbnN0IGc9YCg/ISR7b317MCwxfSR7Zn0pYDtjb25zdCBFPWAoPyEke1J9KWA7Y29uc3QgQz1gW14uJHtsfV1gO2NvbnN0IHk9YCR7cH0qP2A7Y29uc3QgZD17RE9UX0xJVEVSQUw6byxQTFVTX0xJVEVSQUw6aSxRTUFSS19MSVRFUkFMOmEsU0xBU0hfTElURVJBTDpsLE9ORV9DSEFSOmMsUU1BUks6cCxFTkRfQU5DSE9SOmYsRE9UU19TTEFTSDpSLE5PX0RPVDpfLE5PX0RPVFM6aCxOT19ET1RfU0xBU0g6ZyxOT19ET1RTX1NMQVNIOkUsUU1BUktfTk9fRE9UOkMsU1RBUjp5LFNUQVJUX0FOQ0hPUjpBfTtjb25zdCB4PXsuLi5kLFNMQVNIX0xJVEVSQUw6YFske3V9XWAsUU1BUks6cyxTVEFSOmAke3N9Kj9gLERPVFNfU0xBU0g6YCR7b317MSwyfSg/Olske3V9XXwkKWAsTk9fRE9UOmAoPyEke299KWAsTk9fRE9UUzpgKD8hKD86XnxbJHt1fV0pJHtvfXsxLDJ9KD86WyR7dX1dfCQpKWAsTk9fRE9UX1NMQVNIOmAoPyEke299ezAsMX0oPzpbJHt1fV18JCkpYCxOT19ET1RTX1NMQVNIOmAoPyEke299ezEsMn0oPzpbJHt1fV18JCkpYCxRTUFSS19OT19ET1Q6YFteLiR7dX1dYCxTVEFSVF9BTkNIT1I6YCg/Ol58WyR7dX1dKWAsRU5EX0FOQ0hPUjpgKD86WyR7dX1dfCQpYH07Y29uc3QgYj17YWxudW06XCJhLXpBLVowLTlcIixhbHBoYTpcImEtekEtWlwiLGFzY2lpOlwiXFxcXHgwMC1cXFxceDdGXCIsYmxhbms6XCIgXFxcXHRcIixjbnRybDpcIlxcXFx4MDAtXFxcXHgxRlxcXFx4N0ZcIixkaWdpdDpcIjAtOVwiLGdyYXBoOlwiXFxcXHgyMS1cXFxceDdFXCIsbG93ZXI6XCJhLXpcIixwcmludDpcIlxcXFx4MjAtXFxcXHg3RSBcIixwdW5jdDpcIlxcXFwtIVxcXCIjJCUmJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX5cIixzcGFjZTpcIiBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmXCIsdXBwZXI6XCJBLVpcIix3b3JkOlwiQS1aYS16MC05X1wiLHhkaWdpdDpcIkEtRmEtZjAtOVwifTtlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxQT1NJWF9SRUdFWF9TT1VSQ0U6YixSRUdFWF9CQUNLU0xBU0g6L1xcXFwoPyFbKis/XiR7fSh8KVtcXF1dKS9nLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOi9eW15AIVtcXF0uLCQqKz9ee30oKXxcXFxcL10rLyxSRUdFWF9TUEVDSUFMX0NIQVJTOi9bLSorPy5eJHt9KHwpW1xcXV0vLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjovKFxcXFw/KSgoXFxXKShcXDMqKSkvZyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDovKFstKis/Ll4ke30ofClbXFxdXSkvZyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOi8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxSRVBMQUNFTUVOVFM6e1wiKioqXCI6XCIqXCIsXCIqKi8qKlwiOlwiKipcIixcIioqLyoqLyoqXCI6XCIqKlwifSxDSEFSXzA6NDgsQ0hBUl85OjU3LENIQVJfVVBQRVJDQVNFX0E6NjUsQ0hBUl9MT1dFUkNBU0VfQTo5NyxDSEFSX1VQUEVSQ0FTRV9aOjkwLENIQVJfTE9XRVJDQVNFX1o6MTIyLENIQVJfTEVGVF9QQVJFTlRIRVNFUzo0MCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOjQxLENIQVJfQVNURVJJU0s6NDIsQ0hBUl9BTVBFUlNBTkQ6MzgsQ0hBUl9BVDo2NCxDSEFSX0JBQ0tXQVJEX1NMQVNIOjkyLENIQVJfQ0FSUklBR0VfUkVUVVJOOjEzLENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6OTQsQ0hBUl9DT0xPTjo1OCxDSEFSX0NPTU1BOjQ0LENIQVJfRE9UOjQ2LENIQVJfRE9VQkxFX1FVT1RFOjM0LENIQVJfRVFVQUw6NjEsQ0hBUl9FWENMQU1BVElPTl9NQVJLOjMzLENIQVJfRk9STV9GRUVEOjEyLENIQVJfRk9SV0FSRF9TTEFTSDo0NyxDSEFSX0dSQVZFX0FDQ0VOVDo5NixDSEFSX0hBU0g6MzUsQ0hBUl9IWVBIRU5fTUlOVVM6NDUsQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6NjAsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOjEyMyxDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6OTEsQ0hBUl9MSU5FX0ZFRUQ6MTAsQ0hBUl9OT19CUkVBS19TUEFDRToxNjAsQ0hBUl9QRVJDRU5UOjM3LENIQVJfUExVUzo0MyxDSEFSX1FVRVNUSU9OX01BUks6NjMsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOjYyLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6MTI1LENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6OTMsQ0hBUl9TRU1JQ09MT046NTksQ0hBUl9TSU5HTEVfUVVPVEU6MzksQ0hBUl9TUEFDRTozMixDSEFSX1RBQjo5LENIQVJfVU5ERVJTQ09SRTo5NSxDSEFSX1ZFUlRJQ0FMX0xJTkU6MTI0LENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOjY1Mjc5LFNFUDpuLnNlcCxleHRnbG9iQ2hhcnMoZSl7cmV0dXJue1wiIVwiOnt0eXBlOlwibmVnYXRlXCIsb3BlbjpcIig/Oig/ISg/OlwiLGNsb3NlOmApKSR7ZS5TVEFSfSlgfSxcIj9cIjp7dHlwZTpcInFtYXJrXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKT9cIn0sXCIrXCI6e3R5cGU6XCJwbHVzXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKStcIn0sXCIqXCI6e3R5cGU6XCJzdGFyXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKSpcIn0sXCJAXCI6e3R5cGU6XCJhdFwiLG9wZW46XCIoPzpcIixjbG9zZTpcIilcIn19fSxnbG9iQ2hhcnMoZSl7cmV0dXJuIGU9PT10cnVlP3g6ZH19fSw3NTQ6KGUsdCxyKT0+e2NvbnN0IG49cigzNTYpO2NvbnN0IHU9cig1MTMpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6byxSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjphLFJFUExBQ0VNRU5UUzpsfT1uO2NvbnN0IGV4cGFuZFJhbmdlPShlLHQpPT57aWYodHlwZW9mIHQuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiB0LmV4cGFuZFJhbmdlKC4uLmUsdCl9ZS5zb3J0KCk7Y29uc3Qgcj1gWyR7ZS5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cChyKX1jYXRjaCh0KXtyZXR1cm4gZS5tYXAoKGU9PnUuZXNjYXBlUmVnZXgoZSkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHJ9O2NvbnN0IHN5bnRheEVycm9yPShlLHQpPT5gTWlzc2luZyAke2V9OiBcIiR7dH1cIiAtIHVzZSBcIlxcXFxcXFxcJHt0fVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KGUsdCk9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX1lPWxbZV18fGU7Y29uc3Qgcj17Li4udH07Y29uc3QgYz10eXBlb2Ygci5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsci5tYXhMZW5ndGgpOnM7bGV0IHA9ZS5sZW5ndGg7aWYocD5jKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtwfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke2N9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnIucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgUj1yLmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgXz11LmlzV2luZG93cyh0KTtjb25zdCBoPW4uZ2xvYkNoYXJzKF8pO2NvbnN0IGc9bi5leHRnbG9iQ2hhcnMoaCk7Y29uc3R7RE9UX0xJVEVSQUw6RSxQTFVTX0xJVEVSQUw6QyxTTEFTSF9MSVRFUkFMOnksT05FX0NIQVI6ZCxET1RTX1NMQVNIOngsTk9fRE9UOmIsTk9fRE9UX1NMQVNIOlMsTk9fRE9UU19TTEFTSDpILFFNQVJLOnYsUU1BUktfTk9fRE9UOiQsU1RBUjptLFNUQVJUX0FOQ0hPUjpUfT1oO2NvbnN0IGdsb2JzdGFyPWU9PmAoJHtSfSg/Oig/ISR7VH0ke2UuZG90P3g6RX0pLikqPylgO2NvbnN0IEw9ci5kb3Q/XCJcIjpiO2NvbnN0IE89ci5kb3Q/djokO2xldCB3PXIuYmFzaD09PXRydWU/Z2xvYnN0YXIocik6bTtpZihyLmNhcHR1cmUpe3c9YCgke3d9KWB9aWYodHlwZW9mIHIubm9leHQ9PT1cImJvb2xlYW5cIil7ci5ub2V4dGdsb2I9ci5ub2V4dH1jb25zdCBOPXtpbnB1dDplLGluZGV4Oi0xLHN0YXJ0OjAsZG90OnIuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O2U9dS5yZW1vdmVQcmVmaXgoZSxOKTtwPWUubGVuZ3RoO2NvbnN0IGs9W107Y29uc3QgST1bXTtjb25zdCBNPVtdO2xldCBQPWY7bGV0IEI7Y29uc3QgZW9zPSgpPT5OLmluZGV4PT09cC0xO2NvbnN0IEc9Ti5wZWVrPSh0PTEpPT5lW04uaW5kZXgrdF07Y29uc3QgRD1OLmFkdmFuY2U9KCk9PmVbKytOLmluZGV4XTtjb25zdCByZW1haW5pbmc9KCk9PmUuc2xpY2UoTi5pbmRleCsxKTtjb25zdCBjb25zdW1lPShlPVwiXCIsdD0wKT0+e04uY29uc3VtZWQrPWU7Ti5pbmRleCs9dH07Y29uc3QgYXBwZW5kPWU9PntOLm91dHB1dCs9ZS5vdXRwdXQhPW51bGw/ZS5vdXRwdXQ6ZS52YWx1ZTtjb25zdW1lKGUudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgZT0xO3doaWxlKEcoKT09PVwiIVwiJiYoRygyKSE9PVwiKFwifHxHKDMpPT09XCI/XCIpKXtEKCk7Ti5zdGFydCsrO2UrK31pZihlJTI9PT0wKXtyZXR1cm4gZmFsc2V9Ti5uZWdhdGVkPXRydWU7Ti5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9ZT0+e05bZV0rKztNLnB1c2goZSl9O2NvbnN0IGRlY3JlbWVudD1lPT57TltlXS0tO00ucG9wKCl9O2NvbnN0IHB1c2g9ZT0+e2lmKFAudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgdD1OLmJyYWNlcz4wJiYoZS50eXBlPT09XCJjb21tYVwifHxlLnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHI9ZS5leHRnbG9iPT09dHJ1ZXx8ay5sZW5ndGgmJihlLnR5cGU9PT1cInBpcGVcInx8ZS50eXBlPT09XCJwYXJlblwiKTtpZihlLnR5cGUhPT1cInNsYXNoXCImJmUudHlwZSE9PVwicGFyZW5cIiYmIXQmJiFyKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC1QLm91dHB1dC5sZW5ndGgpO1AudHlwZT1cInN0YXJcIjtQLnZhbHVlPVwiKlwiO1Aub3V0cHV0PXc7Ti5vdXRwdXQrPVAub3V0cHV0fX1pZihrLmxlbmd0aCYmZS50eXBlIT09XCJwYXJlblwiJiYhZ1tlLnZhbHVlXSl7a1trLmxlbmd0aC0xXS5pbm5lcis9ZS52YWx1ZX1pZihlLnZhbHVlfHxlLm91dHB1dClhcHBlbmQoZSk7aWYoUCYmUC50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtQLnZhbHVlKz1lLnZhbHVlO1Aub3V0cHV0PShQLm91dHB1dHx8XCJcIikrZS52YWx1ZTtyZXR1cm59ZS5wcmV2PVA7QS5wdXNoKGUpO1A9ZX07Y29uc3QgZXh0Z2xvYk9wZW49KGUsdCk9Pntjb25zdCBuPXsuLi5nW3RdLGNvbmRpdGlvbnM6MSxpbm5lcjpcIlwifTtuLnByZXY9UDtuLnBhcmVucz1OLnBhcmVucztuLm91dHB1dD1OLm91dHB1dDtjb25zdCB1PShyLmNhcHR1cmU/XCIoXCI6XCJcIikrbi5vcGVuO2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOmUsdmFsdWU6dCxvdXRwdXQ6Ti5vdXRwdXQ/XCJcIjpkfSk7cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkQoKSxvdXRwdXQ6dX0pO2sucHVzaChuKX07Y29uc3QgZXh0Z2xvYkNsb3NlPWU9PntsZXQgdD1lLmNsb3NlKyhyLmNhcHR1cmU/XCIpXCI6XCJcIik7aWYoZS50eXBlPT09XCJuZWdhdGVcIil7bGV0IG49dztpZihlLmlubmVyJiZlLmlubmVyLmxlbmd0aD4xJiZlLmlubmVyLmluY2x1ZGVzKFwiL1wiKSl7bj1nbG9ic3RhcihyKX1pZihuIT09d3x8ZW9zKCl8fC9eXFwpKyQvLnRlc3QocmVtYWluaW5nKCkpKXt0PWUuY2xvc2U9YCkkKSkke259YH1pZihlLnByZXYudHlwZT09PVwiYm9zXCIpe04ubmVnYXRlZEV4dGdsb2I9dHJ1ZX19cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9O2lmKHIuZmFzdHBhdGhzIT09ZmFsc2UmJiEvKF5bKiFdfFsvKClbXFxde31cIl0pLy50ZXN0KGUpKXtsZXQgbj1mYWxzZTtsZXQgcz1lLnJlcGxhY2UoYSwoKGUsdCxyLHUscyxvKT0+e2lmKHU9PT1cIlxcXFxcIil7bj10cnVlO3JldHVybiBlfWlmKHU9PT1cIj9cIil7aWYodCl7cmV0dXJuIHQrdSsocz92LnJlcGVhdChzLmxlbmd0aCk6XCJcIil9aWYobz09PTApe3JldHVybiBPKyhzP3YucmVwZWF0KHMubGVuZ3RoKTpcIlwiKX1yZXR1cm4gdi5yZXBlYXQoci5sZW5ndGgpfWlmKHU9PT1cIi5cIil7cmV0dXJuIEUucmVwZWF0KHIubGVuZ3RoKX1pZih1PT09XCIqXCIpe2lmKHQpe3JldHVybiB0K3UrKHM/dzpcIlwiKX1yZXR1cm4gd31yZXR1cm4gdD9lOmBcXFxcJHtlfWB9KSk7aWYobj09PXRydWUpe2lmKHIudW5lc2NhcGU9PT10cnVlKXtzPXMucmVwbGFjZSgvXFxcXC9nLFwiXCIpfWVsc2V7cz1zLnJlcGxhY2UoL1xcXFwrL2csKGU9PmUubGVuZ3RoJTI9PT0wP1wiXFxcXFxcXFxcIjplP1wiXFxcXFwiOlwiXCIpKX19aWYocz09PWUmJnIuY29udGFpbnM9PT10cnVlKXtOLm91dHB1dD1lO3JldHVybiBOfU4ub3V0cHV0PXUud3JhcE91dHB1dChzLE4sdCk7cmV0dXJuIE59d2hpbGUoIWVvcygpKXtCPUQoKTtpZihCPT09XCJcXDBcIil7Y29udGludWV9aWYoQj09PVwiXFxcXFwiKXtjb25zdCBlPUcoKTtpZihlPT09XCIvXCImJnIuYmFzaCE9PXRydWUpe2NvbnRpbnVlfWlmKGU9PT1cIi5cInx8ZT09PVwiO1wiKXtjb250aW51ZX1pZighZSl7Qis9XCJcXFxcXCI7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9Y29uc3QgdD0vXlxcXFwrLy5leGVjKHJlbWFpbmluZygpKTtsZXQgbj0wO2lmKHQmJnRbMF0ubGVuZ3RoPjIpe249dFswXS5sZW5ndGg7Ti5pbmRleCs9bjtpZihuJTIhPT0wKXtCKz1cIlxcXFxcIn19aWYoci51bmVzY2FwZT09PXRydWUpe0I9RCgpfHxcIlwifWVsc2V7Qis9RCgpfHxcIlwifWlmKE4uYnJhY2tldHM9PT0wKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX19aWYoTi5icmFja2V0cz4wJiYoQiE9PVwiXVwifHxQLnZhbHVlPT09XCJbXCJ8fFAudmFsdWU9PT1cIlteXCIpKXtpZihyLnBvc2l4IT09ZmFsc2UmJkI9PT1cIjpcIil7Y29uc3QgZT1QLnZhbHVlLnNsaWNlKDEpO2lmKGUuaW5jbHVkZXMoXCJbXCIpKXtQLnBvc2l4PXRydWU7aWYoZS5pbmNsdWRlcyhcIjpcIikpe2NvbnN0IGU9UC52YWx1ZS5sYXN0SW5kZXhPZihcIltcIik7Y29uc3QgdD1QLnZhbHVlLnNsaWNlKDAsZSk7Y29uc3Qgcj1QLnZhbHVlLnNsaWNlKGUrMik7Y29uc3Qgbj1vW3JdO2lmKG4pe1AudmFsdWU9dCtuO04uYmFja3RyYWNrPXRydWU7RCgpO2lmKCFmLm91dHB1dCYmQS5pbmRleE9mKFApPT09MSl7Zi5vdXRwdXQ9ZH1jb250aW51ZX19fX1pZihCPT09XCJbXCImJkcoKSE9PVwiOlwifHxCPT09XCItXCImJkcoKT09PVwiXVwiKXtCPWBcXFxcJHtCfWB9aWYoQj09PVwiXVwiJiYoUC52YWx1ZT09PVwiW1wifHxQLnZhbHVlPT09XCJbXlwiKSl7Qj1gXFxcXCR7Qn1gfWlmKHIucG9zaXg9PT10cnVlJiZCPT09XCIhXCImJlAudmFsdWU9PT1cIltcIil7Qj1cIl5cIn1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKE4ucXVvdGVzPT09MSYmQiE9PSdcIicpe0I9dS5lc2NhcGVSZWdleChCKTtQLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT0nXCInKXtOLnF1b3Rlcz1OLnF1b3Rlcz09PTE/MDoxO2lmKHIua2VlcFF1b3Rlcz09PXRydWUpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pfWNvbnRpbnVlfWlmKEI9PT1cIihcIil7aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6XCJwYXJlblwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihCPT09XCIpXCIpe2lmKE4ucGFyZW5zPT09MCYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIihcIikpfWNvbnN0IGU9a1trLmxlbmd0aC0xXTtpZihlJiZOLnBhcmVucz09PWUucGFyZW5zKzEpe2V4dGdsb2JDbG9zZShrLnBvcCgpKTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpCLG91dHB1dDpOLnBhcmVucz9cIilcIjpcIlxcXFwpXCJ9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIik7Y29udGludWV9aWYoQj09PVwiW1wiKXtpZihyLm5vYnJhY2tldD09PXRydWV8fCFyZW1haW5pbmcoKS5pbmNsdWRlcyhcIl1cIikpe2lmKHIubm9icmFja2V0IT09dHJ1ZSYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpfUI9YFxcXFwke0J9YH1lbHNle2luY3JlbWVudChcImJyYWNrZXRzXCIpfXB1c2goe3R5cGU6XCJicmFja2V0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIl1cIil7aWYoci5ub2JyYWNrZXQ9PT10cnVlfHxQJiZQLnR5cGU9PT1cImJyYWNrZXRcIiYmUC52YWx1ZS5sZW5ndGg9PT0xKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OmBcXFxcJHtCfWB9KTtjb250aW51ZX1pZihOLmJyYWNrZXRzPT09MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIltcIikpfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6YFxcXFwke0J9YH0pO2NvbnRpbnVlfWRlY3JlbWVudChcImJyYWNrZXRzXCIpO2NvbnN0IGU9UC52YWx1ZS5zbGljZSgxKTtpZihQLnBvc2l4IT09dHJ1ZSYmZVswXT09PVwiXlwiJiYhZS5pbmNsdWRlcyhcIi9cIikpe0I9YC8ke0J9YH1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2lmKHIubGl0ZXJhbEJyYWNrZXRzPT09ZmFsc2V8fHUuaGFzUmVnZXhDaGFycyhlKSl7Y29udGludWV9Y29uc3QgdD11LmVzY2FwZVJlZ2V4KFAudmFsdWUpO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLVAudmFsdWUubGVuZ3RoKTtpZihyLmxpdGVyYWxCcmFja2V0cz09PXRydWUpe04ub3V0cHV0Kz10O1AudmFsdWU9dDtjb250aW51ZX1QLnZhbHVlPWAoJHtSfSR7dH18JHtQLnZhbHVlfSlgO04ub3V0cHV0Kz1QLnZhbHVlO2NvbnRpbnVlfWlmKEI9PT1cIntcIiYmci5ub2JyYWNlIT09dHJ1ZSl7aW5jcmVtZW50KFwiYnJhY2VzXCIpO2NvbnN0IGU9e3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OlwiKFwiLG91dHB1dEluZGV4Ok4ub3V0cHV0Lmxlbmd0aCx0b2tlbnNJbmRleDpOLnRva2Vucy5sZW5ndGh9O0kucHVzaChlKTtwdXNoKGUpO2NvbnRpbnVlfWlmKEI9PT1cIn1cIil7Y29uc3QgZT1JW0kubGVuZ3RoLTFdO2lmKHIubm9icmFjZT09PXRydWV8fCFlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OkJ9KTtjb250aW51ZX1sZXQgdD1cIilcIjtpZihlLmRvdHM9PT10cnVlKXtjb25zdCBlPUEuc2xpY2UoKTtjb25zdCBuPVtdO2ZvcihsZXQgdD1lLmxlbmd0aC0xO3Q+PTA7dC0tKXtBLnBvcCgpO2lmKGVbdF0udHlwZT09PVwiYnJhY2VcIil7YnJlYWt9aWYoZVt0XS50eXBlIT09XCJkb3RzXCIpe24udW5zaGlmdChlW3RdLnZhbHVlKX19dD1leHBhbmRSYW5nZShuLHIpO04uYmFja3RyYWNrPXRydWV9aWYoZS5jb21tYSE9PXRydWUmJmUuZG90cyE9PXRydWUpe2NvbnN0IHI9Ti5vdXRwdXQuc2xpY2UoMCxlLm91dHB1dEluZGV4KTtjb25zdCBuPU4udG9rZW5zLnNsaWNlKGUudG9rZW5zSW5kZXgpO2UudmFsdWU9ZS5vdXRwdXQ9XCJcXFxce1wiO0I9dD1cIlxcXFx9XCI7Ti5vdXRwdXQ9cjtmb3IoY29uc3QgZSBvZiBuKXtOLm91dHB1dCs9ZS5vdXRwdXR8fGUudmFsdWV9fXB1c2goe3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJicmFjZXNcIik7SS5wb3AoKTtjb250aW51ZX1pZihCPT09XCJ8XCIpe2lmKGsubGVuZ3RoPjApe2tbay5sZW5ndGgtMV0uY29uZGl0aW9ucysrfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIixcIil7bGV0IGU9Qjtjb25zdCB0PUlbSS5sZW5ndGgtMV07aWYodCYmTVtNLmxlbmd0aC0xXT09PVwiYnJhY2VzXCIpe3QuY29tbWE9dHJ1ZTtlPVwifFwifXB1c2goe3R5cGU6XCJjb21tYVwiLHZhbHVlOkIsb3V0cHV0OmV9KTtjb250aW51ZX1pZihCPT09XCIvXCIpe2lmKFAudHlwZT09PVwiZG90XCImJk4uaW5kZXg9PT1OLnN0YXJ0KzEpe04uc3RhcnQ9Ti5pbmRleCsxO04uY29uc3VtZWQ9XCJcIjtOLm91dHB1dD1cIlwiO0EucG9wKCk7UD1mO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOkIsb3V0cHV0Onl9KTtjb250aW51ZX1pZihCPT09XCIuXCIpe2lmKE4uYnJhY2VzPjAmJlAudHlwZT09PVwiZG90XCIpe2lmKFAudmFsdWU9PT1cIi5cIilQLm91dHB1dD1FO2NvbnN0IGU9SVtJLmxlbmd0aC0xXTtQLnR5cGU9XCJkb3RzXCI7UC5vdXRwdXQrPUI7UC52YWx1ZSs9QjtlLmRvdHM9dHJ1ZTtjb250aW51ZX1pZihOLmJyYWNlcytOLnBhcmVucz09PTAmJlAudHlwZSE9PVwiYm9zXCImJlAudHlwZSE9PVwic2xhc2hcIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDpFfSk7Y29udGludWV9cHVzaCh7dHlwZTpcImRvdFwiLHZhbHVlOkIsb3V0cHV0OkV9KTtjb250aW51ZX1pZihCPT09XCI/XCIpe2NvbnN0IGU9UCYmUC52YWx1ZT09PVwiKFwiO2lmKCFlJiZyLm5vZXh0Z2xvYiE9PXRydWUmJkcoKT09PVwiKFwiJiZHKDIpIT09XCI/XCIpe2V4dGdsb2JPcGVuKFwicW1hcmtcIixCKTtjb250aW51ZX1pZihQJiZQLnR5cGU9PT1cInBhcmVuXCIpe2NvbnN0IGU9RygpO2xldCB0PUI7aWYoZT09PVwiPFwiJiYhdS5zdXBwb3J0c0xvb2tiZWhpbmRzKCkpe3Rocm93IG5ldyBFcnJvcihcIk5vZGUuanMgdjEwIG9yIGhpZ2hlciBpcyByZXF1aXJlZCBmb3IgcmVnZXggbG9va2JlaGluZHNcIil9aWYoUC52YWx1ZT09PVwiKFwiJiYhL1shPTw6XS8udGVzdChlKXx8ZT09PVwiPFwiJiYhLzwoWyE9XXxcXHcrPikvLnRlc3QocmVtYWluaW5nKCkpKXt0PWBcXFxcJHtCfWB9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDp0fSk7Y29udGludWV9aWYoci5kb3QhPT10cnVlJiYoUC50eXBlPT09XCJzbGFzaFwifHxQLnR5cGU9PT1cImJvc1wiKSl7cHVzaCh7dHlwZTpcInFtYXJrXCIsdmFsdWU6QixvdXRwdXQ6JH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkIsb3V0cHV0OnZ9KTtjb250aW51ZX1pZihCPT09XCIhXCIpe2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmRygpPT09XCIoXCIpe2lmKEcoMikhPT1cIj9cInx8IS9bIT08Ol0vLnRlc3QoRygzKSkpe2V4dGdsb2JPcGVuKFwibmVnYXRlXCIsQik7Y29udGludWV9fWlmKHIubm9uZWdhdGUhPT10cnVlJiZOLmluZGV4PT09MCl7bmVnYXRlKCk7Y29udGludWV9fWlmKEI9PT1cIitcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInBsdXNcIixCKTtjb250aW51ZX1pZihQJiZQLnZhbHVlPT09XCIoXCJ8fHIucmVnZXg9PT1mYWxzZSl7cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpCLG91dHB1dDpDfSk7Y29udGludWV9aWYoUCYmKFAudHlwZT09PVwiYnJhY2tldFwifHxQLnR5cGU9PT1cInBhcmVuXCJ8fFAudHlwZT09PVwiYnJhY2VcIil8fE4ucGFyZW5zPjApe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Qn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Q30pO2NvbnRpbnVlfWlmKEI9PT1cIkBcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtwdXNoKHt0eXBlOlwiYXRcIixleHRnbG9iOnRydWUsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEIhPT1cIipcIil7aWYoQj09PVwiJFwifHxCPT09XCJeXCIpe0I9YFxcXFwke0J9YH1jb25zdCBlPWkuZXhlYyhyZW1haW5pbmcoKSk7aWYoZSl7Qis9ZVswXTtOLmluZGV4Kz1lWzBdLmxlbmd0aH1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJnbG9ic3RhclwifHxQLnN0YXI9PT10cnVlKSl7UC50eXBlPVwic3RhclwiO1Auc3Rhcj10cnVlO1AudmFsdWUrPUI7UC5vdXRwdXQ9dztOLmJhY2t0cmFjaz10cnVlO04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWxldCB0PXJlbWFpbmluZygpO2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmL15cXChbXj9dLy50ZXN0KHQpKXtleHRnbG9iT3BlbihcInN0YXJcIixCKTtjb250aW51ZX1pZihQLnR5cGU9PT1cInN0YXJcIil7aWYoci5ub2dsb2JzdGFyPT09dHJ1ZSl7Y29uc3VtZShCKTtjb250aW51ZX1jb25zdCBuPVAucHJldjtjb25zdCB1PW4ucHJldjtjb25zdCBzPW4udHlwZT09PVwic2xhc2hcInx8bi50eXBlPT09XCJib3NcIjtjb25zdCBvPXUmJih1LnR5cGU9PT1cInN0YXJcInx8dS50eXBlPT09XCJnbG9ic3RhclwiKTtpZihyLmJhc2g9PT10cnVlJiYoIXN8fHRbMF0mJnRbMF0hPT1cIi9cIikpe3B1c2goe3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWNvbnN0IGk9Ti5icmFjZXM+MCYmKG4udHlwZT09PVwiY29tbWFcInx8bi50eXBlPT09XCJicmFjZVwiKTtjb25zdCBhPWsubGVuZ3RoJiYobi50eXBlPT09XCJwaXBlXCJ8fG4udHlwZT09PVwicGFyZW5cIik7aWYoIXMmJm4udHlwZSE9PVwicGFyZW5cIiYmIWkmJiFhKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX13aGlsZSh0LnNsaWNlKDAsMyk9PT1cIi8qKlwiKXtjb25zdCByPWVbTi5pbmRleCs0XTtpZihyJiZyIT09XCIvXCIpe2JyZWFrfXQ9dC5zbGljZSgzKTtjb25zdW1lKFwiLyoqXCIsMyl9aWYobi50eXBlPT09XCJib3NcIiYmZW9zKCkpe1AudHlwZT1cImdsb2JzdGFyXCI7UC52YWx1ZSs9QjtQLm91dHB1dD1nbG9ic3RhcihyKTtOLm91dHB1dD1QLm91dHB1dDtOLmdsb2JzdGFyPXRydWU7Y29uc3VtZShCKTtjb250aW51ZX1pZihuLnR5cGU9PT1cInNsYXNoXCImJm4ucHJldi50eXBlIT09XCJib3NcIiYmIW8mJmVvcygpKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrUC5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpKyhyLnN0cmljdFNsYXNoZXM/XCIpXCI6XCJ8JClcIik7UC52YWx1ZSs9QjtOLmdsb2JzdGFyPXRydWU7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O2NvbnN1bWUoQik7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJnRbMF09PT1cIi9cIil7Y29uc3QgZT10WzFdIT09dm9pZCAwP1wifCRcIjpcIlwiO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLShuLm91dHB1dCtQLm91dHB1dCkubGVuZ3RoKTtuLm91dHB1dD1gKD86JHtuLm91dHB1dH1gO1AudHlwZT1cImdsb2JzdGFyXCI7UC5vdXRwdXQ9YCR7Z2xvYnN0YXIocil9JHt5fXwke3l9JHtlfSlgO1AudmFsdWUrPUI7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIrRCgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWlmKG4udHlwZT09PVwiYm9zXCImJnRbMF09PT1cIi9cIil7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLnZhbHVlKz1CO1Aub3V0cHV0PWAoPzpefCR7eX18JHtnbG9ic3RhcihyKX0ke3l9KWA7Ti5vdXRwdXQ9UC5vdXRwdXQ7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQitEKCkpO3B1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOlwiL1wiLG91dHB1dDpcIlwifSk7Y29udGludWV9Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtUC5vdXRwdXQubGVuZ3RoKTtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpO1AudmFsdWUrPUI7Ti5vdXRwdXQrPVAub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWNvbnN0IG49e3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6d307aWYoci5iYXNoPT09dHJ1ZSl7bi5vdXRwdXQ9XCIuKj9cIjtpZihQLnR5cGU9PT1cImJvc1wifHxQLnR5cGU9PT1cInNsYXNoXCIpe24ub3V0cHV0PUwrbi5vdXRwdXR9cHVzaChuKTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJicmFja2V0XCJ8fFAudHlwZT09PVwicGFyZW5cIikmJnIucmVnZXg9PT10cnVlKXtuLm91dHB1dD1CO3B1c2gobik7Y29udGludWV9aWYoTi5pbmRleD09PU4uc3RhcnR8fFAudHlwZT09PVwic2xhc2hcInx8UC50eXBlPT09XCJkb3RcIil7aWYoUC50eXBlPT09XCJkb3RcIil7Ti5vdXRwdXQrPVM7UC5vdXRwdXQrPVN9ZWxzZSBpZihyLmRvdD09PXRydWUpe04ub3V0cHV0Kz1IO1Aub3V0cHV0Kz1IfWVsc2V7Ti5vdXRwdXQrPUw7UC5vdXRwdXQrPUx9aWYoRygpIT09XCIqXCIpe04ub3V0cHV0Kz1kO1Aub3V0cHV0Kz1kfX1wdXNoKG4pfXdoaWxlKE4uYnJhY2tldHM+MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiXVwiKSk7Ti5vdXRwdXQ9dS5lc2NhcGVMYXN0KE4ub3V0cHV0LFwiW1wiKTtkZWNyZW1lbnQoXCJicmFja2V0c1wiKX13aGlsZShOLnBhcmVucz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCIpXCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCIoXCIpO2RlY3JlbWVudChcInBhcmVuc1wiKX13aGlsZShOLmJyYWNlcz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJ9XCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCJ7XCIpO2RlY3JlbWVudChcImJyYWNlc1wiKX1pZihyLnN0cmljdFNsYXNoZXMhPT10cnVlJiYoUC50eXBlPT09XCJzdGFyXCJ8fFAudHlwZT09PVwiYnJhY2tldFwiKSl7cHVzaCh7dHlwZTpcIm1heWJlX3NsYXNoXCIsdmFsdWU6XCJcIixvdXRwdXQ6YCR7eX0/YH0pfWlmKE4uYmFja3RyYWNrPT09dHJ1ZSl7Ti5vdXRwdXQ9XCJcIjtmb3IoY29uc3QgZSBvZiBOLnRva2Vucyl7Ti5vdXRwdXQrPWUub3V0cHV0IT1udWxsP2Uub3V0cHV0OmUudmFsdWU7aWYoZS5zdWZmaXgpe04ub3V0cHV0Kz1lLnN1ZmZpeH19fXJldHVybiBOfTtwYXJzZS5mYXN0cGF0aHM9KGUsdCk9Pntjb25zdCByPXsuLi50fTtjb25zdCBvPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyxyLm1heExlbmd0aCk6cztjb25zdCBpPWUubGVuZ3RoO2lmKGk+byl7dGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7aX0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHtvfWApfWU9bFtlXXx8ZTtjb25zdCBhPXUuaXNXaW5kb3dzKHQpO2NvbnN0e0RPVF9MSVRFUkFMOmMsU0xBU0hfTElURVJBTDpwLE9ORV9DSEFSOmYsRE9UU19TTEFTSDpBLE5PX0RPVDpSLE5PX0RPVFM6XyxOT19ET1RTX1NMQVNIOmgsU1RBUjpnLFNUQVJUX0FOQ0hPUjpFfT1uLmdsb2JDaGFycyhhKTtjb25zdCBDPXIuZG90P186Ujtjb25zdCB5PXIuZG90P2g6Ujtjb25zdCBkPXIuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCB4PXtuZWdhdGVkOmZhbHNlLHByZWZpeDpcIlwifTtsZXQgYj1yLmJhc2g9PT10cnVlP1wiLio/XCI6ZztpZihyLmNhcHR1cmUpe2I9YCgke2J9KWB9Y29uc3QgZ2xvYnN0YXI9ZT0+e2lmKGUubm9nbG9ic3Rhcj09PXRydWUpcmV0dXJuIGI7cmV0dXJuYCgke2R9KD86KD8hJHtFfSR7ZS5kb3Q/QTpjfSkuKSo/KWB9O2NvbnN0IGNyZWF0ZT1lPT57c3dpdGNoKGUpe2Nhc2VcIipcIjpyZXR1cm5gJHtDfSR7Zn0ke2J9YDtjYXNlXCIuKlwiOnJldHVybmAke2N9JHtmfSR7Yn1gO2Nhc2VcIiouKlwiOnJldHVybmAke0N9JHtifSR7Y30ke2Z9JHtifWA7Y2FzZVwiKi8qXCI6cmV0dXJuYCR7Q30ke2J9JHtwfSR7Zn0ke3l9JHtifWA7Y2FzZVwiKipcIjpyZXR1cm4gQytnbG9ic3RhcihyKTtjYXNlXCIqKi8qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2Z9JHtifWA7Y2FzZVwiKiovKi4qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2J9JHtjfSR7Zn0ke2J9YDtjYXNlXCIqKi8uKlwiOnJldHVybmAoPzoke0N9JHtnbG9ic3RhcihyKX0ke3B9KT8ke2N9JHtmfSR7Yn1gO2RlZmF1bHQ6e2NvbnN0IHQ9L14oLio/KVxcLihcXHcrKSQvLmV4ZWMoZSk7aWYoIXQpcmV0dXJuO2NvbnN0IHI9Y3JlYXRlKHRbMV0pO2lmKCFyKXJldHVybjtyZXR1cm4gcitjK3RbMl19fX07Y29uc3QgUz11LnJlbW92ZVByZWZpeChlLHgpO2xldCBIPWNyZWF0ZShTKTtpZihIJiZyLnN0cmljdFNsYXNoZXMhPT10cnVlKXtIKz1gJHtwfT9gfXJldHVybiBIfTtlLmV4cG9ydHM9cGFyc2V9LDY4MzooZSx0LHIpPT57Y29uc3Qgbj1yKDE3KTtjb25zdCB1PXIoNzAwKTtjb25zdCBzPXIoNzU0KTtjb25zdCBvPXIoNTEzKTtjb25zdCBpPXIoMzU2KTtjb25zdCBpc09iamVjdD1lPT5lJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO2NvbnN0IHBpY29tYXRjaD0oZSx0LHI9ZmFsc2UpPT57aWYoQXJyYXkuaXNBcnJheShlKSl7Y29uc3Qgbj1lLm1hcCgoZT0+cGljb21hdGNoKGUsdCxyKSkpO2NvbnN0IGFycmF5TWF0Y2hlcj1lPT57Zm9yKGNvbnN0IHQgb2Ygbil7Y29uc3Qgcj10KGUpO2lmKHIpcmV0dXJuIHJ9cmV0dXJuIGZhbHNlfTtyZXR1cm4gYXJyYXlNYXRjaGVyfWNvbnN0IG49aXNPYmplY3QoZSkmJmUudG9rZW5zJiZlLmlucHV0O2lmKGU9PT1cIlwifHx0eXBlb2YgZSE9PVwic3RyaW5nXCImJiFuKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9Y29uc3QgdT10fHx7fTtjb25zdCBzPW8uaXNXaW5kb3dzKHQpO2NvbnN0IGk9bj9waWNvbWF0Y2guY29tcGlsZVJlKGUsdCk6cGljb21hdGNoLm1ha2VSZShlLHQsZmFsc2UsdHJ1ZSk7Y29uc3QgYT1pLnN0YXRlO2RlbGV0ZSBpLnN0YXRlO2xldCBpc0lnbm9yZWQ9KCk9PmZhbHNlO2lmKHUuaWdub3JlKXtjb25zdCBlPXsuLi50LGlnbm9yZTpudWxsLG9uTWF0Y2g6bnVsbCxvblJlc3VsdDpudWxsfTtpc0lnbm9yZWQ9cGljb21hdGNoKHUuaWdub3JlLGUscil9Y29uc3QgbWF0Y2hlcj0ocixuPWZhbHNlKT0+e2NvbnN0e2lzTWF0Y2g6byxtYXRjaDpsLG91dHB1dDpjfT1waWNvbWF0Y2gudGVzdChyLGksdCx7Z2xvYjplLHBvc2l4OnN9KTtjb25zdCBwPXtnbG9iOmUsc3RhdGU6YSxyZWdleDppLHBvc2l4OnMsaW5wdXQ6cixvdXRwdXQ6YyxtYXRjaDpsLGlzTWF0Y2g6b307aWYodHlwZW9mIHUub25SZXN1bHQ9PT1cImZ1bmN0aW9uXCIpe3Uub25SZXN1bHQocCl9aWYobz09PWZhbHNlKXtwLmlzTWF0Y2g9ZmFsc2U7cmV0dXJuIG4/cDpmYWxzZX1pZihpc0lnbm9yZWQocikpe2lmKHR5cGVvZiB1Lm9uSWdub3JlPT09XCJmdW5jdGlvblwiKXt1Lm9uSWdub3JlKHApfXAuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9wOmZhbHNlfWlmKHR5cGVvZiB1Lm9uTWF0Y2g9PT1cImZ1bmN0aW9uXCIpe3Uub25NYXRjaChwKX1yZXR1cm4gbj9wOnRydWV9O2lmKHIpe21hdGNoZXIuc3RhdGU9YX1yZXR1cm4gbWF0Y2hlcn07cGljb21hdGNoLnRlc3Q9KGUsdCxyLHtnbG9iOm4scG9zaXg6dX09e30pPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgdG8gYmUgYSBzdHJpbmdcIil9aWYoZT09PVwiXCIpe3JldHVybntpc01hdGNoOmZhbHNlLG91dHB1dDpcIlwifX1jb25zdCBzPXJ8fHt9O2NvbnN0IGk9cy5mb3JtYXR8fCh1P28udG9Qb3NpeFNsYXNoZXM6bnVsbCk7bGV0IGE9ZT09PW47bGV0IGw9YSYmaT9pKGUpOmU7aWYoYT09PWZhbHNlKXtsPWk/aShlKTplO2E9bD09PW59aWYoYT09PWZhbHNlfHxzLmNhcHR1cmU9PT10cnVlKXtpZihzLm1hdGNoQmFzZT09PXRydWV8fHMuYmFzZW5hbWU9PT10cnVlKXthPXBpY29tYXRjaC5tYXRjaEJhc2UoZSx0LHIsdSl9ZWxzZXthPXQuZXhlYyhsKX19cmV0dXJue2lzTWF0Y2g6Qm9vbGVhbihhKSxtYXRjaDphLG91dHB1dDpsfX07cGljb21hdGNoLm1hdGNoQmFzZT0oZSx0LHIsdT1vLmlzV2luZG93cyhyKSk9Pntjb25zdCBzPXQgaW5zdGFuY2VvZiBSZWdFeHA/dDpwaWNvbWF0Y2gubWFrZVJlKHQscik7cmV0dXJuIHMudGVzdChuLmJhc2VuYW1lKGUpKX07cGljb21hdGNoLmlzTWF0Y2g9KGUsdCxyKT0+cGljb21hdGNoKHQscikoZSk7cGljb21hdGNoLnBhcnNlPShlLHQpPT57aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZS5tYXAoKGU9PnBpY29tYXRjaC5wYXJzZShlLHQpKSk7cmV0dXJuIHMoZSx7Li4udCxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KGUsdCk9PnUoZSx0KTtwaWNvbWF0Y2guY29tcGlsZVJlPShlLHQscj1mYWxzZSxuPWZhbHNlKT0+e2lmKHI9PT10cnVlKXtyZXR1cm4gZS5vdXRwdXR9Y29uc3QgdT10fHx7fTtjb25zdCBzPXUuY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCBvPXUuY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgaT1gJHtzfSg/OiR7ZS5vdXRwdXR9KSR7b31gO2lmKGUmJmUubmVnYXRlZD09PXRydWUpe2k9YF4oPyEke2l9KS4qJGB9Y29uc3QgYT1waWNvbWF0Y2gudG9SZWdleChpLHQpO2lmKG49PT10cnVlKXthLnN0YXRlPWV9cmV0dXJuIGF9O3BpY29tYXRjaC5tYWtlUmU9KGUsdCxyPWZhbHNlLG49ZmFsc2UpPT57aWYoIWV8fHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1jb25zdCB1PXR8fHt9O2xldCBvPXtuZWdhdGVkOmZhbHNlLGZhc3RwYXRoczp0cnVlfTtsZXQgaT1cIlwiO2xldCBhO2lmKGUuc3RhcnRzV2l0aChcIi4vXCIpKXtlPWUuc2xpY2UoMik7aT1vLnByZWZpeD1cIi4vXCJ9aWYodS5mYXN0cGF0aHMhPT1mYWxzZSYmKGVbMF09PT1cIi5cInx8ZVswXT09PVwiKlwiKSl7YT1zLmZhc3RwYXRocyhlLHQpfWlmKGE9PT11bmRlZmluZWQpe289cyhlLHQpO28ucHJlZml4PWkrKG8ucHJlZml4fHxcIlwiKX1lbHNle28ub3V0cHV0PWF9cmV0dXJuIHBpY29tYXRjaC5jb21waWxlUmUobyx0LHIsbil9O3BpY29tYXRjaC50b1JlZ2V4PShlLHQpPT57dHJ5e2NvbnN0IHI9dHx8e307cmV0dXJuIG5ldyBSZWdFeHAoZSxyLmZsYWdzfHwoci5ub2Nhc2U/XCJpXCI6XCJcIikpfWNhdGNoKGUpe2lmKHQmJnQuZGVidWc9PT10cnVlKXRocm93IGU7cmV0dXJuLyReL319O3BpY29tYXRjaC5jb25zdGFudHM9aTtlLmV4cG9ydHM9cGljb21hdGNofSw3MDA6KGUsdCxyKT0+e2NvbnN0IG49cig1MTMpO2NvbnN0e0NIQVJfQVNURVJJU0s6dSxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpvLENIQVJfQ09NTUE6aSxDSEFSX0RPVDphLENIQVJfRVhDTEFNQVRJT05fTUFSSzpsLENIQVJfRk9SV0FSRF9TTEFTSDpjLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpwLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpSLENIQVJfUVVFU1RJT05fTUFSSzpfLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6aCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmcsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpFfT1yKDM1Nik7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPWU9PmU9PT1jfHxlPT09bztjb25zdCBkZXB0aD1lPT57aWYoZS5pc1ByZWZpeCE9PXRydWUpe2UuZGVwdGg9ZS5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPShlLHQpPT57Y29uc3Qgcj10fHx7fTtjb25zdCBDPWUubGVuZ3RoLTE7Y29uc3QgeT1yLnBhcnRzPT09dHJ1ZXx8ci5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IGQ9W107Y29uc3QgeD1bXTtjb25zdCBiPVtdO2xldCBTPWU7bGV0IEg9LTE7bGV0IHY9MDtsZXQgJD0wO2xldCBtPWZhbHNlO2xldCBUPWZhbHNlO2xldCBMPWZhbHNlO2xldCBPPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBrPWZhbHNlO2xldCBJPWZhbHNlO2xldCBNPWZhbHNlO2xldCBQPTA7bGV0IEI7bGV0IEc7bGV0IEQ9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Qztjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57Qj1HO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxDKXtHPWFkdmFuY2UoKTtsZXQgZTtpZihHPT09byl7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7aWYoRz09PXApe049dHJ1ZX1jb250aW51ZX1pZihOPT09dHJ1ZXx8Rz09PXApe1ArKzt3aGlsZShlb3MoKSE9PXRydWUmJihHPWFkdmFuY2UoKSkpe2lmKEc9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoRz09PXApe1ArKztjb250aW51ZX1pZihOIT09dHJ1ZSYmRz09PWEmJihHPWFkdmFuY2UoKSk9PT1hKXttPUQuaXNCcmFjZT10cnVlO0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKE4hPT10cnVlJiZHPT09aSl7bT1ELmlzQnJhY2U9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihHPT09aCl7UC0tO2lmKFA9PT0wKXtOPWZhbHNlO209RC5pc0JyYWNlPXRydWU7TT10cnVlO2JyZWFrfX19aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1jKXtkLnB1c2goSCk7eC5wdXNoKEQpO0Q9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKE09PT10cnVlKWNvbnRpbnVlO2lmKEI9PT1hJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfSQ9SCsxO2NvbnRpbnVlfWlmKHIubm9leHQhPT10cnVlKXtjb25zdCBlPUc9PT1SfHxHPT09c3x8Rz09PXV8fEc9PT1ffHxHPT09bDtpZihlPT09dHJ1ZSYmcGVlaygpPT09Zil7TD1ELmlzR2xvYj10cnVlO089RC5pc0V4dGdsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKEc9YWR2YW5jZSgpKSl7aWYoRz09PW8pe2s9RC5iYWNrc2xhc2hlcz10cnVlO0c9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKEc9PT1nKXtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoRz09PXUpe2lmKEI9PT11KXc9RC5pc0dsb2JzdGFyPXRydWU7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoRz09PV8pe0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJihlPWFkdmFuY2UoKSkpe2lmKGU9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoZT09PUUpe1Q9RC5pc0JyYWNrZXQ9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1pZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoci5ub25lZ2F0ZSE9PXRydWUmJkc9PT1sJiZIPT09dil7ST1ELm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYoci5ub3BhcmVuIT09dHJ1ZSYmRz09PWYpe0w9RC5pc0dsb2I9dHJ1ZTtpZih5PT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoRz1hZHZhbmNlKCkpKXtpZihHPT09Zil7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7Y29udGludWV9aWYoRz09PWcpe009dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTD09PXRydWUpe009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHIubm9leHQ9PT10cnVlKXtPPWZhbHNlO0w9ZmFsc2V9bGV0IFU9UztsZXQgSz1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtLPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7JC09dn1pZihVJiZMPT09dHJ1ZSYmJD4wKXtVPVMuc2xpY2UoMCwkKTtGPVMuc2xpY2UoJCl9ZWxzZSBpZihMPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYoci51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJms9PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpLLGlucHV0OmUsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6bSxpc0JyYWNrZXQ6VCxpc0dsb2I6TCxpc0V4dGdsb2I6Tyxpc0dsb2JzdGFyOncsbmVnYXRlZDpJfTtpZihyLnRva2Vucz09PXRydWUpe1EubWF4RGVwdGg9MDtpZighaXNQYXRoU2VwYXJhdG9yKEcpKXt4LnB1c2goRCl9US50b2tlbnM9eH1pZihyLnBhcnRzPT09dHJ1ZXx8ci50b2tlbnM9PT10cnVlKXtsZXQgdDtmb3IobGV0IG49MDtuPGQubGVuZ3RoO24rKyl7Y29uc3QgdT10P3QrMTp2O2NvbnN0IHM9ZFtuXTtjb25zdCBvPWUuc2xpY2UodSxzKTtpZihyLnRva2Vucyl7aWYobj09PTAmJnYhPT0wKXt4W25dLmlzUHJlZml4PXRydWU7eFtuXS52YWx1ZT1LfWVsc2V7eFtuXS52YWx1ZT1vfWRlcHRoKHhbbl0pO1EubWF4RGVwdGgrPXhbbl0uZGVwdGh9aWYobiE9PTB8fG8hPT1cIlwiKXtiLnB1c2gobyl9dD1zfWlmKHQmJnQrMTxlLmxlbmd0aCl7Y29uc3Qgbj1lLnNsaWNlKHQrMSk7Yi5wdXNoKG4pO2lmKHIudG9rZW5zKXt4W3gubGVuZ3RoLTFdLnZhbHVlPW47ZGVwdGgoeFt4Lmxlbmd0aC0xXSk7US5tYXhEZXB0aCs9eFt4Lmxlbmd0aC0xXS5kZXB0aH19US5zbGFzaGVzPWQ7US5wYXJ0cz1ifXJldHVybiBRfTtlLmV4cG9ydHM9c2Nhbn0sNTEzOihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9cHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIjtjb25zdHtSRUdFWF9CQUNLU0xBU0g6cyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOm8sUkVHRVhfU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOmF9PXIoMzU2KTt0LmlzT2JqZWN0PWU9PmUhPT1udWxsJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO3QuaGFzUmVnZXhDaGFycz1lPT5pLnRlc3QoZSk7dC5pc1JlZ2V4Q2hhcj1lPT5lLmxlbmd0aD09PTEmJnQuaGFzUmVnZXhDaGFycyhlKTt0LmVzY2FwZVJlZ2V4PWU9PmUucmVwbGFjZShhLFwiXFxcXCQxXCIpO3QudG9Qb3NpeFNsYXNoZXM9ZT0+ZS5yZXBsYWNlKHMsXCIvXCIpO3QucmVtb3ZlQmFja3NsYXNoZXM9ZT0+ZS5yZXBsYWNlKG8sKGU9PmU9PT1cIlxcXFxcIj9cIlwiOmUpKTt0LnN1cHBvcnRzTG9va2JlaGluZHM9KCk9Pntjb25zdCBlPXByb2Nlc3MudmVyc2lvbi5zbGljZSgxKS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7aWYoZS5sZW5ndGg9PT0zJiZlWzBdPj05fHxlWzBdPT09OCYmZVsxXT49MTApe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc1dpbmRvd3M9ZT0+e2lmKGUmJnR5cGVvZiBlLndpbmRvd3M9PT1cImJvb2xlYW5cIil7cmV0dXJuIGUud2luZG93c31yZXR1cm4gdT09PXRydWV8fG4uc2VwPT09XCJcXFxcXCJ9O3QuZXNjYXBlTGFzdD0oZSxyLG4pPT57Y29uc3QgdT1lLmxhc3RJbmRleE9mKHIsbik7aWYodT09PS0xKXJldHVybiBlO2lmKGVbdS0xXT09PVwiXFxcXFwiKXJldHVybiB0LmVzY2FwZUxhc3QoZSxyLHUtMSk7cmV0dXJuYCR7ZS5zbGljZSgwLHUpfVxcXFwke2Uuc2xpY2UodSl9YH07dC5yZW1vdmVQcmVmaXg9KGUsdD17fSk9PntsZXQgcj1lO2lmKHIuc3RhcnRzV2l0aChcIi4vXCIpKXtyPXIuc2xpY2UoMik7dC5wcmVmaXg9XCIuL1wifXJldHVybiByfTt0LndyYXBPdXRwdXQ9KGUsdD17fSxyPXt9KT0+e2NvbnN0IG49ci5jb250YWlucz9cIlwiOlwiXlwiO2NvbnN0IHU9ci5jb250YWlucz9cIlwiOlwiJFwiO2xldCBzPWAke259KD86JHtlfSkke3V9YDtpZih0Lm5lZ2F0ZWQ9PT10cnVlKXtzPWAoPzpeKD8hJHtzfSkuKiQpYH1yZXR1cm4gc319LDQ5MjooZSx0LHIpPT57XG4vKiFcbiAqIHRvLXJlZ2V4LXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vbWljcm9tYXRjaC90by1yZWdleC1yYW5nZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IG49cigzNTcpO2NvbnN0IHRvUmVnZXhSYW5nZT0oZSx0LHIpPT57aWYobihlKT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBudW1iZXJcIil9aWYodD09PXZvaWQgMHx8ZT09PXQpe3JldHVybiBTdHJpbmcoZSl9aWYobih0KT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyLlwiKX1sZXQgdT17cmVsYXhaZXJvczp0cnVlLC4uLnJ9O2lmKHR5cGVvZiB1LnN0cmljdFplcm9zPT09XCJib29sZWFuXCIpe3UucmVsYXhaZXJvcz11LnN0cmljdFplcm9zPT09ZmFsc2V9bGV0IHM9U3RyaW5nKHUucmVsYXhaZXJvcyk7bGV0IG89U3RyaW5nKHUuc2hvcnRoYW5kKTtsZXQgaT1TdHJpbmcodS5jYXB0dXJlKTtsZXQgYT1TdHJpbmcodS53cmFwKTtsZXQgbD1lK1wiOlwiK3QrXCI9XCIrcytvK2krYTtpZih0b1JlZ2V4UmFuZ2UuY2FjaGUuaGFzT3duUHJvcGVydHkobCkpe3JldHVybiB0b1JlZ2V4UmFuZ2UuY2FjaGVbbF0ucmVzdWx0fWxldCBjPU1hdGgubWluKGUsdCk7bGV0IHA9TWF0aC5tYXgoZSx0KTtpZihNYXRoLmFicyhjLXApPT09MSl7bGV0IHI9ZStcInxcIit0O2lmKHUuY2FwdHVyZSl7cmV0dXJuYCgke3J9KWB9aWYodS53cmFwPT09ZmFsc2Upe3JldHVybiByfXJldHVybmAoPzoke3J9KWB9bGV0IGY9aGFzUGFkZGluZyhlKXx8aGFzUGFkZGluZyh0KTtsZXQgQT17bWluOmUsbWF4OnQsYTpjLGI6cH07bGV0IFI9W107bGV0IF89W107aWYoZil7QS5pc1BhZGRlZD1mO0EubWF4TGVuPVN0cmluZyhBLm1heCkubGVuZ3RofWlmKGM8MCl7bGV0IGU9cDwwP01hdGguYWJzKHApOjE7Xz1zcGxpdFRvUGF0dGVybnMoZSxNYXRoLmFicyhjKSxBLHUpO2M9QS5hPTB9aWYocD49MCl7Uj1zcGxpdFRvUGF0dGVybnMoYyxwLEEsdSl9QS5uZWdhdGl2ZXM9XztBLnBvc2l0aXZlcz1SO0EucmVzdWx0PWNvbGxhdGVQYXR0ZXJucyhfLFIsdSk7aWYodS5jYXB0dXJlPT09dHJ1ZSl7QS5yZXN1bHQ9YCgke0EucmVzdWx0fSlgfWVsc2UgaWYodS53cmFwIT09ZmFsc2UmJlIubGVuZ3RoK18ubGVuZ3RoPjEpe0EucmVzdWx0PWAoPzoke0EucmVzdWx0fSlgfXRvUmVnZXhSYW5nZS5jYWNoZVtsXT1BO3JldHVybiBBLnJlc3VsdH07ZnVuY3Rpb24gY29sbGF0ZVBhdHRlcm5zKGUsdCxyKXtsZXQgbj1maWx0ZXJQYXR0ZXJucyhlLHQsXCItXCIsZmFsc2Uscil8fFtdO2xldCB1PWZpbHRlclBhdHRlcm5zKHQsZSxcIlwiLGZhbHNlLHIpfHxbXTtsZXQgcz1maWx0ZXJQYXR0ZXJucyhlLHQsXCItP1wiLHRydWUscil8fFtdO2xldCBvPW4uY29uY2F0KHMpLmNvbmNhdCh1KTtyZXR1cm4gby5qb2luKFwifFwiKX1mdW5jdGlvbiBzcGxpdFRvUmFuZ2VzKGUsdCl7bGV0IHI9MTtsZXQgbj0xO2xldCB1PWNvdW50TmluZXMoZSxyKTtsZXQgcz1uZXcgU2V0KFt0XSk7d2hpbGUoZTw9dSYmdTw9dCl7cy5hZGQodSk7cis9MTt1PWNvdW50TmluZXMoZSxyKX11PWNvdW50WmVyb3ModCsxLG4pLTE7d2hpbGUoZTx1JiZ1PD10KXtzLmFkZCh1KTtuKz0xO3U9Y291bnRaZXJvcyh0KzEsbiktMX1zPVsuLi5zXTtzLnNvcnQoY29tcGFyZSk7cmV0dXJuIHN9ZnVuY3Rpb24gcmFuZ2VUb1BhdHRlcm4oZSx0LHIpe2lmKGU9PT10KXtyZXR1cm57cGF0dGVybjplLGNvdW50OltdLGRpZ2l0czowfX1sZXQgbj16aXAoZSx0KTtsZXQgdT1uLmxlbmd0aDtsZXQgcz1cIlwiO2xldCBvPTA7Zm9yKGxldCBlPTA7ZTx1O2UrKyl7bGV0W3QsdV09bltlXTtpZih0PT09dSl7cys9dH1lbHNlIGlmKHQhPT1cIjBcInx8dSE9PVwiOVwiKXtzKz10b0NoYXJhY3RlckNsYXNzKHQsdSxyKX1lbHNle28rK319aWYobyl7cys9ci5zaG9ydGhhbmQ9PT10cnVlP1wiXFxcXGRcIjpcIlswLTldXCJ9cmV0dXJue3BhdHRlcm46cyxjb3VudDpbb10sZGlnaXRzOnV9fWZ1bmN0aW9uIHNwbGl0VG9QYXR0ZXJucyhlLHQscixuKXtsZXQgdT1zcGxpdFRvUmFuZ2VzKGUsdCk7bGV0IHM9W107bGV0IG89ZTtsZXQgaTtmb3IobGV0IGU9MDtlPHUubGVuZ3RoO2UrKyl7bGV0IHQ9dVtlXTtsZXQgYT1yYW5nZVRvUGF0dGVybihTdHJpbmcobyksU3RyaW5nKHQpLG4pO2xldCBsPVwiXCI7aWYoIXIuaXNQYWRkZWQmJmkmJmkucGF0dGVybj09PWEucGF0dGVybil7aWYoaS5jb3VudC5sZW5ndGg+MSl7aS5jb3VudC5wb3AoKX1pLmNvdW50LnB1c2goYS5jb3VudFswXSk7aS5zdHJpbmc9aS5wYXR0ZXJuK3RvUXVhbnRpZmllcihpLmNvdW50KTtvPXQrMTtjb250aW51ZX1pZihyLmlzUGFkZGVkKXtsPXBhZFplcm9zKHQscixuKX1hLnN0cmluZz1sK2EucGF0dGVybit0b1F1YW50aWZpZXIoYS5jb3VudCk7cy5wdXNoKGEpO289dCsxO2k9YX1yZXR1cm4gc31mdW5jdGlvbiBmaWx0ZXJQYXR0ZXJucyhlLHQscixuLHUpe2xldCBzPVtdO2ZvcihsZXQgdSBvZiBlKXtsZXR7c3RyaW5nOmV9PXU7aWYoIW4mJiFjb250YWlucyh0LFwic3RyaW5nXCIsZSkpe3MucHVzaChyK2UpfWlmKG4mJmNvbnRhaW5zKHQsXCJzdHJpbmdcIixlKSl7cy5wdXNoKHIrZSl9fXJldHVybiBzfWZ1bmN0aW9uIHppcChlLHQpe2xldCByPVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXIucHVzaChbZVtuXSx0W25dXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gY29tcGFyZShlLHQpe3JldHVybiBlPnQ/MTp0PmU/LTE6MH1mdW5jdGlvbiBjb250YWlucyhlLHQscil7cmV0dXJuIGUuc29tZSgoZT0+ZVt0XT09PXIpKX1mdW5jdGlvbiBjb3VudE5pbmVzKGUsdCl7cmV0dXJuIE51bWJlcihTdHJpbmcoZSkuc2xpY2UoMCwtdCkrXCI5XCIucmVwZWF0KHQpKX1mdW5jdGlvbiBjb3VudFplcm9zKGUsdCl7cmV0dXJuIGUtZSVNYXRoLnBvdygxMCx0KX1mdW5jdGlvbiB0b1F1YW50aWZpZXIoZSl7bGV0W3Q9MCxyPVwiXCJdPWU7aWYocnx8dD4xKXtyZXR1cm5geyR7dCsocj9cIixcIityOlwiXCIpfX1gfXJldHVyblwiXCJ9ZnVuY3Rpb24gdG9DaGFyYWN0ZXJDbGFzcyhlLHQscil7cmV0dXJuYFske2V9JHt0LWU9PT0xP1wiXCI6XCItXCJ9JHt0fV1gfWZ1bmN0aW9uIGhhc1BhZGRpbmcoZSl7cmV0dXJuL14tPygwKylcXGQvLnRlc3QoZSl9ZnVuY3Rpb24gcGFkWmVyb3MoZSx0LHIpe2lmKCF0LmlzUGFkZGVkKXtyZXR1cm4gZX1sZXQgbj1NYXRoLmFicyh0Lm1heExlbi1TdHJpbmcoZSkubGVuZ3RoKTtsZXQgdT1yLnJlbGF4WmVyb3MhPT1mYWxzZTtzd2l0Y2gobil7Y2FzZSAwOnJldHVyblwiXCI7Y2FzZSAxOnJldHVybiB1P1wiMD9cIjpcIjBcIjtjYXNlIDI6cmV0dXJuIHU/XCIwezAsMn1cIjpcIjAwXCI7ZGVmYXVsdDp7cmV0dXJuIHU/YDB7MCwke259fWA6YDB7JHtufX1gfX19dG9SZWdleFJhbmdlLmNhY2hlPXt9O3RvUmVnZXhSYW5nZS5jbGVhckNhY2hlPSgpPT50b1JlZ2V4UmFuZ2UuY2FjaGU9e307ZS5leHBvcnRzPXRvUmVnZXhSYW5nZX0sMTc6ZT0+e2UuZXhwb3J0cz1yZXF1aXJlKFwicGF0aFwiKX0sODM3OmU9PntlLmV4cG9ydHM9cmVxdWlyZShcInV0aWxcIil9fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgdT10W3JdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXtlW3JdKHUsdS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSB0W3JdfXJldHVybiB1LmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oOTcxKTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/micromatch/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-browserify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-browserify/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={114:function(e){function assertPath(e){if(typeof e!==\"string\"){throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(e))}}function normalizeStringPosix(e,r){var t=\"\";var i=0;var n=-1;var a=0;var f;for(var l=0;l<=e.length;++l){if(l<e.length)f=e.charCodeAt(l);else if(f===47)break;else f=47;if(f===47){if(n===l-1||a===1){}else if(n!==l-1&&a===2){if(t.length<2||i!==2||t.charCodeAt(t.length-1)!==46||t.charCodeAt(t.length-2)!==46){if(t.length>2){var s=t.lastIndexOf(\"/\");if(s!==t.length-1){if(s===-1){t=\"\";i=0}else{t=t.slice(0,s);i=t.length-1-t.lastIndexOf(\"/\")}n=l;a=0;continue}}else if(t.length===2||t.length===1){t=\"\";i=0;n=l;a=0;continue}}if(r){if(t.length>0)t+=\"/..\";else t=\"..\";i=2}}else{if(t.length>0)t+=\"/\"+e.slice(n+1,l);else t=e.slice(n+1,l);i=l-n-1}n=l;a=0}else if(f===46&&a!==-1){++a}else{a=-1}}return t}function _format(e,r){var t=r.dir||r.root;var i=r.base||(r.name||\"\")+(r.ext||\"\");if(!t){return i}if(t===r.root){return t+i}return t+e+i}var r={resolve:function resolve(){var e=\"\";var r=false;var t;for(var i=arguments.length-1;i>=-1&&!r;i--){var n;if(i>=0)n=arguments[i];else{if(t===undefined)t=\"\";n=t}assertPath(n);if(n.length===0){continue}e=n+\"/\"+e;r=n.charCodeAt(0)===47}e=normalizeStringPosix(e,!r);if(r){if(e.length>0)return\"/\"+e;else return\"/\"}else if(e.length>0){return e}else{return\".\"}},normalize:function normalize(e){assertPath(e);if(e.length===0)return\".\";var r=e.charCodeAt(0)===47;var t=e.charCodeAt(e.length-1)===47;e=normalizeStringPosix(e,!r);if(e.length===0&&!r)e=\".\";if(e.length>0&&t)e+=\"/\";if(r)return\"/\"+e;return e},isAbsolute:function isAbsolute(e){assertPath(e);return e.length>0&&e.charCodeAt(0)===47},join:function join(){if(arguments.length===0)return\".\";var e;for(var t=0;t<arguments.length;++t){var i=arguments[t];assertPath(i);if(i.length>0){if(e===undefined)e=i;else e+=\"/\"+i}}if(e===undefined)return\".\";return r.normalize(e)},relative:function relative(e,t){assertPath(e);assertPath(t);if(e===t)return\"\";e=r.resolve(e);t=r.resolve(t);if(e===t)return\"\";var i=1;for(;i<e.length;++i){if(e.charCodeAt(i)!==47)break}var n=e.length;var a=n-i;var f=1;for(;f<t.length;++f){if(t.charCodeAt(f)!==47)break}var l=t.length;var s=l-f;var o=a<s?a:s;var u=-1;var h=0;for(;h<=o;++h){if(h===o){if(s>o){if(t.charCodeAt(f+h)===47){return t.slice(f+h+1)}else if(h===0){return t.slice(f+h)}}else if(a>o){if(e.charCodeAt(i+h)===47){u=h}else if(h===0){u=0}}break}var c=e.charCodeAt(i+h);var v=t.charCodeAt(f+h);if(c!==v)break;else if(c===47)u=h}var g=\"\";for(h=i+u+1;h<=n;++h){if(h===n||e.charCodeAt(h)===47){if(g.length===0)g+=\"..\";else g+=\"/..\"}}if(g.length>0)return g+t.slice(f+u);else{f+=u;if(t.charCodeAt(f)===47)++f;return t.slice(f)}},_makeLong:function _makeLong(e){return e},dirname:function dirname(e){assertPath(e);if(e.length===0)return\".\";var r=e.charCodeAt(0);var t=r===47;var i=-1;var n=true;for(var a=e.length-1;a>=1;--a){r=e.charCodeAt(a);if(r===47){if(!n){i=a;break}}else{n=false}}if(i===-1)return t?\"/\":\".\";if(t&&i===1)return\"//\";return e.slice(0,i)},basename:function basename(e,r){if(r!==undefined&&typeof r!==\"string\")throw new TypeError('\"ext\" argument must be a string');assertPath(e);var t=0;var i=-1;var n=true;var a;if(r!==undefined&&r.length>0&&r.length<=e.length){if(r.length===e.length&&r===e)return\"\";var f=r.length-1;var l=-1;for(a=e.length-1;a>=0;--a){var s=e.charCodeAt(a);if(s===47){if(!n){t=a+1;break}}else{if(l===-1){n=false;l=a+1}if(f>=0){if(s===r.charCodeAt(f)){if(--f===-1){i=a}}else{f=-1;i=l}}}}if(t===i)i=l;else if(i===-1)i=e.length;return e.slice(t,i)}else{for(a=e.length-1;a>=0;--a){if(e.charCodeAt(a)===47){if(!n){t=a+1;break}}else if(i===-1){n=false;i=a+1}}if(i===-1)return\"\";return e.slice(t,i)}},extname:function extname(e){assertPath(e);var r=-1;var t=0;var i=-1;var n=true;var a=0;for(var f=e.length-1;f>=0;--f){var l=e.charCodeAt(f);if(l===47){if(!n){t=f+1;break}continue}if(i===-1){n=false;i=f+1}if(l===46){if(r===-1)r=f;else if(a!==1)a=1}else if(r!==-1){a=-1}}if(r===-1||i===-1||a===0||a===1&&r===i-1&&r===t+1){return\"\"}return e.slice(r,i)},format:function format(e){if(e===null||typeof e!==\"object\"){throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof e)}return _format(\"/\",e)},parse:function parse(e){assertPath(e);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(e.length===0)return r;var t=e.charCodeAt(0);var i=t===47;var n;if(i){r.root=\"/\";n=1}else{n=0}var a=-1;var f=0;var l=-1;var s=true;var o=e.length-1;var u=0;for(;o>=n;--o){t=e.charCodeAt(o);if(t===47){if(!s){f=o+1;break}continue}if(l===-1){s=false;l=o+1}if(t===46){if(a===-1)a=o;else if(u!==1)u=1}else if(a!==-1){u=-1}}if(a===-1||l===-1||u===0||u===1&&a===l-1&&a===f+1){if(l!==-1){if(f===0&&i)r.base=r.name=e.slice(1,l);else r.base=r.name=e.slice(f,l)}}else{if(f===0&&i){r.name=e.slice(1,a);r.base=e.slice(1,l)}else{r.name=e.slice(f,a);r.base=e.slice(f,l)}r.ext=e.slice(a,l)}if(f>0)r.dir=e.slice(0,f-1);else if(i)r.dir=\"/\";return r},sep:\"/\",delimiter:\":\",win32:null,posix:null};r.posix=r;e.exports=r}};var r={};function __nccwpck_require__(t){var i=r[t];if(i!==undefined){return i.exports}var n=r[t]={exports:{}};var a=true;try{e[t](n,n.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(114);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxhQUFhLE9BQU8sZ0JBQWdCLHVCQUF1Qix3QkFBd0IsMkVBQTJFLG1DQUFtQyxTQUFTLFFBQVEsU0FBUyxRQUFRLE1BQU0sWUFBWSxZQUFZLEtBQUssZ0NBQWdDLHFCQUFxQixVQUFVLFdBQVcsb0JBQW9CLHdCQUF3QixvRkFBb0YsZUFBZSx5QkFBeUIsbUJBQW1CLFdBQVcsS0FBSyxJQUFJLEtBQUssZUFBZSxnQ0FBZ0MsSUFBSSxJQUFJLFVBQVUsb0NBQW9DLEtBQUssSUFBSSxJQUFJLElBQUksVUFBVSxNQUFNLHVCQUF1QixZQUFZLEtBQUssS0FBSyxvQ0FBb0Msc0JBQXNCLFFBQVEsSUFBSSxJQUFJLHdCQUF3QixJQUFJLEtBQUssTUFBTSxTQUFTLHNCQUFzQixvQkFBb0IsdUNBQXVDLE9BQU8sU0FBUyxlQUFlLFdBQVcsYUFBYSxPQUFPLDJCQUEyQixTQUFTLFlBQVksTUFBTSw2QkFBNkIsVUFBVSxLQUFLLE1BQU0sdUJBQXVCLEtBQUssc0JBQXNCLElBQUksY0FBYyxpQkFBaUIsU0FBUyxVQUFVLHVCQUF1Qiw2QkFBNkIsTUFBTSwwQkFBMEIsZUFBZSxvQkFBb0IsU0FBUyxLQUFLLFdBQVcsaUNBQWlDLGNBQWMsMEJBQTBCLDJCQUEyQixvQ0FBb0MsNkJBQTZCLDBCQUEwQix3QkFBd0IsaUJBQWlCLFNBQVMsbUNBQW1DLGNBQWMsd0NBQXdDLHNCQUFzQixrQ0FBa0MsTUFBTSxZQUFZLG1CQUFtQixLQUFLLG1CQUFtQixjQUFjLGVBQWUscUJBQXFCLGVBQWUsMkJBQTJCLHNCQUFzQixpQ0FBaUMsY0FBYyxjQUFjLGtCQUFrQixlQUFlLGVBQWUsa0JBQWtCLFFBQVEsS0FBSyxXQUFXLEtBQUssOEJBQThCLGVBQWUsVUFBVSxRQUFRLEtBQUssV0FBVyxLQUFLLDhCQUE4QixlQUFlLFVBQVUsY0FBYyxTQUFTLFFBQVEsS0FBSyxLQUFLLEtBQUssVUFBVSxRQUFRLDJCQUEyQixzQkFBc0IsZUFBZSxxQkFBcUIsYUFBYSwyQkFBMkIsSUFBSSxlQUFlLEtBQUssTUFBTSx3QkFBd0Isd0JBQXdCLGVBQWUsbUJBQW1CLFNBQVMsWUFBWSxLQUFLLEtBQUssZ0NBQWdDLHdCQUF3QixlQUFlLG9DQUFvQyxLQUFLLEtBQUssNEJBQTRCLG1CQUFtQixpQ0FBaUMsU0FBUyw2QkFBNkIsY0FBYywwQkFBMEIsc0JBQXNCLGFBQWEsU0FBUyxXQUFXLHFCQUFxQixLQUFLLEtBQUssa0JBQWtCLFdBQVcsT0FBTyxJQUFJLE9BQU8sS0FBSyxTQUFTLDJCQUEyQix1QkFBdUIsb0JBQW9CLGlDQUFpQyw2RkFBNkYsY0FBYyxRQUFRLFNBQVMsV0FBVyxNQUFNLGtEQUFrRCx1Q0FBdUMsaUJBQWlCLFNBQVMsaUJBQWlCLEtBQUssS0FBSyxzQkFBc0IsV0FBVyxPQUFPLE1BQU0sT0FBTyxLQUFLLFdBQVcsUUFBUSxNQUFNLFNBQVMsd0JBQXdCLGFBQWEsS0FBSyxLQUFLLEtBQUssT0FBTyxhQUFhLDBCQUEwQixvQkFBb0IsS0FBSyxpQkFBaUIsS0FBSyxLQUFLLHlCQUF5QixPQUFPLE1BQU0sT0FBTyxnQkFBZ0IsUUFBUSxPQUFPLG1CQUFtQixxQkFBcUIsNkJBQTZCLGNBQWMsU0FBUyxRQUFRLFNBQVMsV0FBVyxRQUFRLHFCQUFxQixLQUFLLEtBQUssc0JBQXNCLFdBQVcsT0FBTyxNQUFNLE1BQU0sU0FBUyxXQUFXLFFBQVEsTUFBTSxXQUFXLGNBQWMsa0JBQWtCLGdCQUFnQixNQUFNLG1EQUFtRCxTQUFTLG9CQUFvQiwyQkFBMkIsa0NBQWtDLGlHQUFpRyxzQkFBc0IseUJBQXlCLGNBQWMsT0FBTyx1Q0FBdUMseUJBQXlCLHNCQUFzQixhQUFhLE1BQU0sTUFBTSxXQUFXLElBQUksS0FBSyxJQUFJLFNBQVMsUUFBUSxTQUFTLFdBQVcsaUJBQWlCLFFBQVEsS0FBSyxLQUFLLEtBQUssa0JBQWtCLFdBQVcsT0FBTyxNQUFNLE1BQU0sU0FBUyxXQUFXLFFBQVEsTUFBTSxXQUFXLGNBQWMsa0JBQWtCLGdCQUFnQixNQUFNLG1EQUFtRCxXQUFXLHVDQUF1QyxpQ0FBaUMsS0FBSyxhQUFhLG9CQUFvQixvQkFBb0IsS0FBSyxvQkFBb0Isb0JBQW9CLG1CQUFtQiw0QkFBNEIsb0JBQW9CLFNBQVMsOENBQThDLFVBQVUsY0FBYyxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzPzNjZDEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezExNDpmdW5jdGlvbihlKXtmdW5jdGlvbiBhc3NlcnRQYXRoKGUpe2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoZSkpfX1mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQb3NpeChlLHIpe3ZhciB0PVwiXCI7dmFyIGk9MDt2YXIgbj0tMTt2YXIgYT0wO3ZhciBmO2Zvcih2YXIgbD0wO2w8PWUubGVuZ3RoOysrbCl7aWYobDxlLmxlbmd0aClmPWUuY2hhckNvZGVBdChsKTtlbHNlIGlmKGY9PT00NylicmVhaztlbHNlIGY9NDc7aWYoZj09PTQ3KXtpZihuPT09bC0xfHxhPT09MSl7fWVsc2UgaWYobiE9PWwtMSYmYT09PTIpe2lmKHQubGVuZ3RoPDJ8fGkhPT0yfHx0LmNoYXJDb2RlQXQodC5sZW5ndGgtMSkhPT00Nnx8dC5jaGFyQ29kZUF0KHQubGVuZ3RoLTIpIT09NDYpe2lmKHQubGVuZ3RoPjIpe3ZhciBzPXQubGFzdEluZGV4T2YoXCIvXCIpO2lmKHMhPT10Lmxlbmd0aC0xKXtpZihzPT09LTEpe3Q9XCJcIjtpPTB9ZWxzZXt0PXQuc2xpY2UoMCxzKTtpPXQubGVuZ3RoLTEtdC5sYXN0SW5kZXhPZihcIi9cIil9bj1sO2E9MDtjb250aW51ZX19ZWxzZSBpZih0Lmxlbmd0aD09PTJ8fHQubGVuZ3RoPT09MSl7dD1cIlwiO2k9MDtuPWw7YT0wO2NvbnRpbnVlfX1pZihyKXtpZih0Lmxlbmd0aD4wKXQrPVwiLy4uXCI7ZWxzZSB0PVwiLi5cIjtpPTJ9fWVsc2V7aWYodC5sZW5ndGg+MCl0Kz1cIi9cIitlLnNsaWNlKG4rMSxsKTtlbHNlIHQ9ZS5zbGljZShuKzEsbCk7aT1sLW4tMX1uPWw7YT0wfWVsc2UgaWYoZj09PTQ2JiZhIT09LTEpeysrYX1lbHNle2E9LTF9fXJldHVybiB0fWZ1bmN0aW9uIF9mb3JtYXQoZSxyKXt2YXIgdD1yLmRpcnx8ci5yb290O3ZhciBpPXIuYmFzZXx8KHIubmFtZXx8XCJcIikrKHIuZXh0fHxcIlwiKTtpZighdCl7cmV0dXJuIGl9aWYodD09PXIucm9vdCl7cmV0dXJuIHQraX1yZXR1cm4gdCtlK2l9dmFyIHI9e3Jlc29sdmU6ZnVuY3Rpb24gcmVzb2x2ZSgpe3ZhciBlPVwiXCI7dmFyIHI9ZmFsc2U7dmFyIHQ7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgtMTtpPj0tMSYmIXI7aS0tKXt2YXIgbjtpZihpPj0wKW49YXJndW1lbnRzW2ldO2Vsc2V7aWYodD09PXVuZGVmaW5lZCl0PVwiXCI7bj10fWFzc2VydFBhdGgobik7aWYobi5sZW5ndGg9PT0wKXtjb250aW51ZX1lPW4rXCIvXCIrZTtyPW4uY2hhckNvZGVBdCgwKT09PTQ3fWU9bm9ybWFsaXplU3RyaW5nUG9zaXgoZSwhcik7aWYocil7aWYoZS5sZW5ndGg+MClyZXR1cm5cIi9cIitlO2Vsc2UgcmV0dXJuXCIvXCJ9ZWxzZSBpZihlLmxlbmd0aD4wKXtyZXR1cm4gZX1lbHNle3JldHVyblwiLlwifX0sbm9ybWFsaXplOmZ1bmN0aW9uIG5vcm1hbGl6ZShlKXthc3NlcnRQYXRoKGUpO2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgcj1lLmNoYXJDb2RlQXQoMCk9PT00Nzt2YXIgdD1lLmNoYXJDb2RlQXQoZS5sZW5ndGgtMSk9PT00NztlPW5vcm1hbGl6ZVN0cmluZ1Bvc2l4KGUsIXIpO2lmKGUubGVuZ3RoPT09MCYmIXIpZT1cIi5cIjtpZihlLmxlbmd0aD4wJiZ0KWUrPVwiL1wiO2lmKHIpcmV0dXJuXCIvXCIrZTtyZXR1cm4gZX0saXNBYnNvbHV0ZTpmdW5jdGlvbiBpc0Fic29sdXRlKGUpe2Fzc2VydFBhdGgoZSk7cmV0dXJuIGUubGVuZ3RoPjAmJmUuY2hhckNvZGVBdCgwKT09PTQ3fSxqb2luOmZ1bmN0aW9uIGpvaW4oKXtpZihhcmd1bWVudHMubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgZTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7Kyt0KXt2YXIgaT1hcmd1bWVudHNbdF07YXNzZXJ0UGF0aChpKTtpZihpLmxlbmd0aD4wKXtpZihlPT09dW5kZWZpbmVkKWU9aTtlbHNlIGUrPVwiL1wiK2l9fWlmKGU9PT11bmRlZmluZWQpcmV0dXJuXCIuXCI7cmV0dXJuIHIubm9ybWFsaXplKGUpfSxyZWxhdGl2ZTpmdW5jdGlvbiByZWxhdGl2ZShlLHQpe2Fzc2VydFBhdGgoZSk7YXNzZXJ0UGF0aCh0KTtpZihlPT09dClyZXR1cm5cIlwiO2U9ci5yZXNvbHZlKGUpO3Q9ci5yZXNvbHZlKHQpO2lmKGU9PT10KXJldHVyblwiXCI7dmFyIGk9MTtmb3IoO2k8ZS5sZW5ndGg7KytpKXtpZihlLmNoYXJDb2RlQXQoaSkhPT00NylicmVha312YXIgbj1lLmxlbmd0aDt2YXIgYT1uLWk7dmFyIGY9MTtmb3IoO2Y8dC5sZW5ndGg7KytmKXtpZih0LmNoYXJDb2RlQXQoZikhPT00NylicmVha312YXIgbD10Lmxlbmd0aDt2YXIgcz1sLWY7dmFyIG89YTxzP2E6czt2YXIgdT0tMTt2YXIgaD0wO2Zvcig7aDw9bzsrK2gpe2lmKGg9PT1vKXtpZihzPm8pe2lmKHQuY2hhckNvZGVBdChmK2gpPT09NDcpe3JldHVybiB0LnNsaWNlKGYraCsxKX1lbHNlIGlmKGg9PT0wKXtyZXR1cm4gdC5zbGljZShmK2gpfX1lbHNlIGlmKGE+byl7aWYoZS5jaGFyQ29kZUF0KGkraCk9PT00Nyl7dT1ofWVsc2UgaWYoaD09PTApe3U9MH19YnJlYWt9dmFyIGM9ZS5jaGFyQ29kZUF0KGkraCk7dmFyIHY9dC5jaGFyQ29kZUF0KGYraCk7aWYoYyE9PXYpYnJlYWs7ZWxzZSBpZihjPT09NDcpdT1ofXZhciBnPVwiXCI7Zm9yKGg9aSt1KzE7aDw9bjsrK2gpe2lmKGg9PT1ufHxlLmNoYXJDb2RlQXQoaCk9PT00Nyl7aWYoZy5sZW5ndGg9PT0wKWcrPVwiLi5cIjtlbHNlIGcrPVwiLy4uXCJ9fWlmKGcubGVuZ3RoPjApcmV0dXJuIGcrdC5zbGljZShmK3UpO2Vsc2V7Zis9dTtpZih0LmNoYXJDb2RlQXQoZik9PT00NykrK2Y7cmV0dXJuIHQuc2xpY2UoZil9fSxfbWFrZUxvbmc6ZnVuY3Rpb24gX21ha2VMb25nKGUpe3JldHVybiBlfSxkaXJuYW1lOmZ1bmN0aW9uIGRpcm5hbWUoZSl7YXNzZXJ0UGF0aChlKTtpZihlLmxlbmd0aD09PTApcmV0dXJuXCIuXCI7dmFyIHI9ZS5jaGFyQ29kZUF0KDApO3ZhciB0PXI9PT00Nzt2YXIgaT0tMTt2YXIgbj10cnVlO2Zvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTE7LS1hKXtyPWUuY2hhckNvZGVBdChhKTtpZihyPT09NDcpe2lmKCFuKXtpPWE7YnJlYWt9fWVsc2V7bj1mYWxzZX19aWYoaT09PS0xKXJldHVybiB0P1wiL1wiOlwiLlwiO2lmKHQmJmk9PT0xKXJldHVyblwiLy9cIjtyZXR1cm4gZS5zbGljZSgwLGkpfSxiYXNlbmFtZTpmdW5jdGlvbiBiYXNlbmFtZShlLHIpe2lmKHIhPT11bmRlZmluZWQmJnR5cGVvZiByIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4dFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTthc3NlcnRQYXRoKGUpO3ZhciB0PTA7dmFyIGk9LTE7dmFyIG49dHJ1ZTt2YXIgYTtpZihyIT09dW5kZWZpbmVkJiZyLmxlbmd0aD4wJiZyLmxlbmd0aDw9ZS5sZW5ndGgpe2lmKHIubGVuZ3RoPT09ZS5sZW5ndGgmJnI9PT1lKXJldHVyblwiXCI7dmFyIGY9ci5sZW5ndGgtMTt2YXIgbD0tMTtmb3IoYT1lLmxlbmd0aC0xO2E+PTA7LS1hKXt2YXIgcz1lLmNoYXJDb2RlQXQoYSk7aWYocz09PTQ3KXtpZighbil7dD1hKzE7YnJlYWt9fWVsc2V7aWYobD09PS0xKXtuPWZhbHNlO2w9YSsxfWlmKGY+PTApe2lmKHM9PT1yLmNoYXJDb2RlQXQoZikpe2lmKC0tZj09PS0xKXtpPWF9fWVsc2V7Zj0tMTtpPWx9fX19aWYodD09PWkpaT1sO2Vsc2UgaWYoaT09PS0xKWk9ZS5sZW5ndGg7cmV0dXJuIGUuc2xpY2UodCxpKX1lbHNle2ZvcihhPWUubGVuZ3RoLTE7YT49MDstLWEpe2lmKGUuY2hhckNvZGVBdChhKT09PTQ3KXtpZighbil7dD1hKzE7YnJlYWt9fWVsc2UgaWYoaT09PS0xKXtuPWZhbHNlO2k9YSsxfX1pZihpPT09LTEpcmV0dXJuXCJcIjtyZXR1cm4gZS5zbGljZSh0LGkpfX0sZXh0bmFtZTpmdW5jdGlvbiBleHRuYW1lKGUpe2Fzc2VydFBhdGgoZSk7dmFyIHI9LTE7dmFyIHQ9MDt2YXIgaT0tMTt2YXIgbj10cnVlO3ZhciBhPTA7Zm9yKHZhciBmPWUubGVuZ3RoLTE7Zj49MDstLWYpe3ZhciBsPWUuY2hhckNvZGVBdChmKTtpZihsPT09NDcpe2lmKCFuKXt0PWYrMTticmVha31jb250aW51ZX1pZihpPT09LTEpe249ZmFsc2U7aT1mKzF9aWYobD09PTQ2KXtpZihyPT09LTEpcj1mO2Vsc2UgaWYoYSE9PTEpYT0xfWVsc2UgaWYociE9PS0xKXthPS0xfX1pZihyPT09LTF8fGk9PT0tMXx8YT09PTB8fGE9PT0xJiZyPT09aS0xJiZyPT09dCsxKXtyZXR1cm5cIlwifXJldHVybiBlLnNsaWNlKHIsaSl9LGZvcm1hdDpmdW5jdGlvbiBmb3JtYXQoZSl7aWYoZT09PW51bGx8fHR5cGVvZiBlIT09XCJvYmplY3RcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgZSl9cmV0dXJuIF9mb3JtYXQoXCIvXCIsZSl9LHBhcnNlOmZ1bmN0aW9uIHBhcnNlKGUpe2Fzc2VydFBhdGgoZSk7dmFyIHI9e3Jvb3Q6XCJcIixkaXI6XCJcIixiYXNlOlwiXCIsZXh0OlwiXCIsbmFtZTpcIlwifTtpZihlLmxlbmd0aD09PTApcmV0dXJuIHI7dmFyIHQ9ZS5jaGFyQ29kZUF0KDApO3ZhciBpPXQ9PT00Nzt2YXIgbjtpZihpKXtyLnJvb3Q9XCIvXCI7bj0xfWVsc2V7bj0wfXZhciBhPS0xO3ZhciBmPTA7dmFyIGw9LTE7dmFyIHM9dHJ1ZTt2YXIgbz1lLmxlbmd0aC0xO3ZhciB1PTA7Zm9yKDtvPj1uOy0tbyl7dD1lLmNoYXJDb2RlQXQobyk7aWYodD09PTQ3KXtpZighcyl7Zj1vKzE7YnJlYWt9Y29udGludWV9aWYobD09PS0xKXtzPWZhbHNlO2w9bysxfWlmKHQ9PT00Nil7aWYoYT09PS0xKWE9bztlbHNlIGlmKHUhPT0xKXU9MX1lbHNlIGlmKGEhPT0tMSl7dT0tMX19aWYoYT09PS0xfHxsPT09LTF8fHU9PT0wfHx1PT09MSYmYT09PWwtMSYmYT09PWYrMSl7aWYobCE9PS0xKXtpZihmPT09MCYmaSlyLmJhc2U9ci5uYW1lPWUuc2xpY2UoMSxsKTtlbHNlIHIuYmFzZT1yLm5hbWU9ZS5zbGljZShmLGwpfX1lbHNle2lmKGY9PT0wJiZpKXtyLm5hbWU9ZS5zbGljZSgxLGEpO3IuYmFzZT1lLnNsaWNlKDEsbCl9ZWxzZXtyLm5hbWU9ZS5zbGljZShmLGEpO3IuYmFzZT1lLnNsaWNlKGYsbCl9ci5leHQ9ZS5zbGljZShhLGwpfWlmKGY+MClyLmRpcj1lLnNsaWNlKDAsZi0xKTtlbHNlIGlmKGkpci5kaXI9XCIvXCI7cmV0dXJuIHJ9LHNlcDpcIi9cIixkZWxpbWl0ZXI6XCI6XCIsd2luMzI6bnVsbCxwb3NpeDpudWxsfTtyLnBvc2l4PXI7ZS5leHBvcnRzPXJ9fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBpPXJbdF07aWYoaSE9PXVuZGVmaW5lZCl7cmV0dXJuIGkuZXhwb3J0c312YXIgbj1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKG4sbi5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBuLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oMTE0KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/path-browserify/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixtQkFBbUIsTUFBTSxNQUFNLDRCQUE0QixtREFBbUQsK0JBQStCLHFEQUFxRCxZQUFZLElBQUksbUNBQW1DLGFBQWEsS0FBSyxvQkFBb0IsU0FBUyxtQkFBbUIsSUFBSSxxQ0FBcUMsZUFBZSxLQUFLLHVCQUF1QixTQUFTLHVCQUF1QixJQUFJLHVCQUF1QixtQkFBbUIsdUJBQXVCLDJDQUEyQyxhQUFhLHVCQUF1QixJQUFJLGNBQWMsU0FBUyxJQUFJLHdCQUF3QixTQUFTLDBCQUEwQiw0QkFBNEIscUJBQXFCLHVCQUF1QixnREFBZ0QsZUFBZSx1QkFBdUIsSUFBSSxZQUFZLFNBQVMsSUFBSSxzQkFBc0IsU0FBUyx3QkFBd0IsU0FBUyxZQUFZLE1BQU0sU0FBUywyQkFBMkIsV0FBVyxPQUFPLFFBQVEsYUFBYSxjQUFjLEtBQUssS0FBSyxhQUFhLGNBQWMsc0JBQXNCLE1BQU0sT0FBTyxrQ0FBa0MsT0FBTyxlQUFlLFNBQVMsSUFBSSxLQUFLLGFBQWEsTUFBTSxZQUFZLEtBQUssV0FBVyxPQUFPLFFBQVEsbUJBQW1CLHVCQUF1QixvQ0FBb0MsdUJBQXVCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLHNCQUFzQixxQkFBcUIseUJBQXlCLG1CQUFtQixXQUFXLGFBQWEsOEJBQThCLGlDQUFpQyxrQkFBa0IsZUFBZSxTQUFTLFVBQVUsYUFBYSxjQUFjLGlCQUFpQixVQUFVLG1CQUFtQixZQUFZLFdBQVcsc0JBQXNCLDBCQUEwQixZQUFZLHVCQUF1QiwyQkFBMkIsd0JBQXdCLFVBQVUsc0JBQXNCLHFEQUFxRCxpQkFBaUIsV0FBVyxvQkFBb0IsbURBQW1ELG1CQUFtQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanM/MWIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MjI5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDIyOSk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/util/util.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/compiled/util/util.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n(function(){var r={992:function(r){r.exports=function(r,t,n){if(r.filter)return r.filter(t,n);if(void 0===r||null===r)throw new TypeError;if(\"function\"!=typeof t)throw new TypeError;var o=[];for(var i=0;i<r.length;i++){if(!e.call(r,i))continue;var a=r[i];if(t.call(n,a,i,r))o.push(a)}return o};var e=Object.prototype.hasOwnProperty},256:function(r,e,t){\"use strict\";var n=t(500);var o=t(139);var i=o(n(\"String.prototype.indexOf\"));r.exports=function callBoundIntrinsic(r,e){var t=n(r,!!e);if(typeof t===\"function\"&&i(r,\".prototype.\")>-1){return o(t)}return t}},139:function(r,e,t){\"use strict\";var n=t(174);var o=t(500);var i=o(\"%Function.prototype.apply%\");var a=o(\"%Function.prototype.call%\");var f=o(\"%Reflect.apply%\",true)||n.call(a,i);var u=o(\"%Object.getOwnPropertyDescriptor%\",true);var s=o(\"%Object.defineProperty%\",true);var y=o(\"%Math.max%\");if(s){try{s({},\"a\",{value:1})}catch(r){s=null}}r.exports=function callBind(r){var e=f(n,a,arguments);if(u&&s){var t=u(e,\"length\");if(t.configurable){s(e,\"length\",{value:1+y(0,r.length-(arguments.length-1))})}}return e};var c=function applyBind(){return f(n,i,arguments)};if(s){s(r.exports,\"apply\",{value:c})}else{r.exports.apply=c}},144:function(r){var e=Object.prototype.hasOwnProperty;var t=Object.prototype.toString;r.exports=function forEach(r,n,o){if(t.call(n)!==\"[object Function]\"){throw new TypeError(\"iterator must be a function\")}var i=r.length;if(i===+i){for(var a=0;a<i;a++){n.call(o,r[a],a,r)}}else{for(var f in r){if(e.call(r,f)){n.call(o,r[f],f,r)}}}}},426:function(r){\"use strict\";var e=\"Function.prototype.bind called on incompatible \";var t=Array.prototype.slice;var n=Object.prototype.toString;var o=\"[object Function]\";r.exports=function bind(r){var i=this;if(typeof i!==\"function\"||n.call(i)!==o){throw new TypeError(e+i)}var a=t.call(arguments,1);var f;var binder=function(){if(this instanceof f){var e=i.apply(this,a.concat(t.call(arguments)));if(Object(e)===e){return e}return this}else{return i.apply(r,a.concat(t.call(arguments)))}};var u=Math.max(0,i.length-a.length);var s=[];for(var y=0;y<u;y++){s.push(\"$\"+y)}f=Function(\"binder\",\"return function (\"+s.join(\",\")+\"){ return binder.apply(this,arguments); }\")(binder);if(i.prototype){var c=function Empty(){};c.prototype=i.prototype;f.prototype=new c;c.prototype=null}return f}},174:function(r,e,t){\"use strict\";var n=t(426);r.exports=Function.prototype.bind||n},500:function(r,e,t){\"use strict\";var n;var o=SyntaxError;var i=Function;var a=TypeError;var getEvalledConstructor=function(r){try{return i('\"use strict\"; return ('+r+\").constructor;\")()}catch(r){}};var f=Object.getOwnPropertyDescriptor;if(f){try{f({},\"\")}catch(r){f=null}}var throwTypeError=function(){throw new a};var u=f?function(){try{arguments.callee;return throwTypeError}catch(r){try{return f(arguments,\"callee\").get}catch(r){return throwTypeError}}}():throwTypeError;var s=t(115)();var y=Object.getPrototypeOf||function(r){return r.__proto__};var c={};var p=typeof Uint8Array===\"undefined\"?n:y(Uint8Array);var l={\"%AggregateError%\":typeof AggregateError===\"undefined\"?n:AggregateError,\"%Array%\":Array,\"%ArrayBuffer%\":typeof ArrayBuffer===\"undefined\"?n:ArrayBuffer,\"%ArrayIteratorPrototype%\":s?y([][Symbol.iterator]()):n,\"%AsyncFromSyncIteratorPrototype%\":n,\"%AsyncFunction%\":c,\"%AsyncGenerator%\":c,\"%AsyncGeneratorFunction%\":c,\"%AsyncIteratorPrototype%\":c,\"%Atomics%\":typeof Atomics===\"undefined\"?n:Atomics,\"%BigInt%\":typeof BigInt===\"undefined\"?n:BigInt,\"%Boolean%\":Boolean,\"%DataView%\":typeof DataView===\"undefined\"?n:DataView,\"%Date%\":Date,\"%decodeURI%\":decodeURI,\"%decodeURIComponent%\":decodeURIComponent,\"%encodeURI%\":encodeURI,\"%encodeURIComponent%\":encodeURIComponent,\"%Error%\":Error,\"%eval%\":eval,\"%EvalError%\":EvalError,\"%Float32Array%\":typeof Float32Array===\"undefined\"?n:Float32Array,\"%Float64Array%\":typeof Float64Array===\"undefined\"?n:Float64Array,\"%FinalizationRegistry%\":typeof FinalizationRegistry===\"undefined\"?n:FinalizationRegistry,\"%Function%\":i,\"%GeneratorFunction%\":c,\"%Int8Array%\":typeof Int8Array===\"undefined\"?n:Int8Array,\"%Int16Array%\":typeof Int16Array===\"undefined\"?n:Int16Array,\"%Int32Array%\":typeof Int32Array===\"undefined\"?n:Int32Array,\"%isFinite%\":isFinite,\"%isNaN%\":isNaN,\"%IteratorPrototype%\":s?y(y([][Symbol.iterator]())):n,\"%JSON%\":typeof JSON===\"object\"?JSON:n,\"%Map%\":typeof Map===\"undefined\"?n:Map,\"%MapIteratorPrototype%\":typeof Map===\"undefined\"||!s?n:y((new Map)[Symbol.iterator]()),\"%Math%\":Math,\"%Number%\":Number,\"%Object%\":Object,\"%parseFloat%\":parseFloat,\"%parseInt%\":parseInt,\"%Promise%\":typeof Promise===\"undefined\"?n:Promise,\"%Proxy%\":typeof Proxy===\"undefined\"?n:Proxy,\"%RangeError%\":RangeError,\"%ReferenceError%\":ReferenceError,\"%Reflect%\":typeof Reflect===\"undefined\"?n:Reflect,\"%RegExp%\":RegExp,\"%Set%\":typeof Set===\"undefined\"?n:Set,\"%SetIteratorPrototype%\":typeof Set===\"undefined\"||!s?n:y((new Set)[Symbol.iterator]()),\"%SharedArrayBuffer%\":typeof SharedArrayBuffer===\"undefined\"?n:SharedArrayBuffer,\"%String%\":String,\"%StringIteratorPrototype%\":s?y(\"\"[Symbol.iterator]()):n,\"%Symbol%\":s?Symbol:n,\"%SyntaxError%\":o,\"%ThrowTypeError%\":u,\"%TypedArray%\":p,\"%TypeError%\":a,\"%Uint8Array%\":typeof Uint8Array===\"undefined\"?n:Uint8Array,\"%Uint8ClampedArray%\":typeof Uint8ClampedArray===\"undefined\"?n:Uint8ClampedArray,\"%Uint16Array%\":typeof Uint16Array===\"undefined\"?n:Uint16Array,\"%Uint32Array%\":typeof Uint32Array===\"undefined\"?n:Uint32Array,\"%URIError%\":URIError,\"%WeakMap%\":typeof WeakMap===\"undefined\"?n:WeakMap,\"%WeakRef%\":typeof WeakRef===\"undefined\"?n:WeakRef,\"%WeakSet%\":typeof WeakSet===\"undefined\"?n:WeakSet};var g=function doEval(r){var e;if(r===\"%AsyncFunction%\"){e=getEvalledConstructor(\"async function () {}\")}else if(r===\"%GeneratorFunction%\"){e=getEvalledConstructor(\"function* () {}\")}else if(r===\"%AsyncGeneratorFunction%\"){e=getEvalledConstructor(\"async function* () {}\")}else if(r===\"%AsyncGenerator%\"){var t=doEval(\"%AsyncGeneratorFunction%\");if(t){e=t.prototype}}else if(r===\"%AsyncIteratorPrototype%\"){var n=doEval(\"%AsyncGenerator%\");if(n){e=y(n.prototype)}}l[r]=e;return e};var b={\"%ArrayBufferPrototype%\":[\"ArrayBuffer\",\"prototype\"],\"%ArrayPrototype%\":[\"Array\",\"prototype\"],\"%ArrayProto_entries%\":[\"Array\",\"prototype\",\"entries\"],\"%ArrayProto_forEach%\":[\"Array\",\"prototype\",\"forEach\"],\"%ArrayProto_keys%\":[\"Array\",\"prototype\",\"keys\"],\"%ArrayProto_values%\":[\"Array\",\"prototype\",\"values\"],\"%AsyncFunctionPrototype%\":[\"AsyncFunction\",\"prototype\"],\"%AsyncGenerator%\":[\"AsyncGeneratorFunction\",\"prototype\"],\"%AsyncGeneratorPrototype%\":[\"AsyncGeneratorFunction\",\"prototype\",\"prototype\"],\"%BooleanPrototype%\":[\"Boolean\",\"prototype\"],\"%DataViewPrototype%\":[\"DataView\",\"prototype\"],\"%DatePrototype%\":[\"Date\",\"prototype\"],\"%ErrorPrototype%\":[\"Error\",\"prototype\"],\"%EvalErrorPrototype%\":[\"EvalError\",\"prototype\"],\"%Float32ArrayPrototype%\":[\"Float32Array\",\"prototype\"],\"%Float64ArrayPrototype%\":[\"Float64Array\",\"prototype\"],\"%FunctionPrototype%\":[\"Function\",\"prototype\"],\"%Generator%\":[\"GeneratorFunction\",\"prototype\"],\"%GeneratorPrototype%\":[\"GeneratorFunction\",\"prototype\",\"prototype\"],\"%Int8ArrayPrototype%\":[\"Int8Array\",\"prototype\"],\"%Int16ArrayPrototype%\":[\"Int16Array\",\"prototype\"],\"%Int32ArrayPrototype%\":[\"Int32Array\",\"prototype\"],\"%JSONParse%\":[\"JSON\",\"parse\"],\"%JSONStringify%\":[\"JSON\",\"stringify\"],\"%MapPrototype%\":[\"Map\",\"prototype\"],\"%NumberPrototype%\":[\"Number\",\"prototype\"],\"%ObjectPrototype%\":[\"Object\",\"prototype\"],\"%ObjProto_toString%\":[\"Object\",\"prototype\",\"toString\"],\"%ObjProto_valueOf%\":[\"Object\",\"prototype\",\"valueOf\"],\"%PromisePrototype%\":[\"Promise\",\"prototype\"],\"%PromiseProto_then%\":[\"Promise\",\"prototype\",\"then\"],\"%Promise_all%\":[\"Promise\",\"all\"],\"%Promise_reject%\":[\"Promise\",\"reject\"],\"%Promise_resolve%\":[\"Promise\",\"resolve\"],\"%RangeErrorPrototype%\":[\"RangeError\",\"prototype\"],\"%ReferenceErrorPrototype%\":[\"ReferenceError\",\"prototype\"],\"%RegExpPrototype%\":[\"RegExp\",\"prototype\"],\"%SetPrototype%\":[\"Set\",\"prototype\"],\"%SharedArrayBufferPrototype%\":[\"SharedArrayBuffer\",\"prototype\"],\"%StringPrototype%\":[\"String\",\"prototype\"],\"%SymbolPrototype%\":[\"Symbol\",\"prototype\"],\"%SyntaxErrorPrototype%\":[\"SyntaxError\",\"prototype\"],\"%TypedArrayPrototype%\":[\"TypedArray\",\"prototype\"],\"%TypeErrorPrototype%\":[\"TypeError\",\"prototype\"],\"%Uint8ArrayPrototype%\":[\"Uint8Array\",\"prototype\"],\"%Uint8ClampedArrayPrototype%\":[\"Uint8ClampedArray\",\"prototype\"],\"%Uint16ArrayPrototype%\":[\"Uint16Array\",\"prototype\"],\"%Uint32ArrayPrototype%\":[\"Uint32Array\",\"prototype\"],\"%URIErrorPrototype%\":[\"URIError\",\"prototype\"],\"%WeakMapPrototype%\":[\"WeakMap\",\"prototype\"],\"%WeakSetPrototype%\":[\"WeakSet\",\"prototype\"]};var d=t(174);var v=t(101);var m=d.call(Function.call,Array.prototype.concat);var S=d.call(Function.apply,Array.prototype.splice);var A=d.call(Function.call,String.prototype.replace);var h=d.call(Function.call,String.prototype.slice);var O=d.call(Function.call,RegExp.prototype.exec);var j=/[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;var w=/\\\\(\\\\)?/g;var P=function stringToPath(r){var e=h(r,0,1);var t=h(r,-1);if(e===\"%\"&&t!==\"%\"){throw new o(\"invalid intrinsic syntax, expected closing `%`\")}else if(t===\"%\"&&e!==\"%\"){throw new o(\"invalid intrinsic syntax, expected opening `%`\")}var n=[];A(r,j,(function(r,e,t,o){n[n.length]=t?A(o,w,\"$1\"):e||r}));return n};var E=function getBaseIntrinsic(r,e){var t=r;var n;if(v(b,t)){n=b[t];t=\"%\"+n[0]+\"%\"}if(v(l,t)){var i=l[t];if(i===c){i=g(t)}if(typeof i===\"undefined\"&&!e){throw new a(\"intrinsic \"+r+\" exists, but is not available. Please file an issue!\")}return{alias:n,name:t,value:i}}throw new o(\"intrinsic \"+r+\" does not exist!\")};r.exports=function GetIntrinsic(r,e){if(typeof r!==\"string\"||r.length===0){throw new a(\"intrinsic name must be a non-empty string\")}if(arguments.length>1&&typeof e!==\"boolean\"){throw new a('\"allowMissing\" argument must be a boolean')}if(O(/^%?[^%]*%?$/g,r)===null){throw new o(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\")}var t=P(r);var i=t.length>0?t[0]:\"\";var u=E(\"%\"+i+\"%\",e);var s=u.name;var y=u.value;var c=false;var p=u.alias;if(p){i=p[0];S(t,m([0,1],p))}for(var g=1,b=true;g<t.length;g+=1){var d=t[g];var A=h(d,0,1);var j=h(d,-1);if((A==='\"'||A===\"'\"||A===\"`\"||(j==='\"'||j===\"'\"||j===\"`\"))&&A!==j){throw new o(\"property names with quotes must have matching quotes\")}if(d===\"constructor\"||!b){c=true}i+=\".\"+d;s=\"%\"+i+\"%\";if(v(l,s)){y=l[s]}else if(y!=null){if(!(d in y)){if(!e){throw new a(\"base intrinsic for \"+r+\" exists, but the property is not available.\")}return void n}if(f&&g+1>=t.length){var w=f(y,d);b=!!w;if(b&&\"get\"in w&&!(\"originalValue\"in w.get)){y=w.get}else{y=y[d]}}else{b=v(y,d);y=y[d]}if(b&&!c){l[s]=y}}}return y}},942:function(r,e,t){\"use strict\";var n=typeof Symbol!==\"undefined\"&&Symbol;var o=t(773);r.exports=function hasNativeSymbols(){if(typeof n!==\"function\"){return false}if(typeof Symbol!==\"function\"){return false}if(typeof n(\"foo\")!==\"symbol\"){return false}if(typeof Symbol(\"bar\")!==\"symbol\"){return false}return o()}},773:function(r){\"use strict\";r.exports=function hasSymbols(){if(typeof Symbol!==\"function\"||typeof Object.getOwnPropertySymbols!==\"function\"){return false}if(typeof Symbol.iterator===\"symbol\"){return true}var r={};var e=Symbol(\"test\");var t=Object(e);if(typeof e===\"string\"){return false}if(Object.prototype.toString.call(e)!==\"[object Symbol]\"){return false}if(Object.prototype.toString.call(t)!==\"[object Symbol]\"){return false}var n=42;r[e]=n;for(e in r){return false}if(typeof Object.keys===\"function\"&&Object.keys(r).length!==0){return false}if(typeof Object.getOwnPropertyNames===\"function\"&&Object.getOwnPropertyNames(r).length!==0){return false}var o=Object.getOwnPropertySymbols(r);if(o.length!==1||o[0]!==e){return false}if(!Object.prototype.propertyIsEnumerable.call(r,e)){return false}if(typeof Object.getOwnPropertyDescriptor===\"function\"){var i=Object.getOwnPropertyDescriptor(r,e);if(i.value!==n||i.enumerable!==true){return false}}return true}},115:function(r,e,t){\"use strict\";var n=typeof Symbol!==\"undefined\"&&Symbol;var o=t(832);r.exports=function hasNativeSymbols(){if(typeof n!==\"function\"){return false}if(typeof Symbol!==\"function\"){return false}if(typeof n(\"foo\")!==\"symbol\"){return false}if(typeof Symbol(\"bar\")!==\"symbol\"){return false}return o()}},832:function(r){\"use strict\";r.exports=function hasSymbols(){if(typeof Symbol!==\"function\"||typeof Object.getOwnPropertySymbols!==\"function\"){return false}if(typeof Symbol.iterator===\"symbol\"){return true}var r={};var e=Symbol(\"test\");var t=Object(e);if(typeof e===\"string\"){return false}if(Object.prototype.toString.call(e)!==\"[object Symbol]\"){return false}if(Object.prototype.toString.call(t)!==\"[object Symbol]\"){return false}var n=42;r[e]=n;for(e in r){return false}if(typeof Object.keys===\"function\"&&Object.keys(r).length!==0){return false}if(typeof Object.getOwnPropertyNames===\"function\"&&Object.getOwnPropertyNames(r).length!==0){return false}var o=Object.getOwnPropertySymbols(r);if(o.length!==1||o[0]!==e){return false}if(!Object.prototype.propertyIsEnumerable.call(r,e)){return false}if(typeof Object.getOwnPropertyDescriptor===\"function\"){var i=Object.getOwnPropertyDescriptor(r,e);if(i.value!==n||i.enumerable!==true){return false}}return true}},101:function(r,e,t){\"use strict\";var n=t(174);r.exports=n.call(Function.call,Object.prototype.hasOwnProperty)},782:function(r){if(typeof Object.create===\"function\"){r.exports=function inherits(r,e){if(e){r.super_=e;r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:false,writable:true,configurable:true}})}}}else{r.exports=function inherits(r,e){if(e){r.super_=e;var TempCtor=function(){};TempCtor.prototype=e.prototype;r.prototype=new TempCtor;r.prototype.constructor=r}}}},157:function(r){\"use strict\";var e=typeof Symbol===\"function\"&&typeof Symbol.toStringTag===\"symbol\";var t=Object.prototype.toString;var n=function isArguments(r){if(e&&r&&typeof r===\"object\"&&Symbol.toStringTag in r){return false}return t.call(r)===\"[object Arguments]\"};var o=function isArguments(r){if(n(r)){return true}return r!==null&&typeof r===\"object\"&&typeof r.length===\"number\"&&r.length>=0&&t.call(r)!==\"[object Array]\"&&t.call(r.callee)===\"[object Function]\"};var i=function(){return n(arguments)}();n.isLegacyArguments=o;r.exports=i?n:o},391:function(r){\"use strict\";var e=Object.prototype.toString;var t=Function.prototype.toString;var n=/^\\s*(?:function)?\\*/;var o=typeof Symbol===\"function\"&&typeof Symbol.toStringTag===\"symbol\";var i=Object.getPrototypeOf;var getGeneratorFunc=function(){if(!o){return false}try{return Function(\"return function*() {}\")()}catch(r){}};var a=getGeneratorFunc();var f=a?i(a):{};r.exports=function isGeneratorFunction(r){if(typeof r!==\"function\"){return false}if(n.test(t.call(r))){return true}if(!o){var a=e.call(r);return a===\"[object GeneratorFunction]\"}return i(r)===f}},994:function(r,e,t){\"use strict\";var n=t(144);var o=t(349);var i=t(256);var a=i(\"Object.prototype.toString\");var f=t(942)();var u=f&&typeof Symbol.toStringTag===\"symbol\";var s=o();var y=i(\"Array.prototype.indexOf\",true)||function indexOf(r,e){for(var t=0;t<r.length;t+=1){if(r[t]===e){return t}}return-1};var c=i(\"String.prototype.slice\");var p={};var l=t(466);var g=Object.getPrototypeOf;if(u&&l&&g){n(s,(function(r){var e=new __webpack_require__.g[r];if(!(Symbol.toStringTag in e)){throw new EvalError(\"this engine has support for Symbol.toStringTag, but \"+r+\" does not have the property! Please report this.\")}var t=g(e);var n=l(t,Symbol.toStringTag);if(!n){var o=g(t);n=l(o,Symbol.toStringTag)}p[r]=n.get}))}var b=function tryAllTypedArrays(r){var e=false;n(p,(function(t,n){if(!e){try{e=t.call(r)===n}catch(r){}}}));return e};r.exports=function isTypedArray(r){if(!r||typeof r!==\"object\"){return false}if(!u){var e=c(a(r),8,-1);return y(s,e)>-1}if(!l){return false}return b(r)}},369:function(r){r.exports=function isBuffer(r){return r instanceof Buffer}},584:function(r,e,t){\"use strict\";var n=t(157);var o=t(391);var i=t(490);var a=t(994);function uncurryThis(r){return r.call.bind(r)}var f=typeof BigInt!==\"undefined\";var u=typeof Symbol!==\"undefined\";var s=uncurryThis(Object.prototype.toString);var y=uncurryThis(Number.prototype.valueOf);var c=uncurryThis(String.prototype.valueOf);var p=uncurryThis(Boolean.prototype.valueOf);if(f){var l=uncurryThis(BigInt.prototype.valueOf)}if(u){var g=uncurryThis(Symbol.prototype.valueOf)}function checkBoxedPrimitive(r,e){if(typeof r!==\"object\"){return false}try{e(r);return true}catch(r){return false}}e.isArgumentsObject=n;e.isGeneratorFunction=o;e.isTypedArray=a;function isPromise(r){return typeof Promise!==\"undefined\"&&r instanceof Promise||r!==null&&typeof r===\"object\"&&typeof r.then===\"function\"&&typeof r.catch===\"function\"}e.isPromise=isPromise;function isArrayBufferView(r){if(typeof ArrayBuffer!==\"undefined\"&&ArrayBuffer.isView){return ArrayBuffer.isView(r)}return a(r)||isDataView(r)}e.isArrayBufferView=isArrayBufferView;function isUint8Array(r){return i(r)===\"Uint8Array\"}e.isUint8Array=isUint8Array;function isUint8ClampedArray(r){return i(r)===\"Uint8ClampedArray\"}e.isUint8ClampedArray=isUint8ClampedArray;function isUint16Array(r){return i(r)===\"Uint16Array\"}e.isUint16Array=isUint16Array;function isUint32Array(r){return i(r)===\"Uint32Array\"}e.isUint32Array=isUint32Array;function isInt8Array(r){return i(r)===\"Int8Array\"}e.isInt8Array=isInt8Array;function isInt16Array(r){return i(r)===\"Int16Array\"}e.isInt16Array=isInt16Array;function isInt32Array(r){return i(r)===\"Int32Array\"}e.isInt32Array=isInt32Array;function isFloat32Array(r){return i(r)===\"Float32Array\"}e.isFloat32Array=isFloat32Array;function isFloat64Array(r){return i(r)===\"Float64Array\"}e.isFloat64Array=isFloat64Array;function isBigInt64Array(r){return i(r)===\"BigInt64Array\"}e.isBigInt64Array=isBigInt64Array;function isBigUint64Array(r){return i(r)===\"BigUint64Array\"}e.isBigUint64Array=isBigUint64Array;function isMapToString(r){return s(r)===\"[object Map]\"}isMapToString.working=typeof Map!==\"undefined\"&&isMapToString(new Map);function isMap(r){if(typeof Map===\"undefined\"){return false}return isMapToString.working?isMapToString(r):r instanceof Map}e.isMap=isMap;function isSetToString(r){return s(r)===\"[object Set]\"}isSetToString.working=typeof Set!==\"undefined\"&&isSetToString(new Set);function isSet(r){if(typeof Set===\"undefined\"){return false}return isSetToString.working?isSetToString(r):r instanceof Set}e.isSet=isSet;function isWeakMapToString(r){return s(r)===\"[object WeakMap]\"}isWeakMapToString.working=typeof WeakMap!==\"undefined\"&&isWeakMapToString(new WeakMap);function isWeakMap(r){if(typeof WeakMap===\"undefined\"){return false}return isWeakMapToString.working?isWeakMapToString(r):r instanceof WeakMap}e.isWeakMap=isWeakMap;function isWeakSetToString(r){return s(r)===\"[object WeakSet]\"}isWeakSetToString.working=typeof WeakSet!==\"undefined\"&&isWeakSetToString(new WeakSet);function isWeakSet(r){return isWeakSetToString(r)}e.isWeakSet=isWeakSet;function isArrayBufferToString(r){return s(r)===\"[object ArrayBuffer]\"}isArrayBufferToString.working=typeof ArrayBuffer!==\"undefined\"&&isArrayBufferToString(new ArrayBuffer);function isArrayBuffer(r){if(typeof ArrayBuffer===\"undefined\"){return false}return isArrayBufferToString.working?isArrayBufferToString(r):r instanceof ArrayBuffer}e.isArrayBuffer=isArrayBuffer;function isDataViewToString(r){return s(r)===\"[object DataView]\"}isDataViewToString.working=typeof ArrayBuffer!==\"undefined\"&&typeof DataView!==\"undefined\"&&isDataViewToString(new DataView(new ArrayBuffer(1),0,1));function isDataView(r){if(typeof DataView===\"undefined\"){return false}return isDataViewToString.working?isDataViewToString(r):r instanceof DataView}e.isDataView=isDataView;var b=typeof SharedArrayBuffer!==\"undefined\"?SharedArrayBuffer:undefined;function isSharedArrayBufferToString(r){return s(r)===\"[object SharedArrayBuffer]\"}function isSharedArrayBuffer(r){if(typeof b===\"undefined\"){return false}if(typeof isSharedArrayBufferToString.working===\"undefined\"){isSharedArrayBufferToString.working=isSharedArrayBufferToString(new b)}return isSharedArrayBufferToString.working?isSharedArrayBufferToString(r):r instanceof b}e.isSharedArrayBuffer=isSharedArrayBuffer;function isAsyncFunction(r){return s(r)===\"[object AsyncFunction]\"}e.isAsyncFunction=isAsyncFunction;function isMapIterator(r){return s(r)===\"[object Map Iterator]\"}e.isMapIterator=isMapIterator;function isSetIterator(r){return s(r)===\"[object Set Iterator]\"}e.isSetIterator=isSetIterator;function isGeneratorObject(r){return s(r)===\"[object Generator]\"}e.isGeneratorObject=isGeneratorObject;function isWebAssemblyCompiledModule(r){return s(r)===\"[object WebAssembly.Module]\"}e.isWebAssemblyCompiledModule=isWebAssemblyCompiledModule;function isNumberObject(r){return checkBoxedPrimitive(r,y)}e.isNumberObject=isNumberObject;function isStringObject(r){return checkBoxedPrimitive(r,c)}e.isStringObject=isStringObject;function isBooleanObject(r){return checkBoxedPrimitive(r,p)}e.isBooleanObject=isBooleanObject;function isBigIntObject(r){return f&&checkBoxedPrimitive(r,l)}e.isBigIntObject=isBigIntObject;function isSymbolObject(r){return u&&checkBoxedPrimitive(r,g)}e.isSymbolObject=isSymbolObject;function isBoxedPrimitive(r){return isNumberObject(r)||isStringObject(r)||isBooleanObject(r)||isBigIntObject(r)||isSymbolObject(r)}e.isBoxedPrimitive=isBoxedPrimitive;function isAnyArrayBuffer(r){return typeof Uint8Array!==\"undefined\"&&(isArrayBuffer(r)||isSharedArrayBuffer(r))}e.isAnyArrayBuffer=isAnyArrayBuffer;[\"isProxy\",\"isExternal\",\"isModuleNamespaceObject\"].forEach((function(r){Object.defineProperty(e,r,{enumerable:false,value:function(){throw new Error(r+\" is not supported in userland\")}})}))},177:function(r,e,t){var n=Object.getOwnPropertyDescriptors||function getOwnPropertyDescriptors(r){var e=Object.keys(r);var t={};for(var n=0;n<e.length;n++){t[e[n]]=Object.getOwnPropertyDescriptor(r,e[n])}return t};var o=/%[sdj%]/g;e.format=function(r){if(!isString(r)){var e=[];for(var t=0;t<arguments.length;t++){e.push(inspect(arguments[t]))}return e.join(\" \")}var t=1;var n=arguments;var i=n.length;var a=String(r).replace(o,(function(r){if(r===\"%%\")return\"%\";if(t>=i)return r;switch(r){case\"%s\":return String(n[t++]);case\"%d\":return Number(n[t++]);case\"%j\":try{return JSON.stringify(n[t++])}catch(r){return\"[Circular]\"}default:return r}}));for(var f=n[t];t<i;f=n[++t]){if(isNull(f)||!isObject(f)){a+=\" \"+f}else{a+=\" \"+inspect(f)}}return a};e.deprecate=function(r,t){if(typeof process!==\"undefined\"&&process.noDeprecation===true){return r}if(typeof process===\"undefined\"){return function(){return e.deprecate(r,t).apply(this,arguments)}}var n=false;function deprecated(){if(!n){if(process.throwDeprecation){throw new Error(t)}else if(process.traceDeprecation){console.trace(t)}else{console.error(t)}n=true}return r.apply(this,arguments)}return deprecated};var i={};var a=/^$/;if(process.env.NODE_DEBUG){var f=process.env.NODE_DEBUG;f=f.replace(/[|\\\\{}()[\\]^$+?.]/g,\"\\\\$&\").replace(/\\*/g,\".*\").replace(/,/g,\"$|^\").toUpperCase();a=new RegExp(\"^\"+f+\"$\",\"i\")}e.debuglog=function(r){r=r.toUpperCase();if(!i[r]){if(a.test(r)){var t=process.pid;i[r]=function(){var n=e.format.apply(e,arguments);console.error(\"%s %d: %s\",r,t,n)}}else{i[r]=function(){}}}return i[r]};function inspect(r,t){var n={seen:[],stylize:stylizeNoColor};if(arguments.length>=3)n.depth=arguments[2];if(arguments.length>=4)n.colors=arguments[3];if(isBoolean(t)){n.showHidden=t}else if(t){e._extend(n,t)}if(isUndefined(n.showHidden))n.showHidden=false;if(isUndefined(n.depth))n.depth=2;if(isUndefined(n.colors))n.colors=false;if(isUndefined(n.customInspect))n.customInspect=true;if(n.colors)n.stylize=stylizeWithColor;return formatValue(n,r,n.depth)}e.inspect=inspect;inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]};inspect.styles={special:\"cyan\",number:\"yellow\",boolean:\"yellow\",undefined:\"grey\",null:\"bold\",string:\"green\",date:\"magenta\",regexp:\"red\"};function stylizeWithColor(r,e){var t=inspect.styles[e];if(t){return\"\u001b[\"+inspect.colors[t][0]+\"m\"+r+\"\u001b[\"+inspect.colors[t][1]+\"m\"}else{return r}}function stylizeNoColor(r,e){return r}function arrayToHash(r){var e={};r.forEach((function(r,t){e[r]=true}));return e}function formatValue(r,t,n){if(r.customInspect&&t&&isFunction(t.inspect)&&t.inspect!==e.inspect&&!(t.constructor&&t.constructor.prototype===t)){var o=t.inspect(n,r);if(!isString(o)){o=formatValue(r,o,n)}return o}var i=formatPrimitive(r,t);if(i){return i}var a=Object.keys(t);var f=arrayToHash(a);if(r.showHidden){a=Object.getOwnPropertyNames(t)}if(isError(t)&&(a.indexOf(\"message\")>=0||a.indexOf(\"description\")>=0)){return formatError(t)}if(a.length===0){if(isFunction(t)){var u=t.name?\": \"+t.name:\"\";return r.stylize(\"[Function\"+u+\"]\",\"special\")}if(isRegExp(t)){return r.stylize(RegExp.prototype.toString.call(t),\"regexp\")}if(isDate(t)){return r.stylize(Date.prototype.toString.call(t),\"date\")}if(isError(t)){return formatError(t)}}var s=\"\",y=false,c=[\"{\",\"}\"];if(isArray(t)){y=true;c=[\"[\",\"]\"]}if(isFunction(t)){var p=t.name?\": \"+t.name:\"\";s=\" [Function\"+p+\"]\"}if(isRegExp(t)){s=\" \"+RegExp.prototype.toString.call(t)}if(isDate(t)){s=\" \"+Date.prototype.toUTCString.call(t)}if(isError(t)){s=\" \"+formatError(t)}if(a.length===0&&(!y||t.length==0)){return c[0]+s+c[1]}if(n<0){if(isRegExp(t)){return r.stylize(RegExp.prototype.toString.call(t),\"regexp\")}else{return r.stylize(\"[Object]\",\"special\")}}r.seen.push(t);var l;if(y){l=formatArray(r,t,n,f,a)}else{l=a.map((function(e){return formatProperty(r,t,n,f,e,y)}))}r.seen.pop();return reduceToSingleString(l,s,c)}function formatPrimitive(r,e){if(isUndefined(e))return r.stylize(\"undefined\",\"undefined\");if(isString(e)){var t=\"'\"+JSON.stringify(e).replace(/^\"|\"$/g,\"\").replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"')+\"'\";return r.stylize(t,\"string\")}if(isNumber(e))return r.stylize(\"\"+e,\"number\");if(isBoolean(e))return r.stylize(\"\"+e,\"boolean\");if(isNull(e))return r.stylize(\"null\",\"null\")}function formatError(r){return\"[\"+Error.prototype.toString.call(r)+\"]\"}function formatArray(r,e,t,n,o){var i=[];for(var a=0,f=e.length;a<f;++a){if(hasOwnProperty(e,String(a))){i.push(formatProperty(r,e,t,n,String(a),true))}else{i.push(\"\")}}o.forEach((function(o){if(!o.match(/^\\d+$/)){i.push(formatProperty(r,e,t,n,o,true))}}));return i}function formatProperty(r,e,t,n,o,i){var a,f,u;u=Object.getOwnPropertyDescriptor(e,o)||{value:e[o]};if(u.get){if(u.set){f=r.stylize(\"[Getter/Setter]\",\"special\")}else{f=r.stylize(\"[Getter]\",\"special\")}}else{if(u.set){f=r.stylize(\"[Setter]\",\"special\")}}if(!hasOwnProperty(n,o)){a=\"[\"+o+\"]\"}if(!f){if(r.seen.indexOf(u.value)<0){if(isNull(t)){f=formatValue(r,u.value,null)}else{f=formatValue(r,u.value,t-1)}if(f.indexOf(\"\\n\")>-1){if(i){f=f.split(\"\\n\").map((function(r){return\"  \"+r})).join(\"\\n\").substr(2)}else{f=\"\\n\"+f.split(\"\\n\").map((function(r){return\"   \"+r})).join(\"\\n\")}}}else{f=r.stylize(\"[Circular]\",\"special\")}}if(isUndefined(a)){if(i&&o.match(/^\\d+$/)){return f}a=JSON.stringify(\"\"+o);if(a.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)){a=a.substr(1,a.length-2);a=r.stylize(a,\"name\")}else{a=a.replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"').replace(/(^\"|\"$)/g,\"'\");a=r.stylize(a,\"string\")}}return a+\": \"+f}function reduceToSingleString(r,e,t){var n=0;var o=r.reduce((function(r,e){n++;if(e.indexOf(\"\\n\")>=0)n++;return r+e.replace(/\\u001b\\[\\d\\d?m/g,\"\").length+1}),0);if(o>60){return t[0]+(e===\"\"?\"\":e+\"\\n \")+\" \"+r.join(\",\\n  \")+\" \"+t[1]}return t[0]+e+\" \"+r.join(\", \")+\" \"+t[1]}e.types=t(584);function isArray(r){return Array.isArray(r)}e.isArray=isArray;function isBoolean(r){return typeof r===\"boolean\"}e.isBoolean=isBoolean;function isNull(r){return r===null}e.isNull=isNull;function isNullOrUndefined(r){return r==null}e.isNullOrUndefined=isNullOrUndefined;function isNumber(r){return typeof r===\"number\"}e.isNumber=isNumber;function isString(r){return typeof r===\"string\"}e.isString=isString;function isSymbol(r){return typeof r===\"symbol\"}e.isSymbol=isSymbol;function isUndefined(r){return r===void 0}e.isUndefined=isUndefined;function isRegExp(r){return isObject(r)&&objectToString(r)===\"[object RegExp]\"}e.isRegExp=isRegExp;e.types.isRegExp=isRegExp;function isObject(r){return typeof r===\"object\"&&r!==null}e.isObject=isObject;function isDate(r){return isObject(r)&&objectToString(r)===\"[object Date]\"}e.isDate=isDate;e.types.isDate=isDate;function isError(r){return isObject(r)&&(objectToString(r)===\"[object Error]\"||r instanceof Error)}e.isError=isError;e.types.isNativeError=isError;function isFunction(r){return typeof r===\"function\"}e.isFunction=isFunction;function isPrimitive(r){return r===null||typeof r===\"boolean\"||typeof r===\"number\"||typeof r===\"string\"||typeof r===\"symbol\"||typeof r===\"undefined\"}e.isPrimitive=isPrimitive;e.isBuffer=t(369);function objectToString(r){return Object.prototype.toString.call(r)}function pad(r){return r<10?\"0\"+r.toString(10):r.toString(10)}var u=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"];function timestamp(){var r=new Date;var e=[pad(r.getHours()),pad(r.getMinutes()),pad(r.getSeconds())].join(\":\");return[r.getDate(),u[r.getMonth()],e].join(\" \")}e.log=function(){console.log(\"%s - %s\",timestamp(),e.format.apply(e,arguments))};e.inherits=t(782);e._extend=function(r,e){if(!e||!isObject(e))return r;var t=Object.keys(e);var n=t.length;while(n--){r[t[n]]=e[t[n]]}return r};function hasOwnProperty(r,e){return Object.prototype.hasOwnProperty.call(r,e)}var s=typeof Symbol!==\"undefined\"?Symbol(\"util.promisify.custom\"):undefined;e.promisify=function promisify(r){if(typeof r!==\"function\")throw new TypeError('The \"original\" argument must be of type Function');if(s&&r[s]){var e=r[s];if(typeof e!==\"function\"){throw new TypeError('The \"util.promisify.custom\" argument must be of type Function')}Object.defineProperty(e,s,{value:e,enumerable:false,writable:false,configurable:true});return e}function e(){var e,t;var n=new Promise((function(r,n){e=r;t=n}));var o=[];for(var i=0;i<arguments.length;i++){o.push(arguments[i])}o.push((function(r,n){if(r){t(r)}else{e(n)}}));try{r.apply(this,o)}catch(r){t(r)}return n}Object.setPrototypeOf(e,Object.getPrototypeOf(r));if(s)Object.defineProperty(e,s,{value:e,enumerable:false,writable:false,configurable:true});return Object.defineProperties(e,n(r))};e.promisify.custom=s;function callbackifyOnRejected(r,e){if(!r){var t=new Error(\"Promise was rejected with a falsy value\");t.reason=r;r=t}return e(r)}function callbackify(r){if(typeof r!==\"function\"){throw new TypeError('The \"original\" argument must be of type Function')}function callbackified(){var e=[];for(var t=0;t<arguments.length;t++){e.push(arguments[t])}var n=e.pop();if(typeof n!==\"function\"){throw new TypeError(\"The last argument must be of type Function\")}var o=this;var cb=function(){return n.apply(o,arguments)};r.apply(this,e).then((function(r){process.nextTick(cb.bind(null,null,r))}),(function(r){process.nextTick(callbackifyOnRejected.bind(null,r,cb))}))}Object.setPrototypeOf(callbackified,Object.getPrototypeOf(r));Object.defineProperties(callbackified,n(r));return callbackified}e.callbackify=callbackify},490:function(r,e,t){\"use strict\";var n=t(144);var o=t(349);var i=t(256);var a=i(\"Object.prototype.toString\");var f=t(942)();var u=f&&typeof Symbol.toStringTag===\"symbol\";var s=o();var y=i(\"String.prototype.slice\");var c={};var p=t(466);var l=Object.getPrototypeOf;if(u&&p&&l){n(s,(function(r){if(typeof __webpack_require__.g[r]===\"function\"){var e=new __webpack_require__.g[r];if(!(Symbol.toStringTag in e)){throw new EvalError(\"this engine has support for Symbol.toStringTag, but \"+r+\" does not have the property! Please report this.\")}var t=l(e);var n=p(t,Symbol.toStringTag);if(!n){var o=l(t);n=p(o,Symbol.toStringTag)}c[r]=n.get}}))}var g=function tryAllTypedArrays(r){var e=false;n(c,(function(t,n){if(!e){try{var o=t.call(r);if(o===n){e=o}}catch(r){}}}));return e};var b=t(994);r.exports=function whichTypedArray(r){if(!b(r)){return false}if(!u){return y(a(r),8,-1)}return g(r)}},349:function(r,e,t){\"use strict\";var n=t(992);r.exports=function availableTypedArrays(){return n([\"BigInt64Array\",\"BigUint64Array\",\"Float32Array\",\"Float64Array\",\"Int16Array\",\"Int32Array\",\"Int8Array\",\"Uint16Array\",\"Uint32Array\",\"Uint8Array\",\"Uint8ClampedArray\"],(function(r){return typeof __webpack_require__.g[r]===\"function\"}))}},466:function(r,e,t){\"use strict\";var n=t(500);var o=n(\"%Object.getOwnPropertyDescriptor%\",true);if(o){try{o([],\"length\")}catch(r){o=null}}r.exports=o}};var e={};function __nccwpck_require__(t){var n=e[t];if(n!==undefined){return n.exports}var o=e[t]={exports:{}};var i=true;try{r[t](o,o.exports,__nccwpck_require__);i=false}finally{if(i)delete e[t]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(177);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLDBCQUEwQixpQ0FBaUMsNENBQTRDLDRDQUE0QyxTQUFTLFlBQVksV0FBVyxLQUFLLHlCQUF5QixXQUFXLDZCQUE2QixVQUFVLHNDQUFzQyxxQkFBcUIsYUFBYSxhQUFhLGFBQWEsdUNBQXVDLDJDQUEyQyxlQUFlLGlEQUFpRCxZQUFZLFVBQVUscUJBQXFCLGFBQWEsYUFBYSxhQUFhLHNDQUFzQyxxQ0FBcUMsNkNBQTZDLGtEQUFrRCx3Q0FBd0Msc0JBQXNCLE1BQU0sSUFBSSxJQUFJLE1BQU0sUUFBUSxFQUFFLFNBQVMsUUFBUSwrQkFBK0IsdUJBQXVCLFNBQVMsb0JBQW9CLG1CQUFtQixjQUFjLDJDQUEyQyxHQUFHLFVBQVUsMkJBQTJCLHlCQUF5QixNQUFNLHFCQUFxQixRQUFRLEVBQUUsS0FBSyxtQkFBbUIsaUJBQWlCLHNDQUFzQyxnQ0FBZ0Msa0NBQWtDLG9DQUFvQyxtREFBbUQsZUFBZSxXQUFXLFlBQVksSUFBSSxLQUFLLG9CQUFvQixLQUFLLGdCQUFnQixnQkFBZ0IsdUJBQXVCLGlCQUFpQixhQUFhLHdEQUF3RCw0QkFBNEIsZ0NBQWdDLDBCQUEwQiwyQkFBMkIsV0FBVyx5Q0FBeUMseUJBQXlCLDBCQUEwQixNQUFNLHNCQUFzQixzQkFBc0IsZ0RBQWdELGtCQUFrQixTQUFTLFlBQVksS0FBSyxnREFBZ0Qsb0NBQW9DLFNBQVMsWUFBWSxJQUFJLEtBQUssY0FBYyx3REFBd0Qsc0NBQXNDLFdBQVcsZ0JBQWdCLHlCQUF5Qix3QkFBd0Isa0JBQWtCLGlCQUFpQixVQUFVLHFCQUFxQixhQUFhLGFBQWEscUNBQXFDLHFCQUFxQixhQUFhLE1BQU0sa0JBQWtCLGVBQWUsZ0JBQWdCLHNDQUFzQyxJQUFJLHdCQUF3QiwyQkFBMkIsS0FBSyxZQUFZLHNDQUFzQyxNQUFNLElBQUksSUFBSSxLQUFLLFNBQVMs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TUFBTSxLQUFLLEtBQUssTUFBTSxHQUFHLElBQUksZ0JBQWdCLFNBQVMsS0FBSyxTQUFTLGtEQUFrRCxnQ0FBZ0MsMERBQTBELEVBQUUsd0NBQXdDLHFCQUFxQixvQ0FBb0MsT0FBTywyREFBMkQsV0FBVyxJQUFJLFlBQVksd0JBQXdCLDBCQUEwQix3RUFBd0UseUJBQXlCLFNBQVMsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsY0FBYywwQkFBMEIsa0VBQWtFLFdBQVcsa0JBQWtCLDZCQUE2QixrQ0FBa0MsT0FBTyxnQ0FBZ0MsZUFBZSxPQUFPLGlEQUFpRCxHQUFHLDhEQUE4RCw0Q0FBNEMscUJBQXFCLDBCQUEwQixxQkFBcUIsYUFBYSxhQUFhLGFBQWEsYUFBYSxxQ0FBcUMsZUFBZSw4Q0FBOEMsVUFBVSxrQ0FBa0MsU0FBUyxhQUFhLDRCQUE0QixZQUFZLGlCQUFpQixVQUFVLHFCQUFNLGtCQUFrQixVQUFVLHFCQUFNLElBQUksK0JBQStCLGlJQUFpSSxXQUFXLDhCQUE4QixPQUFPLFdBQVcsMEJBQTBCLFlBQVksR0FBRyxvQ0FBb0MsWUFBWSxtQkFBbUIsT0FBTyxJQUFJLGdCQUFnQixVQUFVLEtBQUssWUFBWSxHQUFHLFVBQVUsYUFBYSxzQ0FBc0MsVUFBVSxhQUFhLE9BQU8sb0JBQW9CLGFBQWEscUJBQXFCLGFBQWEsYUFBYSwwQ0FBMEMsMExBQTBMLGNBQWMscUJBQU0saUJBQWlCLElBQUkscUJBQXFCLGFBQWEsYUFBYSxrREFBa0QsTUFBTSxJQUFJLGVBQWUsU0FBUyxRQUFRLGNBQWMsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcz9hYzE0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciByPXs5OTI6ZnVuY3Rpb24ocil7ci5leHBvcnRzPWZ1bmN0aW9uKHIsdCxuKXtpZihyLmZpbHRlcilyZXR1cm4gci5maWx0ZXIodCxuKTtpZih2b2lkIDA9PT1yfHxudWxsPT09cil0aHJvdyBuZXcgVHlwZUVycm9yO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgbz1bXTtmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKyl7aWYoIWUuY2FsbChyLGkpKWNvbnRpbnVlO3ZhciBhPXJbaV07aWYodC5jYWxsKG4sYSxpLHIpKW8ucHVzaChhKX1yZXR1cm4gb307dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eX0sMjU2OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDUwMCk7dmFyIG89dCgxMzkpO3ZhciBpPW8obihcIlN0cmluZy5wcm90b3R5cGUuaW5kZXhPZlwiKSk7ci5leHBvcnRzPWZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhyLGUpe3ZhciB0PW4ociwhIWUpO2lmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiJiZpKHIsXCIucHJvdG90eXBlLlwiKT4tMSl7cmV0dXJuIG8odCl9cmV0dXJuIHR9fSwxMzk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoMTc0KTt2YXIgbz10KDUwMCk7dmFyIGk9byhcIiVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklXCIpO3ZhciBhPW8oXCIlRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlXCIpO3ZhciBmPW8oXCIlUmVmbGVjdC5hcHBseSVcIix0cnVlKXx8bi5jYWxsKGEsaSk7dmFyIHU9byhcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLHRydWUpO3ZhciBzPW8oXCIlT2JqZWN0LmRlZmluZVByb3BlcnR5JVwiLHRydWUpO3ZhciB5PW8oXCIlTWF0aC5tYXglXCIpO2lmKHMpe3RyeXtzKHt9LFwiYVwiLHt2YWx1ZToxfSl9Y2F0Y2gocil7cz1udWxsfX1yLmV4cG9ydHM9ZnVuY3Rpb24gY2FsbEJpbmQocil7dmFyIGU9ZihuLGEsYXJndW1lbnRzKTtpZih1JiZzKXt2YXIgdD11KGUsXCJsZW5ndGhcIik7aWYodC5jb25maWd1cmFibGUpe3MoZSxcImxlbmd0aFwiLHt2YWx1ZToxK3koMCxyLmxlbmd0aC0oYXJndW1lbnRzLmxlbmd0aC0xKSl9KX19cmV0dXJuIGV9O3ZhciBjPWZ1bmN0aW9uIGFwcGx5QmluZCgpe3JldHVybiBmKG4saSxhcmd1bWVudHMpfTtpZihzKXtzKHIuZXhwb3J0cyxcImFwcGx5XCIse3ZhbHVlOmN9KX1lbHNle3IuZXhwb3J0cy5hcHBseT1jfX0sMTQ0OmZ1bmN0aW9uKHIpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztyLmV4cG9ydHM9ZnVuY3Rpb24gZm9yRWFjaChyLG4sbyl7aWYodC5jYWxsKG4pIT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpfXZhciBpPXIubGVuZ3RoO2lmKGk9PT0raSl7Zm9yKHZhciBhPTA7YTxpO2ErKyl7bi5jYWxsKG8sclthXSxhLHIpfX1lbHNle2Zvcih2YXIgZiBpbiByKXtpZihlLmNhbGwocixmKSl7bi5jYWxsKG8scltmXSxmLHIpfX19fX0sNDI2OmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPVwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBcIjt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2U7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgbz1cIltvYmplY3QgRnVuY3Rpb25dXCI7ci5leHBvcnRzPWZ1bmN0aW9uIGJpbmQocil7dmFyIGk9dGhpcztpZih0eXBlb2YgaSE9PVwiZnVuY3Rpb25cInx8bi5jYWxsKGkpIT09byl7dGhyb3cgbmV3IFR5cGVFcnJvcihlK2kpfXZhciBhPXQuY2FsbChhcmd1bWVudHMsMSk7dmFyIGY7dmFyIGJpbmRlcj1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiBmKXt2YXIgZT1pLmFwcGx5KHRoaXMsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKTtpZihPYmplY3QoZSk9PT1lKXtyZXR1cm4gZX1yZXR1cm4gdGhpc31lbHNle3JldHVybiBpLmFwcGx5KHIsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKX19O3ZhciB1PU1hdGgubWF4KDAsaS5sZW5ndGgtYS5sZW5ndGgpO3ZhciBzPVtdO2Zvcih2YXIgeT0wO3k8dTt5Kyspe3MucHVzaChcIiRcIit5KX1mPUZ1bmN0aW9uKFwiYmluZGVyXCIsXCJyZXR1cm4gZnVuY3Rpb24gKFwiK3Muam9pbihcIixcIikrXCIpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfVwiKShiaW5kZXIpO2lmKGkucHJvdG90eXBlKXt2YXIgYz1mdW5jdGlvbiBFbXB0eSgpe307Yy5wcm90b3R5cGU9aS5wcm90b3R5cGU7Zi5wcm90b3R5cGU9bmV3IGM7Yy5wcm90b3R5cGU9bnVsbH1yZXR1cm4gZn19LDE3NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCg0MjYpO3IuZXhwb3J0cz1GdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8bn0sNTAwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbjt2YXIgbz1TeW50YXhFcnJvcjt2YXIgaT1GdW5jdGlvbjt2YXIgYT1UeXBlRXJyb3I7dmFyIGdldEV2YWxsZWRDb25zdHJ1Y3Rvcj1mdW5jdGlvbihyKXt0cnl7cmV0dXJuIGkoJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcrcitcIikuY29uc3RydWN0b3I7XCIpKCl9Y2F0Y2gocil7fX07dmFyIGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtpZihmKXt0cnl7Zih7fSxcIlwiKX1jYXRjaChyKXtmPW51bGx9fXZhciB0aHJvd1R5cGVFcnJvcj1mdW5jdGlvbigpe3Rocm93IG5ldyBhfTt2YXIgdT1mP2Z1bmN0aW9uKCl7dHJ5e2FyZ3VtZW50cy5jYWxsZWU7cmV0dXJuIHRocm93VHlwZUVycm9yfWNhdGNoKHIpe3RyeXtyZXR1cm4gZihhcmd1bWVudHMsXCJjYWxsZWVcIikuZ2V0fWNhdGNoKHIpe3JldHVybiB0aHJvd1R5cGVFcnJvcn19fSgpOnRocm93VHlwZUVycm9yO3ZhciBzPXQoMTE1KSgpO3ZhciB5PU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocil7cmV0dXJuIHIuX19wcm90b19ffTt2YXIgYz17fTt2YXIgcD10eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bjp5KFVpbnQ4QXJyYXkpO3ZhciBsPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP246QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9uOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cz95KFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6bixcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6bixcIiVBc3luY0Z1bmN0aW9uJVwiOmMsXCIlQXN5bmNHZW5lcmF0b3IlXCI6YyxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOmMsXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpjLFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP246QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bjpCaWdJbnQsXCIlQm9vbGVhbiVcIjpCb29sZWFuLFwiJURhdGFWaWV3JVwiOnR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCI/bjpEYXRhVmlldyxcIiVEYXRlJVwiOkRhdGUsXCIlZGVjb2RlVVJJJVwiOmRlY29kZVVSSSxcIiVkZWNvZGVVUklDb21wb25lbnQlXCI6ZGVjb2RlVVJJQ29tcG9uZW50LFwiJWVuY29kZVVSSSVcIjplbmNvZGVVUkksXCIlZW5jb2RlVVJJQ29tcG9uZW50JVwiOmVuY29kZVVSSUNvbXBvbmVudCxcIiVFcnJvciVcIjpFcnJvcixcIiVldmFsJVwiOmV2YWwsXCIlRXZhbEVycm9yJVwiOkV2YWxFcnJvcixcIiVGbG9hdDMyQXJyYXklXCI6dHlwZW9mIEZsb2F0MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bjpGbG9hdDMyQXJyYXksXCIlRmxvYXQ2NEFycmF5JVwiOnR5cGVvZiBGbG9hdDY0QXJyYXk9PT1cInVuZGVmaW5lZFwiP246RmxvYXQ2NEFycmF5LFwiJUZpbmFsaXphdGlvblJlZ2lzdHJ5JVwiOnR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeT09PVwidW5kZWZpbmVkXCI/bjpGaW5hbGl6YXRpb25SZWdpc3RyeSxcIiVGdW5jdGlvbiVcIjppLFwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiOmMsXCIlSW50OEFycmF5JVwiOnR5cGVvZiBJbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP246SW50OEFycmF5LFwiJUludDE2QXJyYXklXCI6dHlwZW9mIEludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP246SW50MTZBcnJheSxcIiVJbnQzMkFycmF5JVwiOnR5cGVvZiBJbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9uOkludDMyQXJyYXksXCIlaXNGaW5pdGUlXCI6aXNGaW5pdGUsXCIlaXNOYU4lXCI6aXNOYU4sXCIlSXRlcmF0b3JQcm90b3R5cGUlXCI6cz95KHkoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSk6bixcIiVKU09OJVwiOnR5cGVvZiBKU09OPT09XCJvYmplY3RcIj9KU09OOm4sXCIlTWFwJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwiP246TWFwLFwiJU1hcEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwifHwhcz9uOnkoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bjpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bjpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bjpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP246U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcz9uOnkoKG5ldyBTZXQpW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlU2hhcmVkQXJyYXlCdWZmZXIlXCI6dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9uOlNoYXJlZEFycmF5QnVmZmVyLFwiJVN0cmluZyVcIjpTdHJpbmcsXCIlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlXCI6cz95KFwiXCJbU3ltYm9sLml0ZXJhdG9yXSgpKTpuLFwiJVN5bWJvbCVcIjpzP1N5bWJvbDpuLFwiJVN5bnRheEVycm9yJVwiOm8sXCIlVGhyb3dUeXBlRXJyb3IlXCI6dSxcIiVUeXBlZEFycmF5JVwiOnAsXCIlVHlwZUVycm9yJVwiOmEsXCIlVWludDhBcnJheSVcIjp0eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bjpVaW50OEFycmF5LFwiJVVpbnQ4Q2xhbXBlZEFycmF5JVwiOnR5cGVvZiBVaW50OENsYW1wZWRBcnJheT09PVwidW5kZWZpbmVkXCI/bjpVaW50OENsYW1wZWRBcnJheSxcIiVVaW50MTZBcnJheSVcIjp0eXBlb2YgVWludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP246VWludDE2QXJyYXksXCIlVWludDMyQXJyYXklXCI6dHlwZW9mIFVpbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9uOlVpbnQzMkFycmF5LFwiJVVSSUVycm9yJVwiOlVSSUVycm9yLFwiJVdlYWtNYXAlXCI6dHlwZW9mIFdlYWtNYXA9PT1cInVuZGVmaW5lZFwiP246V2Vha01hcCxcIiVXZWFrUmVmJVwiOnR5cGVvZiBXZWFrUmVmPT09XCJ1bmRlZmluZWRcIj9uOldlYWtSZWYsXCIlV2Vha1NldCVcIjp0eXBlb2YgV2Vha1NldD09PVwidW5kZWZpbmVkXCI/bjpXZWFrU2V0fTt2YXIgZz1mdW5jdGlvbiBkb0V2YWwocil7dmFyIGU7aWYocj09PVwiJUFzeW5jRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24gKCkge31cIil9ZWxzZSBpZihyPT09XCIlR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yJVwiKXt2YXIgdD1kb0V2YWwoXCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIik7aWYodCl7ZT10LnByb3RvdHlwZX19ZWxzZSBpZihyPT09XCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIil7dmFyIG49ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yJVwiKTtpZihuKXtlPXkobi5wcm90b3R5cGUpfX1sW3JdPWU7cmV0dXJuIGV9O3ZhciBiPXtcIiVBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG90eXBlJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlQXJyYXlQcm90b19lbnRyaWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImVudHJpZXNcIl0sXCIlQXJyYXlQcm90b19mb3JFYWNoJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImZvckVhY2hcIl0sXCIlQXJyYXlQcm90b19rZXlzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImtleXNcIl0sXCIlQXJyYXlQcm90b192YWx1ZXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwidmFsdWVzXCJdLFwiJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiQXN5bmNGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUFzeW5jR2VuZXJhdG9yJVwiOltcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvclByb3RvdHlwZSVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVCb29sZWFuUHJvdG90eXBlJVwiOltcIkJvb2xlYW5cIixcInByb3RvdHlwZVwiXSxcIiVEYXRhVmlld1Byb3RvdHlwZSVcIjpbXCJEYXRhVmlld1wiLFwicHJvdG90eXBlXCJdLFwiJURhdGVQcm90b3R5cGUlXCI6W1wiRGF0ZVwiLFwicHJvdG90eXBlXCJdLFwiJUVycm9yUHJvdG90eXBlJVwiOltcIkVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlRXZhbEVycm9yUHJvdG90eXBlJVwiOltcIkV2YWxFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUZsb2F0MzJBcnJheVByb3RvdHlwZSVcIjpbXCJGbG9hdDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDY0QXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQ2NEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3IlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiLFwicHJvdG90eXBlXCJdLFwiJUludDhBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIkludDE2QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIkludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVKU09OUGFyc2UlXCI6W1wiSlNPTlwiLFwicGFyc2VcIl0sXCIlSlNPTlN0cmluZ2lmeSVcIjpbXCJKU09OXCIsXCJzdHJpbmdpZnlcIl0sXCIlTWFwUHJvdG90eXBlJVwiOltcIk1hcFwiLFwicHJvdG90eXBlXCJdLFwiJU51bWJlclByb3RvdHlwZSVcIjpbXCJOdW1iZXJcIixcInByb3RvdHlwZVwiXSxcIiVPYmplY3RQcm90b3R5cGUlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqUHJvdG9fdG9TdHJpbmclXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInRvU3RyaW5nXCJdLFwiJU9ialByb3RvX3ZhbHVlT2YlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInZhbHVlT2ZcIl0sXCIlUHJvbWlzZVByb3RvdHlwZSVcIjpbXCJQcm9taXNlXCIsXCJwcm90b3R5cGVcIl0sXCIlUHJvbWlzZVByb3RvX3RoZW4lXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCIsXCJ0aGVuXCJdLFwiJVByb21pc2VfYWxsJVwiOltcIlByb21pc2VcIixcImFsbFwiXSxcIiVQcm9taXNlX3JlamVjdCVcIjpbXCJQcm9taXNlXCIsXCJyZWplY3RcIl0sXCIlUHJvbWlzZV9yZXNvbHZlJVwiOltcIlByb21pc2VcIixcInJlc29sdmVcIl0sXCIlUmFuZ2VFcnJvclByb3RvdHlwZSVcIjpbXCJSYW5nZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmVmZXJlbmNlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVSZWdFeHBQcm90b3R5cGUlXCI6W1wiUmVnRXhwXCIsXCJwcm90b3R5cGVcIl0sXCIlU2V0UHJvdG90eXBlJVwiOltcIlNldFwiLFwicHJvdG90eXBlXCJdLFwiJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJVwiOltcIlNoYXJlZEFycmF5QnVmZmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlU3RyaW5nUHJvdG90eXBlJVwiOltcIlN0cmluZ1wiLFwicHJvdG90eXBlXCJdLFwiJVN5bWJvbFByb3RvdHlwZSVcIjpbXCJTeW1ib2xcIixcInByb3RvdHlwZVwiXSxcIiVTeW50YXhFcnJvclByb3RvdHlwZSVcIjpbXCJTeW50YXhFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVHlwZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVFcnJvclByb3RvdHlwZSVcIjpbXCJUeXBlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OEFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OENsYW1wZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVUklFcnJvclByb3RvdHlwZSVcIjpbXCJVUklFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtNYXBQcm90b3R5cGUlXCI6W1wiV2Vha01hcFwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtTZXRQcm90b3R5cGUlXCI6W1wiV2Vha1NldFwiLFwicHJvdG90eXBlXCJdfTt2YXIgZD10KDE3NCk7dmFyIHY9dCgxMDEpO3ZhciBtPWQuY2FsbChGdW5jdGlvbi5jYWxsLEFycmF5LnByb3RvdHlwZS5jb25jYXQpO3ZhciBTPWQuY2FsbChGdW5jdGlvbi5hcHBseSxBcnJheS5wcm90b3R5cGUuc3BsaWNlKTt2YXIgQT1kLmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO3ZhciBoPWQuY2FsbChGdW5jdGlvbi5jYWxsLFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO3ZhciBPPWQuY2FsbChGdW5jdGlvbi5jYWxsLFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7dmFyIGo9L1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7dmFyIHc9L1xcXFwoXFxcXCk/L2c7dmFyIFA9ZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHIpe3ZhciBlPWgociwwLDEpO3ZhciB0PWgociwtMSk7aWYoZT09PVwiJVwiJiZ0IT09XCIlXCIpe3Rocm93IG5ldyBvKFwiaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYFwiKX1lbHNlIGlmKHQ9PT1cIiVcIiYmZSE9PVwiJVwiKXt0aHJvdyBuZXcgbyhcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWBcIil9dmFyIG49W107QShyLGosKGZ1bmN0aW9uKHIsZSx0LG8pe25bbi5sZW5ndGhdPXQ/QShvLHcsXCIkMVwiKTplfHxyfSkpO3JldHVybiBufTt2YXIgRT1mdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKHIsZSl7dmFyIHQ9cjt2YXIgbjtpZih2KGIsdCkpe249Ylt0XTt0PVwiJVwiK25bMF0rXCIlXCJ9aWYodihsLHQpKXt2YXIgaT1sW3RdO2lmKGk9PT1jKXtpPWcodCl9aWYodHlwZW9mIGk9PT1cInVuZGVmaW5lZFwiJiYhZSl7dGhyb3cgbmV3IGEoXCJpbnRyaW5zaWMgXCIrcitcIiBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSFcIil9cmV0dXJue2FsaWFzOm4sbmFtZTp0LHZhbHVlOml9fXRocm93IG5ldyBvKFwiaW50cmluc2ljIFwiK3IrXCIgZG9lcyBub3QgZXhpc3QhXCIpfTtyLmV4cG9ydHM9ZnVuY3Rpb24gR2V0SW50cmluc2ljKHIsZSl7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyLmxlbmd0aD09PTApe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9aWYoYXJndW1lbnRzLmxlbmd0aD4xJiZ0eXBlb2YgZSE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgYSgnXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpfWlmKE8oL14lP1teJV0qJT8kL2cscik9PT1udWxsKXt0aHJvdyBuZXcgbyhcImAlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWVcIil9dmFyIHQ9UChyKTt2YXIgaT10Lmxlbmd0aD4wP3RbMF06XCJcIjt2YXIgdT1FKFwiJVwiK2krXCIlXCIsZSk7dmFyIHM9dS5uYW1lO3ZhciB5PXUudmFsdWU7dmFyIGM9ZmFsc2U7dmFyIHA9dS5hbGlhcztpZihwKXtpPXBbMF07Uyh0LG0oWzAsMV0scCkpfWZvcih2YXIgZz0xLGI9dHJ1ZTtnPHQubGVuZ3RoO2crPTEpe3ZhciBkPXRbZ107dmFyIEE9aChkLDAsMSk7dmFyIGo9aChkLC0xKTtpZigoQT09PSdcIid8fEE9PT1cIidcInx8QT09PVwiYFwifHwoaj09PSdcIid8fGo9PT1cIidcInx8aj09PVwiYFwiKSkmJkEhPT1qKXt0aHJvdyBuZXcgbyhcInByb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXNcIil9aWYoZD09PVwiY29uc3RydWN0b3JcInx8IWIpe2M9dHJ1ZX1pKz1cIi5cIitkO3M9XCIlXCIraStcIiVcIjtpZih2KGwscykpe3k9bFtzXX1lbHNlIGlmKHkhPW51bGwpe2lmKCEoZCBpbiB5KSl7aWYoIWUpe3Rocm93IG5ldyBhKFwiYmFzZSBpbnRyaW5zaWMgZm9yIFwiK3IrXCIgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXCIpfXJldHVybiB2b2lkIG59aWYoZiYmZysxPj10Lmxlbmd0aCl7dmFyIHc9Zih5LGQpO2I9ISF3O2lmKGImJlwiZ2V0XCJpbiB3JiYhKFwib3JpZ2luYWxWYWx1ZVwiaW4gdy5nZXQpKXt5PXcuZ2V0fWVsc2V7eT15W2RdfX1lbHNle2I9dih5LGQpO3k9eVtkXX1pZihiJiYhYyl7bFtzXT15fX19cmV0dXJuIHl9fSw5NDI6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2w7dmFyIG89dCg3NzMpO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCl7aWYodHlwZW9mIG4hPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIG4oXCJmb29cIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbChcImJhclwiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gbygpfX0sNzczOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNTeW1ib2xzKCl7aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cInx8dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7cmV0dXJuIHRydWV9dmFyIHI9e307dmFyIGU9U3ltYm9sKFwidGVzdFwiKTt2YXIgdD1PYmplY3QoZSk7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX12YXIgbj00MjtyW2VdPW47Zm9yKGUgaW4gcil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3Qua2V5cz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmtleXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfXZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7aWYoby5sZW5ndGghPT0xfHxvWzBdIT09ZSl7cmV0dXJuIGZhbHNlfWlmKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixlKSl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yPT09XCJmdW5jdGlvblwiKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7aWYoaS52YWx1ZSE9PW58fGkuZW51bWVyYWJsZSE9PXRydWUpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9fSwxMTU6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2w7dmFyIG89dCg4MzIpO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCl7aWYodHlwZW9mIG4hPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIG4oXCJmb29cIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbChcImJhclwiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gbygpfX0sODMyOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNTeW1ib2xzKCl7aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cInx8dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7cmV0dXJuIHRydWV9dmFyIHI9e307dmFyIGU9U3ltYm9sKFwidGVzdFwiKTt2YXIgdD1PYmplY3QoZSk7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX12YXIgbj00MjtyW2VdPW47Zm9yKGUgaW4gcil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3Qua2V5cz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmtleXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfXZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7aWYoby5sZW5ndGghPT0xfHxvWzBdIT09ZSl7cmV0dXJuIGZhbHNlfWlmKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixlKSl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yPT09XCJmdW5jdGlvblwiKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7aWYoaS52YWx1ZSE9PW58fGkuZW51bWVyYWJsZSE9PXRydWUpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9fSwxMDE6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoMTc0KTtyLmV4cG9ydHM9bi5jYWxsKEZ1bmN0aW9uLmNhbGwsT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSl9LDc4MjpmdW5jdGlvbihyKXtpZih0eXBlb2YgT2JqZWN0LmNyZWF0ZT09PVwiZnVuY3Rpb25cIil7ci5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKHIsZSl7aWYoZSl7ci5zdXBlcl89ZTtyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6cixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9fSl9fX1lbHNle3IuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhyLGUpe2lmKGUpe3Iuc3VwZXJfPWU7dmFyIFRlbXBDdG9yPWZ1bmN0aW9uKCl7fTtUZW1wQ3Rvci5wcm90b3R5cGU9ZS5wcm90b3R5cGU7ci5wcm90b3R5cGU9bmV3IFRlbXBDdG9yO3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPXJ9fX19LDE1NzpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgdD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBuPWZ1bmN0aW9uIGlzQXJndW1lbnRzKHIpe2lmKGUmJnImJnR5cGVvZiByPT09XCJvYmplY3RcIiYmU3ltYm9sLnRvU3RyaW5nVGFnIGluIHIpe3JldHVybiBmYWxzZX1yZXR1cm4gdC5jYWxsKHIpPT09XCJbb2JqZWN0IEFyZ3VtZW50c11cIn07dmFyIG89ZnVuY3Rpb24gaXNBcmd1bWVudHMocil7aWYobihyKSl7cmV0dXJuIHRydWV9cmV0dXJuIHIhPT1udWxsJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJnR5cGVvZiByLmxlbmd0aD09PVwibnVtYmVyXCImJnIubGVuZ3RoPj0wJiZ0LmNhbGwocikhPT1cIltvYmplY3QgQXJyYXldXCImJnQuY2FsbChyLmNhbGxlZSk9PT1cIltvYmplY3QgRnVuY3Rpb25dXCJ9O3ZhciBpPWZ1bmN0aW9uKCl7cmV0dXJuIG4oYXJndW1lbnRzKX0oKTtuLmlzTGVnYWN5QXJndW1lbnRzPW87ci5leHBvcnRzPWk/bjpvfSwzOTE6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgdD1GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7dmFyIG49L15cXHMqKD86ZnVuY3Rpb24pP1xcKi87dmFyIG89dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIGk9T2JqZWN0LmdldFByb3RvdHlwZU9mO3ZhciBnZXRHZW5lcmF0b3JGdW5jPWZ1bmN0aW9uKCl7aWYoIW8pe3JldHVybiBmYWxzZX10cnl7cmV0dXJuIEZ1bmN0aW9uKFwicmV0dXJuIGZ1bmN0aW9uKigpIHt9XCIpKCl9Y2F0Y2gocil7fX07dmFyIGE9Z2V0R2VuZXJhdG9yRnVuYygpO3ZhciBmPWE/aShhKTp7fTtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKG4udGVzdCh0LmNhbGwocikpKXtyZXR1cm4gdHJ1ZX1pZighbyl7dmFyIGE9ZS5jYWxsKHIpO3JldHVybiBhPT09XCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwifXJldHVybiBpKHIpPT09Zn19LDk5NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCgxNDQpO3ZhciBvPXQoMzQ5KTt2YXIgaT10KDI1Nik7dmFyIGE9aShcIk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcIik7dmFyIGY9dCg5NDIpKCk7dmFyIHU9ZiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIHM9bygpO3ZhciB5PWkoXCJBcnJheS5wcm90b3R5cGUuaW5kZXhPZlwiLHRydWUpfHxmdW5jdGlvbiBpbmRleE9mKHIsZSl7Zm9yKHZhciB0PTA7dDxyLmxlbmd0aDt0Kz0xKXtpZihyW3RdPT09ZSl7cmV0dXJuIHR9fXJldHVybi0xfTt2YXIgYz1pKFwiU3RyaW5nLnByb3RvdHlwZS5zbGljZVwiKTt2YXIgcD17fTt2YXIgbD10KDQ2Nik7dmFyIGc9T2JqZWN0LmdldFByb3RvdHlwZU9mO2lmKHUmJmwmJmcpe24ocywoZnVuY3Rpb24ocil7dmFyIGU9bmV3IGdsb2JhbFtyXTtpZighKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBlKSl7dGhyb3cgbmV3IEV2YWxFcnJvcihcInRoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCBcIityK1wiIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuXCIpfXZhciB0PWcoZSk7dmFyIG49bCh0LFN5bWJvbC50b1N0cmluZ1RhZyk7aWYoIW4pe3ZhciBvPWcodCk7bj1sKG8sU3ltYm9sLnRvU3RyaW5nVGFnKX1wW3JdPW4uZ2V0fSkpfXZhciBiPWZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHIpe3ZhciBlPWZhbHNlO24ocCwoZnVuY3Rpb24odCxuKXtpZighZSl7dHJ5e2U9dC5jYWxsKHIpPT09bn1jYXRjaChyKXt9fX0pKTtyZXR1cm4gZX07ci5leHBvcnRzPWZ1bmN0aW9uIGlzVHlwZWRBcnJheShyKXtpZighcnx8dHlwZW9mIHIhPT1cIm9iamVjdFwiKXtyZXR1cm4gZmFsc2V9aWYoIXUpe3ZhciBlPWMoYShyKSw4LC0xKTtyZXR1cm4geShzLGUpPi0xfWlmKCFsKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGIocil9fSwzNjk6ZnVuY3Rpb24ocil7ci5leHBvcnRzPWZ1bmN0aW9uIGlzQnVmZmVyKHIpe3JldHVybiByIGluc3RhbmNlb2YgQnVmZmVyfX0sNTg0OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KDE1Nyk7dmFyIG89dCgzOTEpO3ZhciBpPXQoNDkwKTt2YXIgYT10KDk5NCk7ZnVuY3Rpb24gdW5jdXJyeVRoaXMocil7cmV0dXJuIHIuY2FsbC5iaW5kKHIpfXZhciBmPXR5cGVvZiBCaWdJbnQhPT1cInVuZGVmaW5lZFwiO3ZhciB1PXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiO3ZhciBzPXVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO3ZhciB5PXVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7dmFyIGM9dW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTt2YXIgcD11bmN1cnJ5VGhpcyhCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mKTtpZihmKXt2YXIgbD11bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpfWlmKHUpe3ZhciBnPXVuY3VycnlUaGlzKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZil9ZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZShyLGUpe2lmKHR5cGVvZiByIT09XCJvYmplY3RcIil7cmV0dXJuIGZhbHNlfXRyeXtlKHIpO3JldHVybiB0cnVlfWNhdGNoKHIpe3JldHVybiBmYWxzZX19ZS5pc0FyZ3VtZW50c09iamVjdD1uO2UuaXNHZW5lcmF0b3JGdW5jdGlvbj1vO2UuaXNUeXBlZEFycmF5PWE7ZnVuY3Rpb24gaXNQcm9taXNlKHIpe3JldHVybiB0eXBlb2YgUHJvbWlzZSE9PVwidW5kZWZpbmVkXCImJnIgaW5zdGFuY2VvZiBQcm9taXNlfHxyIT09bnVsbCYmdHlwZW9mIHI9PT1cIm9iamVjdFwiJiZ0eXBlb2Ygci50aGVuPT09XCJmdW5jdGlvblwiJiZ0eXBlb2Ygci5jYXRjaD09PVwiZnVuY3Rpb25cIn1lLmlzUHJvbWlzZT1pc1Byb21pc2U7ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcocil7aWYodHlwZW9mIEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmQXJyYXlCdWZmZXIuaXNWaWV3KXtyZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHIpfXJldHVybiBhKHIpfHxpc0RhdGFWaWV3KHIpfWUuaXNBcnJheUJ1ZmZlclZpZXc9aXNBcnJheUJ1ZmZlclZpZXc7ZnVuY3Rpb24gaXNVaW50OEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50OEFycmF5XCJ9ZS5pc1VpbnQ4QXJyYXk9aXNVaW50OEFycmF5O2Z1bmN0aW9uIGlzVWludDhDbGFtcGVkQXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQ4Q2xhbXBlZEFycmF5XCJ9ZS5pc1VpbnQ4Q2xhbXBlZEFycmF5PWlzVWludDhDbGFtcGVkQXJyYXk7ZnVuY3Rpb24gaXNVaW50MTZBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDE2QXJyYXlcIn1lLmlzVWludDE2QXJyYXk9aXNVaW50MTZBcnJheTtmdW5jdGlvbiBpc1VpbnQzMkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50MzJBcnJheVwifWUuaXNVaW50MzJBcnJheT1pc1VpbnQzMkFycmF5O2Z1bmN0aW9uIGlzSW50OEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJJbnQ4QXJyYXlcIn1lLmlzSW50OEFycmF5PWlzSW50OEFycmF5O2Z1bmN0aW9uIGlzSW50MTZBcnJheShyKXtyZXR1cm4gaShyKT09PVwiSW50MTZBcnJheVwifWUuaXNJbnQxNkFycmF5PWlzSW50MTZBcnJheTtmdW5jdGlvbiBpc0ludDMyQXJyYXkocil7cmV0dXJuIGkocik9PT1cIkludDMyQXJyYXlcIn1lLmlzSW50MzJBcnJheT1pc0ludDMyQXJyYXk7ZnVuY3Rpb24gaXNGbG9hdDMyQXJyYXkocil7cmV0dXJuIGkocik9PT1cIkZsb2F0MzJBcnJheVwifWUuaXNGbG9hdDMyQXJyYXk9aXNGbG9hdDMyQXJyYXk7ZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkZsb2F0NjRBcnJheVwifWUuaXNGbG9hdDY0QXJyYXk9aXNGbG9hdDY0QXJyYXk7ZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHIpe3JldHVybiBpKHIpPT09XCJCaWdJbnQ2NEFycmF5XCJ9ZS5pc0JpZ0ludDY0QXJyYXk9aXNCaWdJbnQ2NEFycmF5O2Z1bmN0aW9uIGlzQmlnVWludDY0QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkJpZ1VpbnQ2NEFycmF5XCJ9ZS5pc0JpZ1VpbnQ2NEFycmF5PWlzQmlnVWludDY0QXJyYXk7ZnVuY3Rpb24gaXNNYXBUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBNYXBdXCJ9aXNNYXBUb1N0cmluZy53b3JraW5nPXR5cGVvZiBNYXAhPT1cInVuZGVmaW5lZFwiJiZpc01hcFRvU3RyaW5nKG5ldyBNYXApO2Z1bmN0aW9uIGlzTWFwKHIpe2lmKHR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZz9pc01hcFRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBNYXB9ZS5pc01hcD1pc01hcDtmdW5jdGlvbiBpc1NldFRvU3RyaW5nKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IFNldF1cIn1pc1NldFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIFNldCE9PVwidW5kZWZpbmVkXCImJmlzU2V0VG9TdHJpbmcobmV3IFNldCk7ZnVuY3Rpb24gaXNTZXQocil7aWYodHlwZW9mIFNldD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nP2lzU2V0VG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIFNldH1lLmlzU2V0PWlzU2V0O2Z1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IFdlYWtNYXBdXCJ9aXNXZWFrTWFwVG9TdHJpbmcud29ya2luZz10eXBlb2YgV2Vha01hcCE9PVwidW5kZWZpbmVkXCImJmlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKTtmdW5jdGlvbiBpc1dlYWtNYXAocil7aWYodHlwZW9mIFdlYWtNYXA9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmc/aXNXZWFrTWFwVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIFdlYWtNYXB9ZS5pc1dlYWtNYXA9aXNXZWFrTWFwO2Z1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IFdlYWtTZXRdXCJ9aXNXZWFrU2V0VG9TdHJpbmcud29ya2luZz10eXBlb2YgV2Vha1NldCE9PVwidW5kZWZpbmVkXCImJmlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KTtmdW5jdGlvbiBpc1dlYWtTZXQocil7cmV0dXJuIGlzV2Vha1NldFRvU3RyaW5nKHIpfWUuaXNXZWFrU2V0PWlzV2Vha1NldDtmdW5jdGlvbiBpc0FycmF5QnVmZmVyVG9TdHJpbmcocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgQXJyYXlCdWZmZXJdXCJ9aXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcik7ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcihyKXtpZih0eXBlb2YgQXJyYXlCdWZmZXI9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nP2lzQXJyYXlCdWZmZXJUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ9ZS5pc0FycmF5QnVmZmVyPWlzQXJyYXlCdWZmZXI7ZnVuY3Rpb24gaXNEYXRhVmlld1RvU3RyaW5nKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IERhdGFWaWV3XVwifWlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nPXR5cGVvZiBBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJnR5cGVvZiBEYXRhVmlldyE9PVwidW5kZWZpbmVkXCImJmlzRGF0YVZpZXdUb1N0cmluZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpLDAsMSkpO2Z1bmN0aW9uIGlzRGF0YVZpZXcocil7aWYodHlwZW9mIERhdGFWaWV3PT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZz9pc0RhdGFWaWV3VG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIERhdGFWaWV3fWUuaXNEYXRhVmlldz1pc0RhdGFWaWV3O3ZhciBiPXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCI/U2hhcmVkQXJyYXlCdWZmZXI6dW5kZWZpbmVkO2Z1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl1cIn1mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHIpe2lmKHR5cGVvZiBiPT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz09PVwidW5kZWZpbmVkXCIpe2lzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nPWlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgYil9cmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nP2lzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgYn1lLmlzU2hhcmVkQXJyYXlCdWZmZXI9aXNTaGFyZWRBcnJheUJ1ZmZlcjtmdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24ocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIn1lLmlzQXN5bmNGdW5jdGlvbj1pc0FzeW5jRnVuY3Rpb247ZnVuY3Rpb24gaXNNYXBJdGVyYXRvcihyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBNYXAgSXRlcmF0b3JdXCJ9ZS5pc01hcEl0ZXJhdG9yPWlzTWFwSXRlcmF0b3I7ZnVuY3Rpb24gaXNTZXRJdGVyYXRvcihyKXtyZXR1cm4gcyhyKT09PVwiW29iamVjdCBTZXQgSXRlcmF0b3JdXCJ9ZS5pc1NldEl0ZXJhdG9yPWlzU2V0SXRlcmF0b3I7ZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3Qocil7cmV0dXJuIHMocik9PT1cIltvYmplY3QgR2VuZXJhdG9yXVwifWUuaXNHZW5lcmF0b3JPYmplY3Q9aXNHZW5lcmF0b3JPYmplY3Q7ZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHIpe3JldHVybiBzKHIpPT09XCJbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV1cIn1lLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZT1pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7ZnVuY3Rpb24gaXNOdW1iZXJPYmplY3Qocil7cmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUocix5KX1lLmlzTnVtYmVyT2JqZWN0PWlzTnVtYmVyT2JqZWN0O2Z1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHIpe3JldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHIsYyl9ZS5pc1N0cmluZ09iamVjdD1pc1N0cmluZ09iamVjdDtmdW5jdGlvbiBpc0Jvb2xlYW5PYmplY3Qocil7cmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUocixwKX1lLmlzQm9vbGVhbk9iamVjdD1pc0Jvb2xlYW5PYmplY3Q7ZnVuY3Rpb24gaXNCaWdJbnRPYmplY3Qocil7cmV0dXJuIGYmJmNoZWNrQm94ZWRQcmltaXRpdmUocixsKX1lLmlzQmlnSW50T2JqZWN0PWlzQmlnSW50T2JqZWN0O2Z1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHIpe3JldHVybiB1JiZjaGVja0JveGVkUHJpbWl0aXZlKHIsZyl9ZS5pc1N5bWJvbE9iamVjdD1pc1N5bWJvbE9iamVjdDtmdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHIpe3JldHVybiBpc051bWJlck9iamVjdChyKXx8aXNTdHJpbmdPYmplY3Qocil8fGlzQm9vbGVhbk9iamVjdChyKXx8aXNCaWdJbnRPYmplY3Qocil8fGlzU3ltYm9sT2JqZWN0KHIpfWUuaXNCb3hlZFByaW1pdGl2ZT1pc0JveGVkUHJpbWl0aXZlO2Z1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIocil7cmV0dXJuIHR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIiYmKGlzQXJyYXlCdWZmZXIocil8fGlzU2hhcmVkQXJyYXlCdWZmZXIocikpfWUuaXNBbnlBcnJheUJ1ZmZlcj1pc0FueUFycmF5QnVmZmVyO1tcImlzUHJveHlcIixcImlzRXh0ZXJuYWxcIixcImlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0XCJdLmZvckVhY2goKGZ1bmN0aW9uKHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2VudW1lcmFibGU6ZmFsc2UsdmFsdWU6ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IocitcIiBpcyBub3Qgc3VwcG9ydGVkIGluIHVzZXJsYW5kXCIpfX0pfSkpfSwxNzc6ZnVuY3Rpb24ocixlLHQpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzfHxmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHIpe3ZhciBlPU9iamVjdC5rZXlzKHIpO3ZhciB0PXt9O2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt0W2Vbbl1dPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixlW25dKX1yZXR1cm4gdH07dmFyIG89LyVbc2RqJV0vZztlLmZvcm1hdD1mdW5jdGlvbihyKXtpZighaXNTdHJpbmcocikpe3ZhciBlPVtdO2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe2UucHVzaChpbnNwZWN0KGFyZ3VtZW50c1t0XSkpfXJldHVybiBlLmpvaW4oXCIgXCIpfXZhciB0PTE7dmFyIG49YXJndW1lbnRzO3ZhciBpPW4ubGVuZ3RoO3ZhciBhPVN0cmluZyhyKS5yZXBsYWNlKG8sKGZ1bmN0aW9uKHIpe2lmKHI9PT1cIiUlXCIpcmV0dXJuXCIlXCI7aWYodD49aSlyZXR1cm4gcjtzd2l0Y2gocil7Y2FzZVwiJXNcIjpyZXR1cm4gU3RyaW5nKG5bdCsrXSk7Y2FzZVwiJWRcIjpyZXR1cm4gTnVtYmVyKG5bdCsrXSk7Y2FzZVwiJWpcIjp0cnl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KG5bdCsrXSl9Y2F0Y2gocil7cmV0dXJuXCJbQ2lyY3VsYXJdXCJ9ZGVmYXVsdDpyZXR1cm4gcn19KSk7Zm9yKHZhciBmPW5bdF07dDxpO2Y9blsrK3RdKXtpZihpc051bGwoZil8fCFpc09iamVjdChmKSl7YSs9XCIgXCIrZn1lbHNle2ErPVwiIFwiK2luc3BlY3QoZil9fXJldHVybiBhfTtlLmRlcHJlY2F0ZT1mdW5jdGlvbihyLHQpe2lmKHR5cGVvZiBwcm9jZXNzIT09XCJ1bmRlZmluZWRcIiYmcHJvY2Vzcy5ub0RlcHJlY2F0aW9uPT09dHJ1ZSl7cmV0dXJuIHJ9aWYodHlwZW9mIHByb2Nlc3M9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZS5kZXByZWNhdGUocix0KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fXZhciBuPWZhbHNlO2Z1bmN0aW9uIGRlcHJlY2F0ZWQoKXtpZighbil7aWYocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKXt0aHJvdyBuZXcgRXJyb3IodCl9ZWxzZSBpZihwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pe2NvbnNvbGUudHJhY2UodCl9ZWxzZXtjb25zb2xlLmVycm9yKHQpfW49dHJ1ZX1yZXR1cm4gci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIGRlcHJlY2F0ZWR9O3ZhciBpPXt9O3ZhciBhPS9eJC87aWYocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyl7dmFyIGY9cHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztmPWYucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZyxcIlxcXFwkJlwiKS5yZXBsYWNlKC9cXCovZyxcIi4qXCIpLnJlcGxhY2UoLywvZyxcIiR8XlwiKS50b1VwcGVyQ2FzZSgpO2E9bmV3IFJlZ0V4cChcIl5cIitmK1wiJFwiLFwiaVwiKX1lLmRlYnVnbG9nPWZ1bmN0aW9uKHIpe3I9ci50b1VwcGVyQ2FzZSgpO2lmKCFpW3JdKXtpZihhLnRlc3Qocikpe3ZhciB0PXByb2Nlc3MucGlkO2lbcl09ZnVuY3Rpb24oKXt2YXIgbj1lLmZvcm1hdC5hcHBseShlLGFyZ3VtZW50cyk7Y29uc29sZS5lcnJvcihcIiVzICVkOiAlc1wiLHIsdCxuKX19ZWxzZXtpW3JdPWZ1bmN0aW9uKCl7fX19cmV0dXJuIGlbcl19O2Z1bmN0aW9uIGluc3BlY3Qocix0KXt2YXIgbj17c2VlbjpbXSxzdHlsaXplOnN0eWxpemVOb0NvbG9yfTtpZihhcmd1bWVudHMubGVuZ3RoPj0zKW4uZGVwdGg9YXJndW1lbnRzWzJdO2lmKGFyZ3VtZW50cy5sZW5ndGg+PTQpbi5jb2xvcnM9YXJndW1lbnRzWzNdO2lmKGlzQm9vbGVhbih0KSl7bi5zaG93SGlkZGVuPXR9ZWxzZSBpZih0KXtlLl9leHRlbmQobix0KX1pZihpc1VuZGVmaW5lZChuLnNob3dIaWRkZW4pKW4uc2hvd0hpZGRlbj1mYWxzZTtpZihpc1VuZGVmaW5lZChuLmRlcHRoKSluLmRlcHRoPTI7aWYoaXNVbmRlZmluZWQobi5jb2xvcnMpKW4uY29sb3JzPWZhbHNlO2lmKGlzVW5kZWZpbmVkKG4uY3VzdG9tSW5zcGVjdCkpbi5jdXN0b21JbnNwZWN0PXRydWU7aWYobi5jb2xvcnMpbi5zdHlsaXplPXN0eWxpemVXaXRoQ29sb3I7cmV0dXJuIGZvcm1hdFZhbHVlKG4scixuLmRlcHRoKX1lLmluc3BlY3Q9aW5zcGVjdDtpbnNwZWN0LmNvbG9ycz17Ym9sZDpbMSwyMl0saXRhbGljOlszLDIzXSx1bmRlcmxpbmU6WzQsMjRdLGludmVyc2U6WzcsMjddLHdoaXRlOlszNywzOV0sZ3JleTpbOTAsMzldLGJsYWNrOlszMCwzOV0sYmx1ZTpbMzQsMzldLGN5YW46WzM2LDM5XSxncmVlbjpbMzIsMzldLG1hZ2VudGE6WzM1LDM5XSxyZWQ6WzMxLDM5XSx5ZWxsb3c6WzMzLDM5XX07aW5zcGVjdC5zdHlsZXM9e3NwZWNpYWw6XCJjeWFuXCIsbnVtYmVyOlwieWVsbG93XCIsYm9vbGVhbjpcInllbGxvd1wiLHVuZGVmaW5lZDpcImdyZXlcIixudWxsOlwiYm9sZFwiLHN0cmluZzpcImdyZWVuXCIsZGF0ZTpcIm1hZ2VudGFcIixyZWdleHA6XCJyZWRcIn07ZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihyLGUpe3ZhciB0PWluc3BlY3Quc3R5bGVzW2VdO2lmKHQpe3JldHVyblwiXHUwMDFiW1wiK2luc3BlY3QuY29sb3JzW3RdWzBdK1wibVwiK3IrXCJcdTAwMWJbXCIraW5zcGVjdC5jb2xvcnNbdF1bMV0rXCJtXCJ9ZWxzZXtyZXR1cm4gcn19ZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3IocixlKXtyZXR1cm4gcn1mdW5jdGlvbiBhcnJheVRvSGFzaChyKXt2YXIgZT17fTtyLmZvckVhY2goKGZ1bmN0aW9uKHIsdCl7ZVtyXT10cnVlfSkpO3JldHVybiBlfWZ1bmN0aW9uIGZvcm1hdFZhbHVlKHIsdCxuKXtpZihyLmN1c3RvbUluc3BlY3QmJnQmJmlzRnVuY3Rpb24odC5pbnNwZWN0KSYmdC5pbnNwZWN0IT09ZS5pbnNwZWN0JiYhKHQuY29uc3RydWN0b3ImJnQuY29uc3RydWN0b3IucHJvdG90eXBlPT09dCkpe3ZhciBvPXQuaW5zcGVjdChuLHIpO2lmKCFpc1N0cmluZyhvKSl7bz1mb3JtYXRWYWx1ZShyLG8sbil9cmV0dXJuIG99dmFyIGk9Zm9ybWF0UHJpbWl0aXZlKHIsdCk7aWYoaSl7cmV0dXJuIGl9dmFyIGE9T2JqZWN0LmtleXModCk7dmFyIGY9YXJyYXlUb0hhc2goYSk7aWYoci5zaG93SGlkZGVuKXthPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpfWlmKGlzRXJyb3IodCkmJihhLmluZGV4T2YoXCJtZXNzYWdlXCIpPj0wfHxhLmluZGV4T2YoXCJkZXNjcmlwdGlvblwiKT49MCkpe3JldHVybiBmb3JtYXRFcnJvcih0KX1pZihhLmxlbmd0aD09PTApe2lmKGlzRnVuY3Rpb24odCkpe3ZhciB1PXQubmFtZT9cIjogXCIrdC5uYW1lOlwiXCI7cmV0dXJuIHIuc3R5bGl6ZShcIltGdW5jdGlvblwiK3UrXCJdXCIsXCJzcGVjaWFsXCIpfWlmKGlzUmVnRXhwKHQpKXtyZXR1cm4gci5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSxcInJlZ2V4cFwiKX1pZihpc0RhdGUodCkpe3JldHVybiByLnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSxcImRhdGVcIil9aWYoaXNFcnJvcih0KSl7cmV0dXJuIGZvcm1hdEVycm9yKHQpfX12YXIgcz1cIlwiLHk9ZmFsc2UsYz1bXCJ7XCIsXCJ9XCJdO2lmKGlzQXJyYXkodCkpe3k9dHJ1ZTtjPVtcIltcIixcIl1cIl19aWYoaXNGdW5jdGlvbih0KSl7dmFyIHA9dC5uYW1lP1wiOiBcIit0Lm5hbWU6XCJcIjtzPVwiIFtGdW5jdGlvblwiK3ArXCJdXCJ9aWYoaXNSZWdFeHAodCkpe3M9XCIgXCIrUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpfWlmKGlzRGF0ZSh0KSl7cz1cIiBcIitEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHQpfWlmKGlzRXJyb3IodCkpe3M9XCIgXCIrZm9ybWF0RXJyb3IodCl9aWYoYS5sZW5ndGg9PT0wJiYoIXl8fHQubGVuZ3RoPT0wKSl7cmV0dXJuIGNbMF0rcytjWzFdfWlmKG48MCl7aWYoaXNSZWdFeHAodCkpe3JldHVybiByLnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLFwicmVnZXhwXCIpfWVsc2V7cmV0dXJuIHIuc3R5bGl6ZShcIltPYmplY3RdXCIsXCJzcGVjaWFsXCIpfX1yLnNlZW4ucHVzaCh0KTt2YXIgbDtpZih5KXtsPWZvcm1hdEFycmF5KHIsdCxuLGYsYSl9ZWxzZXtsPWEubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZm9ybWF0UHJvcGVydHkocix0LG4sZixlLHkpfSkpfXIuc2Vlbi5wb3AoKTtyZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcobCxzLGMpfWZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShyLGUpe2lmKGlzVW5kZWZpbmVkKGUpKXJldHVybiByLnN0eWxpemUoXCJ1bmRlZmluZWRcIixcInVuZGVmaW5lZFwiKTtpZihpc1N0cmluZyhlKSl7dmFyIHQ9XCInXCIrSlNPTi5zdHJpbmdpZnkoZSkucmVwbGFjZSgvXlwifFwiJC9nLFwiXCIpLnJlcGxhY2UoLycvZyxcIlxcXFwnXCIpLnJlcGxhY2UoL1xcXFxcIi9nLCdcIicpK1wiJ1wiO3JldHVybiByLnN0eWxpemUodCxcInN0cmluZ1wiKX1pZihpc051bWJlcihlKSlyZXR1cm4gci5zdHlsaXplKFwiXCIrZSxcIm51bWJlclwiKTtpZihpc0Jvb2xlYW4oZSkpcmV0dXJuIHIuc3R5bGl6ZShcIlwiK2UsXCJib29sZWFuXCIpO2lmKGlzTnVsbChlKSlyZXR1cm4gci5zdHlsaXplKFwibnVsbFwiLFwibnVsbFwiKX1mdW5jdGlvbiBmb3JtYXRFcnJvcihyKXtyZXR1cm5cIltcIitFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyKStcIl1cIn1mdW5jdGlvbiBmb3JtYXRBcnJheShyLGUsdCxuLG8pe3ZhciBpPVtdO2Zvcih2YXIgYT0wLGY9ZS5sZW5ndGg7YTxmOysrYSl7aWYoaGFzT3duUHJvcGVydHkoZSxTdHJpbmcoYSkpKXtpLnB1c2goZm9ybWF0UHJvcGVydHkocixlLHQsbixTdHJpbmcoYSksdHJ1ZSkpfWVsc2V7aS5wdXNoKFwiXCIpfX1vLmZvckVhY2goKGZ1bmN0aW9uKG8pe2lmKCFvLm1hdGNoKC9eXFxkKyQvKSl7aS5wdXNoKGZvcm1hdFByb3BlcnR5KHIsZSx0LG4sbyx0cnVlKSl9fSkpO3JldHVybiBpfWZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KHIsZSx0LG4sbyxpKXt2YXIgYSxmLHU7dT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsbyl8fHt2YWx1ZTplW29dfTtpZih1LmdldCl7aWYodS5zZXQpe2Y9ci5zdHlsaXplKFwiW0dldHRlci9TZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfWVsc2V7Zj1yLnN0eWxpemUoXCJbR2V0dGVyXVwiLFwic3BlY2lhbFwiKX19ZWxzZXtpZih1LnNldCl7Zj1yLnN0eWxpemUoXCJbU2V0dGVyXVwiLFwic3BlY2lhbFwiKX19aWYoIWhhc093blByb3BlcnR5KG4sbykpe2E9XCJbXCIrbytcIl1cIn1pZighZil7aWYoci5zZWVuLmluZGV4T2YodS52YWx1ZSk8MCl7aWYoaXNOdWxsKHQpKXtmPWZvcm1hdFZhbHVlKHIsdS52YWx1ZSxudWxsKX1lbHNle2Y9Zm9ybWF0VmFsdWUocix1LnZhbHVlLHQtMSl9aWYoZi5pbmRleE9mKFwiXFxuXCIpPi0xKXtpZihpKXtmPWYuc3BsaXQoXCJcXG5cIikubWFwKChmdW5jdGlvbihyKXtyZXR1cm5cIiAgXCIrcn0pKS5qb2luKFwiXFxuXCIpLnN1YnN0cigyKX1lbHNle2Y9XCJcXG5cIitmLnNwbGl0KFwiXFxuXCIpLm1hcCgoZnVuY3Rpb24ocil7cmV0dXJuXCIgICBcIityfSkpLmpvaW4oXCJcXG5cIil9fX1lbHNle2Y9ci5zdHlsaXplKFwiW0NpcmN1bGFyXVwiLFwic3BlY2lhbFwiKX19aWYoaXNVbmRlZmluZWQoYSkpe2lmKGkmJm8ubWF0Y2goL15cXGQrJC8pKXtyZXR1cm4gZn1hPUpTT04uc3RyaW5naWZ5KFwiXCIrbyk7aWYoYS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpe2E9YS5zdWJzdHIoMSxhLmxlbmd0aC0yKTthPXIuc3R5bGl6ZShhLFwibmFtZVwiKX1lbHNle2E9YS5yZXBsYWNlKC8nL2csXCJcXFxcJ1wiKS5yZXBsYWNlKC9cXFxcXCIvZywnXCInKS5yZXBsYWNlKC8oXlwifFwiJCkvZyxcIidcIik7YT1yLnN0eWxpemUoYSxcInN0cmluZ1wiKX19cmV0dXJuIGErXCI6IFwiK2Z9ZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcocixlLHQpe3ZhciBuPTA7dmFyIG89ci5yZWR1Y2UoKGZ1bmN0aW9uKHIsZSl7bisrO2lmKGUuaW5kZXhPZihcIlxcblwiKT49MCluKys7cmV0dXJuIHIrZS5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZyxcIlwiKS5sZW5ndGgrMX0pLDApO2lmKG8+NjApe3JldHVybiB0WzBdKyhlPT09XCJcIj9cIlwiOmUrXCJcXG4gXCIpK1wiIFwiK3Iuam9pbihcIixcXG4gIFwiKStcIiBcIit0WzFdfXJldHVybiB0WzBdK2UrXCIgXCIrci5qb2luKFwiLCBcIikrXCIgXCIrdFsxXX1lLnR5cGVzPXQoNTg0KTtmdW5jdGlvbiBpc0FycmF5KHIpe3JldHVybiBBcnJheS5pc0FycmF5KHIpfWUuaXNBcnJheT1pc0FycmF5O2Z1bmN0aW9uIGlzQm9vbGVhbihyKXtyZXR1cm4gdHlwZW9mIHI9PT1cImJvb2xlYW5cIn1lLmlzQm9vbGVhbj1pc0Jvb2xlYW47ZnVuY3Rpb24gaXNOdWxsKHIpe3JldHVybiByPT09bnVsbH1lLmlzTnVsbD1pc051bGw7ZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQocil7cmV0dXJuIHI9PW51bGx9ZS5pc051bGxPclVuZGVmaW5lZD1pc051bGxPclVuZGVmaW5lZDtmdW5jdGlvbiBpc051bWJlcihyKXtyZXR1cm4gdHlwZW9mIHI9PT1cIm51bWJlclwifWUuaXNOdW1iZXI9aXNOdW1iZXI7ZnVuY3Rpb24gaXNTdHJpbmcocil7cmV0dXJuIHR5cGVvZiByPT09XCJzdHJpbmdcIn1lLmlzU3RyaW5nPWlzU3RyaW5nO2Z1bmN0aW9uIGlzU3ltYm9sKHIpe3JldHVybiB0eXBlb2Ygcj09PVwic3ltYm9sXCJ9ZS5pc1N5bWJvbD1pc1N5bWJvbDtmdW5jdGlvbiBpc1VuZGVmaW5lZChyKXtyZXR1cm4gcj09PXZvaWQgMH1lLmlzVW5kZWZpbmVkPWlzVW5kZWZpbmVkO2Z1bmN0aW9uIGlzUmVnRXhwKHIpe3JldHVybiBpc09iamVjdChyKSYmb2JqZWN0VG9TdHJpbmcocik9PT1cIltvYmplY3QgUmVnRXhwXVwifWUuaXNSZWdFeHA9aXNSZWdFeHA7ZS50eXBlcy5pc1JlZ0V4cD1pc1JlZ0V4cDtmdW5jdGlvbiBpc09iamVjdChyKXtyZXR1cm4gdHlwZW9mIHI9PT1cIm9iamVjdFwiJiZyIT09bnVsbH1lLmlzT2JqZWN0PWlzT2JqZWN0O2Z1bmN0aW9uIGlzRGF0ZShyKXtyZXR1cm4gaXNPYmplY3QocikmJm9iamVjdFRvU3RyaW5nKHIpPT09XCJbb2JqZWN0IERhdGVdXCJ9ZS5pc0RhdGU9aXNEYXRlO2UudHlwZXMuaXNEYXRlPWlzRGF0ZTtmdW5jdGlvbiBpc0Vycm9yKHIpe3JldHVybiBpc09iamVjdChyKSYmKG9iamVjdFRvU3RyaW5nKHIpPT09XCJbb2JqZWN0IEVycm9yXVwifHxyIGluc3RhbmNlb2YgRXJyb3IpfWUuaXNFcnJvcj1pc0Vycm9yO2UudHlwZXMuaXNOYXRpdmVFcnJvcj1pc0Vycm9yO2Z1bmN0aW9uIGlzRnVuY3Rpb24ocil7cmV0dXJuIHR5cGVvZiByPT09XCJmdW5jdGlvblwifWUuaXNGdW5jdGlvbj1pc0Z1bmN0aW9uO2Z1bmN0aW9uIGlzUHJpbWl0aXZlKHIpe3JldHVybiByPT09bnVsbHx8dHlwZW9mIHI9PT1cImJvb2xlYW5cInx8dHlwZW9mIHI9PT1cIm51bWJlclwifHx0eXBlb2Ygcj09PVwic3RyaW5nXCJ8fHR5cGVvZiByPT09XCJzeW1ib2xcInx8dHlwZW9mIHI9PT1cInVuZGVmaW5lZFwifWUuaXNQcmltaXRpdmU9aXNQcmltaXRpdmU7ZS5pc0J1ZmZlcj10KDM2OSk7ZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcocil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyKX1mdW5jdGlvbiBwYWQocil7cmV0dXJuIHI8MTA/XCIwXCIrci50b1N0cmluZygxMCk6ci50b1N0cmluZygxMCl9dmFyIHU9W1wiSmFuXCIsXCJGZWJcIixcIk1hclwiLFwiQXByXCIsXCJNYXlcIixcIkp1blwiLFwiSnVsXCIsXCJBdWdcIixcIlNlcFwiLFwiT2N0XCIsXCJOb3ZcIixcIkRlY1wiXTtmdW5jdGlvbiB0aW1lc3RhbXAoKXt2YXIgcj1uZXcgRGF0ZTt2YXIgZT1bcGFkKHIuZ2V0SG91cnMoKSkscGFkKHIuZ2V0TWludXRlcygpKSxwYWQoci5nZXRTZWNvbmRzKCkpXS5qb2luKFwiOlwiKTtyZXR1cm5bci5nZXREYXRlKCksdVtyLmdldE1vbnRoKCldLGVdLmpvaW4oXCIgXCIpfWUubG9nPWZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCIlcyAtICVzXCIsdGltZXN0YW1wKCksZS5mb3JtYXQuYXBwbHkoZSxhcmd1bWVudHMpKX07ZS5pbmhlcml0cz10KDc4Mik7ZS5fZXh0ZW5kPWZ1bmN0aW9uKHIsZSl7aWYoIWV8fCFpc09iamVjdChlKSlyZXR1cm4gcjt2YXIgdD1PYmplY3Qua2V5cyhlKTt2YXIgbj10Lmxlbmd0aDt3aGlsZShuLS0pe3JbdFtuXV09ZVt0W25dXX1yZXR1cm4gcn07ZnVuY3Rpb24gaGFzT3duUHJvcGVydHkocixlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsZSl9dmFyIHM9dHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCI/U3ltYm9sKFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIpOnVuZGVmaW5lZDtlLnByb21pc2lmeT1mdW5jdGlvbiBwcm9taXNpZnkocil7aWYodHlwZW9mIHIhPT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtpZihzJiZyW3NdKXt2YXIgZT1yW3NdO2lmKHR5cGVvZiBlIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxzLHt2YWx1ZTplLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6ZmFsc2UsY29uZmlndXJhYmxlOnRydWV9KTtyZXR1cm4gZX1mdW5jdGlvbiBlKCl7dmFyIGUsdDt2YXIgbj1uZXcgUHJvbWlzZSgoZnVuY3Rpb24ocixuKXtlPXI7dD1ufSkpO3ZhciBvPVtdO2Zvcih2YXIgaT0wO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe28ucHVzaChhcmd1bWVudHNbaV0pfW8ucHVzaCgoZnVuY3Rpb24ocixuKXtpZihyKXt0KHIpfWVsc2V7ZShuKX19KSk7dHJ5e3IuYXBwbHkodGhpcyxvKX1jYXRjaChyKXt0KHIpfXJldHVybiBufU9iamVjdC5zZXRQcm90b3R5cGVPZihlLE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSk7aWYocylPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxzLHt2YWx1ZTplLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6ZmFsc2UsY29uZmlndXJhYmxlOnRydWV9KTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxuKHIpKX07ZS5wcm9taXNpZnkuY3VzdG9tPXM7ZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHIsZSl7aWYoIXIpe3ZhciB0PW5ldyBFcnJvcihcIlByb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZVwiKTt0LnJlYXNvbj1yO3I9dH1yZXR1cm4gZShyKX1mdW5jdGlvbiBjYWxsYmFja2lmeShyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKX1mdW5jdGlvbiBjYWxsYmFja2lmaWVkKCl7dmFyIGU9W107Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7ZS5wdXNoKGFyZ3VtZW50c1t0XSl9dmFyIG49ZS5wb3AoKTtpZih0eXBlb2YgbiE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvblwiKX12YXIgbz10aGlzO3ZhciBjYj1mdW5jdGlvbigpe3JldHVybiBuLmFwcGx5KG8sYXJndW1lbnRzKX07ci5hcHBseSh0aGlzLGUpLnRoZW4oKGZ1bmN0aW9uKHIpe3Byb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLG51bGwscikpfSksKGZ1bmN0aW9uKHIpe3Byb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCxyLGNiKSl9KSl9T2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsT2JqZWN0LmdldFByb3RvdHlwZU9mKHIpKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLG4ocikpO3JldHVybiBjYWxsYmFja2lmaWVkfWUuY2FsbGJhY2tpZnk9Y2FsbGJhY2tpZnl9LDQ5MDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCgxNDQpO3ZhciBvPXQoMzQ5KTt2YXIgaT10KDI1Nik7dmFyIGE9aShcIk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcIik7dmFyIGY9dCg5NDIpKCk7dmFyIHU9ZiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIHM9bygpO3ZhciB5PWkoXCJTdHJpbmcucHJvdG90eXBlLnNsaWNlXCIpO3ZhciBjPXt9O3ZhciBwPXQoNDY2KTt2YXIgbD1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7aWYodSYmcCYmbCl7bihzLChmdW5jdGlvbihyKXtpZih0eXBlb2YgZ2xvYmFsW3JdPT09XCJmdW5jdGlvblwiKXt2YXIgZT1uZXcgZ2xvYmFsW3JdO2lmKCEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGUpKXt0aHJvdyBuZXcgRXZhbEVycm9yKFwidGhpcyBlbmdpbmUgaGFzIHN1cHBvcnQgZm9yIFN5bWJvbC50b1N0cmluZ1RhZywgYnV0IFwiK3IrXCIgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy5cIil9dmFyIHQ9bChlKTt2YXIgbj1wKHQsU3ltYm9sLnRvU3RyaW5nVGFnKTtpZighbil7dmFyIG89bCh0KTtuPXAobyxTeW1ib2wudG9TdHJpbmdUYWcpfWNbcl09bi5nZXR9fSkpfXZhciBnPWZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHIpe3ZhciBlPWZhbHNlO24oYywoZnVuY3Rpb24odCxuKXtpZighZSl7dHJ5e3ZhciBvPXQuY2FsbChyKTtpZihvPT09bil7ZT1vfX1jYXRjaChyKXt9fX0pKTtyZXR1cm4gZX07dmFyIGI9dCg5OTQpO3IuZXhwb3J0cz1mdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkocil7aWYoIWIocikpe3JldHVybiBmYWxzZX1pZighdSl7cmV0dXJuIHkoYShyKSw4LC0xKX1yZXR1cm4gZyhyKX19LDM0OTpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCg5OTIpO3IuZXhwb3J0cz1mdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpe3JldHVybiBuKFtcIkJpZ0ludDY0QXJyYXlcIixcIkJpZ1VpbnQ2NEFycmF5XCIsXCJGbG9hdDMyQXJyYXlcIixcIkZsb2F0NjRBcnJheVwiLFwiSW50MTZBcnJheVwiLFwiSW50MzJBcnJheVwiLFwiSW50OEFycmF5XCIsXCJVaW50MTZBcnJheVwiLFwiVWludDMyQXJyYXlcIixcIlVpbnQ4QXJyYXlcIixcIlVpbnQ4Q2xhbXBlZEFycmF5XCJdLChmdW5jdGlvbihyKXtyZXR1cm4gdHlwZW9mIGdsb2JhbFtyXT09PVwiZnVuY3Rpb25cIn0pKX19LDQ2NjpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dCg1MDApO3ZhciBvPW4oXCIlT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciVcIix0cnVlKTtpZihvKXt0cnl7byhbXSxcImxlbmd0aFwiKX1jYXRjaChyKXtvPW51bGx9fXIuZXhwb3J0cz1vfX07dmFyIGU9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgbj1lW3RdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIG89ZVt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7clt0XShvLG8uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgZVt0XX1yZXR1cm4gby5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDE3Nyk7bW9kdWxlLmV4cG9ydHM9dH0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/util/util.js\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/image */ \"./node_modules/next/dist/client/image.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyR0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvaW1hZ2UuanM/MDUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvaW1hZ2UnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/image.js\n"));

/***/ }),

/***/ "./node_modules/openai/dist/api.js":
/*!*****************************************!*\
  !*** ./node_modules/openai/dist/api.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * OpenAI API\n * APIs for sampling from and fine-tuning language models\n *\n * The version of the OpenAPI document: 1.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OpenAIApi = exports.OpenAIApiFactory = exports.OpenAIApiFp = exports.OpenAIApiAxiosParamCreator = exports.CreateImageRequestResponseFormatEnum = exports.CreateImageRequestSizeEnum = void 0;\nconst axios_1 = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ./common */ \"./node_modules/openai/dist/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ./base */ \"./node_modules/openai/dist/base.js\");\nexports.CreateImageRequestSizeEnum = {\n    _256x256: '256x256',\n    _512x512: '512x512',\n    _1024x1024: '1024x1024'\n};\nexports.CreateImageRequestResponseFormatEnum = {\n    Url: 'url',\n    B64Json: 'b64_json'\n};\n/**\n * OpenAIApi - axios parameter creator\n * @export\n */\nexports.OpenAIApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         *\n         * @summary Immediately cancel a fine-tune job.\n         * @param {string} fineTuneId The ID of the fine-tune job to cancel\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        cancelFineTune: (fineTuneId, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'fineTuneId' is not null or undefined\n            common_1.assertParamExists('cancelFineTune', 'fineTuneId', fineTuneId);\n            const localVarPath = `/fine-tunes/{fine_tune_id}/cancel`\n                .replace(`{${\"fine_tune_id\"}}`, encodeURIComponent(String(fineTuneId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).\n         * @param {CreateAnswerRequest} createAnswerRequest\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        createAnswer: (createAnswerRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'createAnswerRequest' is not null or undefined\n            common_1.assertParamExists('createAnswer', 'createAnswerRequest', createAnswerRequest);\n            const localVarPath = `/answers`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createAnswerRequest, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.\n         * @param {CreateClassificationRequest} createClassificationRequest\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        createClassification: (createClassificationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'createClassificationRequest' is not null or undefined\n            common_1.assertParamExists('createClassification', 'createClassificationRequest', createClassificationRequest);\n            const localVarPath = `/classifications`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createClassificationRequest, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Creates a completion for the provided prompt and parameters\n         * @param {CreateCompletionRequest} createCompletionRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createCompletion: (createCompletionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'createCompletionRequest' is not null or undefined\n            common_1.assertParamExists('createCompletion', 'createCompletionRequest', createCompletionRequest);\n            const localVarPath = `/completions`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createCompletionRequest, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Creates a new edit for the provided input, instruction, and parameters\n         * @param {CreateEditRequest} createEditRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createEdit: (createEditRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'createEditRequest' is not null or undefined\n            common_1.assertParamExists('createEdit', 'createEditRequest', createEditRequest);\n            const localVarPath = `/edits`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createEditRequest, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Creates an embedding vector representing the input text.\n         * @param {CreateEmbeddingRequest} createEmbeddingRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createEmbedding: (createEmbeddingRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'createEmbeddingRequest' is not null or undefined\n            common_1.assertParamExists('createEmbedding', 'createEmbeddingRequest', createEmbeddingRequest);\n            const localVarPath = `/embeddings`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createEmbeddingRequest, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.\n         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\\\\&quot;fine-tune\\\\\\&quot;, each line is a JSON record with \\\\\\&quot;prompt\\\\\\&quot; and \\\\\\&quot;completion\\\\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).\n         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\\\\&quot;fine-tune\\\\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFile: (file, purpose, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'file' is not null or undefined\n            common_1.assertParamExists('createFile', 'file', file);\n            // verify required parameter 'purpose' is not null or undefined\n            common_1.assertParamExists('createFile', 'purpose', purpose);\n            const localVarPath = `/files`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();\n            if (file !== undefined) {\n                localVarFormParams.append('file', file);\n            }\n            if (purpose !== undefined) {\n                localVarFormParams.append('purpose', purpose);\n            }\n            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = localVarFormParams;\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)\n         * @param {CreateFineTuneRequest} createFineTuneRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFineTune: (createFineTuneRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'createFineTuneRequest' is not null or undefined\n            common_1.assertParamExists('createFineTune', 'createFineTuneRequest', createFineTuneRequest);\n            const localVarPath = `/fine-tunes`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createFineTuneRequest, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Creates an image given a prompt.\n         * @param {CreateImageRequest} createImageRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createImage: (createImageRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'createImageRequest' is not null or undefined\n            common_1.assertParamExists('createImage', 'createImageRequest', createImageRequest);\n            const localVarPath = `/images/generations`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createImageRequest, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Creates an edited or extended image given an original image and a prompt.\n         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square.\n         * @param {File} mask An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.\n         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.\n         * @param {number} [n] The number of images to generate. Must be between 1 and 10.\n         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.\n         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.\n         * @param {string} [user] A unique identifier representing your end-user, which will help OpenAI to monitor and detect abuse. [Learn more](/docs/usage-policies/end-user-ids).\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createImageEdit: (image, mask, prompt, n, size, responseFormat, user, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'image' is not null or undefined\n            common_1.assertParamExists('createImageEdit', 'image', image);\n            // verify required parameter 'mask' is not null or undefined\n            common_1.assertParamExists('createImageEdit', 'mask', mask);\n            // verify required parameter 'prompt' is not null or undefined\n            common_1.assertParamExists('createImageEdit', 'prompt', prompt);\n            const localVarPath = `/images/edits`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();\n            if (image !== undefined) {\n                localVarFormParams.append('image', image);\n            }\n            if (mask !== undefined) {\n                localVarFormParams.append('mask', mask);\n            }\n            if (prompt !== undefined) {\n                localVarFormParams.append('prompt', prompt);\n            }\n            if (n !== undefined) {\n                localVarFormParams.append('n', n);\n            }\n            if (size !== undefined) {\n                localVarFormParams.append('size', size);\n            }\n            if (responseFormat !== undefined) {\n                localVarFormParams.append('response_format', responseFormat);\n            }\n            if (user !== undefined) {\n                localVarFormParams.append('user', user);\n            }\n            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = localVarFormParams;\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Creates a variation of a given image.\n         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.\n         * @param {number} [n] The number of images to generate. Must be between 1 and 10.\n         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.\n         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.\n         * @param {string} [user] A unique identifier representing your end-user, which will help OpenAI to monitor and detect abuse. [Learn more](/docs/usage-policies/end-user-ids).\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createImageVariation: (image, n, size, responseFormat, user, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'image' is not null or undefined\n            common_1.assertParamExists('createImageVariation', 'image', image);\n            const localVarPath = `/images/variations`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();\n            if (image !== undefined) {\n                localVarFormParams.append('image', image);\n            }\n            if (n !== undefined) {\n                localVarFormParams.append('n', n);\n            }\n            if (size !== undefined) {\n                localVarFormParams.append('size', size);\n            }\n            if (responseFormat !== undefined) {\n                localVarFormParams.append('response_format', responseFormat);\n            }\n            if (user !== undefined) {\n                localVarFormParams.append('user', user);\n            }\n            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), localVarFormParams.getHeaders()), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = localVarFormParams;\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Classifies if text violates OpenAI\\'s Content Policy\n         * @param {CreateModerationRequest} createModerationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createModeration: (createModerationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'createModerationRequest' is not null or undefined\n            common_1.assertParamExists('createModeration', 'createModerationRequest', createModerationRequest);\n            const localVarPath = `/moderations`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createModerationRequest, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.\n         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.\n         * @param {CreateSearchRequest} createSearchRequest\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        createSearch: (engineId, createSearchRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'engineId' is not null or undefined\n            common_1.assertParamExists('createSearch', 'engineId', engineId);\n            // verify required parameter 'createSearchRequest' is not null or undefined\n            common_1.assertParamExists('createSearch', 'createSearchRequest', createSearchRequest);\n            const localVarPath = `/engines/{engine_id}/search`\n                .replace(`{${\"engine_id\"}}`, encodeURIComponent(String(engineId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createSearchRequest, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Delete a file.\n         * @param {string} fileId The ID of the file to use for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteFile: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'fileId' is not null or undefined\n            common_1.assertParamExists('deleteFile', 'fileId', fileId);\n            const localVarPath = `/files/{file_id}`\n                .replace(`{${\"file_id\"}}`, encodeURIComponent(String(fileId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.\n         * @param {string} model The model to delete\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteModel: (model, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'model' is not null or undefined\n            common_1.assertParamExists('deleteModel', 'model', model);\n            const localVarPath = `/models/{model}`\n                .replace(`{${\"model\"}}`, encodeURIComponent(String(model)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Returns the contents of the specified file\n         * @param {string} fileId The ID of the file to use for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        downloadFile: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'fileId' is not null or undefined\n            common_1.assertParamExists('downloadFile', 'fileId', fileId);\n            const localVarPath = `/files/{file_id}/content`\n                .replace(`{${\"file_id\"}}`, encodeURIComponent(String(fileId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        listEngines: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/engines`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Returns a list of files that belong to the user\\'s organization.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFiles: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/files`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Get fine-grained status updates for a fine-tune job.\n         * @param {string} fineTuneId The ID of the fine-tune job to get events for.\n         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFineTuneEvents: (fineTuneId, stream, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'fineTuneId' is not null or undefined\n            common_1.assertParamExists('listFineTuneEvents', 'fineTuneId', fineTuneId);\n            const localVarPath = `/fine-tunes/{fine_tune_id}/events`\n                .replace(`{${\"fine_tune_id\"}}`, encodeURIComponent(String(fineTuneId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (stream !== undefined) {\n                localVarQueryParameter['stream'] = stream;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary List your organization\\'s fine-tuning jobs\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFineTunes: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/fine-tunes`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listModels: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/models`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.\n         * @param {string} engineId The ID of the engine to use for this request\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        retrieveEngine: (engineId, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'engineId' is not null or undefined\n            common_1.assertParamExists('retrieveEngine', 'engineId', engineId);\n            const localVarPath = `/engines/{engine_id}`\n                .replace(`{${\"engine_id\"}}`, encodeURIComponent(String(engineId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Returns information about a specific file.\n         * @param {string} fileId The ID of the file to use for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        retrieveFile: (fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'fileId' is not null or undefined\n            common_1.assertParamExists('retrieveFile', 'fileId', fileId);\n            const localVarPath = `/files/{file_id}`\n                .replace(`{${\"file_id\"}}`, encodeURIComponent(String(fileId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)\n         * @param {string} fineTuneId The ID of the fine-tune job\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        retrieveFineTune: (fineTuneId, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'fineTuneId' is not null or undefined\n            common_1.assertParamExists('retrieveFineTune', 'fineTuneId', fineTuneId);\n            const localVarPath = `/fine-tunes/{fine_tune_id}`\n                .replace(`{${\"fine_tune_id\"}}`, encodeURIComponent(String(fineTuneId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.\n         * @param {string} model The ID of the model to use for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        retrieveModel: (model, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'model' is not null or undefined\n            common_1.assertParamExists('retrieveModel', 'model', model);\n            const localVarPath = `/models/{model}`\n                .replace(`{${\"model\"}}`, encodeURIComponent(String(model)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\n/**\n * OpenAIApi - functional programming interface\n * @export\n */\nexports.OpenAIApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.OpenAIApiAxiosParamCreator(configuration);\n    return {\n        /**\n         *\n         * @summary Immediately cancel a fine-tune job.\n         * @param {string} fineTuneId The ID of the fine-tune job to cancel\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        cancelFineTune(fineTuneId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelFineTune(fineTuneId, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).\n         * @param {CreateAnswerRequest} createAnswerRequest\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        createAnswer(createAnswerRequest, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createAnswer(createAnswerRequest, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.\n         * @param {CreateClassificationRequest} createClassificationRequest\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        createClassification(createClassificationRequest, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createClassification(createClassificationRequest, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Creates a completion for the provided prompt and parameters\n         * @param {CreateCompletionRequest} createCompletionRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createCompletion(createCompletionRequest, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCompletion(createCompletionRequest, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Creates a new edit for the provided input, instruction, and parameters\n         * @param {CreateEditRequest} createEditRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createEdit(createEditRequest, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createEdit(createEditRequest, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Creates an embedding vector representing the input text.\n         * @param {CreateEmbeddingRequest} createEmbeddingRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createEmbedding(createEmbeddingRequest, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createEmbedding(createEmbeddingRequest, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.\n         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\\\\&quot;fine-tune\\\\\\&quot;, each line is a JSON record with \\\\\\&quot;prompt\\\\\\&quot; and \\\\\\&quot;completion\\\\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).\n         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\\\\&quot;fine-tune\\\\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFile(file, purpose, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createFile(file, purpose, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)\n         * @param {CreateFineTuneRequest} createFineTuneRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFineTune(createFineTuneRequest, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createFineTune(createFineTuneRequest, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Creates an image given a prompt.\n         * @param {CreateImageRequest} createImageRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createImage(createImageRequest, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createImage(createImageRequest, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Creates an edited or extended image given an original image and a prompt.\n         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square.\n         * @param {File} mask An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.\n         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.\n         * @param {number} [n] The number of images to generate. Must be between 1 and 10.\n         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.\n         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.\n         * @param {string} [user] A unique identifier representing your end-user, which will help OpenAI to monitor and detect abuse. [Learn more](/docs/usage-policies/end-user-ids).\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createImageEdit(image, mask, prompt, n, size, responseFormat, user, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createImageEdit(image, mask, prompt, n, size, responseFormat, user, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Creates a variation of a given image.\n         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.\n         * @param {number} [n] The number of images to generate. Must be between 1 and 10.\n         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.\n         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.\n         * @param {string} [user] A unique identifier representing your end-user, which will help OpenAI to monitor and detect abuse. [Learn more](/docs/usage-policies/end-user-ids).\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createImageVariation(image, n, size, responseFormat, user, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createImageVariation(image, n, size, responseFormat, user, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Classifies if text violates OpenAI\\'s Content Policy\n         * @param {CreateModerationRequest} createModerationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createModeration(createModerationRequest, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createModeration(createModerationRequest, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.\n         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.\n         * @param {CreateSearchRequest} createSearchRequest\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        createSearch(engineId, createSearchRequest, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createSearch(engineId, createSearchRequest, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Delete a file.\n         * @param {string} fileId The ID of the file to use for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteFile(fileId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFile(fileId, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.\n         * @param {string} model The model to delete\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteModel(model, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteModel(model, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Returns the contents of the specified file\n         * @param {string} fileId The ID of the file to use for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        downloadFile(fileId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadFile(fileId, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        listEngines(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.listEngines(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Returns a list of files that belong to the user\\'s organization.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFiles(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFiles(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Get fine-grained status updates for a fine-tune job.\n         * @param {string} fineTuneId The ID of the fine-tune job to get events for.\n         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFineTuneEvents(fineTuneId, stream, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFineTuneEvents(fineTuneId, stream, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary List your organization\\'s fine-tuning jobs\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFineTunes(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFineTunes(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listModels(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.listModels(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.\n         * @param {string} engineId The ID of the engine to use for this request\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        retrieveEngine(engineId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveEngine(engineId, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Returns information about a specific file.\n         * @param {string} fileId The ID of the file to use for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        retrieveFile(fileId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveFile(fileId, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)\n         * @param {string} fineTuneId The ID of the fine-tune job\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        retrieveFineTune(fineTuneId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveFineTune(fineTuneId, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.\n         * @param {string} model The ID of the model to use for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        retrieveModel(model, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveModel(model, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\n/**\n * OpenAIApi - factory interface\n * @export\n */\nexports.OpenAIApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.OpenAIApiFp(configuration);\n    return {\n        /**\n         *\n         * @summary Immediately cancel a fine-tune job.\n         * @param {string} fineTuneId The ID of the fine-tune job to cancel\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        cancelFineTune(fineTuneId, options) {\n            return localVarFp.cancelFineTune(fineTuneId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).\n         * @param {CreateAnswerRequest} createAnswerRequest\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        createAnswer(createAnswerRequest, options) {\n            return localVarFp.createAnswer(createAnswerRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.\n         * @param {CreateClassificationRequest} createClassificationRequest\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        createClassification(createClassificationRequest, options) {\n            return localVarFp.createClassification(createClassificationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Creates a completion for the provided prompt and parameters\n         * @param {CreateCompletionRequest} createCompletionRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createCompletion(createCompletionRequest, options) {\n            return localVarFp.createCompletion(createCompletionRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Creates a new edit for the provided input, instruction, and parameters\n         * @param {CreateEditRequest} createEditRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createEdit(createEditRequest, options) {\n            return localVarFp.createEdit(createEditRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Creates an embedding vector representing the input text.\n         * @param {CreateEmbeddingRequest} createEmbeddingRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createEmbedding(createEmbeddingRequest, options) {\n            return localVarFp.createEmbedding(createEmbeddingRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.\n         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\\\\&quot;fine-tune\\\\\\&quot;, each line is a JSON record with \\\\\\&quot;prompt\\\\\\&quot; and \\\\\\&quot;completion\\\\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).\n         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\\\\&quot;fine-tune\\\\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFile(file, purpose, options) {\n            return localVarFp.createFile(file, purpose, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)\n         * @param {CreateFineTuneRequest} createFineTuneRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFineTune(createFineTuneRequest, options) {\n            return localVarFp.createFineTune(createFineTuneRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Creates an image given a prompt.\n         * @param {CreateImageRequest} createImageRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createImage(createImageRequest, options) {\n            return localVarFp.createImage(createImageRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Creates an edited or extended image given an original image and a prompt.\n         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square.\n         * @param {File} mask An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.\n         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.\n         * @param {number} [n] The number of images to generate. Must be between 1 and 10.\n         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.\n         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.\n         * @param {string} [user] A unique identifier representing your end-user, which will help OpenAI to monitor and detect abuse. [Learn more](/docs/usage-policies/end-user-ids).\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createImageEdit(image, mask, prompt, n, size, responseFormat, user, options) {\n            return localVarFp.createImageEdit(image, mask, prompt, n, size, responseFormat, user, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Creates a variation of a given image.\n         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.\n         * @param {number} [n] The number of images to generate. Must be between 1 and 10.\n         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.\n         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.\n         * @param {string} [user] A unique identifier representing your end-user, which will help OpenAI to monitor and detect abuse. [Learn more](/docs/usage-policies/end-user-ids).\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createImageVariation(image, n, size, responseFormat, user, options) {\n            return localVarFp.createImageVariation(image, n, size, responseFormat, user, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Classifies if text violates OpenAI\\'s Content Policy\n         * @param {CreateModerationRequest} createModerationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createModeration(createModerationRequest, options) {\n            return localVarFp.createModeration(createModerationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.\n         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.\n         * @param {CreateSearchRequest} createSearchRequest\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        createSearch(engineId, createSearchRequest, options) {\n            return localVarFp.createSearch(engineId, createSearchRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Delete a file.\n         * @param {string} fileId The ID of the file to use for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteFile(fileId, options) {\n            return localVarFp.deleteFile(fileId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.\n         * @param {string} model The model to delete\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteModel(model, options) {\n            return localVarFp.deleteModel(model, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Returns the contents of the specified file\n         * @param {string} fileId The ID of the file to use for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        downloadFile(fileId, options) {\n            return localVarFp.downloadFile(fileId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        listEngines(options) {\n            return localVarFp.listEngines(options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Returns a list of files that belong to the user\\'s organization.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFiles(options) {\n            return localVarFp.listFiles(options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Get fine-grained status updates for a fine-tune job.\n         * @param {string} fineTuneId The ID of the fine-tune job to get events for.\n         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFineTuneEvents(fineTuneId, stream, options) {\n            return localVarFp.listFineTuneEvents(fineTuneId, stream, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary List your organization\\'s fine-tuning jobs\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFineTunes(options) {\n            return localVarFp.listFineTunes(options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listModels(options) {\n            return localVarFp.listModels(options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.\n         * @param {string} engineId The ID of the engine to use for this request\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        retrieveEngine(engineId, options) {\n            return localVarFp.retrieveEngine(engineId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Returns information about a specific file.\n         * @param {string} fileId The ID of the file to use for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        retrieveFile(fileId, options) {\n            return localVarFp.retrieveFile(fileId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)\n         * @param {string} fineTuneId The ID of the fine-tune job\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        retrieveFineTune(fineTuneId, options) {\n            return localVarFp.retrieveFineTune(fineTuneId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.\n         * @param {string} model The ID of the model to use for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        retrieveModel(model, options) {\n            return localVarFp.retrieveModel(model, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n/**\n * OpenAIApi - object-oriented interface\n * @export\n * @class OpenAIApi\n * @extends {BaseAPI}\n */\nclass OpenAIApi extends base_1.BaseAPI {\n    /**\n     *\n     * @summary Immediately cancel a fine-tune job.\n     * @param {string} fineTuneId The ID of the fine-tune job to cancel\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    cancelFineTune(fineTuneId, options) {\n        return exports.OpenAIApiFp(this.configuration).cancelFineTune(fineTuneId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).\n     * @param {CreateAnswerRequest} createAnswerRequest\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    createAnswer(createAnswerRequest, options) {\n        return exports.OpenAIApiFp(this.configuration).createAnswer(createAnswerRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.\n     * @param {CreateClassificationRequest} createClassificationRequest\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    createClassification(createClassificationRequest, options) {\n        return exports.OpenAIApiFp(this.configuration).createClassification(createClassificationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Creates a completion for the provided prompt and parameters\n     * @param {CreateCompletionRequest} createCompletionRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    createCompletion(createCompletionRequest, options) {\n        return exports.OpenAIApiFp(this.configuration).createCompletion(createCompletionRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Creates a new edit for the provided input, instruction, and parameters\n     * @param {CreateEditRequest} createEditRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    createEdit(createEditRequest, options) {\n        return exports.OpenAIApiFp(this.configuration).createEdit(createEditRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Creates an embedding vector representing the input text.\n     * @param {CreateEmbeddingRequest} createEmbeddingRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    createEmbedding(createEmbeddingRequest, options) {\n        return exports.OpenAIApiFp(this.configuration).createEmbedding(createEmbeddingRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.\n     * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\\\\&quot;fine-tune\\\\\\&quot;, each line is a JSON record with \\\\\\&quot;prompt\\\\\\&quot; and \\\\\\&quot;completion\\\\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).\n     * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\\\\&quot;fine-tune\\\\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    createFile(file, purpose, options) {\n        return exports.OpenAIApiFp(this.configuration).createFile(file, purpose, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)\n     * @param {CreateFineTuneRequest} createFineTuneRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    createFineTune(createFineTuneRequest, options) {\n        return exports.OpenAIApiFp(this.configuration).createFineTune(createFineTuneRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Creates an image given a prompt.\n     * @param {CreateImageRequest} createImageRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    createImage(createImageRequest, options) {\n        return exports.OpenAIApiFp(this.configuration).createImage(createImageRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Creates an edited or extended image given an original image and a prompt.\n     * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square.\n     * @param {File} mask An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.\n     * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.\n     * @param {number} [n] The number of images to generate. Must be between 1 and 10.\n     * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.\n     * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.\n     * @param {string} [user] A unique identifier representing your end-user, which will help OpenAI to monitor and detect abuse. [Learn more](/docs/usage-policies/end-user-ids).\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    createImageEdit(image, mask, prompt, n, size, responseFormat, user, options) {\n        return exports.OpenAIApiFp(this.configuration).createImageEdit(image, mask, prompt, n, size, responseFormat, user, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Creates a variation of a given image.\n     * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.\n     * @param {number} [n] The number of images to generate. Must be between 1 and 10.\n     * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.\n     * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.\n     * @param {string} [user] A unique identifier representing your end-user, which will help OpenAI to monitor and detect abuse. [Learn more](/docs/usage-policies/end-user-ids).\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    createImageVariation(image, n, size, responseFormat, user, options) {\n        return exports.OpenAIApiFp(this.configuration).createImageVariation(image, n, size, responseFormat, user, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Classifies if text violates OpenAI\\'s Content Policy\n     * @param {CreateModerationRequest} createModerationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    createModeration(createModerationRequest, options) {\n        return exports.OpenAIApiFp(this.configuration).createModeration(createModerationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.\n     * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.\n     * @param {CreateSearchRequest} createSearchRequest\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    createSearch(engineId, createSearchRequest, options) {\n        return exports.OpenAIApiFp(this.configuration).createSearch(engineId, createSearchRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Delete a file.\n     * @param {string} fileId The ID of the file to use for this request\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    deleteFile(fileId, options) {\n        return exports.OpenAIApiFp(this.configuration).deleteFile(fileId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Delete a fine-tuned model. You must have the Owner role in your organization.\n     * @param {string} model The model to delete\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    deleteModel(model, options) {\n        return exports.OpenAIApiFp(this.configuration).deleteModel(model, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Returns the contents of the specified file\n     * @param {string} fileId The ID of the file to use for this request\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    downloadFile(fileId, options) {\n        return exports.OpenAIApiFp(this.configuration).downloadFile(fileId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    listEngines(options) {\n        return exports.OpenAIApiFp(this.configuration).listEngines(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Returns a list of files that belong to the user\\'s organization.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    listFiles(options) {\n        return exports.OpenAIApiFp(this.configuration).listFiles(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Get fine-grained status updates for a fine-tune job.\n     * @param {string} fineTuneId The ID of the fine-tune job to get events for.\n     * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    listFineTuneEvents(fineTuneId, stream, options) {\n        return exports.OpenAIApiFp(this.configuration).listFineTuneEvents(fineTuneId, stream, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary List your organization\\'s fine-tuning jobs\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    listFineTunes(options) {\n        return exports.OpenAIApiFp(this.configuration).listFineTunes(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    listModels(options) {\n        return exports.OpenAIApiFp(this.configuration).listModels(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.\n     * @param {string} engineId The ID of the engine to use for this request\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    retrieveEngine(engineId, options) {\n        return exports.OpenAIApiFp(this.configuration).retrieveEngine(engineId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Returns information about a specific file.\n     * @param {string} fileId The ID of the file to use for this request\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    retrieveFile(fileId, options) {\n        return exports.OpenAIApiFp(this.configuration).retrieveFile(fileId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)\n     * @param {string} fineTuneId The ID of the fine-tune job\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    retrieveFineTune(fineTuneId, options) {\n        return exports.OpenAIApiFp(this.configuration).retrieveFineTune(fineTuneId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.\n     * @param {string} model The ID of the model to use for this request\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OpenAIApi\n     */\n    retrieveModel(model, options) {\n        return exports.OpenAIApiFp(this.configuration).retrieveModel(model, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.OpenAIApi = OpenAIApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3BlbmFpL2Rpc3QvYXBpLmpzP2E2OWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogT3BlbkFJIEFQSVxuICogQVBJcyBmb3Igc2FtcGxpbmcgZnJvbSBhbmQgZmluZS10dW5pbmcgbGFuZ3VhZ2UgbW9kZWxzXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDEuMS4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9wZW5BSUFwaSA9IGV4cG9ydHMuT3BlbkFJQXBpRmFjdG9yeSA9IGV4cG9ydHMuT3BlbkFJQXBpRnAgPSBleHBvcnRzLk9wZW5BSUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5DcmVhdGVJbWFnZVJlcXVlc3RSZXNwb25zZUZvcm1hdEVudW0gPSBleHBvcnRzLkNyZWF0ZUltYWdlUmVxdWVzdFNpemVFbnVtID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IHJlcXVpcmUoXCJheGlvc1wiKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuZXhwb3J0cy5DcmVhdGVJbWFnZVJlcXVlc3RTaXplRW51bSA9IHtcbiAgICBfMjU2eDI1NjogJzI1NngyNTYnLFxuICAgIF81MTJ4NTEyOiAnNTEyeDUxMicsXG4gICAgXzEwMjR4MTAyNDogJzEwMjR4MTAyNCdcbn07XG5leHBvcnRzLkNyZWF0ZUltYWdlUmVxdWVzdFJlc3BvbnNlRm9ybWF0RW51bSA9IHtcbiAgICBVcmw6ICd1cmwnLFxuICAgIEI2NEpzb246ICdiNjRfanNvbidcbn07XG4vKipcbiAqIE9wZW5BSUFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMuT3BlbkFJQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBJbW1lZGlhdGVseSBjYW5jZWwgYSBmaW5lLXR1bmUgam9iLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmluZVR1bmVJZCBUaGUgSUQgb2YgdGhlIGZpbmUtdHVuZSBqb2IgdG8gY2FuY2VsXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWxGaW5lVHVuZTogKGZpbmVUdW5lSWQsIG9wdGlvbnMgPSB7fSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZmluZVR1bmVJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cygnY2FuY2VsRmluZVR1bmUnLCAnZmluZVR1bmVJZCcsIGZpbmVUdW5lSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9maW5lLXR1bmVzL3tmaW5lX3R1bmVfaWR9L2NhbmNlbGBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJmaW5lX3R1bmVfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhmaW5lVHVuZUlkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQT1NUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiBjb21tb25fMS50b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IEFuc3dlcnMgdGhlIHNwZWNpZmllZCBxdWVzdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgZG9jdW1lbnRzIGFuZCBleGFtcGxlcy4gIFRoZSBlbmRwb2ludCBmaXJzdCBbc2VhcmNoZXNdKC9kb2NzL2FwaS1yZWZlcmVuY2Uvc2VhcmNoZXMpIG92ZXIgcHJvdmlkZWQgZG9jdW1lbnRzIG9yIGZpbGVzIHRvIGZpbmQgcmVsZXZhbnQgY29udGV4dC4gVGhlIHJlbGV2YW50IGNvbnRleHQgaXMgY29tYmluZWQgd2l0aCB0aGUgcHJvdmlkZWQgZXhhbXBsZXMgYW5kIHF1ZXN0aW9uIHRvIGNyZWF0ZSB0aGUgcHJvbXB0IGZvciBbY29tcGxldGlvbl0oL2RvY3MvYXBpLXJlZmVyZW5jZS9jb21wbGV0aW9ucykuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlQW5zd2VyUmVxdWVzdH0gY3JlYXRlQW5zd2VyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQW5zd2VyOiAoY3JlYXRlQW5zd2VyUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjcmVhdGVBbnN3ZXJSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKCdjcmVhdGVBbnN3ZXInLCAnY3JlYXRlQW5zd2VyUmVxdWVzdCcsIGNyZWF0ZUFuc3dlclJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9hbnN3ZXJzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQoY3JlYXRlQW5zd2VyUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogY29tbW9uXzEudG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDbGFzc2lmaWVzIHRoZSBzcGVjaWZpZWQgYHF1ZXJ5YCB1c2luZyBwcm92aWRlZCBleGFtcGxlcy4gIFRoZSBlbmRwb2ludCBmaXJzdCBbc2VhcmNoZXNdKC9kb2NzL2FwaS1yZWZlcmVuY2Uvc2VhcmNoZXMpIG92ZXIgdGhlIGxhYmVsZWQgZXhhbXBsZXMgdG8gc2VsZWN0IHRoZSBvbmVzIG1vc3QgcmVsZXZhbnQgZm9yIHRoZSBwYXJ0aWN1bGFyIHF1ZXJ5LiBUaGVuLCB0aGUgcmVsZXZhbnQgZXhhbXBsZXMgYXJlIGNvbWJpbmVkIHdpdGggdGhlIHF1ZXJ5IHRvIGNvbnN0cnVjdCBhIHByb21wdCB0byBwcm9kdWNlIHRoZSBmaW5hbCBsYWJlbCB2aWEgdGhlIFtjb21wbGV0aW9uc10oL2RvY3MvYXBpLXJlZmVyZW5jZS9jb21wbGV0aW9ucykgZW5kcG9pbnQuICBMYWJlbGVkIGV4YW1wbGVzIGNhbiBiZSBwcm92aWRlZCB2aWEgYW4gdXBsb2FkZWQgYGZpbGVgLCBvciBleHBsaWNpdGx5IGxpc3RlZCBpbiB0aGUgcmVxdWVzdCB1c2luZyB0aGUgYGV4YW1wbGVzYCBwYXJhbWV0ZXIgZm9yIHF1aWNrIHRlc3RzIGFuZCBzbWFsbCBzY2FsZSB1c2UgY2FzZXMuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlQ2xhc3NpZmljYXRpb25SZXF1ZXN0fSBjcmVhdGVDbGFzc2lmaWNhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUNsYXNzaWZpY2F0aW9uOiAoY3JlYXRlQ2xhc3NpZmljYXRpb25SZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZUNsYXNzaWZpY2F0aW9uUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cygnY3JlYXRlQ2xhc3NpZmljYXRpb24nLCAnY3JlYXRlQ2xhc3NpZmljYXRpb25SZXF1ZXN0JywgY3JlYXRlQ2xhc3NpZmljYXRpb25SZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvY2xhc3NpZmljYXRpb25zYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQoY3JlYXRlQ2xhc3NpZmljYXRpb25SZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiBjb21tb25fMS50b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZXMgYSBjb21wbGV0aW9uIGZvciB0aGUgcHJvdmlkZWQgcHJvbXB0IGFuZCBwYXJhbWV0ZXJzXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlQ29tcGxldGlvblJlcXVlc3R9IGNyZWF0ZUNvbXBsZXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVDb21wbGV0aW9uOiAoY3JlYXRlQ29tcGxldGlvblJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY3JlYXRlQ29tcGxldGlvblJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMoJ2NyZWF0ZUNvbXBsZXRpb24nLCAnY3JlYXRlQ29tcGxldGlvblJlcXVlc3QnLCBjcmVhdGVDb21wbGV0aW9uUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2NvbXBsZXRpb25zYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQoY3JlYXRlQ29tcGxldGlvblJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6IGNvbW1vbl8xLnRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlcyBhIG5ldyBlZGl0IGZvciB0aGUgcHJvdmlkZWQgaW5wdXQsIGluc3RydWN0aW9uLCBhbmQgcGFyYW1ldGVyc1xuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUVkaXRSZXF1ZXN0fSBjcmVhdGVFZGl0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRWRpdDogKGNyZWF0ZUVkaXRSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZUVkaXRSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKCdjcmVhdGVFZGl0JywgJ2NyZWF0ZUVkaXRSZXF1ZXN0JywgY3JlYXRlRWRpdFJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9lZGl0c2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKGNyZWF0ZUVkaXRSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiBjb21tb25fMS50b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZXMgYW4gZW1iZWRkaW5nIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRW1iZWRkaW5nUmVxdWVzdH0gY3JlYXRlRW1iZWRkaW5nUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRW1iZWRkaW5nOiAoY3JlYXRlRW1iZWRkaW5nUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjcmVhdGVFbWJlZGRpbmdSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKCdjcmVhdGVFbWJlZGRpbmcnLCAnY3JlYXRlRW1iZWRkaW5nUmVxdWVzdCcsIGNyZWF0ZUVtYmVkZGluZ1JlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9lbWJlZGRpbmdzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQoY3JlYXRlRW1iZWRkaW5nUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogY29tbW9uXzEudG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBVcGxvYWQgYSBmaWxlIHRoYXQgY29udGFpbnMgZG9jdW1lbnQocykgdG8gYmUgdXNlZCBhY3Jvc3MgdmFyaW91cyBlbmRwb2ludHMvZmVhdHVyZXMuIEN1cnJlbnRseSwgdGhlIHNpemUgb2YgYWxsIHRoZSBmaWxlcyB1cGxvYWRlZCBieSBvbmUgb3JnYW5pemF0aW9uIGNhbiBiZSB1cCB0byAxIEdCLiBQbGVhc2UgY29udGFjdCB1cyBpZiB5b3UgbmVlZCB0byBpbmNyZWFzZSB0aGUgc3RvcmFnZSBsaW1pdC5cbiAgICAgICAgICogQHBhcmFtIHtGaWxlfSBmaWxlIE5hbWUgb2YgdGhlIFtKU09OIExpbmVzXShodHRwczovL2pzb25saW5lcy5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvKSBmaWxlIHRvIGJlIHVwbG9hZGVkLiAgSWYgdGhlICYjeDYwO3B1cnBvc2UmI3g2MDsgaXMgc2V0IHRvIFxcXFxcXCZxdW90O2ZpbmUtdHVuZVxcXFxcXCZxdW90OywgZWFjaCBsaW5lIGlzIGEgSlNPTiByZWNvcmQgd2l0aCBcXFxcXFwmcXVvdDtwcm9tcHRcXFxcXFwmcXVvdDsgYW5kIFxcXFxcXCZxdW90O2NvbXBsZXRpb25cXFxcXFwmcXVvdDsgZmllbGRzIHJlcHJlc2VudGluZyB5b3VyIFt0cmFpbmluZyBleGFtcGxlc10oL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nL3ByZXBhcmUtdHJhaW5pbmctZGF0YSkuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdXJwb3NlIFRoZSBpbnRlbmRlZCBwdXJwb3NlIG9mIHRoZSB1cGxvYWRlZCBkb2N1bWVudHMuICBVc2UgXFxcXFxcJnF1b3Q7ZmluZS10dW5lXFxcXFxcJnF1b3Q7IGZvciBbRmluZS10dW5pbmddKC9kb2NzL2FwaS1yZWZlcmVuY2UvZmluZS10dW5lcykuIFRoaXMgYWxsb3dzIHVzIHRvIHZhbGlkYXRlIHRoZSBmb3JtYXQgb2YgdGhlIHVwbG9hZGVkIGZpbGUuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVGaWxlOiAoZmlsZSwgcHVycG9zZSwgb3B0aW9ucyA9IHt9KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWxlJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKCdjcmVhdGVGaWxlJywgJ2ZpbGUnLCBmaWxlKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3B1cnBvc2UnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMoJ2NyZWF0ZUZpbGUnLCAncHVycG9zZScsIHB1cnBvc2UpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9maWxlc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJGb3JtUGFyYW1zID0gbmV3ICgoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmZvcm1EYXRhQ3RvcikgfHwgRm9ybURhdGEpKCk7XG4gICAgICAgICAgICBpZiAoZmlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJGb3JtUGFyYW1zLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHB1cnBvc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyRm9ybVBhcmFtcy5hcHBlbmQoJ3B1cnBvc2UnLCBwdXJwb3NlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdtdWx0aXBhcnQvZm9ybS1kYXRhJztcbiAgICAgICAgICAgIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGxvY2FsVmFyRm9ybVBhcmFtcy5nZXRIZWFkZXJzKCkpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9IGxvY2FsVmFyRm9ybVBhcmFtcztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiBjb21tb25fMS50b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZXMgYSBqb2IgdGhhdCBmaW5lLXR1bmVzIGEgc3BlY2lmaWVkIG1vZGVsIGZyb20gYSBnaXZlbiBkYXRhc2V0LiAgUmVzcG9uc2UgaW5jbHVkZXMgZGV0YWlscyBvZiB0aGUgZW5xdWV1ZWQgam9iIGluY2x1ZGluZyBqb2Igc3RhdHVzIGFuZCB0aGUgbmFtZSBvZiB0aGUgZmluZS10dW5lZCBtb2RlbHMgb25jZSBjb21wbGV0ZS4gIFtMZWFybiBtb3JlIGFib3V0IEZpbmUtdHVuaW5nXSgvZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRmluZVR1bmVSZXF1ZXN0fSBjcmVhdGVGaW5lVHVuZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZpbmVUdW5lOiAoY3JlYXRlRmluZVR1bmVSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZUZpbmVUdW5lUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cygnY3JlYXRlRmluZVR1bmUnLCAnY3JlYXRlRmluZVR1bmVSZXF1ZXN0JywgY3JlYXRlRmluZVR1bmVSZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmluZS10dW5lc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKGNyZWF0ZUZpbmVUdW5lUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogY29tbW9uXzEudG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGVzIGFuIGltYWdlIGdpdmVuIGEgcHJvbXB0LlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUltYWdlUmVxdWVzdH0gY3JlYXRlSW1hZ2VSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVJbWFnZTogKGNyZWF0ZUltYWdlUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjcmVhdGVJbWFnZVJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMoJ2NyZWF0ZUltYWdlJywgJ2NyZWF0ZUltYWdlUmVxdWVzdCcsIGNyZWF0ZUltYWdlUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ltYWdlcy9nZW5lcmF0aW9uc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKGNyZWF0ZUltYWdlUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogY29tbW9uXzEudG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGVzIGFuIGVkaXRlZCBvciBleHRlbmRlZCBpbWFnZSBnaXZlbiBhbiBvcmlnaW5hbCBpbWFnZSBhbmQgYSBwcm9tcHQuXG4gICAgICAgICAqIEBwYXJhbSB7RmlsZX0gaW1hZ2UgVGhlIGltYWdlIHRvIGVkaXQuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuIDRNQiwgYW5kIHNxdWFyZS5cbiAgICAgICAgICogQHBhcmFtIHtGaWxlfSBtYXNrIEFuIGFkZGl0aW9uYWwgaW1hZ2Ugd2hvc2UgZnVsbHkgdHJhbnNwYXJlbnQgYXJlYXMgKGUuZy4gd2hlcmUgYWxwaGEgaXMgemVybykgaW5kaWNhdGUgd2hlcmUgJiN4NjA7aW1hZ2UmI3g2MDsgc2hvdWxkIGJlIGVkaXRlZC4gTXVzdCBiZSBhIHZhbGlkIFBORyBmaWxlLCBsZXNzIHRoYW4gNE1CLCBhbmQgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGFzICYjeDYwO2ltYWdlJiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvbXB0IEEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgZGVzaXJlZCBpbWFnZShzKS4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDEwMDAgY2hhcmFjdGVycy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGltYWdlcyB0byBnZW5lcmF0ZS4gTXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NpemVdIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiAmI3g2MDsyNTZ4MjU2JiN4NjA7LCAmI3g2MDs1MTJ4NTEyJiN4NjA7LCBvciAmI3g2MDsxMDI0eDEwMjQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzcG9uc2VGb3JtYXRdIFRoZSBmb3JtYXQgaW4gd2hpY2ggdGhlIGdlbmVyYXRlZCBpbWFnZXMgYXJlIHJldHVybmVkLiBNdXN0IGJlIG9uZSBvZiAmI3g2MDt1cmwmI3g2MDsgb3IgJiN4NjA7YjY0X2pzb24mI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlcl0gQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggd2lsbCBoZWxwIE9wZW5BSSB0byBtb25pdG9yIGFuZCBkZXRlY3QgYWJ1c2UuIFtMZWFybiBtb3JlXSgvZG9jcy91c2FnZS1wb2xpY2llcy9lbmQtdXNlci1pZHMpLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlSW1hZ2VFZGl0OiAoaW1hZ2UsIG1hc2ssIHByb21wdCwgbiwgc2l6ZSwgcmVzcG9uc2VGb3JtYXQsIHVzZXIsIG9wdGlvbnMgPSB7fSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnaW1hZ2UnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMoJ2NyZWF0ZUltYWdlRWRpdCcsICdpbWFnZScsIGltYWdlKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ21hc2snIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMoJ2NyZWF0ZUltYWdlRWRpdCcsICdtYXNrJywgbWFzayk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdwcm9tcHQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMoJ2NyZWF0ZUltYWdlRWRpdCcsICdwcm9tcHQnLCBwcm9tcHQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9pbWFnZXMvZWRpdHNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQT1NUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyRm9ybVBhcmFtcyA9IG5ldyAoKGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5mb3JtRGF0YUN0b3IpIHx8IEZvcm1EYXRhKSgpO1xuICAgICAgICAgICAgaWYgKGltYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckZvcm1QYXJhbXMuYXBwZW5kKCdpbWFnZScsIGltYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckZvcm1QYXJhbXMuYXBwZW5kKCdtYXNrJywgbWFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvbXB0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckZvcm1QYXJhbXMuYXBwZW5kKCdwcm9tcHQnLCBwcm9tcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyRm9ybVBhcmFtcy5hcHBlbmQoJ24nLCBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckZvcm1QYXJhbXMuYXBwZW5kKCdzaXplJywgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyRm9ybVBhcmFtcy5hcHBlbmQoJ3Jlc3BvbnNlX2Zvcm1hdCcsIHJlc3BvbnNlRm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckZvcm1QYXJhbXMuYXBwZW5kKCd1c2VyJywgdXNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc7XG4gICAgICAgICAgICBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBsb2NhbFZhckZvcm1QYXJhbXMuZ2V0SGVhZGVycygpKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBsb2NhbFZhckZvcm1QYXJhbXM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogY29tbW9uXzEudG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGVzIGEgdmFyaWF0aW9uIG9mIGEgZ2l2ZW4gaW1hZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7RmlsZX0gaW1hZ2UgVGhlIGltYWdlIHRvIHVzZSBhcyB0aGUgYmFzaXMgZm9yIHRoZSB2YXJpYXRpb24ocykuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuIDRNQiwgYW5kIHNxdWFyZS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGltYWdlcyB0byBnZW5lcmF0ZS4gTXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NpemVdIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiAmI3g2MDsyNTZ4MjU2JiN4NjA7LCAmI3g2MDs1MTJ4NTEyJiN4NjA7LCBvciAmI3g2MDsxMDI0eDEwMjQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzcG9uc2VGb3JtYXRdIFRoZSBmb3JtYXQgaW4gd2hpY2ggdGhlIGdlbmVyYXRlZCBpbWFnZXMgYXJlIHJldHVybmVkLiBNdXN0IGJlIG9uZSBvZiAmI3g2MDt1cmwmI3g2MDsgb3IgJiN4NjA7YjY0X2pzb24mI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlcl0gQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggd2lsbCBoZWxwIE9wZW5BSSB0byBtb25pdG9yIGFuZCBkZXRlY3QgYWJ1c2UuIFtMZWFybiBtb3JlXSgvZG9jcy91c2FnZS1wb2xpY2llcy9lbmQtdXNlci1pZHMpLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlSW1hZ2VWYXJpYXRpb246IChpbWFnZSwgbiwgc2l6ZSwgcmVzcG9uc2VGb3JtYXQsIHVzZXIsIG9wdGlvbnMgPSB7fSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnaW1hZ2UnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMoJ2NyZWF0ZUltYWdlVmFyaWF0aW9uJywgJ2ltYWdlJywgaW1hZ2UpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9pbWFnZXMvdmFyaWF0aW9uc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJGb3JtUGFyYW1zID0gbmV3ICgoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmZvcm1EYXRhQ3RvcikgfHwgRm9ybURhdGEpKCk7XG4gICAgICAgICAgICBpZiAoaW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyRm9ybVBhcmFtcy5hcHBlbmQoJ2ltYWdlJywgaW1hZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyRm9ybVBhcmFtcy5hcHBlbmQoJ24nLCBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckZvcm1QYXJhbXMuYXBwZW5kKCdzaXplJywgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyRm9ybVBhcmFtcy5hcHBlbmQoJ3Jlc3BvbnNlX2Zvcm1hdCcsIHJlc3BvbnNlRm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckZvcm1QYXJhbXMuYXBwZW5kKCd1c2VyJywgdXNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc7XG4gICAgICAgICAgICBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBsb2NhbFZhckZvcm1QYXJhbXMuZ2V0SGVhZGVycygpKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBsb2NhbFZhckZvcm1QYXJhbXM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogY29tbW9uXzEudG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDbGFzc2lmaWVzIGlmIHRleHQgdmlvbGF0ZXMgT3BlbkFJXFwncyBDb250ZW50IFBvbGljeVxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZU1vZGVyYXRpb25SZXF1ZXN0fSBjcmVhdGVNb2RlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlTW9kZXJhdGlvbjogKGNyZWF0ZU1vZGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZU1vZGVyYXRpb25SZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKCdjcmVhdGVNb2RlcmF0aW9uJywgJ2NyZWF0ZU1vZGVyYXRpb25SZXF1ZXN0JywgY3JlYXRlTW9kZXJhdGlvblJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9tb2RlcmF0aW9uc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKGNyZWF0ZU1vZGVyYXRpb25SZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiBjb21tb25fMS50b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IFRoZSBzZWFyY2ggZW5kcG9pbnQgY29tcHV0ZXMgc2ltaWxhcml0eSBzY29yZXMgYmV0d2VlbiBwcm92aWRlZCBxdWVyeSBhbmQgZG9jdW1lbnRzLiBEb2N1bWVudHMgY2FuIGJlIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgQVBJIGlmIHRoZXJlIGFyZSBubyBtb3JlIHRoYW4gMjAwIG9mIHRoZW0uICBUbyBnbyBiZXlvbmQgdGhlIDIwMCBkb2N1bWVudCBsaW1pdCwgZG9jdW1lbnRzIGNhbiBiZSBwcm9jZXNzZWQgb2ZmbGluZSBhbmQgdGhlbiB1c2VkIGZvciBlZmZpY2llbnQgcmV0cmlldmFsIGF0IHF1ZXJ5IHRpbWUuIFdoZW4gYGZpbGVgIGlzIHNldCwgdGhlIHNlYXJjaCBlbmRwb2ludCBzZWFyY2hlcyBvdmVyIGFsbCB0aGUgZG9jdW1lbnRzIGluIHRoZSBnaXZlbiBmaWxlIGFuZCByZXR1cm5zIHVwIHRvIHRoZSBgbWF4X3JlcmFua2AgbnVtYmVyIG9mIGRvY3VtZW50cy4gVGhlc2UgZG9jdW1lbnRzIHdpbGwgYmUgcmV0dXJuZWQgYWxvbmcgd2l0aCB0aGVpciBzZWFyY2ggc2NvcmVzLiAgVGhlIHNpbWlsYXJpdHkgc2NvcmUgaXMgYSBwb3NpdGl2ZSBzY29yZSB0aGF0IHVzdWFsbHkgcmFuZ2VzIGZyb20gMCB0byAzMDAgKGJ1dCBjYW4gc29tZXRpbWVzIGdvIGhpZ2hlciksIHdoZXJlIGEgc2NvcmUgYWJvdmUgMjAwIHVzdWFsbHkgbWVhbnMgdGhlIGRvY3VtZW50IGlzIHNlbWFudGljYWxseSBzaW1pbGFyIHRvIHRoZSBxdWVyeS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZ2luZUlkIFRoZSBJRCBvZiB0aGUgZW5naW5lIHRvIHVzZSBmb3IgdGhpcyByZXF1ZXN0LiAgWW91IGNhbiBzZWxlY3Qgb25lIG9mICYjeDYwO2FkYSYjeDYwOywgJiN4NjA7YmFiYmFnZSYjeDYwOywgJiN4NjA7Y3VyaWUmI3g2MDssIG9yICYjeDYwO2RhdmluY2kmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlU2VhcmNoUmVxdWVzdH0gY3JlYXRlU2VhcmNoUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU2VhcmNoOiAoZW5naW5lSWQsIGNyZWF0ZVNlYXJjaFJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZW5naW5lSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMoJ2NyZWF0ZVNlYXJjaCcsICdlbmdpbmVJZCcsIGVuZ2luZUlkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZVNlYXJjaFJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMoJ2NyZWF0ZVNlYXJjaCcsICdjcmVhdGVTZWFyY2hSZXF1ZXN0JywgY3JlYXRlU2VhcmNoUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2VuZ2luZXMve2VuZ2luZV9pZH0vc2VhcmNoYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImVuZ2luZV9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGVuZ2luZUlkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQT1NUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9IGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZChjcmVhdGVTZWFyY2hSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiBjb21tb25fMS50b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IERlbGV0ZSBhIGZpbGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWQgVGhlIElEIG9mIHRoZSBmaWxlIHRvIHVzZSBmb3IgdGhpcyByZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVGaWxlOiAoZmlsZUlkLCBvcHRpb25zID0ge30pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpbGVJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cygnZGVsZXRlRmlsZScsICdmaWxlSWQnLCBmaWxlSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9maWxlcy97ZmlsZV9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiZmlsZV9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGZpbGVJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnREVMRVRFJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiBjb21tb25fMS50b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IERlbGV0ZSBhIGZpbmUtdHVuZWQgbW9kZWwuIFlvdSBtdXN0IGhhdmUgdGhlIE93bmVyIHJvbGUgaW4geW91ciBvcmdhbml6YXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbCBUaGUgbW9kZWwgdG8gZGVsZXRlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVNb2RlbDogKG1vZGVsLCBvcHRpb25zID0ge30pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ21vZGVsJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKCdkZWxldGVNb2RlbCcsICdtb2RlbCcsIG1vZGVsKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvbW9kZWxzL3ttb2RlbH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibW9kZWxcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhtb2RlbCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnREVMRVRFJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiBjb21tb25fMS50b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IFJldHVybnMgdGhlIGNvbnRlbnRzIG9mIHRoZSBzcGVjaWZpZWQgZmlsZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZSB0byB1c2UgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZG93bmxvYWRGaWxlOiAoZmlsZUlkLCBvcHRpb25zID0ge30pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpbGVJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cygnZG93bmxvYWRGaWxlJywgJ2ZpbGVJZCcsIGZpbGVJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZpbGVzL3tmaWxlX2lkfS9jb250ZW50YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImZpbGVfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhmaWxlSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogY29tbW9uXzEudG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0cyB0aGUgY3VycmVudGx5IGF2YWlsYWJsZSAobm9uLWZpbmV0dW5lZCkgbW9kZWxzLCBhbmQgcHJvdmlkZXMgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBvbmUgc3VjaCBhcyB0aGUgb3duZXIgYW5kIGF2YWlsYWJpbGl0eS5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RFbmdpbmVzOiAob3B0aW9ucyA9IHt9KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2VuZ2luZXNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6IGNvbW1vbl8xLnRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgUmV0dXJucyBhIGxpc3Qgb2YgZmlsZXMgdGhhdCBiZWxvbmcgdG8gdGhlIHVzZXJcXCdzIG9yZ2FuaXphdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RGaWxlczogKG9wdGlvbnMgPSB7fSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9maWxlc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogY29tbW9uXzEudG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgZmluZS1ncmFpbmVkIHN0YXR1cyB1cGRhdGVzIGZvciBhIGZpbmUtdHVuZSBqb2IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaW5lVHVuZUlkIFRoZSBJRCBvZiB0aGUgZmluZS10dW5lIGpvYiB0byBnZXQgZXZlbnRzIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbc3RyZWFtXSBXaGV0aGVyIHRvIHN0cmVhbSBldmVudHMgZm9yIHRoZSBmaW5lLXR1bmUgam9iLiBJZiBzZXQgdG8gdHJ1ZSwgZXZlbnRzIHdpbGwgYmUgc2VudCBhcyBkYXRhLW9ubHkgW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdCkgYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLiBUaGUgc3RyZWFtIHdpbGwgdGVybWluYXRlIHdpdGggYSAmI3g2MDtkYXRhOiBbRE9ORV0mI3g2MDsgbWVzc2FnZSB3aGVuIHRoZSBqb2IgaXMgZmluaXNoZWQgKHN1Y2NlZWRlZCwgY2FuY2VsbGVkLCBvciBmYWlsZWQpLiAgSWYgc2V0IHRvIGZhbHNlLCBvbmx5IGV2ZW50cyBnZW5lcmF0ZWQgc28gZmFyIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0RmluZVR1bmVFdmVudHM6IChmaW5lVHVuZUlkLCBzdHJlYW0sIG9wdGlvbnMgPSB7fSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZmluZVR1bmVJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cygnbGlzdEZpbmVUdW5lRXZlbnRzJywgJ2ZpbmVUdW5lSWQnLCBmaW5lVHVuZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmluZS10dW5lcy97ZmluZV90dW5lX2lkfS9ldmVudHNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiZmluZV90dW5lX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZmluZVR1bmVJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3N0cmVhbSddID0gc3RyZWFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6IGNvbW1vbl8xLnRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB5b3VyIG9yZ2FuaXphdGlvblxcJ3MgZmluZS10dW5pbmcgam9ic1xuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEZpbmVUdW5lczogKG9wdGlvbnMgPSB7fSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9maW5lLXR1bmVzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiBjb21tb25fMS50b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3RzIHRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIG1vZGVscywgYW5kIHByb3ZpZGVzIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggb25lIHN1Y2ggYXMgdGhlIG93bmVyIGFuZCBhdmFpbGFiaWxpdHkuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0TW9kZWxzOiAob3B0aW9ucyA9IHt9KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL21vZGVsc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogY29tbW9uXzEudG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXRyaWV2ZXMgYSBtb2RlbCBpbnN0YW5jZSwgcHJvdmlkaW5nIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGl0IHN1Y2ggYXMgdGhlIG93bmVyIGFuZCBhdmFpbGFiaWxpdHkuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmVJZCBUaGUgSUQgb2YgdGhlIGVuZ2luZSB0byB1c2UgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmV0cmlldmVFbmdpbmU6IChlbmdpbmVJZCwgb3B0aW9ucyA9IHt9KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdlbmdpbmVJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cygncmV0cmlldmVFbmdpbmUnLCAnZW5naW5lSWQnLCBlbmdpbmVJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2VuZ2luZXMve2VuZ2luZV9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiZW5naW5lX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZW5naW5lSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogY29tbW9uXzEudG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgZmlsZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZCBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gdXNlIGZvciB0aGlzIHJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHJldHJpZXZlRmlsZTogKGZpbGVJZCwgb3B0aW9ucyA9IHt9KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWxlSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMoJ3JldHJpZXZlRmlsZScsICdmaWxlSWQnLCBmaWxlSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9maWxlcy97ZmlsZV9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiZmlsZV9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGZpbGVJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiBjb21tb25fMS50b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldHMgaW5mbyBhYm91dCB0aGUgZmluZS10dW5lIGpvYi4gIFtMZWFybiBtb3JlIGFib3V0IEZpbmUtdHVuaW5nXSgvZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaW5lVHVuZUlkIFRoZSBJRCBvZiB0aGUgZmluZS10dW5lIGpvYlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmV0cmlldmVGaW5lVHVuZTogKGZpbmVUdW5lSWQsIG9wdGlvbnMgPSB7fSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZmluZVR1bmVJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cygncmV0cmlldmVGaW5lVHVuZScsICdmaW5lVHVuZUlkJywgZmluZVR1bmVJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZpbmUtdHVuZXMve2ZpbmVfdHVuZV9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiZmluZV90dW5lX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZmluZVR1bmVJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiBjb21tb25fMS50b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IFJldHJpZXZlcyBhIG1vZGVsIGluc3RhbmNlLCBwcm92aWRpbmcgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1vZGVsIHN1Y2ggYXMgdGhlIG93bmVyIGFuZCBwZXJtaXNzaW9uaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZWwgVGhlIElEIG9mIHRoZSBtb2RlbCB0byB1c2UgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmV0cmlldmVNb2RlbDogKG1vZGVsLCBvcHRpb25zID0ge30pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ21vZGVsJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKCdyZXRyaWV2ZU1vZGVsJywgJ21vZGVsJywgbW9kZWwpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9tb2RlbHMve21vZGVsfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJtb2RlbFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG1vZGVsKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6IGNvbW1vbl8xLnRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgIH07XG59O1xuLyoqXG4gKiBPcGVuQUlBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLk9wZW5BSUFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5PcGVuQUlBcGlBeGlvc1BhcmFtQ3JlYXRvcihjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgSW1tZWRpYXRlbHkgY2FuY2VsIGEgZmluZS10dW5lIGpvYi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbmVUdW5lSWQgVGhlIElEIG9mIHRoZSBmaW5lLXR1bmUgam9iIHRvIGNhbmNlbFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY2FuY2VsRmluZVR1bmUoZmluZVR1bmVJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IHlpZWxkIGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY2FuY2VsRmluZVR1bmUoZmluZVR1bmVJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbihsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgQW5zd2VycyB0aGUgc3BlY2lmaWVkIHF1ZXN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBkb2N1bWVudHMgYW5kIGV4YW1wbGVzLiAgVGhlIGVuZHBvaW50IGZpcnN0IFtzZWFyY2hlc10oL2RvY3MvYXBpLXJlZmVyZW5jZS9zZWFyY2hlcykgb3ZlciBwcm92aWRlZCBkb2N1bWVudHMgb3IgZmlsZXMgdG8gZmluZCByZWxldmFudCBjb250ZXh0LiBUaGUgcmVsZXZhbnQgY29udGV4dCBpcyBjb21iaW5lZCB3aXRoIHRoZSBwcm92aWRlZCBleGFtcGxlcyBhbmQgcXVlc3Rpb24gdG8gY3JlYXRlIHRoZSBwcm9tcHQgZm9yIFtjb21wbGV0aW9uXSgvZG9jcy9hcGktcmVmZXJlbmNlL2NvbXBsZXRpb25zKS5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVBbnN3ZXJSZXF1ZXN0fSBjcmVhdGVBbnN3ZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVBbnN3ZXIoY3JlYXRlQW5zd2VyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IHlpZWxkIGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlQW5zd2VyKGNyZWF0ZUFuc3dlclJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24obG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IENsYXNzaWZpZXMgdGhlIHNwZWNpZmllZCBgcXVlcnlgIHVzaW5nIHByb3ZpZGVkIGV4YW1wbGVzLiAgVGhlIGVuZHBvaW50IGZpcnN0IFtzZWFyY2hlc10oL2RvY3MvYXBpLXJlZmVyZW5jZS9zZWFyY2hlcykgb3ZlciB0aGUgbGFiZWxlZCBleGFtcGxlcyB0byBzZWxlY3QgdGhlIG9uZXMgbW9zdCByZWxldmFudCBmb3IgdGhlIHBhcnRpY3VsYXIgcXVlcnkuIFRoZW4sIHRoZSByZWxldmFudCBleGFtcGxlcyBhcmUgY29tYmluZWQgd2l0aCB0aGUgcXVlcnkgdG8gY29uc3RydWN0IGEgcHJvbXB0IHRvIHByb2R1Y2UgdGhlIGZpbmFsIGxhYmVsIHZpYSB0aGUgW2NvbXBsZXRpb25zXSgvZG9jcy9hcGktcmVmZXJlbmNlL2NvbXBsZXRpb25zKSBlbmRwb2ludC4gIExhYmVsZWQgZXhhbXBsZXMgY2FuIGJlIHByb3ZpZGVkIHZpYSBhbiB1cGxvYWRlZCBgZmlsZWAsIG9yIGV4cGxpY2l0bHkgbGlzdGVkIGluIHRoZSByZXF1ZXN0IHVzaW5nIHRoZSBgZXhhbXBsZXNgIHBhcmFtZXRlciBmb3IgcXVpY2sgdGVzdHMgYW5kIHNtYWxsIHNjYWxlIHVzZSBjYXNlcy5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVDbGFzc2lmaWNhdGlvblJlcXVlc3R9IGNyZWF0ZUNsYXNzaWZpY2F0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQ2xhc3NpZmljYXRpb24oY3JlYXRlQ2xhc3NpZmljYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0geWllbGQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVDbGFzc2lmaWNhdGlvbihjcmVhdGVDbGFzc2lmaWNhdGlvblJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24obG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZXMgYSBjb21wbGV0aW9uIGZvciB0aGUgcHJvdmlkZWQgcHJvbXB0IGFuZCBwYXJhbWV0ZXJzXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlQ29tcGxldGlvblJlcXVlc3R9IGNyZWF0ZUNvbXBsZXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVDb21wbGV0aW9uKGNyZWF0ZUNvbXBsZXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0geWllbGQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVDb21wbGV0aW9uKGNyZWF0ZUNvbXBsZXRpb25SZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGVzIGEgbmV3IGVkaXQgZm9yIHRoZSBwcm92aWRlZCBpbnB1dCwgaW5zdHJ1Y3Rpb24sIGFuZCBwYXJhbWV0ZXJzXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRWRpdFJlcXVlc3R9IGNyZWF0ZUVkaXRSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVFZGl0KGNyZWF0ZUVkaXRSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0geWllbGQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVFZGl0KGNyZWF0ZUVkaXRSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGVzIGFuIGVtYmVkZGluZyB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUVtYmVkZGluZ1JlcXVlc3R9IGNyZWF0ZUVtYmVkZGluZ1JlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUVtYmVkZGluZyhjcmVhdGVFbWJlZGRpbmdSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0geWllbGQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVFbWJlZGRpbmcoY3JlYXRlRW1iZWRkaW5nUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbihsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgVXBsb2FkIGEgZmlsZSB0aGF0IGNvbnRhaW5zIGRvY3VtZW50KHMpIHRvIGJlIHVzZWQgYWNyb3NzIHZhcmlvdXMgZW5kcG9pbnRzL2ZlYXR1cmVzLiBDdXJyZW50bHksIHRoZSBzaXplIG9mIGFsbCB0aGUgZmlsZXMgdXBsb2FkZWQgYnkgb25lIG9yZ2FuaXphdGlvbiBjYW4gYmUgdXAgdG8gMSBHQi4gUGxlYXNlIGNvbnRhY3QgdXMgaWYgeW91IG5lZWQgdG8gaW5jcmVhc2UgdGhlIHN0b3JhZ2UgbGltaXQuXG4gICAgICAgICAqIEBwYXJhbSB7RmlsZX0gZmlsZSBOYW1lIG9mIHRoZSBbSlNPTiBMaW5lc10oaHR0cHM6Ly9qc29ubGluZXMucmVhZHRoZWRvY3MuaW8vZW4vbGF0ZXN0LykgZmlsZSB0byBiZSB1cGxvYWRlZC4gIElmIHRoZSAmI3g2MDtwdXJwb3NlJiN4NjA7IGlzIHNldCB0byBcXFxcXFwmcXVvdDtmaW5lLXR1bmVcXFxcXFwmcXVvdDssIGVhY2ggbGluZSBpcyBhIEpTT04gcmVjb3JkIHdpdGggXFxcXFxcJnF1b3Q7cHJvbXB0XFxcXFxcJnF1b3Q7IGFuZCBcXFxcXFwmcXVvdDtjb21wbGV0aW9uXFxcXFxcJnF1b3Q7IGZpZWxkcyByZXByZXNlbnRpbmcgeW91ciBbdHJhaW5pbmcgZXhhbXBsZXNdKC9kb2NzL2d1aWRlcy9maW5lLXR1bmluZy9wcmVwYXJlLXRyYWluaW5nLWRhdGEpLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVycG9zZSBUaGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGUgdXBsb2FkZWQgZG9jdW1lbnRzLiAgVXNlIFxcXFxcXCZxdW90O2ZpbmUtdHVuZVxcXFxcXCZxdW90OyBmb3IgW0ZpbmUtdHVuaW5nXSgvZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuZXMpLiBUaGlzIGFsbG93cyB1cyB0byB2YWxpZGF0ZSB0aGUgZm9ybWF0IG9mIHRoZSB1cGxvYWRlZCBmaWxlLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRmlsZShmaWxlLCBwdXJwb3NlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0geWllbGQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVGaWxlKGZpbGUsIHB1cnBvc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24obG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZXMgYSBqb2IgdGhhdCBmaW5lLXR1bmVzIGEgc3BlY2lmaWVkIG1vZGVsIGZyb20gYSBnaXZlbiBkYXRhc2V0LiAgUmVzcG9uc2UgaW5jbHVkZXMgZGV0YWlscyBvZiB0aGUgZW5xdWV1ZWQgam9iIGluY2x1ZGluZyBqb2Igc3RhdHVzIGFuZCB0aGUgbmFtZSBvZiB0aGUgZmluZS10dW5lZCBtb2RlbHMgb25jZSBjb21wbGV0ZS4gIFtMZWFybiBtb3JlIGFib3V0IEZpbmUtdHVuaW5nXSgvZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRmluZVR1bmVSZXF1ZXN0fSBjcmVhdGVGaW5lVHVuZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZpbmVUdW5lKGNyZWF0ZUZpbmVUdW5lUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IHlpZWxkIGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlRmluZVR1bmUoY3JlYXRlRmluZVR1bmVSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGVzIGFuIGltYWdlIGdpdmVuIGEgcHJvbXB0LlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUltYWdlUmVxdWVzdH0gY3JlYXRlSW1hZ2VSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVJbWFnZShjcmVhdGVJbWFnZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSB5aWVsZCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZUltYWdlKGNyZWF0ZUltYWdlUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbihsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlcyBhbiBlZGl0ZWQgb3IgZXh0ZW5kZWQgaW1hZ2UgZ2l2ZW4gYW4gb3JpZ2luYWwgaW1hZ2UgYW5kIGEgcHJvbXB0LlxuICAgICAgICAgKiBAcGFyYW0ge0ZpbGV9IGltYWdlIFRoZSBpbWFnZSB0byBlZGl0LiBNdXN0IGJlIGEgdmFsaWQgUE5HIGZpbGUsIGxlc3MgdGhhbiA0TUIsIGFuZCBzcXVhcmUuXG4gICAgICAgICAqIEBwYXJhbSB7RmlsZX0gbWFzayBBbiBhZGRpdGlvbmFsIGltYWdlIHdob3NlIGZ1bGx5IHRyYW5zcGFyZW50IGFyZWFzIChlLmcuIHdoZXJlIGFscGhhIGlzIHplcm8pIGluZGljYXRlIHdoZXJlICYjeDYwO2ltYWdlJiN4NjA7IHNob3VsZCBiZSBlZGl0ZWQuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuIDRNQiwgYW5kIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBhcyAmI3g2MDtpbWFnZSYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb21wdCBBIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGRlc2lyZWQgaW1hZ2UocykuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAxMDAwIGNoYXJhY3RlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBpbWFnZXMgdG8gZ2VuZXJhdGUuIE11c3QgYmUgYmV0d2VlbiAxIGFuZCAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzaXplXSBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlcy4gTXVzdCBiZSBvbmUgb2YgJiN4NjA7MjU2eDI1NiYjeDYwOywgJiN4NjA7NTEyeDUxMiYjeDYwOywgb3IgJiN4NjA7MTAyNHgxMDI0JiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Jlc3BvbnNlRm9ybWF0XSBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzIGFyZSByZXR1cm5lZC4gTXVzdCBiZSBvbmUgb2YgJiN4NjA7dXJsJiN4NjA7IG9yICYjeDYwO2I2NF9qc29uJiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJdIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIHdpbGwgaGVscCBPcGVuQUkgdG8gbW9uaXRvciBhbmQgZGV0ZWN0IGFidXNlLiBbTGVhcm4gbW9yZV0oL2RvY3MvdXNhZ2UtcG9saWNpZXMvZW5kLXVzZXItaWRzKS5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUltYWdlRWRpdChpbWFnZSwgbWFzaywgcHJvbXB0LCBuLCBzaXplLCByZXNwb25zZUZvcm1hdCwgdXNlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IHlpZWxkIGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlSW1hZ2VFZGl0KGltYWdlLCBtYXNrLCBwcm9tcHQsIG4sIHNpemUsIHJlc3BvbnNlRm9ybWF0LCB1c2VyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGVzIGEgdmFyaWF0aW9uIG9mIGEgZ2l2ZW4gaW1hZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7RmlsZX0gaW1hZ2UgVGhlIGltYWdlIHRvIHVzZSBhcyB0aGUgYmFzaXMgZm9yIHRoZSB2YXJpYXRpb24ocykuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuIDRNQiwgYW5kIHNxdWFyZS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGltYWdlcyB0byBnZW5lcmF0ZS4gTXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NpemVdIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiAmI3g2MDsyNTZ4MjU2JiN4NjA7LCAmI3g2MDs1MTJ4NTEyJiN4NjA7LCBvciAmI3g2MDsxMDI0eDEwMjQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzcG9uc2VGb3JtYXRdIFRoZSBmb3JtYXQgaW4gd2hpY2ggdGhlIGdlbmVyYXRlZCBpbWFnZXMgYXJlIHJldHVybmVkLiBNdXN0IGJlIG9uZSBvZiAmI3g2MDt1cmwmI3g2MDsgb3IgJiN4NjA7YjY0X2pzb24mI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlcl0gQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggd2lsbCBoZWxwIE9wZW5BSSB0byBtb25pdG9yIGFuZCBkZXRlY3QgYWJ1c2UuIFtMZWFybiBtb3JlXSgvZG9jcy91c2FnZS1wb2xpY2llcy9lbmQtdXNlci1pZHMpLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlSW1hZ2VWYXJpYXRpb24oaW1hZ2UsIG4sIHNpemUsIHJlc3BvbnNlRm9ybWF0LCB1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0geWllbGQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVJbWFnZVZhcmlhdGlvbihpbWFnZSwgbiwgc2l6ZSwgcmVzcG9uc2VGb3JtYXQsIHVzZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24obG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IENsYXNzaWZpZXMgaWYgdGV4dCB2aW9sYXRlcyBPcGVuQUlcXCdzIENvbnRlbnQgUG9saWN5XG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlTW9kZXJhdGlvblJlcXVlc3R9IGNyZWF0ZU1vZGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVNb2RlcmF0aW9uKGNyZWF0ZU1vZGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0geWllbGQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVNb2RlcmF0aW9uKGNyZWF0ZU1vZGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBUaGUgc2VhcmNoIGVuZHBvaW50IGNvbXB1dGVzIHNpbWlsYXJpdHkgc2NvcmVzIGJldHdlZW4gcHJvdmlkZWQgcXVlcnkgYW5kIGRvY3VtZW50cy4gRG9jdW1lbnRzIGNhbiBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIEFQSSBpZiB0aGVyZSBhcmUgbm8gbW9yZSB0aGFuIDIwMCBvZiB0aGVtLiAgVG8gZ28gYmV5b25kIHRoZSAyMDAgZG9jdW1lbnQgbGltaXQsIGRvY3VtZW50cyBjYW4gYmUgcHJvY2Vzc2VkIG9mZmxpbmUgYW5kIHRoZW4gdXNlZCBmb3IgZWZmaWNpZW50IHJldHJpZXZhbCBhdCBxdWVyeSB0aW1lLiBXaGVuIGBmaWxlYCBpcyBzZXQsIHRoZSBzZWFyY2ggZW5kcG9pbnQgc2VhcmNoZXMgb3ZlciBhbGwgdGhlIGRvY3VtZW50cyBpbiB0aGUgZ2l2ZW4gZmlsZSBhbmQgcmV0dXJucyB1cCB0byB0aGUgYG1heF9yZXJhbmtgIG51bWJlciBvZiBkb2N1bWVudHMuIFRoZXNlIGRvY3VtZW50cyB3aWxsIGJlIHJldHVybmVkIGFsb25nIHdpdGggdGhlaXIgc2VhcmNoIHNjb3Jlcy4gIFRoZSBzaW1pbGFyaXR5IHNjb3JlIGlzIGEgcG9zaXRpdmUgc2NvcmUgdGhhdCB1c3VhbGx5IHJhbmdlcyBmcm9tIDAgdG8gMzAwIChidXQgY2FuIHNvbWV0aW1lcyBnbyBoaWdoZXIpLCB3aGVyZSBhIHNjb3JlIGFib3ZlIDIwMCB1c3VhbGx5IG1lYW5zIHRoZSBkb2N1bWVudCBpcyBzZW1hbnRpY2FsbHkgc2ltaWxhciB0byB0aGUgcXVlcnkuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmVJZCBUaGUgSUQgb2YgdGhlIGVuZ2luZSB0byB1c2UgZm9yIHRoaXMgcmVxdWVzdC4gIFlvdSBjYW4gc2VsZWN0IG9uZSBvZiAmI3g2MDthZGEmI3g2MDssICYjeDYwO2JhYmJhZ2UmI3g2MDssICYjeDYwO2N1cmllJiN4NjA7LCBvciAmI3g2MDtkYXZpbmNpJiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVNlYXJjaFJlcXVlc3R9IGNyZWF0ZVNlYXJjaFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNlYXJjaChlbmdpbmVJZCwgY3JlYXRlU2VhcmNoUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IHlpZWxkIGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlU2VhcmNoKGVuZ2luZUlkLCBjcmVhdGVTZWFyY2hSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBEZWxldGUgYSBmaWxlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZSB0byB1c2UgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlRmlsZShmaWxlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSB5aWVsZCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmRlbGV0ZUZpbGUoZmlsZUlkLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBEZWxldGUgYSBmaW5lLXR1bmVkIG1vZGVsLiBZb3UgbXVzdCBoYXZlIHRoZSBPd25lciByb2xlIGluIHlvdXIgb3JnYW5pemF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZWwgVGhlIG1vZGVsIHRvIGRlbGV0ZVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlTW9kZWwobW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSB5aWVsZCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmRlbGV0ZU1vZGVsKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgc3BlY2lmaWVkIGZpbGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZCBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gdXNlIGZvciB0aGlzIHJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGRvd25sb2FkRmlsZShmaWxlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSB5aWVsZCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmRvd25sb2FkRmlsZShmaWxlSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24obG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3RzIHRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIChub24tZmluZXR1bmVkKSBtb2RlbHMsIGFuZCBwcm92aWRlcyBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIG9uZSBzdWNoIGFzIHRoZSBvd25lciBhbmQgYXZhaWxhYmlsaXR5LlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEVuZ2luZXMob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IHlpZWxkIGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdEVuZ2luZXMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbihsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgUmV0dXJucyBhIGxpc3Qgb2YgZmlsZXMgdGhhdCBiZWxvbmcgdG8gdGhlIHVzZXJcXCdzIG9yZ2FuaXphdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RGaWxlcyhvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0geWllbGQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0RmlsZXMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbihsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGZpbmUtZ3JhaW5lZCBzdGF0dXMgdXBkYXRlcyBmb3IgYSBmaW5lLXR1bmUgam9iLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmluZVR1bmVJZCBUaGUgSUQgb2YgdGhlIGZpbmUtdHVuZSBqb2IgdG8gZ2V0IGV2ZW50cyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0cmVhbV0gV2hldGhlciB0byBzdHJlYW0gZXZlbnRzIGZvciB0aGUgZmluZS10dW5lIGpvYi4gSWYgc2V0IHRvIHRydWUsIGV2ZW50cyB3aWxsIGJlIHNlbnQgYXMgZGF0YS1vbmx5IFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZS4gVGhlIHN0cmVhbSB3aWxsIHRlcm1pbmF0ZSB3aXRoIGEgJiN4NjA7ZGF0YTogW0RPTkVdJiN4NjA7IG1lc3NhZ2Ugd2hlbiB0aGUgam9iIGlzIGZpbmlzaGVkIChzdWNjZWVkZWQsIGNhbmNlbGxlZCwgb3IgZmFpbGVkKS4gIElmIHNldCB0byBmYWxzZSwgb25seSBldmVudHMgZ2VuZXJhdGVkIHNvIGZhciB3aWxsIGJlIHJldHVybmVkLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEZpbmVUdW5lRXZlbnRzKGZpbmVUdW5lSWQsIHN0cmVhbSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IHlpZWxkIGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdEZpbmVUdW5lRXZlbnRzKGZpbmVUdW5lSWQsIHN0cmVhbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbihsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB5b3VyIG9yZ2FuaXphdGlvblxcJ3MgZmluZS10dW5pbmcgam9ic1xuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEZpbmVUdW5lcyhvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0geWllbGQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0RmluZVR1bmVzKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24obG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3RzIHRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIG1vZGVscywgYW5kIHByb3ZpZGVzIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggb25lIHN1Y2ggYXMgdGhlIG93bmVyIGFuZCBhdmFpbGFiaWxpdHkuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0TW9kZWxzKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSB5aWVsZCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RNb2RlbHMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbihsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgUmV0cmlldmVzIGEgbW9kZWwgaW5zdGFuY2UsIHByb3ZpZGluZyBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCBpdCBzdWNoIGFzIHRoZSBvd25lciBhbmQgYXZhaWxhYmlsaXR5LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5naW5lSWQgVGhlIElEIG9mIHRoZSBlbmdpbmUgdG8gdXNlIGZvciB0aGlzIHJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHJldHJpZXZlRW5naW5lKGVuZ2luZUlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0geWllbGQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5yZXRyaWV2ZUVuZ2luZShlbmdpbmVJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbihsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIGZpbGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWQgVGhlIElEIG9mIHRoZSBmaWxlIHRvIHVzZSBmb3IgdGhpcyByZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXRyaWV2ZUZpbGUoZmlsZUlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0geWllbGQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5yZXRyaWV2ZUZpbGUoZmlsZUlkLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXRzIGluZm8gYWJvdXQgdGhlIGZpbmUtdHVuZSBqb2IuICBbTGVhcm4gbW9yZSBhYm91dCBGaW5lLXR1bmluZ10oL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmluZVR1bmVJZCBUaGUgSUQgb2YgdGhlIGZpbmUtdHVuZSBqb2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHJldHJpZXZlRmluZVR1bmUoZmluZVR1bmVJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IHlpZWxkIGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucmV0cmlldmVGaW5lVHVuZShmaW5lVHVuZUlkLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXRyaWV2ZXMgYSBtb2RlbCBpbnN0YW5jZSwgcHJvdmlkaW5nIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtb2RlbCBzdWNoIGFzIHRoZSBvd25lciBhbmQgcGVybWlzc2lvbmluZy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsIFRoZSBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlIGZvciB0aGlzIHJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHJldHJpZXZlTW9kZWwobW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSB5aWVsZCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnJldHJpZXZlTW9kZWwobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24obG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbi8qKlxuICogT3BlbkFJQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0cy5PcGVuQUlBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSBleHBvcnRzLk9wZW5BSUFwaUZwKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBJbW1lZGlhdGVseSBjYW5jZWwgYSBmaW5lLXR1bmUgam9iLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmluZVR1bmVJZCBUaGUgSUQgb2YgdGhlIGZpbmUtdHVuZSBqb2IgdG8gY2FuY2VsXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWxGaW5lVHVuZShmaW5lVHVuZUlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jYW5jZWxGaW5lVHVuZShmaW5lVHVuZUlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgQW5zd2VycyB0aGUgc3BlY2lmaWVkIHF1ZXN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBkb2N1bWVudHMgYW5kIGV4YW1wbGVzLiAgVGhlIGVuZHBvaW50IGZpcnN0IFtzZWFyY2hlc10oL2RvY3MvYXBpLXJlZmVyZW5jZS9zZWFyY2hlcykgb3ZlciBwcm92aWRlZCBkb2N1bWVudHMgb3IgZmlsZXMgdG8gZmluZCByZWxldmFudCBjb250ZXh0LiBUaGUgcmVsZXZhbnQgY29udGV4dCBpcyBjb21iaW5lZCB3aXRoIHRoZSBwcm92aWRlZCBleGFtcGxlcyBhbmQgcXVlc3Rpb24gdG8gY3JlYXRlIHRoZSBwcm9tcHQgZm9yIFtjb21wbGV0aW9uXSgvZG9jcy9hcGktcmVmZXJlbmNlL2NvbXBsZXRpb25zKS5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVBbnN3ZXJSZXF1ZXN0fSBjcmVhdGVBbnN3ZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVBbnN3ZXIoY3JlYXRlQW5zd2VyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlQW5zd2VyKGNyZWF0ZUFuc3dlclJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDbGFzc2lmaWVzIHRoZSBzcGVjaWZpZWQgYHF1ZXJ5YCB1c2luZyBwcm92aWRlZCBleGFtcGxlcy4gIFRoZSBlbmRwb2ludCBmaXJzdCBbc2VhcmNoZXNdKC9kb2NzL2FwaS1yZWZlcmVuY2Uvc2VhcmNoZXMpIG92ZXIgdGhlIGxhYmVsZWQgZXhhbXBsZXMgdG8gc2VsZWN0IHRoZSBvbmVzIG1vc3QgcmVsZXZhbnQgZm9yIHRoZSBwYXJ0aWN1bGFyIHF1ZXJ5LiBUaGVuLCB0aGUgcmVsZXZhbnQgZXhhbXBsZXMgYXJlIGNvbWJpbmVkIHdpdGggdGhlIHF1ZXJ5IHRvIGNvbnN0cnVjdCBhIHByb21wdCB0byBwcm9kdWNlIHRoZSBmaW5hbCBsYWJlbCB2aWEgdGhlIFtjb21wbGV0aW9uc10oL2RvY3MvYXBpLXJlZmVyZW5jZS9jb21wbGV0aW9ucykgZW5kcG9pbnQuICBMYWJlbGVkIGV4YW1wbGVzIGNhbiBiZSBwcm92aWRlZCB2aWEgYW4gdXBsb2FkZWQgYGZpbGVgLCBvciBleHBsaWNpdGx5IGxpc3RlZCBpbiB0aGUgcmVxdWVzdCB1c2luZyB0aGUgYGV4YW1wbGVzYCBwYXJhbWV0ZXIgZm9yIHF1aWNrIHRlc3RzIGFuZCBzbWFsbCBzY2FsZSB1c2UgY2FzZXMuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlQ2xhc3NpZmljYXRpb25SZXF1ZXN0fSBjcmVhdGVDbGFzc2lmaWNhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUNsYXNzaWZpY2F0aW9uKGNyZWF0ZUNsYXNzaWZpY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlQ2xhc3NpZmljYXRpb24oY3JlYXRlQ2xhc3NpZmljYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlcyBhIGNvbXBsZXRpb24gZm9yIHRoZSBwcm92aWRlZCBwcm9tcHQgYW5kIHBhcmFtZXRlcnNcbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVDb21wbGV0aW9uUmVxdWVzdH0gY3JlYXRlQ29tcGxldGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUNvbXBsZXRpb24oY3JlYXRlQ29tcGxldGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZUNvbXBsZXRpb24oY3JlYXRlQ29tcGxldGlvblJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGVzIGEgbmV3IGVkaXQgZm9yIHRoZSBwcm92aWRlZCBpbnB1dCwgaW5zdHJ1Y3Rpb24sIGFuZCBwYXJhbWV0ZXJzXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRWRpdFJlcXVlc3R9IGNyZWF0ZUVkaXRSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVFZGl0KGNyZWF0ZUVkaXRSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVFZGl0KGNyZWF0ZUVkaXRSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlcyBhbiBlbWJlZGRpbmcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVFbWJlZGRpbmdSZXF1ZXN0fSBjcmVhdGVFbWJlZGRpbmdSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVFbWJlZGRpbmcoY3JlYXRlRW1iZWRkaW5nUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlRW1iZWRkaW5nKGNyZWF0ZUVtYmVkZGluZ1JlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBVcGxvYWQgYSBmaWxlIHRoYXQgY29udGFpbnMgZG9jdW1lbnQocykgdG8gYmUgdXNlZCBhY3Jvc3MgdmFyaW91cyBlbmRwb2ludHMvZmVhdHVyZXMuIEN1cnJlbnRseSwgdGhlIHNpemUgb2YgYWxsIHRoZSBmaWxlcyB1cGxvYWRlZCBieSBvbmUgb3JnYW5pemF0aW9uIGNhbiBiZSB1cCB0byAxIEdCLiBQbGVhc2UgY29udGFjdCB1cyBpZiB5b3UgbmVlZCB0byBpbmNyZWFzZSB0aGUgc3RvcmFnZSBsaW1pdC5cbiAgICAgICAgICogQHBhcmFtIHtGaWxlfSBmaWxlIE5hbWUgb2YgdGhlIFtKU09OIExpbmVzXShodHRwczovL2pzb25saW5lcy5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvKSBmaWxlIHRvIGJlIHVwbG9hZGVkLiAgSWYgdGhlICYjeDYwO3B1cnBvc2UmI3g2MDsgaXMgc2V0IHRvIFxcXFxcXCZxdW90O2ZpbmUtdHVuZVxcXFxcXCZxdW90OywgZWFjaCBsaW5lIGlzIGEgSlNPTiByZWNvcmQgd2l0aCBcXFxcXFwmcXVvdDtwcm9tcHRcXFxcXFwmcXVvdDsgYW5kIFxcXFxcXCZxdW90O2NvbXBsZXRpb25cXFxcXFwmcXVvdDsgZmllbGRzIHJlcHJlc2VudGluZyB5b3VyIFt0cmFpbmluZyBleGFtcGxlc10oL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nL3ByZXBhcmUtdHJhaW5pbmctZGF0YSkuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdXJwb3NlIFRoZSBpbnRlbmRlZCBwdXJwb3NlIG9mIHRoZSB1cGxvYWRlZCBkb2N1bWVudHMuICBVc2UgXFxcXFxcJnF1b3Q7ZmluZS10dW5lXFxcXFxcJnF1b3Q7IGZvciBbRmluZS10dW5pbmddKC9kb2NzL2FwaS1yZWZlcmVuY2UvZmluZS10dW5lcykuIFRoaXMgYWxsb3dzIHVzIHRvIHZhbGlkYXRlIHRoZSBmb3JtYXQgb2YgdGhlIHVwbG9hZGVkIGZpbGUuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVGaWxlKGZpbGUsIHB1cnBvc2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZUZpbGUoZmlsZSwgcHVycG9zZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZXMgYSBqb2IgdGhhdCBmaW5lLXR1bmVzIGEgc3BlY2lmaWVkIG1vZGVsIGZyb20gYSBnaXZlbiBkYXRhc2V0LiAgUmVzcG9uc2UgaW5jbHVkZXMgZGV0YWlscyBvZiB0aGUgZW5xdWV1ZWQgam9iIGluY2x1ZGluZyBqb2Igc3RhdHVzIGFuZCB0aGUgbmFtZSBvZiB0aGUgZmluZS10dW5lZCBtb2RlbHMgb25jZSBjb21wbGV0ZS4gIFtMZWFybiBtb3JlIGFib3V0IEZpbmUtdHVuaW5nXSgvZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRmluZVR1bmVSZXF1ZXN0fSBjcmVhdGVGaW5lVHVuZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZpbmVUdW5lKGNyZWF0ZUZpbmVUdW5lUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlRmluZVR1bmUoY3JlYXRlRmluZVR1bmVSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlcyBhbiBpbWFnZSBnaXZlbiBhIHByb21wdC5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVJbWFnZVJlcXVlc3R9IGNyZWF0ZUltYWdlUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlSW1hZ2UoY3JlYXRlSW1hZ2VSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVJbWFnZShjcmVhdGVJbWFnZVJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGVzIGFuIGVkaXRlZCBvciBleHRlbmRlZCBpbWFnZSBnaXZlbiBhbiBvcmlnaW5hbCBpbWFnZSBhbmQgYSBwcm9tcHQuXG4gICAgICAgICAqIEBwYXJhbSB7RmlsZX0gaW1hZ2UgVGhlIGltYWdlIHRvIGVkaXQuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuIDRNQiwgYW5kIHNxdWFyZS5cbiAgICAgICAgICogQHBhcmFtIHtGaWxlfSBtYXNrIEFuIGFkZGl0aW9uYWwgaW1hZ2Ugd2hvc2UgZnVsbHkgdHJhbnNwYXJlbnQgYXJlYXMgKGUuZy4gd2hlcmUgYWxwaGEgaXMgemVybykgaW5kaWNhdGUgd2hlcmUgJiN4NjA7aW1hZ2UmI3g2MDsgc2hvdWxkIGJlIGVkaXRlZC4gTXVzdCBiZSBhIHZhbGlkIFBORyBmaWxlLCBsZXNzIHRoYW4gNE1CLCBhbmQgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGFzICYjeDYwO2ltYWdlJiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvbXB0IEEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgZGVzaXJlZCBpbWFnZShzKS4gVGhlIG1heGltdW0gbGVuZ3RoIGlzIDEwMDAgY2hhcmFjdGVycy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGltYWdlcyB0byBnZW5lcmF0ZS4gTXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NpemVdIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiAmI3g2MDsyNTZ4MjU2JiN4NjA7LCAmI3g2MDs1MTJ4NTEyJiN4NjA7LCBvciAmI3g2MDsxMDI0eDEwMjQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzcG9uc2VGb3JtYXRdIFRoZSBmb3JtYXQgaW4gd2hpY2ggdGhlIGdlbmVyYXRlZCBpbWFnZXMgYXJlIHJldHVybmVkLiBNdXN0IGJlIG9uZSBvZiAmI3g2MDt1cmwmI3g2MDsgb3IgJiN4NjA7YjY0X2pzb24mI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlcl0gQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggd2lsbCBoZWxwIE9wZW5BSSB0byBtb25pdG9yIGFuZCBkZXRlY3QgYWJ1c2UuIFtMZWFybiBtb3JlXSgvZG9jcy91c2FnZS1wb2xpY2llcy9lbmQtdXNlci1pZHMpLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlSW1hZ2VFZGl0KGltYWdlLCBtYXNrLCBwcm9tcHQsIG4sIHNpemUsIHJlc3BvbnNlRm9ybWF0LCB1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVJbWFnZUVkaXQoaW1hZ2UsIG1hc2ssIHByb21wdCwgbiwgc2l6ZSwgcmVzcG9uc2VGb3JtYXQsIHVzZXIsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGVzIGEgdmFyaWF0aW9uIG9mIGEgZ2l2ZW4gaW1hZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7RmlsZX0gaW1hZ2UgVGhlIGltYWdlIHRvIHVzZSBhcyB0aGUgYmFzaXMgZm9yIHRoZSB2YXJpYXRpb24ocykuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuIDRNQiwgYW5kIHNxdWFyZS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGltYWdlcyB0byBnZW5lcmF0ZS4gTXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NpemVdIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiAmI3g2MDsyNTZ4MjU2JiN4NjA7LCAmI3g2MDs1MTJ4NTEyJiN4NjA7LCBvciAmI3g2MDsxMDI0eDEwMjQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzcG9uc2VGb3JtYXRdIFRoZSBmb3JtYXQgaW4gd2hpY2ggdGhlIGdlbmVyYXRlZCBpbWFnZXMgYXJlIHJldHVybmVkLiBNdXN0IGJlIG9uZSBvZiAmI3g2MDt1cmwmI3g2MDsgb3IgJiN4NjA7YjY0X2pzb24mI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlcl0gQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggd2lsbCBoZWxwIE9wZW5BSSB0byBtb25pdG9yIGFuZCBkZXRlY3QgYWJ1c2UuIFtMZWFybiBtb3JlXSgvZG9jcy91c2FnZS1wb2xpY2llcy9lbmQtdXNlci1pZHMpLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlSW1hZ2VWYXJpYXRpb24oaW1hZ2UsIG4sIHNpemUsIHJlc3BvbnNlRm9ybWF0LCB1c2VyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVJbWFnZVZhcmlhdGlvbihpbWFnZSwgbiwgc2l6ZSwgcmVzcG9uc2VGb3JtYXQsIHVzZXIsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBDbGFzc2lmaWVzIGlmIHRleHQgdmlvbGF0ZXMgT3BlbkFJXFwncyBDb250ZW50IFBvbGljeVxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZU1vZGVyYXRpb25SZXF1ZXN0fSBjcmVhdGVNb2RlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlTW9kZXJhdGlvbihjcmVhdGVNb2RlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlTW9kZXJhdGlvbihjcmVhdGVNb2RlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IFRoZSBzZWFyY2ggZW5kcG9pbnQgY29tcHV0ZXMgc2ltaWxhcml0eSBzY29yZXMgYmV0d2VlbiBwcm92aWRlZCBxdWVyeSBhbmQgZG9jdW1lbnRzLiBEb2N1bWVudHMgY2FuIGJlIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgQVBJIGlmIHRoZXJlIGFyZSBubyBtb3JlIHRoYW4gMjAwIG9mIHRoZW0uICBUbyBnbyBiZXlvbmQgdGhlIDIwMCBkb2N1bWVudCBsaW1pdCwgZG9jdW1lbnRzIGNhbiBiZSBwcm9jZXNzZWQgb2ZmbGluZSBhbmQgdGhlbiB1c2VkIGZvciBlZmZpY2llbnQgcmV0cmlldmFsIGF0IHF1ZXJ5IHRpbWUuIFdoZW4gYGZpbGVgIGlzIHNldCwgdGhlIHNlYXJjaCBlbmRwb2ludCBzZWFyY2hlcyBvdmVyIGFsbCB0aGUgZG9jdW1lbnRzIGluIHRoZSBnaXZlbiBmaWxlIGFuZCByZXR1cm5zIHVwIHRvIHRoZSBgbWF4X3JlcmFua2AgbnVtYmVyIG9mIGRvY3VtZW50cy4gVGhlc2UgZG9jdW1lbnRzIHdpbGwgYmUgcmV0dXJuZWQgYWxvbmcgd2l0aCB0aGVpciBzZWFyY2ggc2NvcmVzLiAgVGhlIHNpbWlsYXJpdHkgc2NvcmUgaXMgYSBwb3NpdGl2ZSBzY29yZSB0aGF0IHVzdWFsbHkgcmFuZ2VzIGZyb20gMCB0byAzMDAgKGJ1dCBjYW4gc29tZXRpbWVzIGdvIGhpZ2hlciksIHdoZXJlIGEgc2NvcmUgYWJvdmUgMjAwIHVzdWFsbHkgbWVhbnMgdGhlIGRvY3VtZW50IGlzIHNlbWFudGljYWxseSBzaW1pbGFyIHRvIHRoZSBxdWVyeS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZ2luZUlkIFRoZSBJRCBvZiB0aGUgZW5naW5lIHRvIHVzZSBmb3IgdGhpcyByZXF1ZXN0LiAgWW91IGNhbiBzZWxlY3Qgb25lIG9mICYjeDYwO2FkYSYjeDYwOywgJiN4NjA7YmFiYmFnZSYjeDYwOywgJiN4NjA7Y3VyaWUmI3g2MDssIG9yICYjeDYwO2RhdmluY2kmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlU2VhcmNoUmVxdWVzdH0gY3JlYXRlU2VhcmNoUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU2VhcmNoKGVuZ2luZUlkLCBjcmVhdGVTZWFyY2hSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVTZWFyY2goZW5naW5lSWQsIGNyZWF0ZVNlYXJjaFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBEZWxldGUgYSBmaWxlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZSB0byB1c2UgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlRmlsZShmaWxlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmRlbGV0ZUZpbGUoZmlsZUlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgRGVsZXRlIGEgZmluZS10dW5lZCBtb2RlbC4gWW91IG11c3QgaGF2ZSB0aGUgT3duZXIgcm9sZSBpbiB5b3VyIG9yZ2FuaXphdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsIFRoZSBtb2RlbCB0byBkZWxldGVcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZU1vZGVsKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5kZWxldGVNb2RlbChtb2RlbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IFJldHVybnMgdGhlIGNvbnRlbnRzIG9mIHRoZSBzcGVjaWZpZWQgZmlsZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZSB0byB1c2UgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZG93bmxvYWRGaWxlKGZpbGVJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZG93bmxvYWRGaWxlKGZpbGVJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3RzIHRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIChub24tZmluZXR1bmVkKSBtb2RlbHMsIGFuZCBwcm92aWRlcyBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIG9uZSBzdWNoIGFzIHRoZSBvd25lciBhbmQgYXZhaWxhYmlsaXR5LlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEVuZ2luZXMob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdEVuZ2luZXMob3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IFJldHVybnMgYSBsaXN0IG9mIGZpbGVzIHRoYXQgYmVsb25nIHRvIHRoZSB1c2VyXFwncyBvcmdhbml6YXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0RmlsZXMob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdEZpbGVzKG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgZmluZS1ncmFpbmVkIHN0YXR1cyB1cGRhdGVzIGZvciBhIGZpbmUtdHVuZSBqb2IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaW5lVHVuZUlkIFRoZSBJRCBvZiB0aGUgZmluZS10dW5lIGpvYiB0byBnZXQgZXZlbnRzIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbc3RyZWFtXSBXaGV0aGVyIHRvIHN0cmVhbSBldmVudHMgZm9yIHRoZSBmaW5lLXR1bmUgam9iLiBJZiBzZXQgdG8gdHJ1ZSwgZXZlbnRzIHdpbGwgYmUgc2VudCBhcyBkYXRhLW9ubHkgW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdCkgYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLiBUaGUgc3RyZWFtIHdpbGwgdGVybWluYXRlIHdpdGggYSAmI3g2MDtkYXRhOiBbRE9ORV0mI3g2MDsgbWVzc2FnZSB3aGVuIHRoZSBqb2IgaXMgZmluaXNoZWQgKHN1Y2NlZWRlZCwgY2FuY2VsbGVkLCBvciBmYWlsZWQpLiAgSWYgc2V0IHRvIGZhbHNlLCBvbmx5IGV2ZW50cyBnZW5lcmF0ZWQgc28gZmFyIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0RmluZVR1bmVFdmVudHMoZmluZVR1bmVJZCwgc3RyZWFtLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0RmluZVR1bmVFdmVudHMoZmluZVR1bmVJZCwgc3RyZWFtLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB5b3VyIG9yZ2FuaXphdGlvblxcJ3MgZmluZS10dW5pbmcgam9ic1xuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEZpbmVUdW5lcyhvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0RmluZVR1bmVzKG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0cyB0aGUgY3VycmVudGx5IGF2YWlsYWJsZSBtb2RlbHMsIGFuZCBwcm92aWRlcyBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIG9uZSBzdWNoIGFzIHRoZSBvd25lciBhbmQgYXZhaWxhYmlsaXR5LlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdE1vZGVscyhvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0TW9kZWxzKG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXRyaWV2ZXMgYSBtb2RlbCBpbnN0YW5jZSwgcHJvdmlkaW5nIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGl0IHN1Y2ggYXMgdGhlIG93bmVyIGFuZCBhdmFpbGFiaWxpdHkuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmVJZCBUaGUgSUQgb2YgdGhlIGVuZ2luZSB0byB1c2UgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmV0cmlldmVFbmdpbmUoZW5naW5lSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnJldHJpZXZlRW5naW5lKGVuZ2luZUlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIGZpbGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWQgVGhlIElEIG9mIHRoZSBmaWxlIHRvIHVzZSBmb3IgdGhpcyByZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXRyaWV2ZUZpbGUoZmlsZUlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5yZXRyaWV2ZUZpbGUoZmlsZUlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHN1bW1hcnkgR2V0cyBpbmZvIGFib3V0IHRoZSBmaW5lLXR1bmUgam9iLiAgW0xlYXJuIG1vcmUgYWJvdXQgRmluZS10dW5pbmddKC9kb2NzL2d1aWRlcy9maW5lLXR1bmluZylcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbmVUdW5lSWQgVGhlIElEIG9mIHRoZSBmaW5lLXR1bmUgam9iXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXRyaWV2ZUZpbmVUdW5lKGZpbmVUdW5lSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnJldHJpZXZlRmluZVR1bmUoZmluZVR1bmVJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdW1tYXJ5IFJldHJpZXZlcyBhIG1vZGVsIGluc3RhbmNlLCBwcm92aWRpbmcgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1vZGVsIHN1Y2ggYXMgdGhlIG93bmVyIGFuZCBwZXJtaXNzaW9uaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZWwgVGhlIElEIG9mIHRoZSBtb2RlbCB0byB1c2UgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmV0cmlldmVNb2RlbChtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAucmV0cmlldmVNb2RlbChtb2RlbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbi8qKlxuICogT3BlbkFJQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIE9wZW5BSUFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIE9wZW5BSUFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEltbWVkaWF0ZWx5IGNhbmNlbCBhIGZpbmUtdHVuZSBqb2IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbmVUdW5lSWQgVGhlIElEIG9mIHRoZSBmaW5lLXR1bmUgam9iIHRvIGNhbmNlbFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT3BlbkFJQXBpXG4gICAgICovXG4gICAgY2FuY2VsRmluZVR1bmUoZmluZVR1bmVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmNhbmNlbEZpbmVUdW5lKGZpbmVUdW5lSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEFuc3dlcnMgdGhlIHNwZWNpZmllZCBxdWVzdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgZG9jdW1lbnRzIGFuZCBleGFtcGxlcy4gIFRoZSBlbmRwb2ludCBmaXJzdCBbc2VhcmNoZXNdKC9kb2NzL2FwaS1yZWZlcmVuY2Uvc2VhcmNoZXMpIG92ZXIgcHJvdmlkZWQgZG9jdW1lbnRzIG9yIGZpbGVzIHRvIGZpbmQgcmVsZXZhbnQgY29udGV4dC4gVGhlIHJlbGV2YW50IGNvbnRleHQgaXMgY29tYmluZWQgd2l0aCB0aGUgcHJvdmlkZWQgZXhhbXBsZXMgYW5kIHF1ZXN0aW9uIHRvIGNyZWF0ZSB0aGUgcHJvbXB0IGZvciBbY29tcGxldGlvbl0oL2RvY3MvYXBpLXJlZmVyZW5jZS9jb21wbGV0aW9ucykuXG4gICAgICogQHBhcmFtIHtDcmVhdGVBbnN3ZXJSZXF1ZXN0fSBjcmVhdGVBbnN3ZXJSZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE9wZW5BSUFwaVxuICAgICAqL1xuICAgIGNyZWF0ZUFuc3dlcihjcmVhdGVBbnN3ZXJSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk9wZW5BSUFwaUZwKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlQW5zd2VyKGNyZWF0ZUFuc3dlclJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IENsYXNzaWZpZXMgdGhlIHNwZWNpZmllZCBgcXVlcnlgIHVzaW5nIHByb3ZpZGVkIGV4YW1wbGVzLiAgVGhlIGVuZHBvaW50IGZpcnN0IFtzZWFyY2hlc10oL2RvY3MvYXBpLXJlZmVyZW5jZS9zZWFyY2hlcykgb3ZlciB0aGUgbGFiZWxlZCBleGFtcGxlcyB0byBzZWxlY3QgdGhlIG9uZXMgbW9zdCByZWxldmFudCBmb3IgdGhlIHBhcnRpY3VsYXIgcXVlcnkuIFRoZW4sIHRoZSByZWxldmFudCBleGFtcGxlcyBhcmUgY29tYmluZWQgd2l0aCB0aGUgcXVlcnkgdG8gY29uc3RydWN0IGEgcHJvbXB0IHRvIHByb2R1Y2UgdGhlIGZpbmFsIGxhYmVsIHZpYSB0aGUgW2NvbXBsZXRpb25zXSgvZG9jcy9hcGktcmVmZXJlbmNlL2NvbXBsZXRpb25zKSBlbmRwb2ludC4gIExhYmVsZWQgZXhhbXBsZXMgY2FuIGJlIHByb3ZpZGVkIHZpYSBhbiB1cGxvYWRlZCBgZmlsZWAsIG9yIGV4cGxpY2l0bHkgbGlzdGVkIGluIHRoZSByZXF1ZXN0IHVzaW5nIHRoZSBgZXhhbXBsZXNgIHBhcmFtZXRlciBmb3IgcXVpY2sgdGVzdHMgYW5kIHNtYWxsIHNjYWxlIHVzZSBjYXNlcy5cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUNsYXNzaWZpY2F0aW9uUmVxdWVzdH0gY3JlYXRlQ2xhc3NpZmljYXRpb25SZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE9wZW5BSUFwaVxuICAgICAqL1xuICAgIGNyZWF0ZUNsYXNzaWZpY2F0aW9uKGNyZWF0ZUNsYXNzaWZpY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZUNsYXNzaWZpY2F0aW9uKGNyZWF0ZUNsYXNzaWZpY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlcyBhIGNvbXBsZXRpb24gZm9yIHRoZSBwcm92aWRlZCBwcm9tcHQgYW5kIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUNvbXBsZXRpb25SZXF1ZXN0fSBjcmVhdGVDb21wbGV0aW9uUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT3BlbkFJQXBpXG4gICAgICovXG4gICAgY3JlYXRlQ29tcGxldGlvbihjcmVhdGVDb21wbGV0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZUNvbXBsZXRpb24oY3JlYXRlQ29tcGxldGlvblJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZXMgYSBuZXcgZWRpdCBmb3IgdGhlIHByb3ZpZGVkIGlucHV0LCBpbnN0cnVjdGlvbiwgYW5kIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUVkaXRSZXF1ZXN0fSBjcmVhdGVFZGl0UmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT3BlbkFJQXBpXG4gICAgICovXG4gICAgY3JlYXRlRWRpdChjcmVhdGVFZGl0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZUVkaXQoY3JlYXRlRWRpdFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZXMgYW4gZW1iZWRkaW5nIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGlucHV0IHRleHQuXG4gICAgICogQHBhcmFtIHtDcmVhdGVFbWJlZGRpbmdSZXF1ZXN0fSBjcmVhdGVFbWJlZGRpbmdSZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBPcGVuQUlBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVFbWJlZGRpbmcoY3JlYXRlRW1iZWRkaW5nUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZUVtYmVkZGluZyhjcmVhdGVFbWJlZGRpbmdSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBVcGxvYWQgYSBmaWxlIHRoYXQgY29udGFpbnMgZG9jdW1lbnQocykgdG8gYmUgdXNlZCBhY3Jvc3MgdmFyaW91cyBlbmRwb2ludHMvZmVhdHVyZXMuIEN1cnJlbnRseSwgdGhlIHNpemUgb2YgYWxsIHRoZSBmaWxlcyB1cGxvYWRlZCBieSBvbmUgb3JnYW5pemF0aW9uIGNhbiBiZSB1cCB0byAxIEdCLiBQbGVhc2UgY29udGFjdCB1cyBpZiB5b3UgbmVlZCB0byBpbmNyZWFzZSB0aGUgc3RvcmFnZSBsaW1pdC5cbiAgICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGUgTmFtZSBvZiB0aGUgW0pTT04gTGluZXNdKGh0dHBzOi8vanNvbmxpbmVzLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC8pIGZpbGUgdG8gYmUgdXBsb2FkZWQuICBJZiB0aGUgJiN4NjA7cHVycG9zZSYjeDYwOyBpcyBzZXQgdG8gXFxcXFxcJnF1b3Q7ZmluZS10dW5lXFxcXFxcJnF1b3Q7LCBlYWNoIGxpbmUgaXMgYSBKU09OIHJlY29yZCB3aXRoIFxcXFxcXCZxdW90O3Byb21wdFxcXFxcXCZxdW90OyBhbmQgXFxcXFxcJnF1b3Q7Y29tcGxldGlvblxcXFxcXCZxdW90OyBmaWVsZHMgcmVwcmVzZW50aW5nIHlvdXIgW3RyYWluaW5nIGV4YW1wbGVzXSgvZG9jcy9ndWlkZXMvZmluZS10dW5pbmcvcHJlcGFyZS10cmFpbmluZy1kYXRhKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVycG9zZSBUaGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGUgdXBsb2FkZWQgZG9jdW1lbnRzLiAgVXNlIFxcXFxcXCZxdW90O2ZpbmUtdHVuZVxcXFxcXCZxdW90OyBmb3IgW0ZpbmUtdHVuaW5nXSgvZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuZXMpLiBUaGlzIGFsbG93cyB1cyB0byB2YWxpZGF0ZSB0aGUgZm9ybWF0IG9mIHRoZSB1cGxvYWRlZCBmaWxlLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT3BlbkFJQXBpXG4gICAgICovXG4gICAgY3JlYXRlRmlsZShmaWxlLCBwdXJwb3NlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk9wZW5BSUFwaUZwKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlRmlsZShmaWxlLCBwdXJwb3NlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGVzIGEgam9iIHRoYXQgZmluZS10dW5lcyBhIHNwZWNpZmllZCBtb2RlbCBmcm9tIGEgZ2l2ZW4gZGF0YXNldC4gIFJlc3BvbnNlIGluY2x1ZGVzIGRldGFpbHMgb2YgdGhlIGVucXVldWVkIGpvYiBpbmNsdWRpbmcgam9iIHN0YXR1cyBhbmQgdGhlIG5hbWUgb2YgdGhlIGZpbmUtdHVuZWQgbW9kZWxzIG9uY2UgY29tcGxldGUuICBbTGVhcm4gbW9yZSBhYm91dCBGaW5lLXR1bmluZ10oL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nKVxuICAgICAqIEBwYXJhbSB7Q3JlYXRlRmluZVR1bmVSZXF1ZXN0fSBjcmVhdGVGaW5lVHVuZVJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE9wZW5BSUFwaVxuICAgICAqL1xuICAgIGNyZWF0ZUZpbmVUdW5lKGNyZWF0ZUZpbmVUdW5lUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZUZpbmVUdW5lKGNyZWF0ZUZpbmVUdW5lUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlcyBhbiBpbWFnZSBnaXZlbiBhIHByb21wdC5cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUltYWdlUmVxdWVzdH0gY3JlYXRlSW1hZ2VSZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBPcGVuQUlBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVJbWFnZShjcmVhdGVJbWFnZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuT3BlbkFJQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVJbWFnZShjcmVhdGVJbWFnZVJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZXMgYW4gZWRpdGVkIG9yIGV4dGVuZGVkIGltYWdlIGdpdmVuIGFuIG9yaWdpbmFsIGltYWdlIGFuZCBhIHByb21wdC5cbiAgICAgKiBAcGFyYW0ge0ZpbGV9IGltYWdlIFRoZSBpbWFnZSB0byBlZGl0LiBNdXN0IGJlIGEgdmFsaWQgUE5HIGZpbGUsIGxlc3MgdGhhbiA0TUIsIGFuZCBzcXVhcmUuXG4gICAgICogQHBhcmFtIHtGaWxlfSBtYXNrIEFuIGFkZGl0aW9uYWwgaW1hZ2Ugd2hvc2UgZnVsbHkgdHJhbnNwYXJlbnQgYXJlYXMgKGUuZy4gd2hlcmUgYWxwaGEgaXMgemVybykgaW5kaWNhdGUgd2hlcmUgJiN4NjA7aW1hZ2UmI3g2MDsgc2hvdWxkIGJlIGVkaXRlZC4gTXVzdCBiZSBhIHZhbGlkIFBORyBmaWxlLCBsZXNzIHRoYW4gNE1CLCBhbmQgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGFzICYjeDYwO2ltYWdlJiN4NjA7LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9tcHQgQSB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBkZXNpcmVkIGltYWdlKHMpLiBUaGUgbWF4aW11bSBsZW5ndGggaXMgMTAwMCBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBpbWFnZXMgdG8gZ2VuZXJhdGUuIE11c3QgYmUgYmV0d2VlbiAxIGFuZCAxMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NpemVdIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiAmI3g2MDsyNTZ4MjU2JiN4NjA7LCAmI3g2MDs1MTJ4NTEyJiN4NjA7LCBvciAmI3g2MDsxMDI0eDEwMjQmI3g2MDsuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtyZXNwb25zZUZvcm1hdF0gVGhlIGZvcm1hdCBpbiB3aGljaCB0aGUgZ2VuZXJhdGVkIGltYWdlcyBhcmUgcmV0dXJuZWQuIE11c3QgYmUgb25lIG9mICYjeDYwO3VybCYjeDYwOyBvciAmI3g2MDtiNjRfanNvbiYjeDYwOy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJdIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIHdpbGwgaGVscCBPcGVuQUkgdG8gbW9uaXRvciBhbmQgZGV0ZWN0IGFidXNlLiBbTGVhcm4gbW9yZV0oL2RvY3MvdXNhZ2UtcG9saWNpZXMvZW5kLXVzZXItaWRzKS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE9wZW5BSUFwaVxuICAgICAqL1xuICAgIGNyZWF0ZUltYWdlRWRpdChpbWFnZSwgbWFzaywgcHJvbXB0LCBuLCBzaXplLCByZXNwb25zZUZvcm1hdCwgdXNlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZUltYWdlRWRpdChpbWFnZSwgbWFzaywgcHJvbXB0LCBuLCBzaXplLCByZXNwb25zZUZvcm1hdCwgdXNlciwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlcyBhIHZhcmlhdGlvbiBvZiBhIGdpdmVuIGltYWdlLlxuICAgICAqIEBwYXJhbSB7RmlsZX0gaW1hZ2UgVGhlIGltYWdlIHRvIHVzZSBhcyB0aGUgYmFzaXMgZm9yIHRoZSB2YXJpYXRpb24ocykuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuIDRNQiwgYW5kIHNxdWFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW25dIFRoZSBudW1iZXIgb2YgaW1hZ2VzIHRvIGdlbmVyYXRlLiBNdXN0IGJlIGJldHdlZW4gMSBhbmQgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzaXplXSBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlcy4gTXVzdCBiZSBvbmUgb2YgJiN4NjA7MjU2eDI1NiYjeDYwOywgJiN4NjA7NTEyeDUxMiYjeDYwOywgb3IgJiN4NjA7MTAyNHgxMDI0JiN4NjA7LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzcG9uc2VGb3JtYXRdIFRoZSBmb3JtYXQgaW4gd2hpY2ggdGhlIGdlbmVyYXRlZCBpbWFnZXMgYXJlIHJldHVybmVkLiBNdXN0IGJlIG9uZSBvZiAmI3g2MDt1cmwmI3g2MDsgb3IgJiN4NjA7YjY0X2pzb24mI3g2MDsuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt1c2VyXSBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCB3aWxsIGhlbHAgT3BlbkFJIHRvIG1vbml0b3IgYW5kIGRldGVjdCBhYnVzZS4gW0xlYXJuIG1vcmVdKC9kb2NzL3VzYWdlLXBvbGljaWVzL2VuZC11c2VyLWlkcykuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBPcGVuQUlBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVJbWFnZVZhcmlhdGlvbihpbWFnZSwgbiwgc2l6ZSwgcmVzcG9uc2VGb3JtYXQsIHVzZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuT3BlbkFJQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVJbWFnZVZhcmlhdGlvbihpbWFnZSwgbiwgc2l6ZSwgcmVzcG9uc2VGb3JtYXQsIHVzZXIsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IENsYXNzaWZpZXMgaWYgdGV4dCB2aW9sYXRlcyBPcGVuQUlcXCdzIENvbnRlbnQgUG9saWN5XG4gICAgICogQHBhcmFtIHtDcmVhdGVNb2RlcmF0aW9uUmVxdWVzdH0gY3JlYXRlTW9kZXJhdGlvblJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE9wZW5BSUFwaVxuICAgICAqL1xuICAgIGNyZWF0ZU1vZGVyYXRpb24oY3JlYXRlTW9kZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuT3BlbkFJQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVNb2RlcmF0aW9uKGNyZWF0ZU1vZGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBUaGUgc2VhcmNoIGVuZHBvaW50IGNvbXB1dGVzIHNpbWlsYXJpdHkgc2NvcmVzIGJldHdlZW4gcHJvdmlkZWQgcXVlcnkgYW5kIGRvY3VtZW50cy4gRG9jdW1lbnRzIGNhbiBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIEFQSSBpZiB0aGVyZSBhcmUgbm8gbW9yZSB0aGFuIDIwMCBvZiB0aGVtLiAgVG8gZ28gYmV5b25kIHRoZSAyMDAgZG9jdW1lbnQgbGltaXQsIGRvY3VtZW50cyBjYW4gYmUgcHJvY2Vzc2VkIG9mZmxpbmUgYW5kIHRoZW4gdXNlZCBmb3IgZWZmaWNpZW50IHJldHJpZXZhbCBhdCBxdWVyeSB0aW1lLiBXaGVuIGBmaWxlYCBpcyBzZXQsIHRoZSBzZWFyY2ggZW5kcG9pbnQgc2VhcmNoZXMgb3ZlciBhbGwgdGhlIGRvY3VtZW50cyBpbiB0aGUgZ2l2ZW4gZmlsZSBhbmQgcmV0dXJucyB1cCB0byB0aGUgYG1heF9yZXJhbmtgIG51bWJlciBvZiBkb2N1bWVudHMuIFRoZXNlIGRvY3VtZW50cyB3aWxsIGJlIHJldHVybmVkIGFsb25nIHdpdGggdGhlaXIgc2VhcmNoIHNjb3Jlcy4gIFRoZSBzaW1pbGFyaXR5IHNjb3JlIGlzIGEgcG9zaXRpdmUgc2NvcmUgdGhhdCB1c3VhbGx5IHJhbmdlcyBmcm9tIDAgdG8gMzAwIChidXQgY2FuIHNvbWV0aW1lcyBnbyBoaWdoZXIpLCB3aGVyZSBhIHNjb3JlIGFib3ZlIDIwMCB1c3VhbGx5IG1lYW5zIHRoZSBkb2N1bWVudCBpcyBzZW1hbnRpY2FsbHkgc2ltaWxhciB0byB0aGUgcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZ2luZUlkIFRoZSBJRCBvZiB0aGUgZW5naW5lIHRvIHVzZSBmb3IgdGhpcyByZXF1ZXN0LiAgWW91IGNhbiBzZWxlY3Qgb25lIG9mICYjeDYwO2FkYSYjeDYwOywgJiN4NjA7YmFiYmFnZSYjeDYwOywgJiN4NjA7Y3VyaWUmI3g2MDssIG9yICYjeDYwO2RhdmluY2kmI3g2MDsuXG4gICAgICogQHBhcmFtIHtDcmVhdGVTZWFyY2hSZXF1ZXN0fSBjcmVhdGVTZWFyY2hSZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE9wZW5BSUFwaVxuICAgICAqL1xuICAgIGNyZWF0ZVNlYXJjaChlbmdpbmVJZCwgY3JlYXRlU2VhcmNoUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZVNlYXJjaChlbmdpbmVJZCwgY3JlYXRlU2VhcmNoUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgRGVsZXRlIGEgZmlsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZSB0byB1c2UgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT3BlbkFJQXBpXG4gICAgICovXG4gICAgZGVsZXRlRmlsZShmaWxlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuT3BlbkFJQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKS5kZWxldGVGaWxlKGZpbGVJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgRGVsZXRlIGEgZmluZS10dW5lZCBtb2RlbC4gWW91IG11c3QgaGF2ZSB0aGUgT3duZXIgcm9sZSBpbiB5b3VyIG9yZ2FuaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZWwgVGhlIG1vZGVsIHRvIGRlbGV0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT3BlbkFJQXBpXG4gICAgICovXG4gICAgZGVsZXRlTW9kZWwobW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuT3BlbkFJQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKS5kZWxldGVNb2RlbChtb2RlbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIHNwZWNpZmllZCBmaWxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZCBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gdXNlIGZvciB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE9wZW5BSUFwaVxuICAgICAqL1xuICAgIGRvd25sb2FkRmlsZShmaWxlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuT3BlbkFJQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKS5kb3dubG9hZEZpbGUoZmlsZUlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBMaXN0cyB0aGUgY3VycmVudGx5IGF2YWlsYWJsZSAobm9uLWZpbmV0dW5lZCkgbW9kZWxzLCBhbmQgcHJvdmlkZXMgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBvbmUgc3VjaCBhcyB0aGUgb3duZXIgYW5kIGF2YWlsYWJpbGl0eS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT3BlbkFJQXBpXG4gICAgICovXG4gICAgbGlzdEVuZ2luZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RFbmdpbmVzKG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFJldHVybnMgYSBsaXN0IG9mIGZpbGVzIHRoYXQgYmVsb25nIHRvIHRoZSB1c2VyXFwncyBvcmdhbml6YXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBPcGVuQUlBcGlcbiAgICAgKi9cbiAgICBsaXN0RmlsZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RGaWxlcyhvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBHZXQgZmluZS1ncmFpbmVkIHN0YXR1cyB1cGRhdGVzIGZvciBhIGZpbmUtdHVuZSBqb2IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbmVUdW5lSWQgVGhlIElEIG9mIHRoZSBmaW5lLXR1bmUgam9iIHRvIGdldCBldmVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0cmVhbV0gV2hldGhlciB0byBzdHJlYW0gZXZlbnRzIGZvciB0aGUgZmluZS10dW5lIGpvYi4gSWYgc2V0IHRvIHRydWUsIGV2ZW50cyB3aWxsIGJlIHNlbnQgYXMgZGF0YS1vbmx5IFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZS4gVGhlIHN0cmVhbSB3aWxsIHRlcm1pbmF0ZSB3aXRoIGEgJiN4NjA7ZGF0YTogW0RPTkVdJiN4NjA7IG1lc3NhZ2Ugd2hlbiB0aGUgam9iIGlzIGZpbmlzaGVkIChzdWNjZWVkZWQsIGNhbmNlbGxlZCwgb3IgZmFpbGVkKS4gIElmIHNldCB0byBmYWxzZSwgb25seSBldmVudHMgZ2VuZXJhdGVkIHNvIGZhciB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT3BlbkFJQXBpXG4gICAgICovXG4gICAgbGlzdEZpbmVUdW5lRXZlbnRzKGZpbmVUdW5lSWQsIHN0cmVhbSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RGaW5lVHVuZUV2ZW50cyhmaW5lVHVuZUlkLCBzdHJlYW0sIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IExpc3QgeW91ciBvcmdhbml6YXRpb25cXCdzIGZpbmUtdHVuaW5nIGpvYnNcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE9wZW5BSUFwaVxuICAgICAqL1xuICAgIGxpc3RGaW5lVHVuZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RGaW5lVHVuZXMob3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgTGlzdHMgdGhlIGN1cnJlbnRseSBhdmFpbGFibGUgbW9kZWxzLCBhbmQgcHJvdmlkZXMgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBvbmUgc3VjaCBhcyB0aGUgb3duZXIgYW5kIGF2YWlsYWJpbGl0eS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE9wZW5BSUFwaVxuICAgICAqL1xuICAgIGxpc3RNb2RlbHMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RNb2RlbHMob3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgUmV0cmlldmVzIGEgbW9kZWwgaW5zdGFuY2UsIHByb3ZpZGluZyBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCBpdCBzdWNoIGFzIHRoZSBvd25lciBhbmQgYXZhaWxhYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmVJZCBUaGUgSUQgb2YgdGhlIGVuZ2luZSB0byB1c2UgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBPcGVuQUlBcGlcbiAgICAgKi9cbiAgICByZXRyaWV2ZUVuZ2luZShlbmdpbmVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLnJldHJpZXZlRW5naW5lKGVuZ2luZUlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgZmlsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZSB0byB1c2UgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT3BlbkFJQXBpXG4gICAgICovXG4gICAgcmV0cmlldmVGaWxlKGZpbGVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5PcGVuQUlBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pLnJldHJpZXZlRmlsZShmaWxlSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEdldHMgaW5mbyBhYm91dCB0aGUgZmluZS10dW5lIGpvYi4gIFtMZWFybiBtb3JlIGFib3V0IEZpbmUtdHVuaW5nXSgvZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbmVUdW5lSWQgVGhlIElEIG9mIHRoZSBmaW5lLXR1bmUgam9iXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBPcGVuQUlBcGlcbiAgICAgKi9cbiAgICByZXRyaWV2ZUZpbmVUdW5lKGZpbmVUdW5lSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuT3BlbkFJQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKS5yZXRyaWV2ZUZpbmVUdW5lKGZpbmVUdW5lSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFJldHJpZXZlcyBhIG1vZGVsIGluc3RhbmNlLCBwcm92aWRpbmcgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1vZGVsIHN1Y2ggYXMgdGhlIG93bmVyIGFuZCBwZXJtaXNzaW9uaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbCBUaGUgSUQgb2YgdGhlIG1vZGVsIHRvIHVzZSBmb3IgdGhpcyByZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBPcGVuQUlBcGlcbiAgICAgKi9cbiAgICByZXRyaWV2ZU1vZGVsKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk9wZW5BSUFwaUZwKHRoaXMuY29uZmlndXJhdGlvbikucmV0cmlldmVNb2RlbChtb2RlbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5PcGVuQUlBcGkgPSBPcGVuQUlBcGk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/openai/dist/api.js\n"));

/***/ }),

/***/ "./node_modules/openai/dist/base.js":
/*!******************************************!*\
  !*** ./node_modules/openai/dist/base.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * OpenAI API\n * APIs for sampling from and fine-tuning language models\n *\n * The version of the OpenAPI document: 1.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst axios_1 = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\nexports.BASE_PATH = \"https://api.openai.com/v1\".replace(/\\/+$/, \"\");\n/**\n *\n * @export\n */\nexports.COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n/**\n *\n * @export\n * @class BaseAPI\n */\nclass BaseAPI {\n    constructor(configuration, basePath = exports.BASE_PATH, axios = axios_1.default) {\n        this.basePath = basePath;\n        this.axios = axios;\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = configuration.basePath || this.basePath;\n        }\n    }\n}\nexports.BaseAPI = BaseAPI;\n;\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\nexports.RequiredError = RequiredError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb3BlbmFpL2Rpc3QvYmFzZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLGVBQWUsR0FBRywwQkFBMEIsR0FBRyxpQkFBaUI7QUFDeEY7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDRDQUFPO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3BlbmFpL2Rpc3QvYmFzZS5qcz9hZGRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIE9wZW5BSSBBUElcbiAqIEFQSXMgZm9yIHNhbXBsaW5nIGZyb20gYW5kIGZpbmUtdHVuaW5nIGxhbmd1YWdlIG1vZGVsc1xuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAxLjEuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVxdWlyZWRFcnJvciA9IGV4cG9ydHMuQmFzZUFQSSA9IGV4cG9ydHMuQ09MTEVDVElPTl9GT1JNQVRTID0gZXhwb3J0cy5CQVNFX1BBVEggPSB2b2lkIDA7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGF4aW9zXzEgPSByZXF1aXJlKFwiYXhpb3NcIik7XG5leHBvcnRzLkJBU0VfUEFUSCA9IFwiaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MVwiLnJlcGxhY2UoL1xcLyskLywgXCJcIik7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMuQ09MTEVDVElPTl9GT1JNQVRTID0ge1xuICAgIGNzdjogXCIsXCIsXG4gICAgc3N2OiBcIiBcIixcbiAgICB0c3Y6IFwiXFx0XCIsXG4gICAgcGlwZXM6IFwifFwiLFxufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBCYXNlQVBJXG4gKi9cbmNsYXNzIEJhc2VBUEkge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoID0gZXhwb3J0cy5CQVNFX1BBVEgsIGF4aW9zID0gYXhpb3NfMS5kZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aDtcbiAgICAgICAgdGhpcy5heGlvcyA9IGF4aW9zO1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhdGggPSBjb25maWd1cmF0aW9uLmJhc2VQYXRoIHx8IHRoaXMuYmFzZVBhdGg7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJhc2VBUEkgPSBCYXNlQVBJO1xuO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIFJlcXVpcmVkRXJyb3JcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqL1xuY2xhc3MgUmVxdWlyZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSZXF1aXJlZEVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1aXJlZEVycm9yID0gUmVxdWlyZWRFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/openai/dist/base.js\n"));

/***/ }),

/***/ "./node_modules/openai/dist/common.js":
/*!********************************************!*\
  !*** ./node_modules/openai/dist/common.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * OpenAI API\n * APIs for sampling from and fine-tuning language models\n *\n * The version of the OpenAPI document: 1.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;\nconst base_1 = __webpack_require__(/*! ./base */ \"./node_modules/openai/dist/base.js\");\n/**\n *\n * @export\n */\nexports.DUMMY_BASE_URL = 'https://example.com';\n/**\n *\n * @throws {RequiredError}\n * @export\n */\nexports.assertParamExists = function (functionName, paramName, paramValue) {\n    if (paramValue === null || paramValue === undefined) {\n        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\n    }\n};\n/**\n *\n * @export\n */\nexports.setApiKeyToObject = function (object, keyParamName, configuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (configuration && configuration.apiKey) {\n            const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n                ? yield configuration.apiKey(keyParamName)\n                : yield configuration.apiKey;\n            object[keyParamName] = localVarApiKeyValue;\n        }\n    });\n};\n/**\n *\n * @export\n */\nexports.setBasicAuthToObject = function (object, configuration) {\n    if (configuration && (configuration.username || configuration.password)) {\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\n    }\n};\n/**\n *\n * @export\n */\nexports.setBearerAuthToObject = function (object, configuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (configuration && configuration.accessToken) {\n            const accessToken = typeof configuration.accessToken === 'function'\n                ? yield configuration.accessToken()\n                : yield configuration.accessToken;\n            object[\"Authorization\"] = \"Bearer \" + accessToken;\n        }\n    });\n};\n/**\n *\n * @export\n */\nexports.setOAuthToObject = function (object, name, scopes, configuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (configuration && configuration.accessToken) {\n            const localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n                ? yield configuration.accessToken(name, scopes)\n                : yield configuration.accessToken;\n            object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n        }\n    });\n};\nfunction setFlattenedQueryParams(urlSearchParams, parameter, key = \"\") {\n    if (typeof parameter === \"object\") {\n        if (Array.isArray(parameter)) {\n            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));\n        }\n        else {\n            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));\n        }\n    }\n    else {\n        if (urlSearchParams.has(key)) {\n            urlSearchParams.append(key, parameter);\n        }\n        else {\n            urlSearchParams.set(key, parameter);\n        }\n    }\n}\n/**\n *\n * @export\n */\nexports.setSearchParams = function (url, ...objects) {\n    const searchParams = new URLSearchParams(url.search);\n    setFlattenedQueryParams(searchParams, objects);\n    url.search = searchParams.toString();\n};\n/**\n *\n * @export\n */\nexports.serializeDataIfNeeded = function (value, requestOptions, configuration) {\n    const nonString = typeof value !== 'string';\n    const needsSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    return needsSerialization\n        ? JSON.stringify(value !== undefined ? value : {})\n        : (value || \"\");\n};\n/**\n *\n * @export\n */\nexports.toPathString = function (url) {\n    return url.pathname + url.search + url.hash;\n};\n/**\n *\n * @export\n */\nexports.createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {\n    return (axios = globalAxios, basePath = BASE_PATH) => {\n        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url });\n        return axios.request(axiosRequestArgs);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb3BlbmFpL2Rpc3QvY29tbW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLG9CQUFvQixHQUFHLDZCQUE2QixHQUFHLHVCQUF1QixHQUFHLHdCQUF3QixHQUFHLDZCQUE2QixHQUFHLDRCQUE0QixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQjtBQUN6UixlQUFlLG1CQUFPLENBQUMsa0RBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esd0VBQXdFLFdBQVcscUNBQXFDLGFBQWE7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEgsSUFBSSxFQUFFLHNCQUFzQixFQUFFLFdBQVc7QUFDcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsK0RBQStELHdCQUF3QiwySEFBMkg7QUFDbE47QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vcGVuYWkvZGlzdC9jb21tb24uanM/ZGMzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBPcGVuQUkgQVBJXG4gKiBBUElzIGZvciBzYW1wbGluZyBmcm9tIGFuZCBmaW5lLXR1bmluZyBsYW5ndWFnZSBtb2RlbHNcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMS4xLjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uID0gZXhwb3J0cy50b1BhdGhTdHJpbmcgPSBleHBvcnRzLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCA9IGV4cG9ydHMuc2V0U2VhcmNoUGFyYW1zID0gZXhwb3J0cy5zZXRPQXV0aFRvT2JqZWN0ID0gZXhwb3J0cy5zZXRCZWFyZXJBdXRoVG9PYmplY3QgPSBleHBvcnRzLnNldEJhc2ljQXV0aFRvT2JqZWN0ID0gZXhwb3J0cy5zZXRBcGlLZXlUb09iamVjdCA9IGV4cG9ydHMuYXNzZXJ0UGFyYW1FeGlzdHMgPSBleHBvcnRzLkRVTU1ZX0JBU0VfVVJMID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4vYmFzZVwiKTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0cy5EVU1NWV9CQVNFX1VSTCA9ICdodHRwczovL2V4YW1wbGUuY29tJztcbi8qKlxuICpcbiAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMuYXNzZXJ0UGFyYW1FeGlzdHMgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lLCBwYXJhbU5hbWUsIHBhcmFtVmFsdWUpIHtcbiAgICBpZiAocGFyYW1WYWx1ZSA9PT0gbnVsbCB8fCBwYXJhbVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IGJhc2VfMS5SZXF1aXJlZEVycm9yKHBhcmFtTmFtZSwgYFJlcXVpcmVkIHBhcmFtZXRlciAke3BhcmFtTmFtZX0gd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyAke2Z1bmN0aW9uTmFtZX0uYCk7XG4gICAgfVxufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0cy5zZXRBcGlLZXlUb09iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleVBhcmFtTmFtZSwgY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckFwaUtleVZhbHVlID0gdHlwZW9mIGNvbmZpZ3VyYXRpb24uYXBpS2V5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyB5aWVsZCBjb25maWd1cmF0aW9uLmFwaUtleShrZXlQYXJhbU5hbWUpXG4gICAgICAgICAgICAgICAgOiB5aWVsZCBjb25maWd1cmF0aW9uLmFwaUtleTtcbiAgICAgICAgICAgIG9iamVjdFtrZXlQYXJhbU5hbWVdID0gbG9jYWxWYXJBcGlLZXlWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0cy5zZXRCYXNpY0F1dGhUb09iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbiAmJiAoY29uZmlndXJhdGlvbi51c2VybmFtZSB8fCBjb25maWd1cmF0aW9uLnBhc3N3b3JkKSkge1xuICAgICAgICBvYmplY3RbXCJhdXRoXCJdID0geyB1c2VybmFtZTogY29uZmlndXJhdGlvbi51c2VybmFtZSwgcGFzc3dvcmQ6IGNvbmZpZ3VyYXRpb24ucGFzc3dvcmQgfTtcbiAgICB9XG59O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLnNldEJlYXJlckF1dGhUb09iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHR5cGVvZiBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyB5aWVsZCBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuKClcbiAgICAgICAgICAgICAgICA6IHlpZWxkIGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW47XG4gICAgICAgICAgICBvYmplY3RbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCZWFyZXIgXCIgKyBhY2Nlc3NUb2tlbjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0cy5zZXRPQXV0aFRvT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgc2NvcGVzLCBjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBY2Nlc3NUb2tlblZhbHVlID0gdHlwZW9mIGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IHlpZWxkIGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4obmFtZSwgc2NvcGVzKVxuICAgICAgICAgICAgICAgIDogeWllbGQgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIG9iamVjdFtcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJlYXJlciBcIiArIGxvY2FsVmFyQWNjZXNzVG9rZW5WYWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmZ1bmN0aW9uIHNldEZsYXR0ZW5lZFF1ZXJ5UGFyYW1zKHVybFNlYXJjaFBhcmFtcywgcGFyYW1ldGVyLCBrZXkgPSBcIlwiKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgcGFyYW1ldGVyLmZvckVhY2goaXRlbSA9PiBzZXRGbGF0dGVuZWRRdWVyeVBhcmFtcyh1cmxTZWFyY2hQYXJhbXMsIGl0ZW0sIGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1ldGVyKS5mb3JFYWNoKGN1cnJlbnRLZXkgPT4gc2V0RmxhdHRlbmVkUXVlcnlQYXJhbXModXJsU2VhcmNoUGFyYW1zLCBwYXJhbWV0ZXJbY3VycmVudEtleV0sIGAke2tleX0ke2tleSAhPT0gJycgPyAnLicgOiAnJ30ke2N1cnJlbnRLZXl9YCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodXJsU2VhcmNoUGFyYW1zLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB1cmxTZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgcGFyYW1ldGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVybFNlYXJjaFBhcmFtcy5zZXQoa2V5LCBwYXJhbWV0ZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLnNldFNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uICh1cmwsIC4uLm9iamVjdHMpIHtcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5zZWFyY2gpO1xuICAgIHNldEZsYXR0ZW5lZFF1ZXJ5UGFyYW1zKHNlYXJjaFBhcmFtcywgb2JqZWN0cyk7XG4gICAgdXJsLnNlYXJjaCA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpO1xufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0cy5zZXJpYWxpemVEYXRhSWZOZWVkZWQgPSBmdW5jdGlvbiAodmFsdWUsIHJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3Qgbm9uU3RyaW5nID0gdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJztcbiAgICBjb25zdCBuZWVkc1NlcmlhbGl6YXRpb24gPSBub25TdHJpbmcgJiYgY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmlzSnNvbk1pbWVcbiAgICAgICAgPyBjb25maWd1cmF0aW9uLmlzSnNvbk1pbWUocmVxdWVzdE9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10pXG4gICAgICAgIDogbm9uU3RyaW5nO1xuICAgIHJldHVybiBuZWVkc1NlcmlhbGl6YXRpb25cbiAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSlcbiAgICAgICAgOiAodmFsdWUgfHwgXCJcIik7XG59O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLnRvUGF0aFN0cmluZyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCArIHVybC5oYXNoO1xufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0cy5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24gPSBmdW5jdGlvbiAoYXhpb3NBcmdzLCBnbG9iYWxBeGlvcywgQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIChheGlvcyA9IGdsb2JhbEF4aW9zLCBiYXNlUGF0aCA9IEJBU0VfUEFUSCkgPT4ge1xuICAgICAgICBjb25zdCBheGlvc1JlcXVlc3RBcmdzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBheGlvc0FyZ3Mub3B0aW9ucyksIHsgdXJsOiAoKGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5iYXNlUGF0aCkgfHwgYmFzZVBhdGgpICsgYXhpb3NBcmdzLnVybCB9KTtcbiAgICAgICAgcmV0dXJuIGF4aW9zLnJlcXVlc3QoYXhpb3NSZXF1ZXN0QXJncyk7XG4gICAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/openai/dist/common.js\n"));

/***/ }),

/***/ "./node_modules/openai/dist/configuration.js":
/*!***************************************************!*\
  !*** ./node_modules/openai/dist/configuration.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * OpenAI API\n * APIs for sampling from and fine-tuning language models\n *\n * The version of the OpenAPI document: 1.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Configuration = void 0;\nconst packageJson = __webpack_require__(/*! ../package.json */ \"./node_modules/openai/package.json\");\nclass Configuration {\n    constructor(param = {}) {\n        this.apiKey = param.apiKey;\n        this.organization = param.organization;\n        this.username = param.username;\n        this.password = param.password;\n        this.accessToken = param.accessToken;\n        this.basePath = param.basePath;\n        this.baseOptions = param.baseOptions;\n        this.formDataCtor = param.formDataCtor;\n        if (!this.baseOptions) {\n            this.baseOptions = {};\n        }\n        this.baseOptions.headers = Object.assign({ 'User-Agent': `OpenAI/NodeJS/${packageJson.version}`, 'Authorization': `Bearer ${this.apiKey}` }, this.baseOptions.headers);\n        if (this.organization) {\n            this.baseOptions.headers['OpenAI-Organization'] = this.organization;\n        }\n        if (!this.formDataCtor) {\n            this.formDataCtor = __webpack_require__(/*! form-data */ \"./node_modules/form-data/lib/browser.js\");\n        }\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        const jsonMime = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\nexports.Configuration = Configuration;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb3BlbmFpL2Rpc3QvY29uZmlndXJhdGlvbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixvQkFBb0IsbUJBQU8sQ0FBQywyREFBaUI7QUFDN0M7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwrQkFBK0Isb0JBQW9CLDhCQUE4QixZQUFZLEdBQUc7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQU8sQ0FBQywwREFBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVcsc0JBQXNCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3BlbmFpL2Rpc3QvY29uZmlndXJhdGlvbi5qcz83ODJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIE9wZW5BSSBBUElcbiAqIEFQSXMgZm9yIHNhbXBsaW5nIGZyb20gYW5kIGZpbmUtdHVuaW5nIGxhbmd1YWdlIG1vZGVsc1xuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAxLjEuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29uZmlndXJhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHBhY2thZ2VKc29uID0gcmVxdWlyZShcIi4uL3BhY2thZ2UuanNvblwiKTtcbmNsYXNzIENvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtID0ge30pIHtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBwYXJhbS5hcGlLZXk7XG4gICAgICAgIHRoaXMub3JnYW5pemF0aW9uID0gcGFyYW0ub3JnYW5pemF0aW9uO1xuICAgICAgICB0aGlzLnVzZXJuYW1lID0gcGFyYW0udXNlcm5hbWU7XG4gICAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXJhbS5wYXNzd29yZDtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHBhcmFtLmFjY2Vzc1Rva2VuO1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gcGFyYW0uYmFzZVBhdGg7XG4gICAgICAgIHRoaXMuYmFzZU9wdGlvbnMgPSBwYXJhbS5iYXNlT3B0aW9ucztcbiAgICAgICAgdGhpcy5mb3JtRGF0YUN0b3IgPSBwYXJhbS5mb3JtRGF0YUN0b3I7XG4gICAgICAgIGlmICghdGhpcy5iYXNlT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5iYXNlT3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFzZU9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oeyAnVXNlci1BZ2VudCc6IGBPcGVuQUkvTm9kZUpTLyR7cGFja2FnZUpzb24udmVyc2lvbn1gLCAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmFwaUtleX1gIH0sIHRoaXMuYmFzZU9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLm9yZ2FuaXphdGlvbikge1xuICAgICAgICAgICAgdGhpcy5iYXNlT3B0aW9ucy5oZWFkZXJzWydPcGVuQUktT3JnYW5pemF0aW9uJ10gPSB0aGlzLm9yZ2FuaXphdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZm9ybURhdGFDdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1EYXRhQ3RvciA9IHJlcXVpcmUoXCJmb3JtLWRhdGFcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIE1JTUUgaXMgYSBKU09OIE1JTUUuXG4gICAgICogSlNPTiBNSU1FIGV4YW1wbGVzOlxuICAgICAqICAgYXBwbGljYXRpb24vanNvblxuICAgICAqICAgYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEY4XG4gICAgICogICBBUFBMSUNBVElPTi9KU09OXG4gICAgICogICBhcHBsaWNhdGlvbi92bmQuY29tcGFueStqc29uXG4gICAgICogQHBhcmFtIG1pbWUgLSBNSU1FIChNdWx0aXB1cnBvc2UgSW50ZXJuZXQgTWFpbCBFeHRlbnNpb25zKVxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgZ2l2ZW4gTUlNRSBpcyBKU09OLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNKc29uTWltZShtaW1lKSB7XG4gICAgICAgIGNvbnN0IGpzb25NaW1lID0gbmV3IFJlZ0V4cCgnXihhcHBsaWNhdGlvblxcL2pzb258W147LyBcXHRdK1xcL1teOy8gXFx0XStbK11qc29uKVsgXFx0XSooOy4qKT8kJywgJ2knKTtcbiAgICAgICAgcmV0dXJuIG1pbWUgIT09IG51bGwgJiYgKGpzb25NaW1lLnRlc3QobWltZSkgfHwgbWltZS50b0xvd2VyQ2FzZSgpID09PSAnYXBwbGljYXRpb24vanNvbi1wYXRjaCtqc29uJyk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/openai/dist/configuration.js\n"));

/***/ }),

/***/ "./node_modules/openai/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/openai/dist/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * OpenAI API\n * APIs for sampling from and fine-tuning language models\n *\n * The version of the OpenAPI document: 1.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./api */ \"./node_modules/openai/dist/api.js\"), exports);\n__exportStar(__webpack_require__(/*! ./configuration */ \"./node_modules/openai/dist/configuration.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb3BlbmFpL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLGdEQUFPO0FBQzVCLGFBQWEsbUJBQU8sQ0FBQyxvRUFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29wZW5haS9kaXN0L2luZGV4LmpzP2YzODgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogT3BlbkFJIEFQSVxuICogQVBJcyBmb3Igc2FtcGxpbmcgZnJvbSBhbmQgZmluZS10dW5pbmcgbGFuZ3VhZ2UgbW9kZWxzXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDEuMS4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FwaVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29uZmlndXJhdGlvblwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/openai/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/openai/package.json":
/*!******************************************!*\
  !*** ./node_modules/openai/package.json ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = JSON.parse('{"name":"openai","version":"3.1.0","description":"Node.js library for the OpenAI API","repository":{"type":"git","url":"git@github.com:openai/openai-node.git"},"keywords":["openai","open","ai","gpt-3","gpt3"],"author":"OpenAI","license":"MIT","main":"./dist/index.js","types":"./dist/index.d.ts","scripts":{"build":"tsc --outDir dist/"},"dependencies":{"axios":"^0.26.0","form-data":"^4.0.0"},"devDependencies":{"@types/node":"^12.11.5","typescript":"^3.6.4"}}');

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2FJon%2FProjects%2Fchrome-extension%2FOpenAI%20Hackathon%2Fopenai-hackathon-dec-22%2Fpages%2Findex.tsx&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);